Command: git show de906f6982f0c737093203d0ecdc34e1b9063a25

commit de906f6982f0c737093203d0ecdc34e1b9063a25
Author: Simon Peter <simpeter@cs.washington.edu>
Date:   Fri Feb 28 09:54:25 2014 +0100

    The Arrakis backport to Barrelfish.
    
    Here are the macro changes:
    * Made lwIP an optional network stack
      * Moved lwIP headers out of the general include directory
      * Parallel hake
      * CPU-virtualized ("arrakis") applications
      * libarrakis is a new libOS that uses CPU features directly
      * arrakismon is a new monitor for Arrakis apps
      * QEMU Multiboot support instead of GRUB (enables KVM)
      * e10k virtual function driver
      * Software virtual->physical mapping (substitutes IOMMU)
      * To be replaced soon with an Intel IOMMU driver
      * Better GDB and stack tracing support
      * New POSIX support
         * pthreads, inet_*(), usleep(), syslimits.h, sigaction(), mman.h,
         * resource.h, sendmsg(), recvmsg(), mkfifo(), syslog.h, sysexits.h,
         * fcntl(), getegid(), getgid(), pipe(), rlimits
         * epoll support
         * Separate waitset for interrupts
      * Thread TLS key and ID support
      * Moved PCRE headers to include/, where they usually are
      * Intel performance counters support
      * Handle boot-time RAM overflow (for machines with >=64GB RAM)
      * Arranet network stack
      * Fix for build of lib/barrelfish/arch/x86_64/dispatch.c without -O2
      * New comandline options to pci daemon:
         * maxvfs=x, x is number of virtual functions to create for each
         * device supporting it
         * skb_bridge_program=x, x is SKB bridge programming script to use
         * bridge_bios is a script that uses the BIOS pre-set values, like Linux
       * Correctly build machine-optimized newlib parts
       * Library versions of e1000 and e10k drivers
       * Support for virtualization in e10k driver
       * e10k datacenter control plane daemon
       * Modified hellotest to be both a Barrelfish and an Arrakis application
    
    I've decided not to include the lwIP 1.4.1 code, as the port is
    not finished and who wants to use lwIP anyway with the Arrakis
    network stack and mTCP being released soon. If you want this,
    let me know (it's hugely superior to lwIP 1.3.1).
    
    I've made the code backwards-compatible with Barrelfish. The
    default should do what Barrelfish does. One can specify
    commandline options to the PCI daemon and e10k driver to
    configure I/O virtualization and the optional arrakismon allows
    loading CPU-virtualized "arrakis" programs.
    
    There are more pending changes, such as support for hardware
    rate limiting and weighted round robin packet scheduling, but
    I'd like these to go in first, before I push the rest.

diff --git a/devices/Hakefile b/devices/Hakefile
index e8cc54f..b0d1aa5 100644
--- a/devices/Hakefile
+++ b/devices/Hakefile
@@ -1,5 +1,5 @@
 --------------------------------------------------------------------------
--- Copyright (c) 2007-2012, ETH Zurich.
+-- Copyright (c) 2007-2013, ETH Zurich.
 -- All rights reserved.
 --
 -- This file is distributed under the terms in the attached LICENSE file.
@@ -27,6 +27,7 @@
            "audio_nbm",
            "e1000",
            "e10k",
+           "e10k_vf",
            "e10k_q",
            "ehci",
            "fat16_ebpb",
@@ -86,6 +87,7 @@
            "omap/omap44xx_sysctrl_padconf_core",
            "omap/omap44xx_sysctrl_padconf_wkup",
            "omap/omap44xx_usbconf",
+           "pci_sr_iov_cap",
            "omap/omap44xx_usbtllhs_config",
            "omap/omap44xx_uart3"
          ], arch <- allArchitectures
diff --git a/devices/e10k.dev b/devices/e10k.dev
index d41ebb6..c7f8016 100644
--- a/devices/e10k.dev
+++ b/devices/e10k.dev
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011, ETH Zurich. All rights reserved.
+ * Copyright (c) 2011, 2013, ETH Zurich. All rights reserved.
  *
  * This file is distributed under the terms in the attached LICENSE file.
  * If you do not find this file, copies can be found by writing to:
@@ -539,6 +539,9 @@ device e10k lsbfirst ( addr base ) "Intel 82599 10 GbE Controller" {
     _           27 rsvd;
   };
 
+  // Undocumented
+  register ciaa rw addr(base, 0x11088) "CIAA" type(uint32);
+  register ciad rw addr(base, 0x1108C) "CIAD" type(uint32);
 
   /************************************
    * 8.2.3.5 Interrupt Registers
@@ -707,7 +710,7 @@ device e10k lsbfirst ( addr base ) "Intel 82599 10 GbE Controller" {
     eimen       1 "EICS Immediate Interrupt Enable";
     ll_int      4 "Low latency Credits Increment Rate";
     rsc_delay   3 "RSC Delay";
-    vt_mode     2 "VT_Mode";
+    vtmode      2 type(vt_mode) "VT_Mode";
     _           14 rsvd;
     eiame       1 "Extended Interrupt Auto Mask Enable";
     pba_sup     1 "BA Support";
@@ -1445,6 +1448,14 @@ device e10k lsbfirst ( addr base ) "Intel 82599 10 GbE Controller" {
    * 8.2.3.12 - 8.2.3.18 TODO
    ***********************************/
 
+  // 8.2.3.12.4
+  register sectxminifg rw addr(base, 0x08810) "Security Tx Buffer Minimum IFG" {
+    minsecifg   4      	"Minimum IFG between packets";
+    _		4;
+    sectxdcb	5	"If PFC enabled, set to 0x1f, else set to 0x10";
+    _		19;
+  };
+
   // 8.2.3.12.5
   register secrxctrl rw addr(base, 0x08d00) "Security Rx Control" {
     secrx_dis   1 "Rx Security Offload Disable Bit";
@@ -2256,67 +2267,119 @@ device e10k lsbfirst ( addr base ) "Intel 82599 10 GbE Controller" {
   register rlec rc addr(base, 0x04040) "Receive Length Error Count"
     type(uint32);
 
-  // 8.2.23.26
+  // 8.2.3.23.8
+  register ssvpc rc addr(base, 0x08780) "Switch Security Violation Packet Count"
+    type(uint32);
+
+  // 8.2.3.23.26
   register gprc ro addr(base, 0x04074) "Good packets recieved count"
     type(uint32);
 
+  // 8.2.3.23.27
+  register gorcl rc addr(base, 0x04088) "Good Octets Received Count Low"
+    type(uint32);
+
+  // 8.2.3.23.28
+  register gorch rc addr(base, 0x0408c) "Good Octets Received Count High"
+    type(uint32);
+
   // 8.2.3.23.29
   register rxnfgpc rc addr(base, 0x041B0) "Good Rx Non-Filtered Packet Counter"
     type(uint32);
 
-  // 8.2.23.32
+  // 8.2.3.23.32
   register rxdgpc rc addr(base, 0x02F50) "DMA Good Rx Packet Counter"
     type(uint32);
 
-  // 8.2.23.44
+  // 8.2.3.23.44
   register gptc rc addr(base, 0x04080) "Good packets trasmitted count"
     type(uint32);
 
-  // 8.2.23.47
+  // 8.2.3.23.45
+  register gotcl rc addr(base, 0x04090) "Good octets transmitted count low"
+    type(uint32);
+
+  // 8.2.3.23.46
+  register gotch rc addr(base, 0x04094) "Good octets transmitted count high"
+    type(uint32);
+
+  // 8.2.3.23.47
   register txdgpc rc addr(base, 0x087A0) "DMA Good Tx Packet Counter"
     type(uint32);
 
-  // 8.2.23.50
+  // 8.2.3.23.50
   register ruc rc addr(base, 0x040A4) "Receive Undersize Count"
     type(uint32);
 
-  // 8.2.23.51
+  // 8.2.3.23.51
   register rfc rc addr(base, 0x040A8) "Receive Fragment Count"
     type(uint32);
 
-  // 8.2.23.52
+  // 8.2.3.23.52
   register roc rc addr(base, 0x040AC) "Receive Oversize Count"
     type(uint32);
 
-  // 8.2.23.53
+  // 8.2.3.23.53
   register rjc rc addr(base, 0x040B0) "Receive Jabber Count"
     type(uint32);
 
-  // 8.2.23.54
+  // 8.2.3.23.54
   register mngprc rc addr(base, 0x040B4) "Management Packets Received Count"
     type(uint32);
 
-  // 8.2.23.55
+  // 8.2.3.23.55
   register mngpdc rc addr(base, 0x040B8) "Management Packets Dropped Count"
     type(uint32);
 
-  // 8.2.23.59
+  // 8.2.3.23.57
+  register torl rc addr(base, 0x040c0) "Total octets received low"
+    type(uint32);
+
+  // 8.2.3.23.58
+  register torh rc addr(base, 0x040c4) "Total octets received high"
+    type(uint32);
+
+  // 8.2.3.23.59
   register tpr rc addr(base, 0x040D0) "Total Packets Recieved"
     type(uint32);
 
-  // 8.2.23.60
+  // 8.2.3.23.60
   register tpt rc addr(base, 0x040D4) "Total Packets Transmitted"
     type(uint32);
 
-  // 8.2.23.69
+  // 8.2.3.23.69
   register mspdc rc addr(base, 0x04010) "MAC Short Packet Discard Count"
     type(uint32);
 
-  // 8.2.23.74
+  // 8.2.3.23.71
+  regarray rqsmr rw addr(base, 0x02300) [32; 0x4] "Receive Queue Statistics Mapping" {
+    q_map0 	 4  "Map to queue 4*n+0";
+    _		 4;
+    q_map1 	 4  "Map to queue 4*n+1";
+    _		 4;
+    q_map2 	 4  "Map to queue 4*n+2";
+    _		 4;
+    q_map3 	 4  "Map to queue 4*n+3";
+    _		 4;
+  };
+
+  // 8.2.3.23.73
+  regarray tqsm rw addr(base, 0x08600) [32; 0x4] "Transmit Queue Statistics Mapping" {
+    q_map0 	 4  "Map to queue 4*n+0";
+    _		 4;
+    q_map1 	 4  "Map to queue 4*n+1";
+    _		 4;
+    q_map2 	 4  "Map to queue 4*n+2";
+    _		 4;
+    q_map3 	 4  "Map to queue 4*n+3";
+    _		 4;
+  };
+
+  // 8.2.3.23.74
   regarray qprc rc addr(base, 0x01030) [16; 0x40] "Queue Packets Received Count"
     type(uint32);
 
-  // 8.2.23.75
+  // 8.2.3.23.75
   regarray qprdc rc addr(base, 0x01430) [16; 0x40] "Queue Packets Received Drop Count"
     type(uint32);
 
@@ -2413,6 +2476,18 @@ device e10k lsbfirst ( addr base ) "Intel 82599 10 GbE Controller" {
     _           1 rsvd;
   };
 
+  // 8.2.3.27.5
+  regarray pfvflre ro addr(base, 0x00600) [2] "PF VFLR Events Indication" type(uint32);
+
+  // 8.2.3.27.6
+  regarray pfvflrec rw1c addr(base, 0x00700) [2] "PF VFLR Events Clear" type(uint32);
+
+  // 8.2.3.27.7
+  regarray pfvfre rw addr(base, 0x051e0) [2] "PF VF Receive Enable" type(uint32);
+
+  // 8.2.3.27.8
+  regarray pfvfte rw addr(base, 0x08110) [2] "PF VF Transmit Enable" type(uint32);
+
   // 8.2.3.27.9
   register pfqde rw addr(base, 0x02F04) "PF PF Queue Drop Enable Register" {
     qde         1 "Enable drop of packets from Rx Queue queue_idx";
@@ -2424,6 +2499,30 @@ device e10k lsbfirst ( addr base ) "Intel 82599 10 GbE Controller" {
     _           14 rsvd;
   };
 
+  // 8.2.3.27.11
+  regarray pfvfspoof rw addr(base, 0x08200) [8] "PF VF Anti Spoof Control" {
+    macas  8	     "MAC Address Anti-spoofing filter";
+    vlanas 8	     "VLAN tag anti-spoofing filter";
+    _	   16;
+  };
+
+  // 8.2.3.27.12
+  register pfdtxgswc rw addr(base, 0x08220) "PFDMA Tx General Switch Control" {
+    lbe	   1	     "Enables VMDQ loopback";
+    _	   31;
+  };
+
+  // 8.2.3.27.14
+  regarray pfvml2flt rw addr(base, 0x0f000) [64] "PF VM L2 Control" {
+    _	   24;
+    aupe   1	"Accept Untagged Packets Enable";
+    rompe  1	"Receive Overflow Multicast Packets";
+    rope   1	"Receive MAC Filters Overflow";
+    bam	   1	"Broadcast accept";
+    mpe	   1	"Multicast Promiscuous";
+    _	   3;
+  };
+
   // 8.2.3.27.15
   regarray pfvlvf rw addr(base, 0x0F100) [64] "PF VM VLAN Pool Filter" {
     vlan_id     12 "VLAN tag for pool VLAN filter n";
diff --git a/devices/e10k_vf.dev b/devices/e10k_vf.dev
new file mode 100644
index 0000000..51a44d3
--- /dev/null
+++ b/devices/e10k_vf.dev
@@ -0,0 +1,430 @@
+/*
+ * Copyright (c) 2011, 2013, ETH Zurich. All rights reserved.
+ *
+ * This file is distributed under the terms in the attached LICENSE file.
+ * If you do not find this file, copies can be found by writing to:
+ * ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich. Attn: Systems Group.
+ */
+
+/*
+ * e10k_vf.dev
+ *
+ * DESCRIPTION: Intel 82599 10 GbE Controller Virtual Function
+ *
+ * Numbers in comments refer to the Intel 82599 10 GbE Controller Datasheet,
+ * Revison 2.76, September 2012
+ */
+
+device e10k_vf lsbfirst ( addr base ) "Intel 82599 10 GbE Controller Virtual Function" {
+
+  /************************************
+   * 8.3.5.1 General control registers--VF
+   ***********************************/
+
+  // 8.3.5.1.1
+  register vfctrl wo addr(base, 0x00000) "VF control" {
+    _           26 rsvd;
+    rst         1 "Device reset";
+    _           5 rsvd;
+  };
+
+  constants lanid "LAN ID" {
+    lan_0       = 0b00 "LAN 0";
+    lan_1       = 0b01 "LAN 1";
+    lan_not_u1  = 0b10 "LAN ID not used";
+    lan_not_u2  = 0b11 "LAN ID not used";
+  };
+
+  // 8.3.5.1.2
+  register vfstatus ro addr(base, 0x00008) "VF status" {
+    _           2;
+    lan_id      2 type(lanid) "LAN ID";
+    _           3;
+    link_up     1 "Linkup Status Indication";
+    _           2;
+    num_vfs     8 "Num VFs";
+    iov_active  1 "IOV Active";
+    pcie_mes    1 "PCIe Master Enable Status";
+    _           12;
+  };
+
+  // 8.3.5.1.3
+  constants mac_lnkmode "MAC link mode status" {
+    lms_1g      = 0b00 "1 GbE";
+    lms_10g_par = 0b01 "10 GbE parallel";
+    lms_10g_ser = 0b10 "10 GbE serial";
+    lms_aneg    = 0b11 "auto-negotiation";
+  };
+
+  constants link_speed "MAC link speed status" {
+    ls_100m     = 0b01 "100 Mb/s";
+    ls_1g       = 0b10 "1 GbE";
+    ls_10g      = 0b11 "10 GbE";
+  };
+
+  register vflinks ro addr(base, 0x00010) "VF Link Status Register" {
+    kxsig_det   1 "A signal is present";
+    fecsig_det  1 "FEC reports signal detected";
+    fecblk_lck  1 "FEC reached block lock";
+    krhberr     1 "10GbE serial KR_PCS high error rate";
+    krpcsbl     1 "10 GbE serial PCS block lock";
+    kxr_annprcv 1 "KX/KX4/KR AN Next Page Received";
+    kxr_anprcv  1 "KX/KX4/KR Backplane Auto Negotiation Page Received";
+    lnk_stat    1 "Link Up and there was no link down from last time read";
+    kx4sig_det  4 "Signal Detect of 10 GbE Parallel (KX4, CX4 or XAUI) (1bit per lane)";
+    krsig_det   1 "Signal Detect of 10 GbE serial (KR or SFI)";
+    l10g_syncst 4 "10G Parallel lane sync status (1bit per lane)";
+    l10g_algst  1 "10 GbE align_status";
+    l1g_syncst  1 "1G sync_status";
+    kxr_anrxid  1 "KX/KX4/KR Backplane Auto Negotiation Rx Idle";
+    l1g_anen    1 "PCS_1 GbE auto-negotiation is enabled";
+    l1g_lnken   1 "1 GbE PCS enabled for 1 GbE and SGMII operation";
+    l10g_lnken  1 "XGXS Enabled for 10 GbE operation";
+    fec_en      1 "Status of forwarderrorcorrection in 10 GbE serial link";
+    l10g_seren  1 "Status of 10 GbE serial PCS (KR PCS) for KR or SFI operation";
+    sgmii_en    1 "Status of SGMII operation";
+    mlink_mode  2 type (mac_lnkmode) "MAC link mode status";
+    lnk_speed   2 type (link_speed) "MAC link speed status";
+    lnk_up      1 "Link is up";
+    kxr_ancomp  1 "KX/KX4/KR backplane auto-negotiation has completed successfully";
+  };
+
+  // NYI:
+  // 8.3.5.1.4 VF Free Running Timer (VFFRTIMER)
+  // 8.3.5.1.5 VF Mailbox (VFMailbox)
+  // 8.3.5.1.6 VF Mailbox Memory (VFMBMEM)
+
+  // 8.3.5.1.7
+  register vfrxmemwrap ro addr(base, 0x03190) "VF Rx Packet Buffer Flush Detect" {
+    tc0_wrap    3 "Packet Buffer 0 Wrap Around Counter";
+    tc0_empty   1 "Packet Buffer 0 Empty";
+    tc1_wrap    3 "Packet Buffer 1 Wrap Around Counter";
+    tc1_empty   1 "Packet Buffer 1 Empty";
+    tc2_wrap    3 "Packet Buffer 2 Wrap Around Counter";
+    tc2_empty   1 "Packet Buffer 2 Empty";
+    tc3_wrap    3 "Packet Buffer 3 Wrap Around Counter";
+    tc3_empty   1 "Packet Buffer 3 Empty";
+    tc4_wrap    3 "Packet Buffer 4 Wrap Around Counter";
+    tc4_empty   1 "Packet Buffer 4 Empty";
+    tc5_wrap    3 "Packet Buffer 5 Wrap Around Counter";
+    tc5_empty   1 "Packet Buffer 5 Empty";
+    tc6_wrap    3 "Packet Buffer 6 Wrap Around Counter";
+    tc6_empty   1 "Packet Buffer 6 Empty";
+    tc7_wrap    3 "Packet Buffer 7 Wrap Around Counter";
+    tc7_empty   1 "Packet Buffer 7 Empty";
+  };
+
+  /************************************
+   * 8.3.5.2 Interrupt Registers--VF
+   ***********************************/
+
+  // 8.3.5.2.1
+  register vfeicr rw1c addr(base, 0x00100) "VF Extended Interrupt Cause" {
+    msix   	3  "Indicates an interrupt cause mapped to MSI-X vectors 2:0";
+    _           29 rsvd;
+  };
+
+  // 8.3.5.2.2
+  register vfeics wo addr(base, 0x00104) "VF Extended Interrupt Cause Set" {
+    msix        3  "Sets to corresponding EICR bit of MSI-X vectors 2:0";
+    _           29 rsvd;
+  };
+
+  // 8.3.5.2.3
+  register vfeims rw addr(base, 0x00108) "VF Extended Interrupt Mask Set/Read" {
+    msix        3  "Set mask bit for the corresponding EICR bit of MSI-X vectors 2:0";
+    _           29 rsvd;
+  };
+
+  // 8.3.5.2.4
+  register vfeimc wo addr(base, 0x0010c) "VF Extended Interrupt Mask Clear" {
+    msix        3  "Clear mask bit for the corresponding EICR bit of MSI-X vectors 2:0";
+    _           29 rsvd;
+  };
+
+  // 8.3.5.2.5
+  register vfeiam rw addr(base, 0x00114) "VF Extended Interrupt Auto Mask Enable" {
+    msix        3  "Auto mask bit for the corresponding EICR bit of MSI-X vectors 2:0";
+    _           29 rsvd;
+  };
+
+  // 8.3.5.2.6
+/*
+  regtype vfeitrn "VF Extended Interrupt Throttle Register Type" {
+    _           3 rsvd;
+    itr_int     9 "Minimum inter-interrupt interval";
+    _           3 rsvd;
+    lli_mod     1 "LLI Moderation";
+    lli_credit  5 "LLI Credit";
+    itr_count   7 "ITR Counter";
+    _           3 rsvd;
+    cnt_wdis    1 "CNT_WDIS";
+  };
+*/
+  // XXX: Not sure if this is correct...
+  regarray vfeitr rw addr(base, 0x00820) [2]
+                "VF Extended Interrupt Mask Set/Read #0-#1"
+                type(uint32);
+
+  // 8.3.5.2.7
+  regarray vfivar rw addr(base, 0x00120) [4] "VF Interrupt Vector Allocation Registers" {
+    i_alloc0    1 "Defines the MSI-X vector (0 or 1) assigned to Rx queue 2*N for IVAR N register (N = 0..3)";
+    _           6 rsvd;
+    i_allocval0 1 "Interrupt allocation 0 valid";
+    i_alloc1    1 "The interrupt allocation for Tx queue 2n";
+    _           6 rsvd;
+    i_allocval1 1 "Interrupt allocation 1 valid";
+    i_alloc2    1 "The interrupt allocation for Rx queue 2n+1";
+    _           6 rsvd;
+    i_allocval2 1 "Interrupt allocation 2 valid";
+    i_alloc3    1 "The interrupt allocation for Tx queue 2n+1";
+    _           6 rsvd;
+    i_allocval3 1 "Interrupt allocation 3 valid";
+  };
+
+  // 8.3.5.2.8
+  register vfivar_misc rw addr(base, 0x00140) "VF Miscellaneous Interrupt Vector Allocation" {
+    i_alloc0    2 "MSI-X vector assigned to the mailbox interrupt";
+    _		5 rsvd;
+    i_allocval0 1 "Interrupt allocation 0 valid";
+    _           24 rsvd;
+  };
+
+  // 8.3.5.2.9
+  // XXX: Not sure if this is correct...
+  regarray vfrscint rw addr(base, 0x00180) [2] "VF RSC Enable Interrupt" type(uint32);
+
+  // 8.3.5.2.10
+  register vfpbacl rw1c addr(base, 0x00148) "VF MSI-X PBA Clear" {
+    penbit 	   3	"MSI-X Pending Bits Clear. Reading returns PBA vector.";
+    _		   29	rsvd;
+  };
+
+  /************************************
+   * 8.3.5.3 Receive DMA Registers -- VF
+   ***********************************/
+
+  // 8.3.5.3.1
+  regarray vfrdbal rw addr(base, 0x01000) [8; 0x40]
+                "VF Receive Descriptor Base Address Low (#0-#7)"
+                type(uint32);
+
+  // 8.3.5.3.2
+  regarray vfrdbah rw addr(base, 0x01004) [8; 0x40]
+                "VF Receive Descriptor Base Address High (#0-#7)"
+                type(uint32);
+
+  // 8.3.5.3.3
+  regarray vfrdlen rw addr(base, 0x01008) [8; 0x40]
+                "VF Receive Descriptor Length (#0-#7)"
+                type(uint32);
+
+  // 8.3.5.3.4
+  regarray vfrdh rw addr(base, 0x01010) [8; 0x40]
+                "VF Receive Descriptor Head (#0-#7)"
+                type(uint32);
+
+  // 8.3.5.3.5
+  regarray vfrdt rw addr(base, 0x01018) [8; 0x40]
+                "VF Receive Descriptor Tail (#0-#7)"
+                type(uint32);
+
+  // 8.3.5.3.6
+  regtype rxdctl "Receive Descriptor Control" {
+    _           25 rsvd;
+    enable      1 "Receive Queue Enable";
+    _           4 rsvd;
+    vme         1 "VLAN Mode Enable";
+    _           1 rsvd;
+  };
+
+  regarray vfrxdctl rw addr(base, 0x01028) [8; 0x40]
+                "VF Receive Descriptor Control (#0-#7)"
+                type(rxdctl);
+
+  // 8.3.5.3.7
+  constants rx_desctype "RX Descriptor Type" {
+    legacy      = 0b000 "Legacy";
+    adv_1buf    = 0b001 "Advanced descriptor one buffer";
+    adv_hdrsp   = 0b010 "Advanced descriptor header splitting";
+    adv_usehb   = 0b101 "Advanced descriptor header splitting always use header buffer";
+  };
+
+  regtype srrctl "Split Receive Control Registers" {
+    bsz_pkt     5 "Receive Buffer Size for Packet Buffer";
+    _           3 mbz;
+    bsz_hdr     6 "Receive Buffer Size for Header Buffer";
+    _           8 rsvd;
+    rdmts       3 "Receive Descriptor Minimum Threshold Size";
+    desctype    3 type(rx_desctype) "Define the descriptor type";
+    drop_en     1 "Drop Enabled";
+    _           3 rsvd;
+  };
+
+  regarray vfsrrctl rw addr(base, 0x01014) [8; 0x40]
+                "VF Split Receive Control Registers (#0-#7)"
+                type(srrctl);
+
+  // 8.3.5.3.8
+  register vfpsrtype rw addr(base, 0x00300) "VF Replication Packet Split Receive Type" {
+    _           1 mbz;
+    split_nfs   1 "Split received NFS packets after NFS header";
+    _           2 mbz;
+    split_tcp   1 "Split received TCP packets after TCP header";
+    split_udp   1 "Split received UDP packets after UDP header";
+    _           2 mbz;
+    split_ip4   1 "Split received IPv4 packets after IPv4 header";
+    split_ip6   1 "Split received IPv6 packets after IPv6 header";
+    _           2 mbz;
+    split_l2    1 "Split received L2 packets after L2 header";
+    _           16 mbz;
+    rqpl        3 "Number of bits to use for RSS redirection";
+  };
+
+  // 8.3.5.3.9
+  constants rsc_maxdesc "Maximum descriptors per Large receive" {
+    max_1desc   = 0b00 "Maximum of 1 descriptor per large receive";
+    max_4desc   = 0b01 "Maximum of 4 descriptors per large receive";
+    max_8desc   = 0b10 "Maximum of 8 descriptors per large receive";
+    max_16desc  = 0b11 "Maximum of 16 descriptors per large receive";
+  };
+
+  regtype rscctl "RSC Control" {
+    rsc_en      1 "RSC Enable";
+    _           1 rsvd;
+    maxdesc     2 type(rsc_maxdesc) "Maximum descriptors per Large receive";
+    _           28 rsvd;
+  };
+
+  regarray vfrscctl rw addr(base, 0x0102c) [8; 0x40]
+                "RSC Control (#0-#7)"
+                type(rscctl);
+
+  /************************************
+   * 8.3.5.4 Transmit Registers -- VF
+   ***********************************/
+
+  // 8.3.5.4.1
+  regarray vftdbal rw addr(base, 0x02000) [4; 0x40]
+                "VF Transmit Descriptor Base Address Low"
+                type(uint32);
+
+  // 8.3.5.4.2
+  regarray vftdbah rw addr(base, 0x02004) [4; 0x40]
+                "VF Transmit Descriptor Base Address High"
+                type(uint32);
+
+  // 8.3.5.4.3
+  regarray vftdlen rw addr(base, 0x02008) [4; 0x40]
+                "VF Transmit Descriptor Length"
+                type(uint32);
+
+  // 8.3.5.4.4
+  // rw is only partially accurate here. This register must only be written
+  // directly after reset.
+  regarray vftdh rw addr(base, 0x02010) [4; 0x40]
+                "VF Transmit Descriptor Head"
+                type(uint32);
+
+  // 8.3.5.4.5
+  regarray vftdt rw addr(base, 0x02018) [4; 0x40]
+                "VF Transmit Descriptor Tail"
+                type(uint32);
+
+  // 8.3.5.4.6
+  regarray vftxdctl rw addr(base, 0x02028) [4; 0x40] "VF Transmit Descriptor Control" {
+    pthresh     7 "Pre-Fetch Threshold";
+    _           1 rsvd;
+    hthresh     7 "Host Threshold";
+    _           1 rsvd;
+    wthresh     7 "Write-Back Threshold";
+    _           2 rsvd;
+    enable      1 "Transmit Queue Enable";
+    swflsh      1 "Transmit Software Flush";
+    _           5 rsvd;
+  };
+
+  // 8.3.5.4.7
+  regarray vftdwbal rw addr(base, 0x02038) [4; 0x40] "VF Tx Descriptor Completion Write Back Address Low" {
+    headwb_en   1 "Head Write-Back Enable";
+    _           1 rsvd;
+    headwb_low  30 "Lowest 32 bits of the head write-back memory location";
+  };
+
+  // 8.3.5.4.8
+  regarray vftdwbah rw addr(base, 0x0203c) [4; 0x40] "VF Tx Descriptor Completion Write Back Address High" {
+    headwb_high 32 "Highest 32 bits of the head write-back memory location";
+  };
+
+  /************************************
+   * 8.3.5.5 DCA Registers -- VF
+   ***********************************/
+
+  // 8.3.5.5.1
+  regtype dca_rxctrl "Rx DCA Control Register" {
+    _           5 rsvd;
+    rxdca_desc  1 "Descriptor DCA EN";
+    rxdca_hdr   1 "Rx Header DCA EN";
+    rxdca_payl  1 "Payload DCA EN";
+    _           1 rsvd;
+    rxdesc_rdro 1 "Rx Descriptor Read Relax Order Enable";
+    _           1 rsvd;
+    rxdesc_wbro 1 mbz "Rx Descriptor Write Back Relax Order Enable";
+    _           1 rsvd;
+    rxdata_wrro 1 "Rx data Write Relax Order Enable";
+    _           1 rsvd;
+    rxhdr_ro    1 "Rx Split Header Relax Order Enable";
+    _           8 rsvd;
+    cpuid       8 "Physical ID";
+  };
+
+  regarray vfdca_rxctrl rw addr(base, 0x0100c) [8; 0x40]
+                "VF Rx DCA Control Register (#0-#7)"
+                type(dca_rxctrl);
+
+  // 8.3.5.5.2
+  regarray vfdca_txctrl rw addr(base, 0x0200c) [8; 0x40] "VF Tx DCA Control Registers" {
+    _           5 rsvd;
+    txdesc_dca  1 "Descriptor DCA Enable";
+    _           3 rsvd;
+    txdesc_rdro 1 "Tx Descriptor Read Relax Order Enable";
+    _           1 rsvd;
+    txdesc_wbro 1 "Relax Order Enable of Tx Descriptor well as head pointer write back";
+    _           1 rsvd;
+    txdata_rdro 1 "Tx Data Read Relax Order Enable";
+    _           10 rsvd;
+    cpuid       8 "Physical ID";
+  };
+
+  /************************************
+   * 8.3.5.6 Statistics -- VF
+   ***********************************/
+
+  // 8.3.5.6.1
+  register vfgprc ro addr(base, 0x0101c) "VF Good packets received count"
+    type(uint32);
+
+  // 8.3.5.6.2
+  register vfgptc ro addr(base, 0x0201c) "VF Good packets trasmitted count"
+    type(uint32);
+
+  // 8.3.5.6.3
+  register vfgorc_lsb ro addr(base, 0x01020) "VF Good Octets Received Count Low"
+    type(uint32);
+
+  // 8.3.5.6.4
+  register vfgorc_msb ro addr(base, 0x01024) "VF Good Octets Received Count High"
+    type(uint32);
+
+  // 8.3.5.6.5
+  register vfgotc_lsb ro addr(base, 0x02020) "VF Good Octets Transmitted Count Low"
+    type(uint32);
+ 
+  // 8.3.5.6.6
+  register vfgotc_msb ro addr(base, 0x02024) "VF Good Octets Transmitted Count High"
+    type(uint32);
+
+  // 8.3.5.6.7
+  register vfmprc ro addr(base, 0x01034) "VF Multicast Packets Received Count"
+    type(uint32);
+};
diff --git a/devices/pci_hdr0.dev b/devices/pci_hdr0.dev
index 4ed06cc..c3794ef 100644
--- a/devices/pci_hdr0.dev
+++ b/devices/pci_hdr0.dev
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008, ETH Zurich. All rights reserved.
+ * Copyright (c) 2008, 2013, ETH Zurich. All rights reserved.
  *
  * This file is distributed under the terms in the attached LICENSE file.
  * If you do not find this file, copies can be found by writing to:
@@ -167,7 +167,7 @@ device pci_hdr0 msbfirst ( pci base ) "PCI Type 0 Configuration" {
   register cap_ptr ro pci(base, 0x34) "Capabilities ptr" type(uint8);
 
   register int_line rw pci(base, 0x3c) "Interrupt line" type(uint8);
-  register int_pin ro pci(base, 0x3d) "Interrupt ping" type(uint8);
+  register int_pin ro pci(base, 0x3d) "Interrupt pin" type(uint8);
 
   register min_gnt ro pci(base, 0x3e) "Min Gnt" type(uint8);
   register max_lat ro pci(base, 0x3f) "Max Lat" type(uint8);
diff --git a/devices/pci_hdr1.dev b/devices/pci_hdr1.dev
index 37fca9e..96c286a 100644
--- a/devices/pci_hdr1.dev
+++ b/devices/pci_hdr1.dev
@@ -138,10 +138,12 @@ device pci_hdr1 msbfirst ( pci base ) "PCI Type 1 Configuration" {
   register bar0 pci ( base, 0x10 ) "Base address 0" type(uint32);
   register bar1 pci ( base, 0x14 ) "Base address 1" type(uint32);
 
-  register pri_bus pci (base, 0x18) "Primary bus number" type(uint8);
-  register sec_bus pci (base, 0x19) "Secondary bus number" type(uint8);
-  register sub_bus pci (base, 0x1a) "Subordinate bus number" type(uint8);
-  register sec_lat pci (base, 0x1b) "Secondary latency timer" type(uint8);
+  register bcfg pci (base, 0x18) "Bus configuration register" {
+    sec_lat    8   "Secondary latency timer";
+    sub_bus    8   "Subordinate bus number";
+    sec_bus    8   "Secondary bus number";
+    pri_bus    8   "Primary bus number";
+  };
 
   //
   // I/O base and limit registers
@@ -163,13 +165,11 @@ device pci_hdr1 msbfirst ( pci base ) "PCI Type 1 Configuration" {
   //
   // Memory-mapped I/O base and limit registers
   //
-  
-  regtype membl "Memory-mapped base and limit" {
-    addr	12 rw "Low bits of address";
-    _		4;
+
+  register membl pci (base, 0x20) "Memory base and limit" {
+    limit  16	 "Limit";
+    base   16	 "Base";
   };
-  register mem_base pci (base, 0x20) "Memory base" type(uint16);
-  register mem_limit pci (base, 0x22) "Memory limit" type(uint16);
 
   //
   // Prefetchable memory base and limit registers
@@ -206,7 +206,7 @@ device pci_hdr1 msbfirst ( pci base ) "PCI Type 1 Configuration" {
     pritm_dis	1 ro "Primary discard timeout";
     back2back   1 ro "Fast back-to-back enable";
     sec_reset   1 rw "Secondary bus reset";
-    mabort	1 ro "Master abort mode";
+    mabort	1 rw "Master abort mode";
     _		1;
     vga		1 rw "VGA enable";
     isa		1 rw "ISA enable";
diff --git a/devices/pci_sr_iov_cap.dev b/devices/pci_sr_iov_cap.dev
new file mode 100644
index 0000000..144044d
--- /dev/null
+++ b/devices/pci_sr_iov_cap.dev
@@ -0,0 +1,80 @@
+/*
+ * Copyright (c) 2013, ETH Zurich. All rights reserved.
+ *
+ * This file is distributed under the terms in the attached LICENSE file.
+ * If you do not find this file, copies can be found by writing to:
+ * ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich. Attn: Systems Group.
+ */
+
+/*
+ * pci_sr_iov_cap.dev
+ *
+ * DESCRIPTION: PCI SR-IOV Extended Capability
+ * 
+ * Numbers in comments refer to the Single Root I/O Virtualization and
+ * Sharing Specification, Revision 1.1, January 20, 2010.
+ */
+
+device pci_sr_iov_cap lsbfirst ( addr base ) "PCI SR-IOV Extended Capability" {
+
+  // 3.3.1
+  register hdr ro addr( base, 0x00 ) "Extended Capabilities Header" {
+    id	   16  "PCI Express Extended Capability ID";
+    ver	   4   "Capability Version";
+    next   12  "Next Capability Offset";
+  };
+
+  // 3.3.2
+  register caps ro addr( base, 0x04 ) "SR-IOV Capabilities" {
+    vf_migration   1	 "VF Migration Capable";
+    ari_preserved  1	 "ARI Capable Hierarchy Preserved";
+    _		   19;
+    vf_mig_int	   11	 "VF Migration Interrupt Message Number";
+  };
+
+  // 3.3.3
+  register ctrl rw addr( base, 0x08 ) "SR-IOV Control" {
+    vf_enable	   	 1	 "VF Enable";
+    vf_mig_enable  	 1	 "VF Migration Enable";
+    vf_mig_int_enable	 1	 "VF Migration Interrupt Enable";
+    vf_mse		 1	 "VF MSE";
+    ari_capable		 1	 "ARI Capable Hierarchy";
+    _			 11;
+  };
+
+  // 3.3.4
+  register status rw addr( base, 0x0a ) "SR-IOV Status" {
+    vf_migration     1	   "VF Migration Status";
+    _		     15 mbz;
+  };
+
+  // 3.3.5
+  register initialvfs ro addr( base, 0x0c ) "InitialVFs" type(uint16);
+  // 3.3.6
+  register totalvfs ro addr( base, 0x0e ) "TotalVFs" type(uint16);
+  // 3.3.7
+  register numvfs rw addr( base, 0x10 ) "NumVFs" type(uint16);
+  // 3.3.8
+  register fdl ro addr( base, 0x12 ) "Function Dependency Link" type(uint8);
+  // 3.3.9
+  register offset ro addr( base, 0x14 ) "First VF Offset" type(uint16);
+  // 3.3.10
+  register stride ro addr( base, 0x16 ) "VF Stride" type(uint16);
+  // 3.3.11
+  register devid ro addr( base, 0x1a ) "VF Device ID" type(uint16);
+
+  // 3.3.12
+  register sup_psize ro addr( base, 0x1c ) "Supported Page Sizes" type(uint32);
+  // 3.3.13
+  register sys_psize rw addr( base, 0x20 ) "System Page Size" type(uint32);
+
+  // 3.3.14
+  regarray vf_bar rw addr( base, 0x24 ) [6] "VF BAR" type(uint32);
+
+  // 3.3.15
+  register vf_mig_state ro addr( base, 0x3c ) "VF Migration State Array Offset" {
+    bir	   3		"VF Migration State BIR";
+    offset 29		"VF Migration State Offset";
+  };
+
+};
diff --git a/hake/ArchDefaults.hs b/hake/ArchDefaults.hs
index 93c0661..aaa502d 100644
--- a/hake/ArchDefaults.hs
+++ b/hake/ArchDefaults.hs
@@ -60,7 +60,8 @@ cStdIncs arch archFamily =
       NoDep SrcTree "src" Config.libcInc,
       NoDep SrcTree "src" "/include/c",
       NoDep SrcTree "src" ("/include/target" ./. archFamily),
-      NoDep SrcTree "src" "/include/ipv4", -- XXX
+      NoDep SrcTree "src" Config.lwipxxxInc, -- XXX
+      NoDep SrcTree "src" Config.lwipInc,
       NoDep InstallTree arch "/include",
       NoDep InstallTree arch "/include/dev",
       NoDep SrcTree "src" ".",
diff --git a/hake/Config.hs.template b/hake/Config.hs.template
index 438ec59..cf982a3 100644
--- a/hake/Config.hs.template
+++ b/hake/Config.hs.template
@@ -1,5 +1,5 @@
 --------------------------------------------------------------------------
--- Copyright (c) 2007-2010, 2012, ETH Zurich.
+-- Copyright (c) 2007-2010, 2012, 2013, ETH Zurich.
 -- All rights reserved.
 --
 -- This file is distributed under the terms in the attached LICENSE file.
@@ -275,6 +275,12 @@ libcInc :: String
 libcInc = if libc == "oldc" then "/include/oldc"
           else "/lib/newlib/newlib/libc/include"
 
+-- Sets the include path for lwIP
+lwipInc :: String
+lwipInc = "/lib/lwip/src/include"
+lwipxxxInc :: String
+lwipxxxInc = "/lib/lwip/src/include/ipv4"
+
 -- some defines depend on the architecture/compile options
 arch_defines :: Options -> [RuleToken]
 arch_defines opts
diff --git a/hake/Main.hs b/hake/Main.hs
index 21edf14..36eea1b 100755
--- a/hake/Main.hs
+++ b/hake/Main.hs
@@ -26,6 +26,7 @@ import Data.Dynamic
 import Data.Maybe
 import Data.List
 import Control.Monad
+import Control.Parallel.Strategies
 
 import RuleDefs
 import HakeTypes
@@ -211,7 +212,7 @@ resolveRelativePathName' d a f root =
 --
 makeDirectories :: [(String, HRule)] -> String
 makeDirectories r = 
-    let alldirs = makeDirs1 (Rules [ rl | (f,rl) <- r ])
+    let alldirs = makeDirs1 (Rules [ rl | (f,rl) <- r ]) `using` parListChunk 200 rdeepseq
         marker d = d ./. ".marker"
     in unlines ([ "# Directories follow" ] ++
                 [ "hake_dirs: " ++ (marker d) ++ "\n\n" ++
@@ -219,7 +220,7 @@ makeDirectories r =
                   "\tmkdir -p " ++ d ++ "\n" ++
                   "\ttouch " ++ (marker d) ++ "\n"
                 | d <- nub alldirs])
-       
+
 makeDirs1 :: HRule -> [String]
 makeDirs1 (Rules hrules) = concat [ makeDirs1 r | r <- hrules]
 makeDirs1 (Include tok) = 
@@ -265,7 +266,7 @@ allowedArchs = all (\a -> a `elem` (Config.architectures ++ specialArchitectures
 --
 makeMakefile :: [(String, HRule)] -> String
 makeMakefile r = 
-  unlines $ intersperse "" [makeMakefileSection f rl | (f,rl) <- r]
+  unlines $ intersperse "" ([makeMakefileSection f rl | (f,rl) <- r] `using` parList rdeepseq)
 
 makeMakefileSection :: String -> HRule -> String
 makeMakefileSection fname rules = 
diff --git a/hake/RuleDefs.hs b/hake/RuleDefs.hs
index a25ed38..19cf0dc 100644
--- a/hake/RuleDefs.hs
+++ b/hake/RuleDefs.hs
@@ -932,6 +932,60 @@ appBuildArch af tf args arch =
             )
 
 --
+-- Build an Arrakis application binary
+--
+
+arrakisapplication :: Args.Args
+arrakisapplication = Args.defaultArgs { Args.buildFunction = arrakisApplicationBuildFn }
+
+arrakisApplicationBuildFn :: [String] -> String -> Args.Args -> HRule
+arrakisApplicationBuildFn af tf args
+    | debugFlag && trace (Args.showArgs (tf ++ " Arrakis Application ") args) False
+        = undefined
+arrakisApplicationBuildFn af tf args =
+    Rules [ arrakisAppBuildArch af tf args arch | arch <- Args.architectures args ]
+
+arrakisAppGetOptionsForArch arch args =
+    (options arch) { extraIncludes =
+                         [ NoDep SrcTree "src" a | a <- Args.addIncludes args],
+                     optIncludes = (optIncludes $ options arch) \\
+                         [ NoDep SrcTree "src" i | i <- Args.omitIncludes args ],
+                     optFlags = ((optFlags $ options arch) ++ [ Str "-DARRAKIS" ]) \\
+                                [ Str f | f <- Args.omitCFlags args ],
+                     optCxxFlags = (optCxxFlags $ options arch) \\
+                                   [ Str f | f <- Args.omitCxxFlags args ],
+                     optSuffix = "_for_app_" ++ Args.target args,
+                     optLibs = [ In InstallTree arch "/lib/libarrakis.a" ] ++
+                               ((optLibs $ options arch) \\
+                                [ In InstallTree arch "/lib/libbarrelfish.a" ]),
+                     extraFlags = Args.addCFlags args ++ Args.addCxxFlags args,
+                     extraLdFlags = [ Str f | f <- Args.addLinkFlags args ],
+                     extraDependencies =
+                         [Dep BuildTree arch s | s <- Args.addGeneratedDependencies args]
+                   }
+
+arrakisAppBuildArch af tf args arch =
+    let -- Fiddle the options
+        opts = arrakisAppGetOptionsForArch arch args
+        csrcs = Args.cFiles args
+        cxxsrcs = Args.cxxFiles args
+        appname = Args.target args
+        -- XXX: Not sure if this is correct. Currently assuming that if the app
+        -- contains C++ files, we have to use the C++ linker.
+        mylink = if cxxsrcs == [] then link else linkCxx
+    in
+      Rules ( flounderRules opts args csrcs
+              ++
+              [ mackerelDependencies opts m csrcs | m <- Args.mackerelDevices args ]
+              ++
+              [ compileCFiles opts csrcs,
+                compileCxxFiles opts cxxsrcs,
+                assembleSFiles opts (Args.assemblyFiles args),
+                mylink opts (allObjectPaths opts args) (allLibraryPaths args) appname
+              ]
+            )
+
+--
 -- Build a static library
 --
 
@@ -985,13 +1039,13 @@ data LibDepTree = LibDep String | LibDeps [LibDepTree] deriving (Show,Eq)
 -- manually add dependencies for now (it would be better if each library
 -- defined each own dependencies locally, but that does not seem to be an
 -- easy thing to do currently
-libposixcompat_deps   = LibDeps [ LibDep "posixcompat", liblwip_deps,
+libposixcompat_deps   = LibDeps [ LibDep "posixcompat",
                                   libvfs_deps_all, LibDep "term_server" ]
 liblwip_deps          = LibDeps $ [ LibDep x | x <- deps ]
     where deps = ["lwip" ,"contmng" ,"net_if_raw" ,"timer" ,"hashtable"]
 libnetQmng_deps       = LibDeps $ [ LibDep x | x <- deps ]
     where deps = ["net_queue_manager", "contmng" ,"procon" , "net_if_raw", "bfdmuxvm"]
-libnfs_deps           = LibDeps $ [ LibDep "nfs", liblwip_deps ]
+libnfs_deps           = LibDeps $ [ LibDep "nfs" ]
 libssh_deps           = LibDeps [ libposixcompat_deps, libopenbsdcompat_deps,
                                   LibDep "zlib", LibDep "crypto", LibDep "ssh" ]
 libopenbsdcompat_deps = LibDeps [ libposixcompat_deps, LibDep "crypto",
@@ -1008,6 +1062,7 @@ vfsdeps (VFS_FAT:xs)        = [] ++ vfsdeps xs
 
 libvfs_deps_all        = LibDeps $ vfsdeps [VFS_NFS, VFS_RamFS, VFS_BlockdevFS,
                                             VFS_FAT]
+libvfs_deps_nonfs      = LibDeps $ vfsdeps [VFS_RamFS, VFS_BlockdevFS, VFS_FAT]
 libvfs_deps_nfs        = LibDeps $ vfsdeps [VFS_NFS]
 libvfs_deps_ramfs      = LibDeps $ vfsdeps [VFS_RamFS]
 libvfs_deps_blockdevfs = LibDeps $ vfsdeps [VFS_BlockdevFS]
@@ -1022,6 +1077,7 @@ flat ((LibDeps t):xs) = flat t ++ flat xs
 str2dep :: String -> LibDepTree
 str2dep  str
     | str == "vfs"           = libvfs_deps_all
+    | str == "vfs_nonfs"     = libvfs_deps_nonfs
     | str == "posixcompat"   = libposixcompat_deps
     | str == "lwip"          = liblwip_deps
     | str == "netQmng"       = libnetQmng_deps
@@ -1045,6 +1101,10 @@ libDeps xs = [x | (LibDep x) <- (sortBy xcmp) . nub . flat $ map str2dep xs ]
                   , "net_queue_manager"
                   , "bfdmuxvm"
                   , "lwip"
+                  , "arranet"
+                  , "e1000n"
+                  , "e10k"
+                  , "e10k_vf"
                   , "contmng"
                   , "procon"
                   , "net_if_raw"
diff --git a/hake/hake.sh b/hake/hake.sh
index 91dba77..1d53fad 100755
--- a/hake/hake.sh
+++ b/hake/hake.sh
@@ -1,7 +1,7 @@
 #!/bin/bash
 
 ##########################################################################
-# Copyright (c) 2009, 2011, ETH Zurich.
+# Copyright (c) 2009, 2011, 2013, ETH Zurich.
 # All rights reserved.
 #
 # This file is distributed under the terms in the attached LICENSE file.
@@ -132,16 +132,20 @@ ghc -O --make -XDeriveDataTypeable \
     -i$SRCDIR/hake \
     -ihake \
     -rtsopts=all \
+    -threaded \
     -with-rtsopts="-K32m" \
     $SRCDIR/hake/Main.hs $LDFLAGS || exit 1
 
+    # -eventlog \
+
 if [ "$RUN_HAKE" == "No" ] ; then
     echo "Not running hake as per your request."
     exit
 fi
 
 echo "Running hake..."
-./hake/hake --output-filename Makefile --source-dir "$SRCDIR" || exit
+#./hake/hake --output-filename Makefile --source-dir "$SRCDIR" +RTS -s -N -K64M -A64M -ls -lf || exit
+./hake/hake --output-filename Makefile --source-dir "$SRCDIR" +RTS -N -K64M -A64M || exit
 cat <<EOF
 
 OK - Hake has bootstrapped.  You should now have a Makefile in this
diff --git a/hake/menu.lst.x86_64 b/hake/menu.lst.x86_64
index 3cbdc01..9966ced 100644
--- a/hake/menu.lst.x86_64
+++ b/hake/menu.lst.x86_64
@@ -36,10 +36,7 @@ module /x86_64/sbin/pci auto
 module /x86_64/sbin/ahcid auto
 
 ## For networking
-## For qemu, enable rtl8029
 module /x86_64/sbin/rtl8029 auto
-
-## For real hardware, enable e1000n
 module /x86_64/sbin/e1000n auto
 
 ## Other services needed for networking
diff --git a/hake/symbolic_targets.mk b/hake/symbolic_targets.mk
index 7120851..85a23f1 100644
--- a/hake/symbolic_targets.mk
+++ b/hake/symbolic_targets.mk
@@ -80,6 +80,15 @@ MODULES_GENERIC= \
 # this should shrink as targets are ported and move into the generic list above
 MODULES_x86_64= \
 	sbin/cpu \
+	sbin/e1000test \
+	sbin/e10ktest \
+	sbin/e10ktest_vf \
+	sbin/e10k_ctrl \
+	sbin/udpecho_arranet_e1000 \
+	sbin/udpecho_arranet_e10k \
+	sbin/udpecho_arranet_e10kvf \
+	sbin/udpecho_arranet_e1000_recvfrom \
+	sbin/udpecho_arranet_e10k_recvfrom \
 	sbin/mdbtest_range_query \
 	sbin/mdbtest_addr_zero \
 	sbin/mdb_bench \
@@ -135,6 +144,9 @@ MODULES_x86_64= \
 	$(BIN_RCCE_LU) \
 	sbin/rcce_pingpong \
 	sbin/serial \
+	sbin/arrakismon \
+	sbin/arrakis_hellotest \
+	sbin/socketpipetest \
 	sbin/shared_mem_clock_bench \
 	sbin/sif \
 	sbin/slideshow \
@@ -171,6 +183,7 @@ MODULES_x86_64= \
 	sbin/angler \
 	sbin/sshd \
 	sbin/lshw \
+	sbin/spin \
 
 # the following are broken in the newidc system
 MODULES_x86_64_broken= \
@@ -295,8 +308,12 @@ CLEAN_HD=
 DISK=hd.img
 AHCI=-device ahci,id=ahci -device ide-drive,drive=disk,bus=ahci.0 -drive id=disk,file=$(DISK),if=none
 
+MENU_LST=-kernel $(shell sed -rne 's,^kernel[ \t]*/([^ ]*).*,\1,p' menu.lst) \
+	-append '$(shell sed -rne 's,^kernel[ \t]*[^ ]*[ \t]*(.*),\1,p' menu.lst)' \
+	-initrd '$(shell sed -rne 's,^module(nounzip)?[ \t]*/(.*),\2,p' menu.lst | awk '{ if(NR == 1) printf($$0); else printf("," $$0) } END { printf("\n") }')'
+
 ifeq ($(ARCH),x86_64)
-        QEMU_CMD=qemu-system-x86_64 -no-kvm -smp 2 -m 1024 -net nic,model=ne2k_pci -net user $(AHCI) -fda $(SRCDIR)/tools/grub-qemu.img -tftp $(PWD) -nographic
+        QEMU_CMD=qemu-system-x86_64 -smp 2 -m 1024 -net nic,model=e1000 -net user $(AHCI) -nographic $(MENU_LST)
 	GDB=x86_64-pc-linux-gdb
 	CLEAN_HD=qemu-img create $(DISK) 10M
 else ifeq ($(ARCH),x86_32)
diff --git a/if/Hakefile b/if/Hakefile
index a67bd93..f4ff932 100644
--- a/if/Hakefile
+++ b/if/Hakefile
@@ -68,6 +68,8 @@
                "unixsock",
 	       "bcache",
 	       "replay",
+               "arrakis",
+               "e10k_vf",
 	       "empty"],
              arch <- allArchitectures
 ] ++
diff --git a/if/arrakis.if b/if/arrakis.if
new file mode 100644
index 0000000..bf7fc01
--- /dev/null
+++ b/if/arrakis.if
@@ -0,0 +1,13 @@
+/*
+ * Copyright (c) 2007, 2008, 2009, 2010, 2011, 2012, ETH Zurich.
+ * All rights reserved.
+ *
+ * This file is distributed under the terms in the attached LICENSE file.
+ * If you do not find this file, copies can be found by writing to:
+ * ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich. Attn: Systems Group.
+ */
+
+interface arrakis "Interface to arrakismon" {
+    rpc spawn_arrakis_domain(in string path, in char argvbuf[argvbytes],
+    	in char envbuf[envbytes], out errval err, out domainid domain_id);
+};
diff --git a/if/e10k_vf.if b/if/e10k_vf.if
new file mode 100644
index 0000000..f774eb7
--- /dev/null
+++ b/if/e10k_vf.if
@@ -0,0 +1,13 @@
+/*
+ * Copyright (c) 2007-2011, 2013, ETH Zurich.
+ * All rights reserved.
+ *
+ * This file is distributed under the terms in the attached LICENSE file.
+ * If you do not find this file, copies can be found by writing to:
+ * ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich. Attn: Systems Group.
+ */
+
+interface e10k_vf "e10k VF/PF interface" {
+	  rpc get_mac_address(in uint8 vfn, out uint64 mac);
+	  rpc init_done(in uint8 vfn);
+};
diff --git a/include/Hakefile b/include/Hakefile
index 7c4c218..b8c14c8 100644
--- a/include/Hakefile
+++ b/include/Hakefile
@@ -14,7 +14,6 @@
       | f <- [ 
    "cpiobin.h",
    "dlfcn.h",
-   "lwipopts.h",
    "multicast.h",
    "utime.h",
    "values.h",
diff --git a/include/arch/sys_arch.h b/include/arch/sys_arch.h
deleted file mode 100644
index 6497993..0000000
--- a/include/arch/sys_arch.h
+++ /dev/null
@@ -1,36 +0,0 @@
-/*
- * Copyright (c) 2007, 2008, 2009, 2011, 2012, ETH Zurich.
- * All rights reserved.
- *
- * This file is distributed under the terms in the attached LICENSE file.
- * If you do not find this file, copies can be found by writing to:
- * ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich. Attn: Systems Group.
- */
-
-#ifndef SYS_ARCH_H
-#define SYS_ARCH_H
-
-#include <stdbool.h>
-#include <assert.h>
-#include <barrelfish/thread_sync.h>
-
-/// Protection level
-typedef u8_t    sys_prot_t;
-
-typedef struct thread_wrapper *sys_thread_t;
-
-typedef struct thread_sem *sys_sem_t;
-
-struct bf_sys_mbox {
-    void *msg;
-    bool empty;
-    struct thread_mutex mutex;
-    struct thread_cond changed_cond;
-};
-typedef struct bf_sys_mbox * sys_mbox_t;
-
-
-#define SYS_MBOX_NULL   0
-#define SYS_SEM_NULL    0
-
-#endif
diff --git a/include/arch/x86/barrelfish_kpi/perfmon.h b/include/arch/x86/barrelfish_kpi/perfmon.h
index 5de715e..90c3d3e 100644
--- a/include/arch/x86/barrelfish_kpi/perfmon.h
+++ b/include/arch/x86/barrelfish_kpi/perfmon.h
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2007, 2008, 2009, 2010, ETH Zurich.
+ * Copyright (c) 2007, 2008, 2009, 2010, 2013, ETH Zurich.
  * All rights reserved.
  *
  * This file is distributed under the terms in the attached LICENSE file.
diff --git a/include/arch/x86_64/barrelfish/syscall_arch.h b/include/arch/x86_64/barrelfish/syscall_arch.h
index 1452f09..1bfa695 100644
--- a/include/arch/x86_64/barrelfish/syscall_arch.h
+++ b/include/arch/x86_64/barrelfish/syscall_arch.h
@@ -53,7 +53,8 @@
           "r" (a8), "r" (a9), "r" (a11), "r" (a12), "r" (syscall_num) \
         : "r11", "rcx");
 #else /* DEBUG */
-# define BF_SYSCALL_ASM(arg11, label) \
+# ifndef ARRAKIS
+#  define BF_SYSCALL_ASM(arg11, label) \
     __asm volatile("pushq %%rbp             \n\t"   \
                    "movq %%rcx, %%rbp       \n\t"   \
                    "syscall                 \n\t"   \
@@ -63,6 +64,18 @@
           "+r" (a3), "+r" (a4), "+r" (a5), "+r" (syscall_num)  \
         : "r" (a6), "r" (a7), "r" (a8), "r" (a9), "r" (a12) \
         : "r11");
+#else
+#  define BF_SYSCALL_ASM(arg11, label) \
+    __asm volatile("pushq %%rbp             \n\t"   \
+                   "movq %%rcx, %%rbp       \n\t"   \
+                   "vmmcall                 \n\t"   \
+                   label                            \
+                   "popq %%rbp              \n\t"   \
+        : "+a" (a10_ret1), "+c" (arg11), "+d" (a2_ret2), "+r" (a1), \
+          "+r" (a3), "+r" (a4), "+r" (a5), "+r" (syscall_num)  \
+        : "r" (a6), "r" (a7), "r" (a8), "r" (a9), "r" (a12) \
+        : "r11");
+#endif
 #endif
 
 /* NB: We use a10_ret (in the rax register) as both input and output
diff --git a/include/arch/x86_64/barrelfish_kpi/eflags_arch.h b/include/arch/x86_64/barrelfish_kpi/eflags_arch.h
index 4fffc24..b694000 100644
--- a/include/arch/x86_64/barrelfish_kpi/eflags_arch.h
+++ b/include/arch/x86_64/barrelfish_kpi/eflags_arch.h
@@ -4,7 +4,7 @@
  */
 
 /*
- * Copyright (c) 2010, ETH Zurich.
+ * Copyright (c) 2010, 2013, ETH Zurich.
  * All rights reserved.
  *
  * This file is distributed under the terms in the attached LICENSE file.
@@ -18,8 +18,16 @@
 /**
  * State of EFLAGS when executing a user-space program: Enable interrupts
  */
-#define USER_CS                         0x23
-#define USER_SS                         0x1b
+#ifndef ARRAKIS
+// Unprivileged mode
+#       define USER_CS                         0x23
+#       define USER_SS                         0x1b
+#else
+// Privileged mode
+#       define USER_CS                         0x8
+#       define USER_SS                         0x10
+#endif
+
 #define USER_EFLAGS                     0x202
 
 #endif // ARCH_X86_64_BARRELFISH_KPI_EFLAGS_H
diff --git a/include/arpa/inet.h b/include/arpa/inet.h
index c160458..a26795d 100644
--- a/include/arpa/inet.h
+++ b/include/arpa/inet.h
@@ -3,4 +3,9 @@
 
 #include <lwip/sockets.h>
 
+const char *
+inet_ntop(int af, const void * __restrict src, char * __restrict dst,
+          socklen_t size);
+int inet_pton(int af, const char * __restrict src, void * __restrict dst);
+
 #endif
diff --git a/include/arranet.h b/include/arranet.h
new file mode 100644
index 0000000..b7178fc
--- /dev/null
+++ b/include/arranet.h
@@ -0,0 +1,34 @@
+/*
+ * Copyright (c) 2014, ETH Zurich.
+ * All rights reserved.
+ *
+ * This file is distributed under the terms in the attached LICENSE file.
+ * If you do not find this file, copies can be found by writing to:
+ * ETH Zurich D-INFK, CAB F.78, Universitaetstr. 6, CH-8092 Zurich. 
+ * Attn: Systems Group.
+ */
+
+#ifndef ARRAKIS_ARRANET_H
+#define ARRAKIS_ARRANET_H
+
+struct packet {
+    struct packet       *next;
+    uint8_t             *payload;
+    lpaddr_t            pa;
+    size_t              len;
+    uint64_t            flags;
+    struct socket       *sock;
+    void                *opaque;
+};
+
+typedef void (*arranet_tx_done_fn)(void *opaque);
+
+int recvfrom_arranet(int sockfd, void **buf, struct packet **p,
+                     struct sockaddr *src_addr, socklen_t *addrlen);
+void arranet_recv_free(struct packet *p);
+int sendmsg_arranet(int sockfd, const struct msghdr *msg);
+void arranet_register_tx_done_callback(arranet_tx_done_fn callback);
+
+#define SENDMSG_WITH_COPY
+
+#endif
diff --git a/include/arranet_debug.h b/include/arranet_debug.h
new file mode 100644
index 0000000..c56f09f
--- /dev/null
+++ b/include/arranet_debug.h
@@ -0,0 +1,117 @@
+/*
+ * Copyright (c) 2014, ETH Zurich.
+ * All rights reserved.
+ *
+ * This file is distributed under the terms in the attached LICENSE file.
+ * If you do not find this file, copies can be found by writing to:
+ * ETH Zurich D-INFK, CAB F.78, Universitaetstr. 6, CH-8092 Zurich. 
+ * Attn: Systems Group.
+ */
+
+#ifndef ARRANET_DEBUG_H
+#define ARRANET_DEBUG_H
+
+//#define DEBUG_LATENCIES
+
+//#include <lwip/udp.h>
+#include <arranet_impl.h>
+#include <barrelfish/sys_debug.h>
+
+#define POSIX_TRANSA    1000
+
+#define MIN(a,b)        ((a) < (b) ? (a) : (b))
+
+#define	timersub(a, b, result)						      \
+  do {									      \
+    (result)->tv_sec = (a)->tv_sec - (b)->tv_sec;			      \
+    (result)->tv_usec = (a)->tv_usec - (b)->tv_usec;			      \
+    if ((result)->tv_usec < 0) {					      \
+      --(result)->tv_sec;						      \
+      (result)->tv_usec += 1000000;					      \
+    }									      \
+  } while (0)
+
+    /**
+     * Definition of the header structure for a request packet.
+     * See section 2
+     */
+    typedef union {
+        struct {
+            uint8_t magic;
+            uint8_t opcode;
+            uint16_t keylen;
+            uint8_t extlen;
+            uint8_t datatype;
+            uint16_t reserved;
+            uint32_t bodylen;
+            uint32_t opaque;
+            uint64_t cas;
+        } request;
+        uint8_t bytes[24];
+    } protocol_binary_request_header;
+
+    /**
+     * Definition of the header structure for a response packet.
+     * See section 2
+     */
+    typedef union {
+        struct {
+            uint8_t magic;
+            uint8_t opcode;
+            uint16_t keylen;
+            uint8_t extlen;
+            uint8_t datatype;
+            uint16_t status;
+            uint32_t bodylen;
+            uint32_t opaque;
+            uint64_t cas;
+        } response;
+        uint8_t bytes[24];
+    } protocol_binary_response_header;
+
+    /**
+     * Definition of a request-packet containing no extras
+     */
+    typedef union {
+        struct {
+            protocol_binary_request_header header;
+        } message;
+        uint8_t bytes[sizeof(protocol_binary_request_header)];
+    } protocol_binary_request_no_extras;
+
+    /**
+     * Definition of a response-packet containing no extras
+     */
+    typedef union {
+        struct {
+            protocol_binary_response_header header;
+        } message;
+        uint8_t bytes[sizeof(protocol_binary_response_header)];
+    } protocol_binary_response_no_extras;
+
+typedef struct {
+  uint16_t req_id;
+  uint16_t seq_id;
+  uint16_t n_data;
+  uint16_t extras;
+} memcached_udp_header;
+
+#define UDP_HEADLEN sizeof(memcached_udp_header)
+
+static inline int get_time(void)
+{
+    uint64_t now = rdtsc();
+    static uint64_t tscperms = 0;
+
+    if(tscperms == 0) {
+        errval_t err = sys_debug_get_tsc_per_ms(&tscperms);
+        assert(err_is_ok(err));
+        assert(tscperms >= 100000);
+    }
+
+    uint64_t tod_us = now / (tscperms / 100000);
+
+    return tod_us;
+}
+
+#endif
diff --git a/include/arranet_impl.h b/include/arranet_impl.h
new file mode 100644
index 0000000..9c36946
--- /dev/null
+++ b/include/arranet_impl.h
@@ -0,0 +1,206 @@
+/*
+ * Copyright (c) 2014, ETH Zurich.
+ * All rights reserved.
+ *
+ * This file is distributed under the terms in the attached LICENSE file.
+ * If you do not find this file, copies can be found by writing to:
+ * ETH Zurich D-INFK, CAB F.78, Universitaetstr. 6, CH-8092 Zurich. 
+ * Attn: Systems Group.
+ */
+
+#ifndef ARRANET_IMPL_H
+#define ARRANET_IMPL_H
+
+#ifndef ETHARP_HWADDR_LEN
+#define ETHARP_HWADDR_LEN     6
+#endif
+
+PACK_STRUCT_BEGIN
+struct eth_addr {
+  PACK_STRUCT_FIELD(u8_t addr[ETHARP_HWADDR_LEN]);
+} PACK_STRUCT_STRUCT;
+PACK_STRUCT_END
+
+PACK_STRUCT_BEGIN
+/** Ethernet header */
+struct eth_hdr {
+#if ETH_PAD_SIZE
+  PACK_STRUCT_FIELD(u8_t padding[ETH_PAD_SIZE]);
+#endif
+  PACK_STRUCT_FIELD(struct eth_addr dest);
+  PACK_STRUCT_FIELD(struct eth_addr src);
+  PACK_STRUCT_FIELD(u16_t type);
+} PACK_STRUCT_STRUCT;
+PACK_STRUCT_END
+
+#define SIZEOF_ETH_HDR (14 + ETH_PAD_SIZE)
+
+PACK_STRUCT_BEGIN
+/** the ARP message, see RFC 826 ("Packet format") */
+struct etharp_hdr {
+  PACK_STRUCT_FIELD(u16_t hwtype);
+  PACK_STRUCT_FIELD(u16_t proto);
+  PACK_STRUCT_FIELD(u8_t  hwlen);
+  PACK_STRUCT_FIELD(u8_t  protolen);
+  PACK_STRUCT_FIELD(u16_t opcode);
+  PACK_STRUCT_FIELD(struct eth_addr shwaddr);
+  PACK_STRUCT_FIELD(struct ip_addr2 sipaddr);
+  PACK_STRUCT_FIELD(struct eth_addr dhwaddr);
+  PACK_STRUCT_FIELD(struct ip_addr2 dipaddr);
+} PACK_STRUCT_STRUCT;
+PACK_STRUCT_END
+
+#define SIZEOF_ETHARP_HDR 28
+#define SIZEOF_ETHARP_PACKET (SIZEOF_ETH_HDR + SIZEOF_ETHARP_HDR)
+
+#define ETHTYPE_ARP       0x0806U
+#define ETHTYPE_IP        0x0800U
+#define ETHTYPE_VLAN      0x8100U
+#define ETHTYPE_PPPOEDISC 0x8863U  /* PPP Over Ethernet Discovery Stage */
+#define ETHTYPE_PPPOE     0x8864U  /* PPP Over Ethernet Session Stage */
+
+#define ETH_PAD_SIZE          0
+
+/** ARP message types (opcodes) */
+#define ARP_REQUEST 1
+#define ARP_REPLY   2
+
+PACK_STRUCT_BEGIN
+struct ip_hdr {
+  /* version / header length */
+  PACK_STRUCT_FIELD(u8_t _v_hl);
+  /* type of service */
+  PACK_STRUCT_FIELD(u8_t _tos);
+  /* total length */
+  PACK_STRUCT_FIELD(u16_t _len);
+  /* identification */
+  PACK_STRUCT_FIELD(u16_t _id);
+  /* fragment offset field */
+  PACK_STRUCT_FIELD(u16_t _offset);
+#define IP_RF 0x8000U        /* reserved fragment flag */
+#define IP_DF 0x4000U        /* dont fragment flag */
+#define IP_MF 0x2000U        /* more fragments flag */
+#define IP_OFFMASK 0x1fffU   /* mask for fragmenting bits */
+  /* time to live */
+  PACK_STRUCT_FIELD(u8_t _ttl);
+  /* protocol*/
+  PACK_STRUCT_FIELD(u8_t _proto);
+  /* checksum */
+  PACK_STRUCT_FIELD(u16_t _chksum);
+  /* source and destination IP addresses */
+  PACK_STRUCT_FIELD(ip_addr_p_t src);
+  PACK_STRUCT_FIELD(ip_addr_p_t dest); 
+} PACK_STRUCT_STRUCT;
+PACK_STRUCT_END
+
+#define IPH_V(hdr)  ((hdr)->_v_hl >> 4)
+#define IPH_HL(hdr) ((hdr)->_v_hl & 0x0f)
+#define IPH_TOS(hdr) ((hdr)->_tos)
+#define IPH_LEN(hdr) ((hdr)->_len)
+#define IPH_ID(hdr) ((hdr)->_id)
+#define IPH_OFFSET(hdr) ((hdr)->_offset)
+#define IPH_TTL(hdr) ((hdr)->_ttl)
+#define IPH_PROTO(hdr) ((hdr)->_proto)
+#define IPH_CHKSUM(hdr) ((hdr)->_chksum)
+
+#define IPH_VHL_SET(hdr, v, hl) (hdr)->_v_hl = (((v) << 4) | (hl))
+#define IPH_TOS_SET(hdr, tos) (hdr)->_tos = (tos)
+#define IPH_LEN_SET(hdr, len) (hdr)->_len = (len)
+#define IPH_ID_SET(hdr, id) (hdr)->_id = (id)
+#define IPH_OFFSET_SET(hdr, off) (hdr)->_offset = (off)
+#define IPH_TTL_SET(hdr, ttl) (hdr)->_ttl = (u8_t)(ttl)
+#define IPH_PROTO_SET(hdr, proto) (hdr)->_proto = (u8_t)(proto)
+#define IPH_CHKSUM_SET(hdr, chksum) (hdr)->_chksum = (chksum)
+
+#define IP_HLEN 20
+
+#define IP_PROTO_ICMP    1
+#define IP_PROTO_IGMP    2
+#define IP_PROTO_UDP     17
+#define IP_PROTO_UDPLITE 136
+#define IP_PROTO_TCP     6
+
+PACK_STRUCT_BEGIN
+struct udp_hdr {
+  PACK_STRUCT_FIELD(u16_t src);
+  PACK_STRUCT_FIELD(u16_t dest);  /* src/dest UDP ports */
+  PACK_STRUCT_FIELD(u16_t len);
+  PACK_STRUCT_FIELD(u16_t chksum);
+} PACK_STRUCT_STRUCT;
+PACK_STRUCT_END
+
+PACK_STRUCT_BEGIN
+struct tcp_hdr {
+  PACK_STRUCT_FIELD(u16_t src);
+  PACK_STRUCT_FIELD(u16_t dest);
+  PACK_STRUCT_FIELD(u32_t seqno);
+  PACK_STRUCT_FIELD(u32_t ackno);
+  PACK_STRUCT_FIELD(u16_t _hdrlen_rsvd_flags);
+  PACK_STRUCT_FIELD(u16_t wnd);
+  PACK_STRUCT_FIELD(u16_t chksum);
+  PACK_STRUCT_FIELD(u16_t urgp);
+} PACK_STRUCT_STRUCT;
+PACK_STRUCT_END
+
+#define TCP_FIN 0x01U
+#define TCP_SYN 0x02U
+#define TCP_RST 0x04U
+#define TCP_PSH 0x08U
+#define TCP_ACK 0x10U
+#define TCP_URG 0x20U
+#define TCP_ECE 0x40U
+#define TCP_CWR 0x80U
+
+#define TCP_FLAGS 0x3fU
+
+/* Length of the TCP header, excluding options. */
+#define TCP_HLEN 20
+
+#define TCPH_HDRLEN(phdr) (ntohs((phdr)->_hdrlen_rsvd_flags) >> 12)
+#define TCPH_FLAGS(phdr)  (ntohs((phdr)->_hdrlen_rsvd_flags) & TCP_FLAGS)
+
+#define TCPH_HDRLEN_SET(phdr, len) (phdr)->_hdrlen_rsvd_flags = htons(((len) << 12) | TCPH_FLAGS(phdr))
+#define TCPH_FLAGS_SET(phdr, flags) (phdr)->_hdrlen_rsvd_flags = (((phdr)->_hdrlen_rsvd_flags & PP_HTONS((u16_t)(~(u16_t)(TCP_FLAGS)))) | htons(flags))
+#define TCPH_HDRLEN_FLAGS_SET(phdr, len, flags) (phdr)->_hdrlen_rsvd_flags = htons(((len) << 12) | (flags))
+
+#define TCPH_SET_FLAG(phdr, flags ) (phdr)->_hdrlen_rsvd_flags = ((phdr)->_hdrlen_rsvd_flags | htons(flags))
+#define TCPH_UNSET_FLAG(phdr, flags) (phdr)->_hdrlen_rsvd_flags = htons(ntohs((phdr)->_hdrlen_rsvd_flags) | (TCPH_FLAGS(phdr) & ~(flags)) )
+
+#define TCP_TCPLEN(seg) ((seg)->len + ((TCPH_FLAGS((seg)->tcphdr) & (TCP_FIN | TCP_SYN)) != 0))
+
+/** This returns a TCP header option for MSS in an u32_t */
+#define TCP_BUILD_MSS_OPTION(mss) htonl(0x02040000 | ((mss) & 0xFFFF))
+
+void lwip_mutex_lock(void);
+void lwip_mutex_unlock(void);
+
+// XXX: These assume a little-endian system!
+/* These macros should be calculated by the preprocessor and are used
+   with compile-time constants only (so that there is no little-endian
+   overhead at runtime). */
+#define PP_HTONS(x) ((((x) & 0xff) << 8) | (((x) & 0xff00) >> 8))
+#define PP_NTOHS(x) PP_HTONS(x)
+#define PP_HTONL(x) ((((x) & 0xff) << 24) | \
+                     (((x) & 0xff00) << 8) | \
+                     (((x) & 0xff0000UL) >> 8) | \
+                     (((x) & 0xff000000UL) >> 24))
+#define PP_NTOHL(x) PP_HTONL(x)
+
+#define lwip_htons(x) LWIP_PLATFORM_HTONS(x)
+#define lwip_ntohs(x) LWIP_PLATFORM_HTONS(x)
+#define lwip_htonl(x) LWIP_PLATFORM_HTONL(x)
+#define lwip_ntohl(x) LWIP_PLATFORM_HTONL(x)
+
+#define ip_addr_isbroadcast(ipaddr, netif) ip4_addr_isbroadcast((ipaddr)->addr, (netif))
+u8_t ip4_addr_isbroadcast(u32_t addr, const struct netif *netif);
+
+#define ip_addr_netmask_valid(netmask) ip4_addr_netmask_valid((netmask)->addr)
+u8_t ip4_addr_netmask_valid(u32_t netmask);
+
+u32_t ipaddr_addr(const char *cp);
+int ipaddr_aton(const char *cp, ip_addr_t *addr);
+/** returns ptr to static buffer; not reentrant! */
+char *ipaddr_ntoa(const ip_addr_t *addr);
+char *ipaddr_ntoa_r(const ip_addr_t *addr, char *buf, int buflen);
+
+#endif
diff --git a/include/barrelfish/core_state.h b/include/barrelfish/core_state.h
index f216b37..adc7007 100644
--- a/include/barrelfish/core_state.h
+++ b/include/barrelfish/core_state.h
@@ -41,11 +41,21 @@ struct captrack {
 };
 #endif // 0 DELETEME
 
+#define MAX_V2P_MAPPINGS        64
+
+struct v2pmap {
+    genvaddr_t  va;
+    genpaddr_t  pa;
+    size_t      size;
+};
+
 struct morecore_state {
     struct thread_mutex mutex;
     Header header_base;
     Header *header_freep;
     struct vspace_mmu_aware mmu_state;
+    struct v2pmap v2p_mappings[MAX_V2P_MAPPINGS];
+    int v2p_entries;
 #if 0 // DELETEME
     struct captrack track_frames[MAX_TRACK_FRAMES];
 #endif // 0 DELETEME
@@ -88,6 +98,7 @@ struct spawn_state;
 struct monitor_binding;
 struct mem_rpc_client;
 struct spawn_rpc_client;
+struct arrakis_rpc_client;
 
 struct core_state_generic {
     struct waitset default_waitset;
@@ -98,6 +109,7 @@ struct core_state_generic {
     struct ram_alloc_state ram_alloc_state;
     struct octopus_rpc_client *octopus_rpc_client;
     struct spawn_rpc_client *spawn_rpc_clients[MAX_CPUS];
+    struct arrakis_rpc_client *arrakis_rpc_clients[MAX_CPUS];
     struct terminal_state *terminal_state;
     struct domain_state *domain_state;
     struct spawn_state *spawn_state;
diff --git a/include/barrelfish/debug.h b/include/barrelfish/debug.h
index 630622d..43b9356 100644
--- a/include/barrelfish/debug.h
+++ b/include/barrelfish/debug.h
@@ -39,7 +39,7 @@ void debug_dump(arch_registers_state_t *state);
 void debug_call_chain(arch_registers_state_t *state);
 void debug_return_addresses(void);
 void debug_dump_mem_around_addr(lvaddr_t addr);
-void debug_dump_mem(lvaddr_t base, lvaddr_t limit);
+void debug_dump_mem(lvaddr_t base, lvaddr_t limit, lvaddr_t point);
 
 void debug_err(const char *file, const char *func, int line,
                errval_t err, const char *msg, ...);
diff --git a/include/barrelfish/deferred.h b/include/barrelfish/deferred.h
index 9a512ff..ffa4e21 100644
--- a/include/barrelfish/deferred.h
+++ b/include/barrelfish/deferred.h
@@ -4,7 +4,7 @@
  */
 
 /*
- * Copyright (c) 2009, 2011, ETH Zurich.
+ * Copyright (c) 2009, 2011, 2013, ETH Zurich.
  * All rights reserved.
  *
  * This file is distributed under the terms in the attached LICENSE file.
@@ -33,6 +33,7 @@ errval_t deferred_event_register(struct deferred_event *event,
                                  struct waitset *ws, delayus_t delay,
                                  struct event_closure closure);
 errval_t deferred_event_cancel(struct deferred_event *event);
+errval_t barrelfish_usleep(delayus_t delay);
 
 struct periodic_event {
     struct deferred_event de;
diff --git a/include/barrelfish/domain.h b/include/barrelfish/domain.h
index eb705be..68ff2d3 100644
--- a/include/barrelfish/domain.h
+++ b/include/barrelfish/domain.h
@@ -28,6 +28,7 @@ struct monitor_binding;
 struct monitor_blocking_rpc_client;
 struct waitset;
 struct spawn_rpc_client;
+struct arrakis_rpc_client;
 
 struct waitset *get_default_waitset(void);
 void disp_set_core_id(coreid_t core_id);
@@ -48,7 +49,9 @@ struct ram_alloc_state *get_ram_alloc_state(void);
 void set_octopus_rpc_client(struct octopus_rpc_client *st);
 struct octopus_rpc_client *get_octopus_rpc_client(void);
 void set_spawn_rpc_client(coreid_t core, struct spawn_rpc_client *st);
+void set_arrakis_rpc_client(coreid_t core, struct arrakis_rpc_client *st);
 struct spawn_rpc_client *get_spawn_rpc_client(coreid_t core);
+struct arrakis_rpc_client *get_arrakis_rpc_client(coreid_t core);
 struct terminal_state *get_terminal_state(void);
 void set_terminal_state(struct terminal_state *st);
 struct domain_state *get_domain_state(void);
diff --git a/include/barrelfish/inthandler.h b/include/barrelfish/inthandler.h
index c103a59..a999522 100644
--- a/include/barrelfish/inthandler.h
+++ b/include/barrelfish/inthandler.h
@@ -21,6 +21,8 @@ errval_t inthandler_setup(interrupt_handler_fn handler, void *handler_arg,
 errval_t inthandler_setup_arm(interrupt_handler_fn handler, void *handler_arg,
         uint32_t irq);
 
+extern struct waitset *barrelfish_interrupt_waitset;
+
 __END_DECLS
 
 #endif
diff --git a/include/barrelfish/memobj.h b/include/barrelfish/memobj.h
index fac10c5..80f40b0 100644
--- a/include/barrelfish/memobj.h
+++ b/include/barrelfish/memobj.h
@@ -96,6 +96,7 @@ struct memobj_frame_list {
     genpaddr_t offset;              ///< Offset into the frame
     struct capref frame;            ///< Capability of the frame
     size_t size;                    ///< Size of the frame
+    genpaddr_t pa;                  ///< XXX: physical address of frame
     struct memobj_frame_list *next;
 };
 
diff --git a/include/barrelfish/spawn_client.h b/include/barrelfish/spawn_client.h
index 48a2f7c..5fc7671 100644
--- a/include/barrelfish/spawn_client.h
+++ b/include/barrelfish/spawn_client.h
@@ -35,6 +35,11 @@ errval_t spawn_program_with_caps(coreid_t coreid, const char *path,
                                  struct capref inheritcn_cap,
                                  struct capref argcn_cap, spawn_flags_t flags,
                                  domainid_t *ret_domainid);
+errval_t spawn_arrakis_program(coreid_t coreid, const char *path,
+                                 char *const argv[], char *const envp[],
+                                 struct capref inheritcn_cap,
+                                 struct capref argcn_cap, spawn_flags_t flags,
+                                 domainid_t *ret_domainid);
 errval_t spawn_program(coreid_t coreid, const char *path,
                        char *const argv[], char *const envp[],
                        spawn_flags_t flags, domainid_t *ret_domainid);
diff --git a/include/barrelfish/sys_debug.h b/include/barrelfish/sys_debug.h
index 16c2482..94fc23d 100644
--- a/include/barrelfish/sys_debug.h
+++ b/include/barrelfish/sys_debug.h
@@ -32,6 +32,7 @@ errval_t sys_debug_context_counter_reset(void);
 errval_t sys_debug_context_counter_read(uint64_t *ret);
 errval_t sys_debug_timeslice_counter_read(uint64_t *ret);
 errval_t sys_debug_get_tsc_per_ms(uint64_t *ret);
+errval_t sys_debug_get_apic_id(uint8_t *ret);
 errval_t sys_debug_get_apic_timer(uint32_t *ret);
 errval_t sys_debug_print_context_counter(void);
 errval_t sys_debug_print_timeslice(void);
diff --git a/include/barrelfish/threads.h b/include/barrelfish/threads.h
index 2050cd8..d57e4b0 100644
--- a/include/barrelfish/threads.h
+++ b/include/barrelfish/threads.h
@@ -66,6 +66,12 @@ void thread_sem_post(struct thread_sem *sem);
 void thread_set_tls(void *);
 void *thread_get_tls(void);
 
+void thread_set_tls_key(int, void *);
+void *thread_get_tls_key(int);
+
+uintptr_t thread_id(void);
+void thread_set_id(uintptr_t id);
+
 __END_DECLS
 
 #endif
diff --git a/include/barrelfish/waitset_chan.h b/include/barrelfish/waitset_chan.h
index 8c60a42..3d04d69 100644
--- a/include/barrelfish/waitset_chan.h
+++ b/include/barrelfish/waitset_chan.h
@@ -38,6 +38,9 @@ errval_t waitset_chan_register(struct waitset *ws, struct waitset_chanstate *cha
                                struct event_closure closure);
 void waitset_chan_migrate(struct waitset_chanstate *chan,
                           struct waitset *new_ws);
+errval_t waitset_chan_register_polled(struct waitset *ws,
+                                      struct waitset_chanstate *chan,
+                                      struct event_closure closure);
 
 __END_DECLS
 
diff --git a/include/barrelfish_kpi/sys_debug.h b/include/barrelfish_kpi/sys_debug.h
index 13809fd..00a39e7 100644
--- a/include/barrelfish_kpi/sys_debug.h
+++ b/include/barrelfish_kpi/sys_debug.h
@@ -29,7 +29,8 @@ enum debug_message {
     DEBUG_GET_TSC_PER_MS,
     DEBUG_GET_APIC_TIMER,
     DEBUG_GET_APIC_TICKS_PER_SEC,
-    DEBUG_FEIGN_FRAME_CAP
+    DEBUG_FEIGN_FRAME_CAP,
+    DEBUG_GET_APIC_ID
 };
 
 #endif //BARRELFISH_KPI_SYS_DEBUG_H
diff --git a/include/contmng/netbench.h b/include/contmng/netbench.h
index 8eb0065..09c8854 100644
--- a/include/contmng/netbench.h
+++ b/include/contmng/netbench.h
@@ -76,7 +76,12 @@ struct netbench_details {
     char name[NAME_SIZE];
 };
 
+// Utility functions
+uint64_t my_avg(uint64_t sum, uint64_t n);
 
+#ifndef LIBRARY
+
+float in_seconds(uint64_t cycles);
 void netbench_reset(struct netbench_details *nbp);
 struct netbench_details *netbench_alloc(char *name, uint32_t total_events);
 
@@ -91,9 +96,22 @@ void netbench_print_event_stat(struct netbench_details *nbp,
         uint8_t event_type, char *event_name, int type);
 void netbench_print_all_stats(struct netbench_details *nbp);
 
-// Utility functions
-uint64_t my_avg(uint64_t sum, uint64_t n);
-float in_seconds(uint64_t cycles);
+#else
+
+#define netbench_reset(a)
+#define netbench_alloc(a, b)
+#define netbench_record_event(a, b, c)
+#define netbench_record_event_no_ts(a, b)
+#define netbench_record_event_simple(a, b, c)   while(0) { (void)c; }
+#define netbench_print_event_stat(a, b, c, d)
+#define netbench_print_all_stats(a)
+
+static inline float in_seconds(uint64_t cycles)
+{
+    return cycles;
+}
+
+#endif
 
 __END_DECLS
 
diff --git a/include/fcntl.h b/include/fcntl.h
index 1c02807..c662def 100644
--- a/include/fcntl.h
+++ b/include/fcntl.h
@@ -88,7 +88,9 @@ typedef	__pid_t		pid_t;
 #define O_NOCTTY   00400
 #define O_TRUNC    01000	
 #define O_APPEND   02000
+#ifndef O_NONBLOCK
 #define O_NONBLOCK 04000
+#endif
 #define O_SYNC    010000
 #define O_FSYNC	  O_SYNC
 #define O_ASYNC	  020000
@@ -151,8 +153,10 @@ typedef	__pid_t		pid_t;
 #define	FFSYNC		O_FSYNC		/* kernel */
 #define	FNONBLOCK	O_NONBLOCK	/* kernel */
 #define	FNDELAY		O_NONBLOCK	/* compat */
+#ifndef O_NDELAY
 #define	O_NDELAY	O_NONBLOCK	/* compat */
 #endif
+#endif
 
 /*
  * We are out of bits in f_flag (which is a short).  However,
diff --git a/include/ipv4/lwip/autoip.h b/include/ipv4/lwip/autoip.h
deleted file mode 100644
index 83c0da5..0000000
--- a/include/ipv4/lwip/autoip.h
+++ /dev/null
@@ -1,104 +0,0 @@
-/**
- * @file
- *
- * AutoIP Automatic LinkLocal IP Configuration
- */
-
-/*
- *
- * Copyright (c) 2007 Dominik Spies <kontakt@dspies.de>
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * Author: Dominik Spies <kontakt@dspies.de>
- *
- * This is a AutoIP implementation for the lwIP TCP/IP stack. It aims to conform
- * with RFC 3927.
- *
- *
- * Please coordinate changes and requests with Dominik Spies
- * <kontakt@dspies.de>
- */
-
-#ifndef __LWIP_AUTOIP_H__
-#define __LWIP_AUTOIP_H__
-
-#include "lwip/opt.h"
-
-#if LWIP_AUTOIP                 /* don't build if not configured for use in lwipopts.h */
-
-#include "lwip/netif.h"
-#include "lwip/udp.h"
-#include "netif/etharp.h"
-
-/* AutoIP Timing */
-#define AUTOIP_TMR_INTERVAL      100
-#define AUTOIP_TICKS_PER_SECOND (1000 / AUTOIP_TMR_INTERVAL)
-
-/* RFC 3927 Constants */
-#define PROBE_WAIT               1      /* second   (initial random delay)                 */
-#define PROBE_MIN                1      /* second   (minimum delay till repeated probe)    */
-#define PROBE_MAX                2      /* seconds  (maximum delay till repeated probe)    */
-#define PROBE_NUM                3      /*          (number of probe packets)              */
-#define ANNOUNCE_NUM             2      /*          (number of announcement packets)       */
-#define ANNOUNCE_INTERVAL        2      /* seconds  (time between announcement packets)    */
-#define ANNOUNCE_WAIT            2      /* seconds  (delay before announcing)              */
-#define MAX_CONFLICTS            10     /*          (max conflicts before rate limiting)   */
-#define RATE_LIMIT_INTERVAL      60     /* seconds  (delay between successive attempts)    */
-#define DEFEND_INTERVAL          10     /* seconds  (min. wait between defensive ARPs)     */
-
-/* AutoIP client states */
-#define AUTOIP_STATE_OFF         0
-#define AUTOIP_STATE_PROBING     1
-#define AUTOIP_STATE_ANNOUNCING  2
-#define AUTOIP_STATE_BOUND       3
-
-struct autoip {
-    struct ip_addr llipaddr;    /* the currently selected, probed, announced or used LL IP-Address */
-    u8_t state;                 /* current AutoIP state machine state */
-    u8_t sent_num;              /* sent number of probes or announces, dependent on state */
-    u16_t ttw;                  /* ticks to wait, tick is AUTOIP_TMR_INTERVAL long */
-    u8_t lastconflict;          /* ticks until a conflict can be solved by defending */
-    u8_t tried_llipaddr;        /* total number of probed/used Link Local IP-Addresses */
-};
-
-
-/** Init srand, has to be called before entering mainloop */
-void autoip_init(void);
-
-/** Start AutoIP client */
-err_t autoip_start(struct netif *netif);
-
-/** Stop AutoIP client */
-err_t autoip_stop(struct netif *netif);
-
-/** Handles every incoming ARP Packet, called by etharp_arp_input */
-void autoip_arp_reply(struct netif *netif, struct etharp_hdr *hdr);
-
-/** Has to be called in loop every AUTOIP_TMR_INTERVAL milliseconds */
-void autoip_tmr(void);
-
-#endif                          /* LWIP_AUTOIP */
-
-#endif                          /* __LWIP_AUTOIP_H__ */
diff --git a/include/ipv4/lwip/icmp.h b/include/ipv4/lwip/icmp.h
deleted file mode 100644
index fa36e1b..0000000
--- a/include/ipv4/lwip/icmp.h
+++ /dev/null
@@ -1,110 +0,0 @@
-/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved. 
- * 
- * Redistribution and use in source and binary forms, with or without modification, 
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission. 
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- * 
- * Author: Adam Dunkels <adam@sics.se>
- *
- */
-#ifndef __LWIP_ICMP_H__
-#define __LWIP_ICMP_H__
-
-#include "lwip/opt.h"
-
-#if LWIP_ICMP                   /* don't build if not configured for use in lwipopts.h */
-
-#include "lwip/pbuf.h"
-#include "lwip/ip_addr.h"
-#include "lwip/netif.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#define ICMP_ER 0               /* echo reply */
-#define ICMP_DUR 3              /* destination unreachable */
-#define ICMP_SQ 4               /* source quench */
-#define ICMP_RD 5               /* redirect */
-#define ICMP_ECHO 8             /* echo */
-#define ICMP_TE 11              /* time exceeded */
-#define ICMP_PP 12              /* parameter problem */
-#define ICMP_TS 13              /* timestamp */
-#define ICMP_TSR 14             /* timestamp reply */
-#define ICMP_IRQ 15             /* information request */
-#define ICMP_IR 16              /* information reply */
-
-    enum icmp_dur_type {
-        ICMP_DUR_NET = 0,       /* net unreachable */
-        ICMP_DUR_HOST = 1,      /* host unreachable */
-        ICMP_DUR_PROTO = 2,     /* protocol unreachable */
-        ICMP_DUR_PORT = 3,      /* port unreachable */
-        ICMP_DUR_FRAG = 4,      /* fragmentation needed and DF set */
-        ICMP_DUR_SR = 5         /* source route failed */
-    };
-
-    enum icmp_te_type {
-        ICMP_TE_TTL = 0,        /* time to live exceeded in transit */
-        ICMP_TE_FRAG = 1        /* fragment reassembly time exceeded */
-    };
-
-/* for ICMP notifications needed for ICMP benchmark. */
-    typedef void (*icmp_notification_fn) (struct pbuf * p);
-    void record_icmp_upcall(icmp_notification_fn notification_function_name);
-
-    void icmp_input(struct pbuf *p, struct netif *inp);
-
-    void icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t);
-    void icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t);
-
-#ifdef PACK_STRUCT_USE_INCLUDES
-#include "arch/bpstruct.h"
-#endif
-/** This is the standard ICMP header only that the u32_t data
- *  is splitted to two u16_t like ICMP echo needs it.
- *  This header is also used for other ICMP types that do not
- *  use the data part.
- */
-     PACK_STRUCT_BEGIN struct icmp_echo_hdr {
-        PACK_STRUCT_FIELD(u8_t type);
-        PACK_STRUCT_FIELD(u8_t code);
-        PACK_STRUCT_FIELD(u16_t chksum);
-        PACK_STRUCT_FIELD(u16_t id);
-        PACK_STRUCT_FIELD(u16_t seqno);
-    } PACK_STRUCT_STRUCT;
-     PACK_STRUCT_END
-#ifdef PACK_STRUCT_USE_INCLUDES
-#include "arch/epstruct.h"
-#endif
-#define ICMPH_TYPE(hdr) ((hdr)->type)
-#define ICMPH_CODE(hdr) ((hdr)->code)
-/** Combines type and code to an u16_t */
-#define ICMPH_TYPE_SET(hdr, t) ((hdr)->type = (t))
-#define ICMPH_CODE_SET(hdr, c) ((hdr)->code = (c))
-#ifdef __cplusplus
-}
-#endif
-#endif                          /* LWIP_ICMP */
-#endif                          /* __LWIP_ICMP_H__ */
diff --git a/include/ipv4/lwip/igmp.h b/include/ipv4/lwip/igmp.h
deleted file mode 100644
index 43189c8..0000000
--- a/include/ipv4/lwip/igmp.h
+++ /dev/null
@@ -1,161 +0,0 @@
-/*
- * Copyright (c) 2002 CITEL Technologies Ltd.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without 
- * modification, are permitted provided that the following conditions 
- * are met: 
- * 1. Redistributions of source code must retain the above copyright 
- *    notice, this list of conditions and the following disclaimer. 
- * 2. Redistributions in binary form must reproduce the above copyright 
- *    notice, this list of conditions and the following disclaimer in the 
- *    documentation and/or other materials provided with the distribution. 
- * 3. Neither the name of CITEL Technologies Ltd nor the names of its contributors 
- *    may be used to endorse or promote products derived from this software 
- *    without specific prior written permission. 
- *
- * THIS SOFTWARE IS PROVIDED BY CITEL TECHNOLOGIES AND CONTRIBUTORS ``AS IS''
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
- * ARE DISCLAIMED.  IN NO EVENT SHALL CITEL TECHNOLOGIES OR CONTRIBUTORS BE LIABLE 
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS 
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY 
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
- * SUCH DAMAGE. 
- *
- * This file is a contribution to the lwIP TCP/IP stack.
- * The Swedish Institute of Computer Science and Adam Dunkels
- * are specifically granted permission to redistribute this
- * source code.
-*/
-
-#ifndef __LWIP_IGMP_H__
-#define __LWIP_IGMP_H__
-
-#include "lwip/opt.h"
-#include "lwip/ip_addr.h"
-#include "lwip/netif.h"
-#include "lwip/pbuf.h"
-
-#if LWIP_IGMP                   /* don't build if not configured for use in lwipopts.h */
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* 
- * IGMP constants
- */
-#define IP_PROTO_IGMP                  2
-#define IGMP_TTL                       1
-#define IGMP_MINLEN                    8
-#define ROUTER_ALERT                   0x9404
-#define ROUTER_ALERTLEN                4
-
-/*
- * IGMP message types, including version number.
- */
-#define IGMP_MEMB_QUERY                0x11     /* Membership query         */
-#define IGMP_V1_MEMB_REPORT            0x12     /* Ver. 1 membership report */
-#define IGMP_V2_MEMB_REPORT            0x16     /* Ver. 2 membership report */
-#define IGMP_LEAVE_GROUP               0x17     /* Leave-group message      */
-
-/* IGMP timer */
-#define IGMP_TMR_INTERVAL              100      /* Milliseconds */
-#define IGMP_V1_DELAYING_MEMBER_TMR   (1000/IGMP_TMR_INTERVAL)
-#define IGMP_JOIN_DELAYING_MEMBER_TMR (500 /IGMP_TMR_INTERVAL)
-
-/* MAC Filter Actions */
-#define IGMP_DEL_MAC_FILTER            0
-#define IGMP_ADD_MAC_FILTER            1
-
-/* Group  membership states */
-#define IGMP_GROUP_NON_MEMBER          0
-#define IGMP_GROUP_DELAYING_MEMBER     1
-#define IGMP_GROUP_IDLE_MEMBER         2
-
-/*
- * IGMP packet format.
- */
-#ifdef PACK_STRUCT_USE_INCLUDES
-#include "arch/bpstruct.h"
-#endif
-    PACK_STRUCT_BEGIN struct igmp_msg {
-        PACK_STRUCT_FIELD(u8_t igmp_msgtype);
-        PACK_STRUCT_FIELD(u8_t igmp_maxresp);
-        PACK_STRUCT_FIELD(u16_t igmp_checksum);
-        PACK_STRUCT_FIELD(struct ip_addr igmp_group_address);
-    } PACK_STRUCT_STRUCT;
-     PACK_STRUCT_END
-#ifdef PACK_STRUCT_USE_INCLUDES
-#include "arch/epstruct.h"
-#endif
-/* 
- * now a group structure - there is
- * a list of groups for each interface
- * these should really be linked from the interface, but
- * if we keep them separate we will not affect the lwip original code
- * too much
- * 
- * There will be a group for the all systems group address but this 
- * will not run the state machine as it is used to kick off reports
- * from all the other groups
- */
-      struct igmp_group {
-        struct igmp_group *next;
-        struct netif *interface;
-        struct ip_addr group_address;
-        u8_t last_reporter_flag;        /* signifies we were the last person to report */
-        u8_t group_state;
-        u16_t timer;
-        u8_t use;               /* counter of simultaneous uses */
-    };
-
-
-/*  Prototypes */
-    void igmp_init(void);
-
-    err_t igmp_start(struct netif *netif);
-
-    err_t igmp_stop(struct netif *netif);
-
-    void igmp_report_groups(struct netif *netif);
-
-    struct igmp_group *igmp_lookfor_group(struct netif *ifp,
-                                          struct ip_addr *addr);
-
-    struct igmp_group *igmp_lookup_group(struct netif *ifp,
-                                         struct ip_addr *addr);
-
-    err_t igmp_remove_group(struct igmp_group *group);
-
-    void igmp_input(struct pbuf *p, struct netif *inp, struct ip_addr *dest);
-
-    err_t igmp_joingroup(struct ip_addr *ifaddr, struct ip_addr *groupaddr);
-
-    err_t igmp_leavegroup(struct ip_addr *ifaddr, struct ip_addr *groupaddr);
-
-    void igmp_tmr(void);
-
-    void igmp_timeout(struct igmp_group *group);
-
-    void igmp_start_timer(struct igmp_group *group, u8_t max_time);
-
-    void igmp_stop_timer(struct igmp_group *group);
-
-    void igmp_delaying_member(struct igmp_group *group, u8_t maxresp);
-
-    err_t igmp_ip_output_if(struct pbuf *p, struct ip_addr *src,
-                            struct ip_addr *dest, u8_t ttl, u8_t proto,
-                            struct netif *netif);
-
-    void igmp_send(struct igmp_group *group, u8_t type);
-
-#ifdef __cplusplus
-}
-#endif
-#endif                          /* LWIP_IGMP */
-#endif                          /* __LWIP_IGMP_H__ */
diff --git a/include/ipv4/lwip/inet.h b/include/ipv4/lwip/inet.h
deleted file mode 100644
index b52698b..0000000
--- a/include/ipv4/lwip/inet.h
+++ /dev/null
@@ -1,102 +0,0 @@
-/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved. 
- * 
- * Redistribution and use in source and binary forms, with or without modification, 
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission. 
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- * 
- * Author: Adam Dunkels <adam@sics.se>
- *
- */
-#ifndef __LWIP_INET_H__
-#define __LWIP_INET_H__
-
-#include "lwip/opt.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* For compatibility with BSD code */
-    struct in_addr {
-        u32_t s_addr;
-    };
-
-#define INADDR_NONE         ((u32_t)0xffffffffUL)       /* 255.255.255.255 */
-#define INADDR_LOOPBACK     ((u32_t)0x7f000001UL)       /* 127.0.0.1 */
-#define INADDR_ANY          ((u32_t)0x00000000UL)       /* 0.0.0.0 */
-#define INADDR_BROADCAST    ((u32_t)0xffffffffUL)       /* 255.255.255.255 */
-
-    u32_t inet_addr(const char *cp);
-    int inet_aton(const char *cp, struct in_addr *addr);
-    char *inet_ntoa(struct in_addr addr);       /* returns ptr to static buffer; not reentrant! */
-
-#ifdef htons
-#undef htons
-#endif                          /* htons */
-#ifdef htonl
-#undef htonl
-#endif                          /* htonl */
-#ifdef ntohs
-#undef ntohs
-#endif                          /* ntohs */
-#ifdef ntohl
-#undef ntohl
-#endif                          /* ntohl */
-
-#ifndef LWIP_PLATFORM_BYTESWAP
-#define LWIP_PLATFORM_BYTESWAP 0
-#endif
-
-#if BYTE_ORDER == BIG_ENDIAN
-#define htons(x) (x)
-#define ntohs(x) (x)
-#define htonl(x) (x)
-#define ntohl(x) (x)
-#else                           /* BYTE_ORDER != BIG_ENDIAN */
-#ifdef LWIP_PREFIX_BYTEORDER_FUNCS
-/* workaround for naming collisions on some platforms */
-#define htons lwip_htons
-#define ntohs lwip_ntohs
-#define htonl lwip_htonl
-#define ntohl lwip_ntohl
-#endif                          /* LWIP_PREFIX_BYTEORDER_FUNCS */
-#if LWIP_PLATFORM_BYTESWAP
-#define htons(x) LWIP_PLATFORM_HTONS(x)
-#define ntohs(x) LWIP_PLATFORM_HTONS(x)
-#define htonl(x) LWIP_PLATFORM_HTONL(x)
-#define ntohl(x) LWIP_PLATFORM_HTONL(x)
-#else                           /* LWIP_PLATFORM_BYTESWAP */
-    u16_t htons(u16_t x);
-    u16_t ntohs(u16_t x);
-    u32_t htonl(u32_t x);
-    u32_t ntohl(u32_t x);
-#endif                          /* LWIP_PLATFORM_BYTESWAP */
-
-#endif                          /* BYTE_ORDER == BIG_ENDIAN */
-
-#ifdef __cplusplus
-}
-#endif
-#endif                          /* __LWIP_INET_H__ */
diff --git a/include/ipv4/lwip/inet_chksum.h b/include/ipv4/lwip/inet_chksum.h
deleted file mode 100644
index 98bd72f..0000000
--- a/include/ipv4/lwip/inet_chksum.h
+++ /dev/null
@@ -1,57 +0,0 @@
-/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved. 
- * 
- * Redistribution and use in source and binary forms, with or without modification, 
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission. 
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- * 
- * Author: Adam Dunkels <adam@sics.se>
- *
- */
-#ifndef __LWIP_INET_CHKSUM_H__
-#define __LWIP_INET_CHKSUM_H__
-
-#include "lwip/opt.h"
-
-#include "lwip/pbuf.h"
-#include "lwip/ip_addr.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-    u16_t inet_chksum(void *dataptr, u16_t len);
-    u16_t inet_chksum_pbuf(struct pbuf *p);
-    u16_t inet_chksum_pseudo(struct pbuf *p,
-                             struct ip_addr *src, struct ip_addr *dest,
-                             u8_t proto, u16_t proto_len);
-    u16_t inet_chksum_pseudo_partial(struct pbuf *p,
-                                     struct ip_addr *src, struct ip_addr *dest,
-                                     u8_t proto, u16_t proto_len,
-                                     u16_t chksum_len);
-
-#ifdef __cplusplus
-}
-#endif
-#endif                          /* __LWIP_INET_H__ */
diff --git a/include/ipv4/lwip/ip.h b/include/ipv4/lwip/ip.h
deleted file mode 100644
index f5ad351..0000000
--- a/include/ipv4/lwip/ip.h
+++ /dev/null
@@ -1,181 +0,0 @@
-/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved. 
- * 
- * Redistribution and use in source and binary forms, with or without modification, 
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission. 
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- * 
- * Author: Adam Dunkels <adam@sics.se>
- *
- */
-#ifndef __LWIP_IP_H__
-#define __LWIP_IP_H__
-
-#include "lwip/opt.h"
-
-#include "lwip/def.h"
-#include "lwip/pbuf.h"
-#include "lwip/ip_addr.h"
-#include "lwip/err.h"
-#include "lwip/netif.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/** Currently, the function ip_output_if_opt() is only used with IGMP */
-#define IP_OPTIONS_SEND   LWIP_IGMP
-
-#define IP_HLEN 20
-
-#define IP_PROTO_ICMP    1
-#define IP_PROTO_UDP     17
-#define IP_PROTO_UDPLITE 136
-#define IP_PROTO_TCP     6
-
-/* This is passed as the destination address to ip_output_if (not
-   to ip_output), meaning that an IP header already is constructed
-   in the pbuf. This is used when TCP retransmits. */
-#ifdef IP_HDRINCL
-#undef IP_HDRINCL
-#endif                          /* IP_HDRINCL */
-#define IP_HDRINCL  NULL
-
-#if LWIP_NETIF_HWADDRHINT
-#define IP_PCB_ADDRHINT ;u8_t addr_hint
-#else
-#define IP_PCB_ADDRHINT
-#endif                          /* LWIP_NETIF_HWADDRHINT */
-
-/* This is the common part of all PCB types. It needs to be at the
-   beginning of a PCB type definition. It is located here so that
-   changes to this common part are made in one location instead of
-   having to change all PCB structs. */
-#define IP_PCB \
-  /* ip addresses in network byte order */ \
-  struct ip_addr local_ip; \
-  struct ip_addr remote_ip; \
-   /* Socket options */  \
-  u16_t so_options;      \
-   /* Type Of Service */ \
-  u8_t tos;              \
-  /* Time To Live */     \
-  u8_t ttl               \
-  /* link layer address resolution hint */ \
-  IP_PCB_ADDRHINT
-
-    struct ip_pcb {
-/* Common members of all PCB types */
-        IP_PCB;
-    };
-
-/*
- * Option flags per-socket. These are the same like SO_XXX.
- */
-#define SOF_DEBUG       (u16_t)0x0001U  /* turn on debugging info recording */
-#define SOF_ACCEPTCONN  (u16_t)0x0002U  /* socket has had listen() */
-#define SOF_REUSEADDR   (u16_t)0x0004U  /* allow local address reuse */
-#define SOF_KEEPALIVE   (u16_t)0x0008U  /* keep connections alive */
-#define SOF_DONTROUTE   (u16_t)0x0010U  /* just use interface addresses */
-#define SOF_BROADCAST   (u16_t)0x0020U  /* permit to send and to receive broadcast messages (see IP_SOF_BROADCAST option) */
-#define SOF_USELOOPBACK (u16_t)0x0040U  /* bypass hardware when possible */
-#define SOF_LINGER      (u16_t)0x0080U  /* linger on close if data present */
-#define SOF_OOBINLINE   (u16_t)0x0100U  /* leave received OOB data in line */
-#define SOF_REUSEPORT   (u16_t)0x0200U  /* allow local address & port reuse */
-
-
-#ifdef PACK_STRUCT_USE_INCLUDES
-#include "arch/bpstruct.h"
-#endif
-     PACK_STRUCT_BEGIN struct ip_hdr {
-        /* version / header length / type of service */
-        PACK_STRUCT_FIELD(u16_t _v_hl_tos);
-        /* total length */
-        PACK_STRUCT_FIELD(u16_t _len);
-        /* identification */
-        PACK_STRUCT_FIELD(u16_t _id);
-        /* fragment offset field */
-        PACK_STRUCT_FIELD(u16_t _offset);
-#define IP_RF 0x8000            /* reserved fragment flag */
-#define IP_DF 0x4000            /* dont fragment flag */
-#define IP_MF 0x2000            /* more fragments flag */
-#define IP_OFFMASK 0x1fff       /* mask for fragmenting bits */
-        /* time to live / protocol */
-        PACK_STRUCT_FIELD(u16_t _ttl_proto);
-        /* checksum */
-        PACK_STRUCT_FIELD(u16_t _chksum);
-        /* source and destination IP addresses */
-        PACK_STRUCT_FIELD(struct ip_addr src);
-         PACK_STRUCT_FIELD(struct ip_addr dest);
-    } PACK_STRUCT_STRUCT;
-     PACK_STRUCT_END
-#ifdef PACK_STRUCT_USE_INCLUDES
-#include "arch/epstruct.h"
-#endif
-#define IPH_V(hdr)  (ntohs((hdr)->_v_hl_tos) >> 12)
-#define IPH_HL(hdr) ((ntohs((hdr)->_v_hl_tos) >> 8) & 0x0f)
-#define IPH_TOS(hdr) (ntohs((hdr)->_v_hl_tos) & 0xff)
-#define IPH_LEN(hdr) ((hdr)->_len)
-#define IPH_ID(hdr) ((hdr)->_id)
-#define IPH_OFFSET(hdr) ((hdr)->_offset)
-#define IPH_TTL(hdr) (ntohs((hdr)->_ttl_proto) >> 8)
-#define IPH_PROTO(hdr) (ntohs((hdr)->_ttl_proto) & 0xff)
-#define IPH_CHKSUM(hdr) ((hdr)->_chksum)
-#define IPH_VHLTOS_SET(hdr, v, hl, tos) (hdr)->_v_hl_tos = (htons(((v) << 12) | ((hl) << 8) | (tos)))
-#define IPH_LEN_SET(hdr, len) (hdr)->_len = (len)
-#define IPH_ID_SET(hdr, id) (hdr)->_id = (id)
-#define IPH_OFFSET_SET(hdr, off) (hdr)->_offset = (off)
-#define IPH_TTL_SET(hdr, ttl) (hdr)->_ttl_proto = (htons(IPH_PROTO(hdr) | ((u16_t)(ttl) << 8)))
-#define IPH_PROTO_SET(hdr, proto) (hdr)->_ttl_proto = (htons((proto) | (IPH_TTL(hdr) << 8)))
-#define IPH_CHKSUM_SET(hdr, chksum) (hdr)->_chksum = (chksum)
-#define ip_init()               /* Compatibility define, not init needed. */
-    struct netif *ip_route(struct ip_addr *dest);
-    err_t ip_input(struct pbuf *p, struct netif *inp);
-    err_t ip_output(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
-                    u8_t ttl, u8_t tos, u8_t proto);
-    err_t ip_output_if(struct pbuf *p, struct ip_addr *src,
-                       struct ip_addr *dest, u8_t ttl, u8_t tos, u8_t proto,
-                       struct netif *netif);
-#if LWIP_NETIF_HWADDRHINT
-    err_t ip_output_hinted(struct pbuf *p, struct ip_addr *src,
-                           struct ip_addr *dest, u8_t ttl, u8_t tos, u8_t proto,
-                           u8_t * addr_hint);
-#endif                          /* LWIP_NETIF_HWADDRHINT */
-#if IP_OPTIONS_SEND
-    err_t ip_output_if_opt(struct pbuf *p, struct ip_addr *src,
-                           struct ip_addr *dest, u8_t ttl, u8_t tos, u8_t proto,
-                           struct netif *netif, void *ip_options, u16_t optlen);
-#endif                          /* IP_OPTIONS_SEND */
-    struct netif *ip_current_netif(void);
-    const struct ip_hdr *ip_current_header(void);
-#if IP_DEBUG
-    void ip_debug_print(struct pbuf *p);
-#else
-#define ip_debug_print(p)
-#endif                          /* IP_DEBUG */
-
-#ifdef __cplusplus
-}
-#endif
-#endif                          /* __LWIP_IP_H__ */
diff --git a/include/ipv4/lwip/ip_addr.h b/include/ipv4/lwip/ip_addr.h
deleted file mode 100644
index bf6c293..0000000
--- a/include/ipv4/lwip/ip_addr.h
+++ /dev/null
@@ -1,163 +0,0 @@
-/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Adam Dunkels <adam@sics.se>
- *
- */
-#ifndef __LWIP_IP_ADDR_H__
-#define __LWIP_IP_ADDR_H__
-
-#include "lwip/opt.h"
-
-#include "lwip/inet.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#ifdef PACK_STRUCT_USE_INCLUDES
-#include "arch/bpstruct.h"
-#endif
-    PACK_STRUCT_BEGIN struct ip_addr {
-        PACK_STRUCT_FIELD(u32_t addr);
-    } PACK_STRUCT_STRUCT;
-     PACK_STRUCT_END
-#ifdef PACK_STRUCT_USE_INCLUDES
-#include "arch/epstruct.h"
-#endif
-/*
- * struct ipaddr2 is used in the definition of the ARP packet format in
- * order to support compilers that don't have structure packing.
- */
-#ifdef PACK_STRUCT_USE_INCLUDES
-#include "arch/bpstruct.h"
-#endif
-     PACK_STRUCT_BEGIN struct ip_addr2 {
-        PACK_STRUCT_FIELD(u16_t addrw[2]);
-    } PACK_STRUCT_STRUCT;
-     PACK_STRUCT_END
-#ifdef PACK_STRUCT_USE_INCLUDES
-#include "arch/epstruct.h"
-#endif
-      struct netif;
-
-    extern const struct ip_addr ip_addr_any;
-    extern const struct ip_addr ip_addr_broadcast;
-
-/** IP_ADDR_ can be used as a fixed IP address
- *  for the wildcard and the broadcast address
- */
-#define IP_ADDR_ANY         ((struct ip_addr *)&ip_addr_any)
-#define IP_ADDR_BROADCAST   ((struct ip_addr *)&ip_addr_broadcast)
-
-/* Definitions of the bits in an Internet address integer.
-
-   On subnets, host and network parts are found according to
-   the subnet mask, not these masks.  */
-
-#define IN_CLASSA(a)        ((((u32_t)(a)) & 0x80000000UL) == 0)
-#define IN_CLASSA_NET       0xff000000
-#define IN_CLASSA_NSHIFT    24
-#define IN_CLASSA_HOST      (0xffffffff & ~IN_CLASSA_NET)
-#define IN_CLASSA_MAX       128
-
-#define IN_CLASSB(a)        ((((u32_t)(a)) & 0xc0000000UL) == 0x80000000UL)
-#define IN_CLASSB_NET       0xffff0000
-#define IN_CLASSB_NSHIFT    16
-#define IN_CLASSB_HOST      (0xffffffff & ~IN_CLASSB_NET)
-#define IN_CLASSB_MAX       65536
-
-#define IN_CLASSC(a)        ((((u32_t)(a)) & 0xe0000000UL) == 0xc0000000UL)
-#define IN_CLASSC_NET       0xffffff00
-#define IN_CLASSC_NSHIFT    8
-#define IN_CLASSC_HOST      (0xffffffff & ~IN_CLASSC_NET)
-
-#define IN_CLASSD(a)        (((u32_t)(a) & 0xf0000000UL) == 0xe0000000UL)
-#define IN_CLASSD_NET       0xf0000000  /* These ones aren't really */
-#define IN_CLASSD_NSHIFT    28  /*   net and host fields, but */
-#define IN_CLASSD_HOST      0x0fffffff  /*   routing needn't know. */
-#define IN_MULTICAST(a)     IN_CLASSD(a)
-
-#define IN_EXPERIMENTAL(a)  (((u32_t)(a) & 0xf0000000UL) == 0xf0000000UL)
-#define IN_BADCLASS(a)      (((u32_t)(a) & 0xf0000000UL) == 0xf0000000UL)
-
-#define IN_LOOPBACKNET      127 /* official! */
-
-#define IP4_ADDR(ipaddr, a,b,c,d) \
-        (ipaddr)->addr = htonl(((u32_t)((a) & 0xff) << 24) | \
-                               ((u32_t)((b) & 0xff) << 16) | \
-                               ((u32_t)((c) & 0xff) << 8) | \
-                                (u32_t)((d) & 0xff))
-
-#define ip_addr_set(dest, src) (dest)->addr = \
-                               ((src) == NULL? 0:\
-                               (src)->addr)
-/**
- * Determine if two address are on the same network.
- *
- * @arg addr1 IP address 1
- * @arg addr2 IP address 2
- * @arg mask network identifier mask
- * @return !0 if the network identifiers of both address match
- */
-#define ip_addr_netcmp(addr1, addr2, mask) (((addr1)->addr & \
-                                              (mask)->addr) == \
-                                             ((addr2)->addr & \
-                                              (mask)->addr))
-#define ip_addr_cmp(addr1, addr2) ((addr1)->addr == (addr2)->addr)
-
-#define ip_addr_isany(addr1) ((addr1) == NULL || (addr1)->addr == 0)
-
-    u8_t ip_addr_isbroadcast(struct ip_addr *, struct netif *);
-
-#define ip_addr_ismulticast(addr1) (((addr1)->addr & ntohl(0xf0000000UL)) == ntohl(0xe0000000UL))
-
-#define ip_addr_islinklocal(addr1) (((addr1)->addr & ntohl(0xffff0000UL)) == ntohl(0xa9fe0000UL))
-
-#define ip_addr_debug_print(debug, ipaddr) \
-  LWIP_DEBUGF(debug, ("%"U16_F".%"U16_F".%"U16_F".%"U16_F,              \
-                      ipaddr != NULL ?                                  \
-                      (u16_t)(ntohl((ipaddr)->addr) >> 24) & 0xff : 0,  \
-                      ipaddr != NULL ?                                  \
-                      (u16_t)(ntohl((ipaddr)->addr) >> 16) & 0xff : 0,  \
-                      ipaddr != NULL ?                                  \
-                      (u16_t)(ntohl((ipaddr)->addr) >> 8) & 0xff : 0,   \
-                      ipaddr != NULL ?                                  \
-                      (u16_t)ntohl((ipaddr)->addr) & 0xff : 0))
-
-/* These are cast to u16_t, with the intent that they are often arguments
- * to printf using the U16_F format from cc.h. */
-#define ip4_addr1(ipaddr) ((u16_t)(ntohl((ipaddr)->addr) >> 24) & 0xff)
-#define ip4_addr2(ipaddr) ((u16_t)(ntohl((ipaddr)->addr) >> 16) & 0xff)
-#define ip4_addr3(ipaddr) ((u16_t)(ntohl((ipaddr)->addr) >> 8) & 0xff)
-#define ip4_addr4(ipaddr) ((u16_t)(ntohl((ipaddr)->addr)) & 0xff)
-
-#ifdef __cplusplus
-}
-#endif
-#endif                          /* __LWIP_IP_ADDR_H__ */
diff --git a/include/ipv4/lwip/ip_frag.h b/include/ipv4/lwip/ip_frag.h
deleted file mode 100644
index e99f942..0000000
--- a/include/ipv4/lwip/ip_frag.h
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved. 
- * 
- * Redistribution and use in source and binary forms, with or without modification, 
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission. 
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- * 
- * Author: Jani Monoses <jani@iv.ro>
- *
- */
-
-#ifndef __LWIP_IP_FRAG_H__
-#define __LWIP_IP_FRAG_H__
-
-#include "lwip/opt.h"
-#include "lwip/err.h"
-#include "lwip/pbuf.h"
-#include "lwip/netif.h"
-#include "lwip/ip_addr.h"
-#include "lwip/ip.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#if IP_REASSEMBLY
-/* The IP reassembly timer interval in milliseconds. */
-#define IP_TMR_INTERVAL 1000
-
-/* IP reassembly helper struct.
- * This is exported because memp needs to know the size.
- */
-    struct ip_reassdata {
-        struct ip_reassdata *next;
-        struct pbuf *p;
-        struct ip_hdr iphdr;
-        u16_t datagram_len;
-        u8_t flags;
-        u8_t timer;
-    };
-
-    void ip_reass_init(void);
-    void ip_reass_tmr(void);
-    struct pbuf *ip_reass(struct pbuf *p);
-#endif                          /* IP_REASSEMBLY */
-
-#if IP_FRAG
-    err_t ip_frag(struct pbuf *p, struct netif *netif, struct ip_addr *dest);
-#endif                          /* IP_FRAG */
-
-#ifdef __cplusplus
-}
-#endif
-#endif                          /* __LWIP_IP_FRAG_H__ */
diff --git a/include/ipv6/lwip/icmp.h b/include/ipv6/lwip/icmp.h
deleted file mode 100644
index 9028978..0000000
--- a/include/ipv6/lwip/icmp.h
+++ /dev/null
@@ -1,97 +0,0 @@
-/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved. 
- * 
- * Redistribution and use in source and binary forms, with or without modification, 
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission. 
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- * 
- * Author: Adam Dunkels <adam@sics.se>
- *
- */
-#ifndef __LWIP_ICMP_H__
-#define __LWIP_ICMP_H__
-
-#include "lwip/opt.h"
-
-#if LWIP_ICMP                   /* don't build if not configured for use in lwipopts.h */
-
-#include "lwip/pbuf.h"
-#include "lwip/netif.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#define ICMP6_DUR  1
-#define ICMP6_TE   3
-#define ICMP6_ECHO 128          /* echo */
-#define ICMP6_ER   129          /* echo reply */
-
-
-    enum icmp_dur_type {
-        ICMP_DUR_NET = 0,       /* net unreachable */
-        ICMP_DUR_HOST = 1,      /* host unreachable */
-        ICMP_DUR_PROTO = 2,     /* protocol unreachable */
-        ICMP_DUR_PORT = 3,      /* port unreachable */
-        ICMP_DUR_FRAG = 4,      /* fragmentation needed and DF set */
-        ICMP_DUR_SR = 5         /* source route failed */
-    };
-
-    enum icmp_te_type {
-        ICMP_TE_TTL = 0,        /* time to live exceeded in transit */
-        ICMP_TE_FRAG = 1        /* fragment reassembly time exceeded */
-    };
-
-    void icmp_input(struct pbuf *p, struct netif *inp);
-
-    void icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t);
-    void icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t);
-
-    struct icmp_echo_hdr {
-        u8_t type;
-        u8_t icode;
-        u16_t chksum;
-        u16_t id;
-        u16_t seqno;
-    };
-
-    struct icmp_dur_hdr {
-        u8_t type;
-        u8_t icode;
-        u16_t chksum;
-        u32_t unused;
-    };
-
-    struct icmp_te_hdr {
-        u8_t type;
-        u8_t icode;
-        u16_t chksum;
-        u32_t unused;
-    };
-
-#ifdef __cplusplus
-}
-#endif
-#endif                          /* LWIP_ICMP */
-#endif                          /* __LWIP_ICMP_H__ */
diff --git a/include/ipv6/lwip/inet.h b/include/ipv6/lwip/inet.h
deleted file mode 100644
index 680be42..0000000
--- a/include/ipv6/lwip/inet.h
+++ /dev/null
@@ -1,66 +0,0 @@
-/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved. 
- * 
- * Redistribution and use in source and binary forms, with or without modification, 
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission. 
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- * 
- * Author: Adam Dunkels <adam@sics.se>
- *
- */
-#ifndef __LWIP_INET_H__
-#define __LWIP_INET_H__
-
-#include "lwip/opt.h"
-#include "lwip/pbuf.h"
-#include "lwip/ip_addr.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-    u16_t inet_chksum(void *data, u16_t len);
-    u16_t inet_chksum_pbuf(struct pbuf *p);
-    u16_t inet_chksum_pseudo(struct pbuf *p,
-                             struct ip_addr *src, struct ip_addr *dest,
-                             u8_t proto, u32_t proto_len);
-
-    u32_t inet_addr(const char *cp);
-    s8_t inet_aton(const char *cp, struct in_addr *addr);
-
-#ifndef _MACHINE_ENDIAN_H_
-#ifndef _NETINET_IN_H
-#ifndef _LINUX_BYTEORDER_GENERIC_H
-    u16_t htons(u16_t n);
-    u16_t ntohs(u16_t n);
-    u32_t htonl(u32_t n);
-    u32_t ntohl(u32_t n);
-#endif                          /* _LINUX_BYTEORDER_GENERIC_H */
-#endif                          /* _NETINET_IN_H */
-#endif                          /* _MACHINE_ENDIAN_H_ */
-
-#ifdef __cplusplus
-}
-#endif
-#endif                          /* __LWIP_INET_H__ */
diff --git a/include/ipv6/lwip/ip.h b/include/ipv6/lwip/ip.h
deleted file mode 100644
index a345408..0000000
--- a/include/ipv6/lwip/ip.h
+++ /dev/null
@@ -1,127 +0,0 @@
-/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved. 
- * 
- * Redistribution and use in source and binary forms, with or without modification, 
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission. 
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- * 
- * Author: Adam Dunkels <adam@sics.se>
- *
- */
-#ifndef __LWIP_IP_H__
-#define __LWIP_IP_H__
-
-#include "lwip/opt.h"
-#include "lwip/def.h"
-#include "lwip/pbuf.h"
-#include "lwip/ip_addr.h"
-
-#include "lwip/err.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#define IP_HLEN 40
-
-#define IP_PROTO_ICMP    58
-#define IP_PROTO_UDP     17
-#define IP_PROTO_UDPLITE 136
-#define IP_PROTO_TCP     6
-
-/* This is passed as the destination address to ip_output_if (not
-   to ip_output), meaning that an IP header already is constructed
-   in the pbuf. This is used when TCP retransmits. */
-#ifdef IP_HDRINCL
-#undef IP_HDRINCL
-#endif                          /* IP_HDRINCL */
-#define IP_HDRINCL  NULL
-
-#if LWIP_NETIF_HWADDRHINT
-#define IP_PCB_ADDRHINT ;u8_t addr_hint
-#else
-#define IP_PCB_ADDRHINT
-#endif                          /* LWIP_NETIF_HWADDRHINT */
-
-/* This is the common part of all PCB types. It needs to be at the
-   beginning of a PCB type definition. It is located here so that
-   changes to this common part are made in one location instead of
-   having to change all PCB structs. */
-#define IP_PCB struct ip_addr local_ip; \
-  struct ip_addr remote_ip; \
-   /* Socket options */  \
-  u16_t so_options;      \
-   /* Type Of Service */ \
-  u8_t tos;              \
-  /* Time To Live */     \
-  u8_t ttl;              \
-  /* link layer address resolution hint */ \
-  IP_PCB_ADDRHINT
-
-
-/* The IPv6 header. */
-    struct ip_hdr {
-#if BYTE_ORDER == LITTLE_ENDIAN
-        u8_t tclass1:4, v:4;
-        u8_t flow1:4, tclass2:4;
-#else
-        u8_t v:4, tclass1:4;
-        u8_t tclass2:8, flow1:4;
-#endif
-        u16_t flow2;
-        u16_t len;              /* payload length */
-        u8_t nexthdr;           /* next header */
-        u8_t hoplim;            /* hop limit (TTL) */
-        struct ip_addr src, dest;       /* source and destination IP addresses */
-    };
-
-#define IPH_PROTO(hdr) (iphdr->nexthdr)
-
-    void ip_init(void);
-
-#include "lwip/netif.h"
-
-    struct netif *ip_route(struct ip_addr *dest);
-
-    void ip_input(struct pbuf *p, struct netif *inp);
-
-/* source and destination addresses in network byte order, please */
-    err_t ip_output(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
-                    u8_t ttl, u8_t proto);
-
-    err_t ip_output_if(struct pbuf *p, struct ip_addr *src,
-                       struct ip_addr *dest, u8_t ttl, u8_t proto,
-                       struct netif *netif);
-
-#define ip_current_netif() NULL
-#define ip_current_header() NULL
-
-#if IP_DEBUG
-    void ip_debug_print(struct pbuf *p);
-#endif                          /* IP_DEBUG */
-
-#ifdef __cplusplus
-}
-#endif
-#endif                          /* __LWIP_IP_H__ */
diff --git a/include/ipv6/lwip/ip_addr.h b/include/ipv6/lwip/ip_addr.h
deleted file mode 100644
index ecdbdd4..0000000
--- a/include/ipv6/lwip/ip_addr.h
+++ /dev/null
@@ -1,91 +0,0 @@
-/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved. 
- * 
- * Redistribution and use in source and binary forms, with or without modification, 
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission. 
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- * 
- * Author: Adam Dunkels <adam@sics.se>
- *
- */
-#ifndef __LWIP_IP_ADDR_H__
-#define __LWIP_IP_ADDR_H__
-
-#include "lwip/opt.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#define IP_ADDR_ANY 0
-
-#ifdef PACK_STRUCT_USE_INCLUDES
-#include "arch/bpstruct.h"
-#endif
-    PACK_STRUCT_BEGIN struct ip_addr {
-        PACK_STRUCT_FIELD(u32_t addr[4]);
-    } PACK_STRUCT_STRUCT;
-     PACK_STRUCT_END
-#ifdef PACK_STRUCT_USE_INCLUDES
-#include "arch/epstruct.h"
-#endif
-/*
- * struct ipaddr2 is used in the definition of the ARP packet format in
- * order to support compilers that don't have structure packing.
- */
-#ifdef PACK_STRUCT_USE_INCLUDES
-#include "arch/bpstruct.h"
-#endif
-     PACK_STRUCT_BEGIN struct ip_addr2 {
-        PACK_STRUCT_FIELD(u16_t addrw[2]);
-    } PACK_STRUCT_STRUCT;
-     PACK_STRUCT_END
-#ifdef PACK_STRUCT_USE_INCLUDES
-#include "arch/epstruct.h"
-#endif
-#define IP6_ADDR(ipaddr, a,b,c,d,e,f,g,h) do { (ipaddr)->addr[0] = htonl((u32_t)((a & 0xffff) << 16) | (b & 0xffff)); \
-                                               (ipaddr)->addr[1] = htonl(((c & 0xffff) << 16) | (d & 0xffff)); \
-                                               (ipaddr)->addr[2] = htonl(((e & 0xffff) << 16) | (f & 0xffff)); \
-                                               (ipaddr)->addr[3] = htonl(((g & 0xffff) << 16) | (h & 0xffff)); } while(0)
-     u8_t ip_addr_netcmp(struct ip_addr *addr1, struct ip_addr *addr2,
-                         struct ip_addr *mask);
-    u8_t ip_addr_cmp(struct ip_addr *addr1, struct ip_addr *addr2);
-    void ip_addr_set(struct ip_addr *dest, struct ip_addr *src);
-    u8_t ip_addr_isany(struct ip_addr *addr);
-
-#define ip_addr_debug_print(debug, ipaddr) \
-        LWIP_DEBUGF(debug, ("%"X32_F":%"X32_F":%"X32_F":%"X32_F":%"X32_F":%"X32_F":%"X32_F":%"X32_F"\n", \
-         (ntohl(ipaddr->addr[0]) >> 16) & 0xffff, \
-         ntohl(ipaddr->addr[0]) & 0xffff, \
-         (ntohl(ipaddr->addr[1]) >> 16) & 0xffff, \
-         ntohl(ipaddr->addr[1]) & 0xffff, \
-         (ntohl(ipaddr->addr[2]) >> 16) & 0xffff, \
-         ntohl(ipaddr->addr[2]) & 0xffff, \
-         (ntohl(ipaddr->addr[3]) >> 16) & 0xffff, \
-         ntohl(ipaddr->addr[3]) & 0xffff));
-
-#ifdef __cplusplus
-}
-#endif
-#endif                          /* __LWIP_IP_ADDR_H__ */
diff --git a/include/limits.h b/include/limits.h
index fb09777..fd96534 100644
--- a/include/limits.h
+++ b/include/limits.h
@@ -29,8 +29,8 @@
  * $FreeBSD: src/sys/sys/limits.h,v 1.10 2005/12/02 07:45:28 davidxu Exp $
  */
 
-#ifndef _SYS_LIMITS_H_
-#define	_SYS_LIMITS_H_
+#ifndef _LIMITS_H_
+#define	_LIMITS_H_
 
 #include <sys/cdefs.h>
 #include <machine/_limits.h>
@@ -113,8 +113,10 @@
 #undef ULONG_LONG_MAX
 #define ULONG_LONG_MAX (LONG_LONG_MAX * 2ULL + 1ULL)
 
-// Barrelfish addition
-// I'm not sure where this belongs, but limits.h must provide it -AB
-#define PATH_MAX 1330
+#if __POSIX_VISIBLE
+#ifdef CONFIG_NEWLIB
+#include <sys/syslimits.h>
+#endif
+#endif
 
 #endif /* !_SYS_LIMITS_H_ */
diff --git a/include/lwip/api.h b/include/lwip/api.h
deleted file mode 100644
index 3f9cac5..0000000
--- a/include/lwip/api.h
+++ /dev/null
@@ -1,225 +0,0 @@
-/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved. 
- * 
- * Redistribution and use in source and binary forms, with or without modification, 
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission. 
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- * 
- * Author: Adam Dunkels <adam@sics.se>
- *
- */
-#ifndef __LWIP_API_H__
-#define __LWIP_API_H__
-
-#include "lwip/opt.h"
-
-#if LWIP_NETCONN                /* don't build if not configured for use in lwipopts.h */
-
-#include <stddef.h>             /* for size_t */
-
-#include "lwip/netbuf.h"
-#include "lwip/sys.h"
-#include "lwip/ip_addr.h"
-#include "lwip/err.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* Throughout this file, IP addresses and port numbers are expected to be in
- * the same byte order as in the corresponding pcb.
- */
-
-/* Flags for netconn_write */
-#define NETCONN_NOFLAG 0x00
-#define NETCONN_NOCOPY 0x00     /* Only for source code compatibility */
-#define NETCONN_COPY   0x01
-#define NETCONN_MORE   0x02
-
-/* Helpers to process several netconn_types by the same code */
-#define NETCONNTYPE_GROUP(t)    (t&0xF0)
-#define NETCONNTYPE_DATAGRAM(t) (t&0xE0)
-
-    enum netconn_type {
-        NETCONN_INVALID = 0,
-        /* NETCONN_TCP Group */
-        NETCONN_TCP = 0x10,
-        /* NETCONN_UDP Group */
-        NETCONN_UDP = 0x20,
-        NETCONN_UDPLITE = 0x21,
-        NETCONN_UDPNOCHKSUM = 0x22,
-        /* NETCONN_RAW Group */
-        NETCONN_RAW = 0x40
-    };
-
-    enum netconn_state {
-        NETCONN_NONE,
-        NETCONN_WRITE,
-        NETCONN_LISTEN,
-        NETCONN_CONNECT,
-        NETCONN_CLOSE
-    };
-
-    enum netconn_evt {
-        NETCONN_EVT_RCVPLUS,
-        NETCONN_EVT_RCVMINUS,
-        NETCONN_EVT_SENDPLUS,
-        NETCONN_EVT_SENDMINUS
-    };
-
-#if LWIP_IGMP
-    enum netconn_igmp {
-        NETCONN_JOIN,
-        NETCONN_LEAVE
-    };
-#endif                          /* LWIP_IGMP */
-
-/* forward-declare some structs to avoid to include their headers */
-    struct ip_pcb;
-    struct tcp_pcb;
-    struct udp_pcb;
-    struct raw_pcb;
-    struct netconn;
-
-/** A callback prototype to inform about events for a netconn */
-    typedef void (*netconn_callback) (struct netconn *, enum netconn_evt,
-                                      u16_t len);
-
-/** A netconn descriptor */
-    struct netconn {
-  /** type of the netconn (TCP, UDP or RAW) */
-        enum netconn_type type;
-  /** current state of the netconn */
-        enum netconn_state state;
-  /** the lwIP internal protocol control block */
-        union {
-            struct ip_pcb *ip;
-            struct tcp_pcb *tcp;
-            struct udp_pcb *udp;
-            struct raw_pcb *raw;
-        } pcb;
-  /** the last error this netconn had */
-        err_t err;
-  /** sem that is used to synchroneously execute functions in the core context */
-        sys_sem_t op_completed;
-  /** mbox where received packets are stored until they are fetched
-      by the netconn application thread (can grow quite big) */
-        sys_mbox_t recvmbox;
-  /** mbox where new connections are stored until processed
-      by the application thread */
-        sys_mbox_t acceptmbox;
-  /** only used for socket layer */
-        int socket;
-#if LWIP_SO_RCVTIMEO
-  /** timeout to wait for new data to be received
-      (or connections to arrive for listening netconns) */
-        int recv_timeout;
-#endif                          /* LWIP_SO_RCVTIMEO */
-#if LWIP_SO_RCVBUF
-  /** maximum amount of bytes queued in recvmbox */
-        int recv_bufsize;
-#endif                          /* LWIP_SO_RCVBUF */
-        s16_t recv_avail;
-#if LWIP_TCP
-  /** TCP: when data passed to netconn_write doesn't fit into the send buffer,
-      this temporarily stores the message. */
-        struct api_msg_msg *write_msg;
-  /** TCP: when data passed to netconn_write doesn't fit into the send buffer,
-      this temporarily stores how much is already sent. */
-        size_t write_offset;
-#if LWIP_TCPIP_CORE_LOCKING
-  /** TCP: when data passed to netconn_write doesn't fit into the send buffer,
-      this temporarily stores whether to wake up the original application task
-      if data couldn't be sent in the first try. */
-        u8_t write_delayed;
-#endif                          /* LWIP_TCPIP_CORE_LOCKING */
-#endif                          /* LWIP_TCP */
-  /** A callback function that is informed about events for this netconn */
-        netconn_callback callback;
-    };
-
-/* Register an Network connection event */
-#define API_EVENT(c,e,l) if (c->callback) {         \
-                           (*c->callback)(c, e, l); \
-                         }
-
-/* Network connection functions: */
-#define netconn_new(t)                  netconn_new_with_proto_and_callback(t, 0, NULL)
-#define netconn_new_with_callback(t, c) netconn_new_with_proto_and_callback(t, 0, c)
-    struct
-    netconn *netconn_new_with_proto_and_callback(enum netconn_type t,
-                                                 u8_t proto,
-                                                 netconn_callback callback);
-    err_t netconn_delete(struct netconn *conn);
-/** Get the type of a netconn (as enum netconn_type). */
-#define netconn_type(conn) (conn->type)
-
-    err_t netconn_getaddr(struct netconn *conn,
-                          struct ip_addr *addr, u16_t * port, u8_t local);
-#define netconn_peer(c,i,p) netconn_getaddr(c,i,p,0)
-#define netconn_addr(c,i,p) netconn_getaddr(c,i,p,1)
-
-    err_t netconn_bind(struct netconn *conn, struct ip_addr *addr, u16_t port);
-
-    err_t netconn_redirect(struct netconn *conn,
-                           struct ip_addr *local_ip,
-                           u16_t local_port,
-                           struct ip_addr *remote_ip, u16_t remote_port);
-     err_t
-      netconn_pause(struct netconn *conn, struct ip_addr *local_ip,
-                    u16_t local_port,
-                    struct ip_addr *remote_ip, u16_t remote_port);
-
-    err_t netconn_connect(struct netconn *conn,
-                          struct ip_addr *addr, u16_t port);
-    err_t netconn_disconnect(struct netconn *conn);
-    err_t netconn_listen_with_backlog(struct netconn *conn, u8_t backlog);
-#define netconn_listen(conn) netconn_listen_with_backlog(conn, TCP_DEFAULT_LISTEN_BACKLOG)
-    struct netconn *netconn_accept(struct netconn *conn);
-    struct netbuf *netconn_recv(struct netconn *conn);
-    err_t netconn_sendto(struct netconn *conn,
-                         struct netbuf *buf, struct ip_addr *addr, u16_t port);
-    err_t netconn_send(struct netconn *conn, struct netbuf *buf);
-    err_t netconn_write(struct netconn *conn,
-                        const void *dataptr, size_t size, u8_t apiflags);
-    err_t netconn_close(struct netconn *conn);
-
-#if LWIP_IGMP
-    err_t netconn_join_leave_group(struct netconn *conn,
-                                   struct ip_addr *multiaddr,
-                                   struct ip_addr *interface,
-                                   enum netconn_igmp join_or_leave);
-#endif                          /* LWIP_IGMP */
-#if LWIP_DNS
-    err_t netconn_gethostbyname(const char *name, struct ip_addr *addr);
-#endif                          /* LWIP_DNS */
-
-#define netconn_err(conn)          ((conn)->err)
-#define netconn_recv_bufsize(conn) ((conn)->recv_bufsize)
-
-#ifdef __cplusplus
-}
-#endif
-#endif                          /* LWIP_NETCONN */
-#endif                          /* __LWIP_API_H__ */
diff --git a/include/lwip/api_msg.h b/include/lwip/api_msg.h
deleted file mode 100644
index 0089177..0000000
--- a/include/lwip/api_msg.h
+++ /dev/null
@@ -1,171 +0,0 @@
-/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved. 
- * 
- * Redistribution and use in source and binary forms, with or without modification, 
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission. 
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- * 
- * Author: Adam Dunkels <adam@sics.se>
- *
- */
-#ifndef __LWIP_API_MSG_H__
-#define __LWIP_API_MSG_H__
-
-#include "lwip/opt.h"
-
-#if LWIP_NETCONN                /* don't build if not configured for use in lwipopts.h */
-
-#include <stddef.h>             /* for size_t */
-
-#include "lwip/ip_addr.h"
-#include "lwip/err.h"
-#include "lwip/sys.h"
-#include "lwip/igmp.h"
-#include "lwip/api.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* IP addresses and port numbers are expected to be in
- * the same byte order as in the corresponding pcb.
- */
-/** This struct includes everything that is necessary to execute a function
-    for a netconn in another thread context (mainly used to process netconns
-    in the tcpip_thread context to be thread safe). */
-    struct api_msg_msg {
-  /** The netconn which to process - always needed: it includes the semaphore
-      which is used to block the application thread until the function finished. */
-        struct netconn *conn;
-  /** Depending on the executed function, one of these union members is used */
-        union {
-    /** used for do_send */
-            struct netbuf *b;
-    /** used for do_newconn */
-            struct {
-                u8_t proto;
-            } n;
-    /** used for do_bind and do_connect */
-            struct {
-                struct ip_addr *ipaddr;
-                u16_t port;
-            } bc;
-    /** used for do_getaddr */
-            struct {
-                struct ip_addr *ipaddr;
-                u16_t *port;
-                u8_t local;
-            } ad;
-    /** used for do_write */
-            struct {
-                const void *dataptr;
-                size_t len;
-                u8_t apiflags;
-            } w;
-    /** used ofr do_recv */
-            struct {
-                u16_t len;
-            } r;
-#if LWIP_IGMP
-    /** used for do_join_leave_group */
-            struct {
-                struct ip_addr *multiaddr;
-                struct ip_addr *interface;
-                enum netconn_igmp join_or_leave;
-            } jl;
-#endif                          /* LWIP_IGMP */
-#if TCP_LISTEN_BACKLOG
-            struct {
-                u8_t backlog;
-            } lb;
-#endif                          /* TCP_LISTEN_BACKLOG */
-            // IK
-            struct {
-                struct ip_addr *local_ip;
-                u16_t local_port;
-                struct ip_addr *remote_ip;
-                u16_t remote_port;
-            } red;
-
-        } msg;
-    };
-
-/** This struct contains a function to execute in another thread context and
-    a struct api_msg_msg that serves as an argument for this function.
-    This is passed to tcpip_apimsg to execute functions in tcpip_thread context. */
-    struct api_msg {
-  /** function to execute in tcpip_thread context */
-        void (*function) (struct api_msg_msg * msg);
-  /** arguments for this function */
-        struct api_msg_msg msg;
-    };
-
-#if LWIP_DNS
-/** As do_gethostbyname requires more arguments but doesn't require a netconn,
-    it has its own struct (to avoid struct api_msg getting bigger than necessary).
-    do_gethostbyname must be called using tcpip_callback instead of tcpip_apimsg
-    (see netconn_gethostbyname). */
-    struct dns_api_msg {
-  /** Hostname to query or dotted IP address string */
-        const char *name;
-  /** Rhe resolved address is stored here */
-        struct ip_addr *addr;
-  /** This semaphore is posted when the name is resolved, the application thread
-      should wait on it. */
-        sys_sem_t sem;
-  /** Errors are given back here */
-        err_t *err;
-    };
-#endif                          /* LWIP_DNS */
-
-    void do_newconn(struct api_msg_msg *msg);
-    void do_delconn(struct api_msg_msg *msg);
-    void do_bind(struct api_msg_msg *msg);
-    void do_redirect(struct api_msg_msg *msg);
-    void do_pause(struct api_msg_msg *msg);
-    void do_connect(struct api_msg_msg *msg);
-    void do_disconnect(struct api_msg_msg *msg);
-    void do_listen(struct api_msg_msg *msg);
-    void do_send(struct api_msg_msg *msg);
-    void do_recv(struct api_msg_msg *msg);
-    void do_write(struct api_msg_msg *msg);
-    void do_getaddr(struct api_msg_msg *msg);
-    void do_close(struct api_msg_msg *msg);
-#if LWIP_IGMP
-    void do_join_leave_group(struct api_msg_msg *msg);
-#endif                          /* LWIP_IGMP */
-
-#if LWIP_DNS
-    void do_gethostbyname(void *arg);
-#endif                          /* LWIP_DNS */
-
-    struct netconn *netconn_alloc(enum netconn_type t,
-                                  netconn_callback callback);
-    void netconn_free(struct netconn *conn);
-
-#ifdef __cplusplus
-}
-#endif
-#endif                          /* LWIP_NETCONN */
-#endif                          /* __LWIP_API_MSG_H__ */
diff --git a/include/lwip/arch.h b/include/lwip/arch.h
deleted file mode 100644
index 9e9d10d..0000000
--- a/include/lwip/arch.h
+++ /dev/null
@@ -1,226 +0,0 @@
-/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved. 
- * 
- * Redistribution and use in source and binary forms, with or without modification, 
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission. 
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- * 
- * Author: Adam Dunkels <adam@sics.se>
- *
- */
-#ifndef __LWIP_ARCH_H__
-#define __LWIP_ARCH_H__
-
-#include "arch/cc.h"
-
-/** Temporary: define format string for size_t if not defined in cc.h */
-#ifndef SZT_F
-#define SZT_F U32_F
-#endif                          /* SZT_F */
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#ifndef PACK_STRUCT_BEGIN
-#define PACK_STRUCT_BEGIN
-#endif                          /* PACK_STRUCT_BEGIN */
-
-#ifndef PACK_STRUCT_END
-#define PACK_STRUCT_END
-#endif                          /* PACK_STRUCT_END */
-
-#ifndef PACK_STRUCT_FIELD
-#define PACK_STRUCT_FIELD(x) x
-#endif                          /* PACK_STRUCT_FIELD */
-
-
-#ifndef LWIP_UNUSED_ARG
-#define LWIP_UNUSED_ARG(x) (void)x
-#endif                          /* LWIP_UNUSED_ARG */
-
-
-#ifdef LWIP_PROVIDE_ERRNO
-
-#define  EPERM     1            /* Operation not permitted */
-#define  ENOENT     2           /* No such file or directory */
-#define  ESRCH     3            /* No such process */
-#define  EINTR     4            /* Interrupted system call */
-#define  EIO     5              /* I/O error */
-#define  ENXIO     6            /* No such device or address */
-#define  E2BIG     7            /* Arg list too long */
-#define  ENOEXEC     8          /* Exec format error */
-#define  EBADF     9            /* Bad file number */
-#define  ECHILD    10           /* No child processes */
-#define  EAGAIN    11           /* Try again */
-#define  ENOMEM    12           /* Out of memory */
-#define  EACCES    13           /* Permission denied */
-#define  EFAULT    14           /* Bad address */
-#define  ENOTBLK    15          /* Block device required */
-#define  EBUSY    16            /* Device or resource busy */
-#define  EEXIST    17           /* File exists */
-#define  EXDEV    18            /* Cross-device link */
-#define  ENODEV    19           /* No such device */
-#define  ENOTDIR    20          /* Not a directory */
-#define  EISDIR    21           /* Is a directory */
-#define  EINVAL    22           /* Invalid argument */
-#define  ENFILE    23           /* File table overflow */
-#define  EMFILE    24           /* Too many open files */
-#define  ENOTTY    25           /* Not a typewriter */
-#define  ETXTBSY    26          /* Text file busy */
-#define  EFBIG    27            /* File too large */
-#define  ENOSPC    28           /* No space left on device */
-#define  ESPIPE    29           /* Illegal seek */
-#define  EROFS    30            /* Read-only file system */
-#define  EMLINK    31           /* Too many links */
-#define  EPIPE    32            /* Broken pipe */
-#define  EDOM    33             /* Math argument out of domain of func */
-#define  ERANGE    34           /* Math result not representable */
-#define  EDEADLK    35          /* Resource deadlock would occur */
-#define  ENAMETOOLONG  36       /* File name too long */
-#define  ENOLCK    37           /* No record locks available */
-#define  ENOSYS    38           /* Function not implemented */
-#define  ENOTEMPTY  39          /* Directory not empty */
-#define  ELOOP    40            /* Too many symbolic links encountered */
-#define  EWOULDBLOCK  EAGAIN    /* Operation would block */
-#define  ENOMSG    42           /* No message of desired type */
-#define  EIDRM    43            /* Identifier removed */
-#define  ECHRNG    44           /* Channel number out of range */
-#define  EL2NSYNC  45           /* Level 2 not synchronized */
-#define  EL3HLT    46           /* Level 3 halted */
-#define  EL3RST    47           /* Level 3 reset */
-#define  ELNRNG    48           /* Link number out of range */
-#define  EUNATCH    49          /* Protocol driver not attached */
-#define  ENOCSI    50           /* No CSI structure available */
-#define  EL2HLT    51           /* Level 2 halted */
-#define  EBADE    52            /* Invalid exchange */
-#define  EBADR    53            /* Invalid request descriptor */
-#define  EXFULL    54           /* Exchange full */
-#define  ENOANO    55           /* No anode */
-#define  EBADRQC    56          /* Invalid request code */
-#define  EBADSLT    57          /* Invalid slot */
-
-#define  EDEADLOCK  EDEADLK
-
-#define  EBFONT    59           /* Bad font file format */
-#define  ENOSTR    60           /* Device not a stream */
-#define  ENODATA    61          /* No data available */
-#define  ETIME    62            /* Timer expired */
-#define  ENOSR    63            /* Out of streams resources */
-#define  ENONET    64           /* Machine is not on the network */
-#define  ENOPKG    65           /* Package not installed */
-#define  EREMOTE    66          /* Object is remote */
-#define  ENOLINK    67          /* Link has been severed */
-#define  EADV    68             /* Advertise error */
-#define  ESRMNT    69           /* Srmount error */
-#define  ECOMM    70            /* Communication error on send */
-#define  EPROTO    71           /* Protocol error */
-#define  EMULTIHOP  72          /* Multihop attempted */
-#define  EDOTDOT    73          /* RFS specific error */
-#define  EBADMSG    74          /* Not a data message */
-#define  EOVERFLOW  75          /* Value too large for defined data type */
-#define  ENOTUNIQ  76           /* Name not unique on network */
-#define  EBADFD    77           /* File descriptor in bad state */
-#define  EREMCHG    78          /* Remote address changed */
-#define  ELIBACC    79          /* Can not access a needed shared library */
-#define  ELIBBAD    80          /* Accessing a corrupted shared library */
-#define  ELIBSCN    81          /* .lib section in a.out corrupted */
-#define  ELIBMAX    82          /* Attempting to link in too many shared libraries */
-#define  ELIBEXEC  83           /* Cannot exec a shared library directly */
-#define  EILSEQ    84           /* Illegal byte sequence */
-#define  ERESTART  85           /* Interrupted system call should be restarted */
-#define  ESTRPIPE  86           /* Streams pipe error */
-#define  EUSERS    87           /* Too many users */
-#define  ENOTSOCK  88           /* Socket operation on non-socket */
-#define  EDESTADDRREQ  89       /* Destination address required */
-#define  EMSGSIZE  90           /* Message too long */
-#define  EPROTOTYPE  91         /* Protocol wrong type for socket */
-#define  ENOPROTOOPT  92        /* Protocol not available */
-#define  EPROTONOSUPPORT  93    /* Protocol not supported */
-#define  ESOCKTNOSUPPORT  94    /* Socket type not supported */
-#define  EOPNOTSUPP  95         /* Operation not supported on transport endpoint */
-#define  EPFNOSUPPORT  96       /* Protocol family not supported */
-#define  EAFNOSUPPORT  97       /* Address family not supported by protocol */
-#define  EADDRINUSE  98         /* Address already in use */
-#define  EADDRNOTAVAIL  99      /* Cannot assign requested address */
-#define  ENETDOWN  100          /* Network is down */
-#define  ENETUNREACH  101       /* Network is unreachable */
-#define  ENETRESET  102         /* Network dropped connection because of reset */
-#define  ECONNABORTED  103      /* Software caused connection abort */
-#define  ECONNRESET  104        /* Connection reset by peer */
-#define  ENOBUFS    105         /* No buffer space available */
-#define  EISCONN    106         /* Transport endpoint is already connected */
-#define  ENOTCONN  107          /* Transport endpoint is not connected */
-/* XXX: ESHUTDOWN (108) has been moved down, for newlib compatiblity -AKK */
-#define  ETOOMANYREFS  109      /* Too many references: cannot splice */
-#define  ETIMEDOUT  110         /* Connection timed out */
-#define  ECONNREFUSED  111      /* Connection refused */
-#define  EHOSTDOWN  112         /* Host is down */
-#define  EHOSTUNREACH  113      /* No route to host */
-#define  EALREADY  114          /* Operation already in progress */
-#define  EINPROGRESS  115       /* Operation now in progress */
-#define  ESTALE    116          /* Stale NFS file handle */
-#define  EUCLEAN    117         /* Structure needs cleaning */
-#define  ENOTNAM    118         /* Not a XENIX named type file */
-#define  ENAVAIL    119         /* No XENIX semaphores available */
-#define  EISNAM    120          /* Is a named type file */
-#define  EREMOTEIO  121         /* Remote I/O error */
-#define  EDQUOT    122          /* Quota exceeded */
-
-#define  ENOMEDIUM  123         /* No medium found */
-#define  EMEDIUMTYPE  124       /* Wrong medium type */
-
-#ifndef errno
-extern int errno;
-#endif
-
-#endif /* LWIP_PROVIDE_ERRNO */
-
-/* These are not protected by LWIP_PROVIDE_ERRNO for newlib compatiblity -AKK */
-
-#define ENSROK    0             /* DNS server returned answer with no data */
-#define ESHUTDOWN  108         /* Cannot send after transport endpoint shutdown */
-#define ENSRNODATA  160         /* DNS server returned answer with no data */
-#define ENSRFORMERR 161         /* DNS server claims query was misformatted */
-#define ENSRSERVFAIL 162        /* DNS server returned general failure */
-#define ENSRNOTFOUND 163        /* Domain name not found */
-#define ENSRNOTIMP  164         /* DNS server does not implement requested operation */
-#define ENSRREFUSED 165         /* DNS server refused query */
-#define ENSRBADQUERY 166        /* Misformatted DNS query */
-#define ENSRBADNAME 167         /* Misformatted domain name */
-#define ENSRBADFAMILY 168       /* Unsupported address family */
-#define ENSRBADRESP 169         /* Misformatted DNS reply */
-#define ENSRCONNREFUSED 170     /* Could not contact DNS servers */
-#define ENSRTIMEOUT 171         /* Timeout while contacting DNS servers */
-#define ENSROF    172           /* End of file */
-#define ENSRFILE  173           /* Error reading file */
-#define ENSRNOMEM 174           /* Out of memory */
-#define ENSRDESTRUCTION 175     /* Application terminated lookup */
-#define ENSRQUERYDOMAINTOOLONG  176     /* Domain name is too long */
-#define ENSRCNAMELOOP 177       /* Domain name is too long */
-
-#ifdef __cplusplus
-}
-#endif
-#endif                          /* __LWIP_ARCH_H__ */
diff --git a/include/lwip/barrelfish.h b/include/lwip/barrelfish.h
deleted file mode 100644
index 4bd0c7a..0000000
--- a/include/lwip/barrelfish.h
+++ /dev/null
@@ -1,18 +0,0 @@
-/*
- * Copyright (c) 2012, ETH Zurich.
- * All rights reserved.
- *
- * This file is distributed under the terms in the attached LICENSE file.
- * If you do not find this file, copies can be found by writing to:
- * ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich. Attn: Systems Group.
- */
-
-#ifndef BARRELFISH_LWIP_H
-#define BARRELFISH_LWIP_H
-
-#include <errors/errno.h>
-#include <lwip/err.h>
-
-errval_t lwip_err_to_errval(err_t e);
-
-#endif
diff --git a/include/lwip/debug.h b/include/lwip/debug.h
deleted file mode 100644
index ee633a4..0000000
--- a/include/lwip/debug.h
+++ /dev/null
@@ -1,108 +0,0 @@
-/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Adam Dunkels <adam@sics.se>
- *
- */
-#ifndef __LWIP_DEBUG_H__
-#define __LWIP_DEBUG_H__
-
-#include "lwip/arch.h"
-
-/** lower two bits indicate debug level
- * - 0 off
- * - 1 warning
- * - 2 serious
- * - 3 severe
- */
-#define LWIP_DBG_LEVEL_OFF     0x00
-#define LWIP_DBG_LEVEL_WARNING 0x01     /* bad checksums, dropped packets, ... */
-#define LWIP_DBG_LEVEL_SERIOUS 0x02     /* memory allocation failures, ... */
-#define LWIP_DBG_LEVEL_SEVERE  0x03
-#define LWIP_DBG_MASK_LEVEL    0x03
-
-/** flag for LWIP_DEBUGF to enable that debug message */
-#define LWIP_DBG_ON            0x80U
-/** flag for LWIP_DEBUGF to disable that debug message */
-#define LWIP_DBG_OFF           0x00U
-
-/** flag for LWIP_DEBUGF indicating a tracing message (to follow program flow) */
-#define LWIP_DBG_TRACE         0x40U
-/** flag for LWIP_DEBUGF indicating a state debug message (to follow module states) */
-#define LWIP_DBG_STATE         0x20U
-/** flag for LWIP_DEBUGF indicating newly added code, not thoroughly tested yet */
-#define LWIP_DBG_FRESH         0x10U
-/** flag for LWIP_DEBUGF to halt after printing this debug message */
-#define LWIP_DBG_HALT          0x08U
-
-#ifndef LWIP_NOASSERT
-#define LWIP_ASSERT(message, assertion) do { if(!(assertion)) \
-  LWIP_PLATFORM_ASSERT(message); } while(0)
-#else                           /* LWIP_NOASSERT */
-#define LWIP_ASSERT(message, assertion)
-#endif                          /* LWIP_NOASSERT */
-
-/** if "expression" isn't true, then print "message" and execute "handler" expression */
-#ifndef LWIP_ERROR
-#define LWIP_ERROR(message, expression, handler) do { if (!(expression)) { \
-  LWIP_PLATFORM_ASSERT(message); handler;}} while(0)
-#endif                          /* LWIP_ERROR */
-
-//#define LWIP_DEBUG 1
-#ifdef LWIP_DEBUG
-/** print debug message only if debug message type is enabled...
- *  AND is of correct type AND is at least LWIP_DBG_LEVEL
- */
-
-/*
-#define LWIP_DEBUGF(debug, message) do { \
-                                 LWIP_PLATFORM_DIAG(message); \
-                                } while(0)
-
-#else                          // LWIP_DEBUG
-#define LWIP_DEBUGF(debug, message)
-#endif                          // LWIP_DEBUG
-*/
-
-#define LWIP_DEBUGF(debug, message) do { \
-                               if ( \
-                                   ((debug) & LWIP_DBG_ON) && \
-                                   ((debug) & LWIP_DBG_TYPES_ON) && \
-                                   ((s16_t)((debug) & LWIP_DBG_MASK_LEVEL) >= LWIP_DBG_MIN_LEVEL)) { \
-                                 LWIP_PLATFORM_DIAG(message); \
-                                 if ((debug) & LWIP_DBG_HALT) { \
-                                   while(1); \
-                                 } \
-                               } \
-                             } while(0)
-
-#else                          // LWIP_DEBUG
-#define LWIP_DEBUGF(debug, message)
-#endif                          // LWIP_DEBUG
-
-#endif                          /* __LWIP_DEBUG_H__ */
diff --git a/include/lwip/def.h b/include/lwip/def.h
deleted file mode 100644
index 31980ef..0000000
--- a/include/lwip/def.h
+++ /dev/null
@@ -1,53 +0,0 @@
-/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Adam Dunkels <adam@sics.se>
- *
- */
-#ifndef __LWIP_DEF_H__
-#define __LWIP_DEF_H__
-
-/* this might define NULL already */
-#include "lwip/arch.h"
-
-/* This enum is used to give buffer_id */
-/*enum buffer_memory_types {
-    RX_BUFFER_ID = 0,
-    TX_BUFFER_ID = 1,
-};
-*/
-
-#define LWIP_MAX(x , y)  (((x) > (y)) ? (x) : (y))
-#define LWIP_MIN(x , y)  (((x) < (y)) ? (x) : (y))
-
-#ifndef NULL
-#define NULL ((void *)0)
-#endif
-
-
-#endif                          /* __LWIP_DEF_H__ */
diff --git a/include/lwip/dhcp.h b/include/lwip/dhcp.h
deleted file mode 100644
index 13a2166..0000000
--- a/include/lwip/dhcp.h
+++ /dev/null
@@ -1,241 +0,0 @@
-/** @file
- */
-
-#ifndef __LWIP_DHCP_H__
-#define __LWIP_DHCP_H__
-
-#include "lwip/opt.h"
-
-#if LWIP_DHCP                   /* don't build if not configured for use in lwipopts.h */
-
-#include "lwip/netif.h"
-#include "lwip/udp.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/** period (in seconds) of the application calling dhcp_coarse_tmr() */
-#define DHCP_COARSE_TIMER_SECS 60
-/** period (in milliseconds) of the application calling dhcp_coarse_tmr() */
-#define DHCP_COARSE_TIMER_MSECS (DHCP_COARSE_TIMER_SECS * 1000UL)
-/** period (in milliseconds) of the application calling dhcp_fine_tmr() */
-#define DHCP_FINE_TIMER_MSECS 500
-
-    struct dhcp {
-  /** current DHCP state machine state */
-        u8_t state;
-  /** retries of current request */
-        u8_t tries;
-  /** transaction identifier of last sent request */
-        u32_t xid;
-  /** our connection to the DHCP server */
-        struct udp_pcb *pcb;
-  /** (first) pbuf of incoming msg */
-        struct pbuf *p;
-  /** incoming msg */
-        struct dhcp_msg *msg_in;
-  /** incoming msg options */
-        struct dhcp_msg *options_in;
-  /** ingoing msg options length */
-        u16_t options_in_len;
-
-        struct pbuf *p_out;     /* pbuf of outcoming msg */
-        struct dhcp_msg *msg_out;       /* outgoing msg */
-        u16_t options_out_len;  /* outgoing msg options length */
-        u16_t request_timeout;  /* #ticks with period DHCP_FINE_TIMER_SECS for request timeout */
-        u16_t t1_timeout;       /* #ticks with period DHCP_COARSE_TIMER_SECS for renewal time */
-        u16_t t2_timeout;       /* #ticks with period DHCP_COARSE_TIMER_SECS for rebind time */
-        struct ip_addr server_ip_addr;  /* dhcp server address that offered this lease */
-        struct ip_addr offered_ip_addr;
-        struct ip_addr offered_sn_mask;
-        struct ip_addr offered_gw_addr;
-        struct ip_addr offered_bc_addr;
-#define DHCP_MAX_DNS 2
-        u32_t dns_count;        /* actual number of DNS servers obtained */
-        struct ip_addr offered_dns_addr[DHCP_MAX_DNS];  /* DNS server addresses */
-
-        u32_t offered_t0_lease; /* lease period (in seconds) */
-        u32_t offered_t1_renew; /* recommended renew time (usually 50% of lease period) */
-        u32_t offered_t2_rebind;        /* recommended rebind time (usually 66% of lease period)  */
-#if LWIP_DHCP_AUTOIP_COOP
-        u8_t autoip_coop_state;
-#endif
-/** Patch #1308
- *  TODO: See dhcp.c "TODO"s
- */
-#if 0
-        struct ip_addr offered_si_addr;
-        u8_t *boot_file_name;
-#endif
-    };
-
-/* MUST be compiled with "pack structs" or equivalent! */
-#ifdef PACK_STRUCT_USE_INCLUDES
-#include "arch/bpstruct.h"
-#endif
-     PACK_STRUCT_BEGIN
-/** minimum set of fields of any DHCP message */
-      struct dhcp_msg {
-        PACK_STRUCT_FIELD(u8_t op);
-        PACK_STRUCT_FIELD(u8_t htype);
-        PACK_STRUCT_FIELD(u8_t hlen);
-        PACK_STRUCT_FIELD(u8_t hops);
-        PACK_STRUCT_FIELD(u32_t xid);
-        PACK_STRUCT_FIELD(u16_t secs);
-        PACK_STRUCT_FIELD(u16_t flags);
-        PACK_STRUCT_FIELD(struct ip_addr ciaddr);
-         PACK_STRUCT_FIELD(struct ip_addr yiaddr);
-         PACK_STRUCT_FIELD(struct ip_addr siaddr);
-         PACK_STRUCT_FIELD(struct ip_addr giaddr);
-#define DHCP_CHADDR_LEN 16U
-         PACK_STRUCT_FIELD(u8_t chaddr[DHCP_CHADDR_LEN]);
-#define DHCP_SNAME_LEN 64U
-         PACK_STRUCT_FIELD(u8_t sname[DHCP_SNAME_LEN]);
-#define DHCP_FILE_LEN 128U
-         PACK_STRUCT_FIELD(u8_t file[DHCP_FILE_LEN]);
-         PACK_STRUCT_FIELD(u32_t cookie);
-#define DHCP_MIN_OPTIONS_LEN 68U
-/** make sure user does not configure this too small */
-#if ((defined(DHCP_OPTIONS_LEN)) && (DHCP_OPTIONS_LEN < DHCP_MIN_OPTIONS_LEN))
-#undef DHCP_OPTIONS_LEN
-#endif
-/** allow this to be configured in lwipopts.h, but not too small */
-#if (!defined(DHCP_OPTIONS_LEN))
-/** set this to be sufficient for your options in outgoing DHCP msgs */
-#define DHCP_OPTIONS_LEN DHCP_MIN_OPTIONS_LEN
-#endif
-         PACK_STRUCT_FIELD(u8_t options[DHCP_OPTIONS_LEN]);
-    } PACK_STRUCT_STRUCT;
-     PACK_STRUCT_END
-#ifdef PACK_STRUCT_USE_INCLUDES
-#include "arch/epstruct.h"
-#endif
-/** start DHCP configuration */
-     err_t dhcp_start(struct netif *netif);
-/** enforce early lease renewal (not needed normally)*/
-    err_t dhcp_renew(struct netif *netif);
-/** release the DHCP lease, usually called before dhcp_stop()*/
-    err_t dhcp_release(struct netif *netif);
-/** stop DHCP configuration */
-    void dhcp_stop(struct netif *netif);
-/** inform server of our manual IP address */
-    void dhcp_inform(struct netif *netif);
-
-/** if enabled, check whether the offered IP address is not in use, using ARP */
-#if DHCP_DOES_ARP_CHECK
-    void dhcp_arp_reply(struct netif *netif, struct ip_addr *addr);
-#endif
-
-/** to be called every minute */
-    void dhcp_coarse_tmr(void);
-/** to be called every half second */
-    void dhcp_fine_tmr(void);
-
-/** DHCP message item offsets and length */
-#define DHCP_MSG_OFS (UDP_DATA_OFS)
-#define DHCP_OP_OFS (DHCP_MSG_OFS + 0)
-#define DHCP_HTYPE_OFS (DHCP_MSG_OFS + 1)
-#define DHCP_HLEN_OFS (DHCP_MSG_OFS + 2)
-#define DHCP_HOPS_OFS (DHCP_MSG_OFS + 3)
-#define DHCP_XID_OFS (DHCP_MSG_OFS + 4)
-#define DHCP_SECS_OFS (DHCP_MSG_OFS + 8)
-#define DHCP_FLAGS_OFS (DHCP_MSG_OFS + 10)
-#define DHCP_CIADDR_OFS (DHCP_MSG_OFS + 12)
-#define DHCP_YIADDR_OFS (DHCP_MSG_OFS + 16)
-#define DHCP_SIADDR_OFS (DHCP_MSG_OFS + 20)
-#define DHCP_GIADDR_OFS (DHCP_MSG_OFS + 24)
-#define DHCP_CHADDR_OFS (DHCP_MSG_OFS + 28)
-#define DHCP_SNAME_OFS (DHCP_MSG_OFS + 44)
-#define DHCP_FILE_OFS (DHCP_MSG_OFS + 108)
-#define DHCP_MSG_LEN 236
-
-#define DHCP_COOKIE_OFS (DHCP_MSG_OFS + DHCP_MSG_LEN)
-#define DHCP_OPTIONS_OFS (DHCP_MSG_OFS + DHCP_MSG_LEN + 4)
-
-#define DHCP_CLIENT_PORT 68
-#define DHCP_SERVER_PORT 67
-
-/** DHCP client states */
-#define DHCP_REQUESTING 1
-#define DHCP_INIT 2
-#define DHCP_REBOOTING 3
-#define DHCP_REBINDING 4
-#define DHCP_RENEWING 5
-#define DHCP_SELECTING 6
-#define DHCP_INFORMING 7
-#define DHCP_CHECKING 8
-#define DHCP_PERMANENT 9
-#define DHCP_BOUND 10
-/** not yet implemented #define DHCP_RELEASING 11 */
-#define DHCP_BACKING_OFF 12
-#define DHCP_OFF 13
-
-/** AUTOIP cooperatation flags */
-#define DHCP_AUTOIP_COOP_STATE_OFF 0
-#define DHCP_AUTOIP_COOP_STATE_ON 1
-
-#define DHCP_BOOTREQUEST 1
-#define DHCP_BOOTREPLY 2
-
-#define DHCP_DISCOVER 1
-#define DHCP_OFFER 2
-#define DHCP_REQUEST 3
-#define DHCP_DECLINE 4
-#define DHCP_ACK 5
-#define DHCP_NAK 6
-#define DHCP_RELEASE 7
-#define DHCP_INFORM 8
-
-#define DHCP_HTYPE_ETH 1
-
-#define DHCP_HLEN_ETH 6
-
-#define DHCP_BROADCAST_FLAG 15
-#define DHCP_BROADCAST_MASK (1 << DHCP_FLAG_BROADCAST)
-
-/** BootP options */
-#define DHCP_OPTION_PAD 0
-#define DHCP_OPTION_SUBNET_MASK 1       /* RFC 2132 3.3 */
-#define DHCP_OPTION_ROUTER 3
-#define DHCP_OPTION_DNS_SERVER 6
-#define DHCP_OPTION_HOSTNAME 12
-#define DHCP_OPTION_IP_TTL 23
-#define DHCP_OPTION_MTU 26
-#define DHCP_OPTION_BROADCAST 28
-#define DHCP_OPTION_TCP_TTL 37
-#define DHCP_OPTION_END 255
-
-/** DHCP options */
-#define DHCP_OPTION_REQUESTED_IP 50     /* RFC 2132 9.1, requested IP address */
-#define DHCP_OPTION_LEASE_TIME 51       /* RFC 2132 9.2, time in seconds, in 4 bytes */
-#define DHCP_OPTION_OVERLOAD 52 /* RFC2132 9.3, use file and/or sname field for options */
-
-#define DHCP_OPTION_MESSAGE_TYPE 53     /* RFC 2132 9.6, important for DHCP */
-#define DHCP_OPTION_MESSAGE_TYPE_LEN 1
-
-
-#define DHCP_OPTION_SERVER_ID 54        /* RFC 2132 9.7, server IP address */
-#define DHCP_OPTION_PARAMETER_REQUEST_LIST 55   /* RFC 2132 9.8, requested option types */
-
-#define DHCP_OPTION_MAX_MSG_SIZE 57     /* RFC 2132 9.10, message size accepted >= 576 */
-#define DHCP_OPTION_MAX_MSG_SIZE_LEN 2
-
-#define DHCP_OPTION_T1 58       /* T1 renewal time */
-#define DHCP_OPTION_T2 59       /* T2 rebinding time */
-#define DHCP_OPTION_US 60
-#define DHCP_OPTION_CLIENT_ID 61
-#define DHCP_OPTION_TFTP_SERVERNAME 66
-#define DHCP_OPTION_BOOTFILE 67
-
-/** possible combinations of overloading the file and sname fields with options */
-#define DHCP_OVERLOAD_NONE 0
-#define DHCP_OVERLOAD_FILE 1
-#define DHCP_OVERLOAD_SNAME  2
-#define DHCP_OVERLOAD_SNAME_FILE 3
-
-#ifdef __cplusplus
-}
-#endif
-#endif                          /* LWIP_DHCP */
-#endif /*__LWIP_DHCP_H__*/
diff --git a/include/lwip/dns.h b/include/lwip/dns.h
deleted file mode 100644
index 7f463bf..0000000
--- a/include/lwip/dns.h
+++ /dev/null
@@ -1,98 +0,0 @@
-/**
- * lwip DNS resolver header file.
-
- * Author: Jim Pettinato 
- *   April 2007
-
- * ported from uIP resolv.c Copyright (c) 2002-2003, Adam Dunkels.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote
- *    products derived from this software without specific prior
- *    written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
- * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
- * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef __LWIP_DNS_H__
-#define __LWIP_DNS_H__
-
-#include "lwip/opt.h"
-
-#if LWIP_DNS                    /* don't build if not configured for use in lwipopts.h */
-
-/** DNS timer period */
-#define DNS_TMR_INTERVAL          1000
-
-/** DNS field TYPE used for "Resource Records" */
-#define DNS_RRTYPE_A              1     /* a host address */
-#define DNS_RRTYPE_NS             2     /* an authoritative name server */
-#define DNS_RRTYPE_MD             3     /* a mail destination (Obsolete - use MX) */
-#define DNS_RRTYPE_MF             4     /* a mail forwarder (Obsolete - use MX) */
-#define DNS_RRTYPE_CNAME          5     /* the canonical name for an alias */
-#define DNS_RRTYPE_SOA            6     /* marks the start of a zone of authority */
-#define DNS_RRTYPE_MB             7     /* a mailbox domain name (EXPERIMENTAL) */
-#define DNS_RRTYPE_MG             8     /* a mail group member (EXPERIMENTAL) */
-#define DNS_RRTYPE_MR             9     /* a mail rename domain name (EXPERIMENTAL) */
-#define DNS_RRTYPE_NULL           10    /* a null RR (EXPERIMENTAL) */
-#define DNS_RRTYPE_WKS            11    /* a well known service description */
-#define DNS_RRTYPE_PTR            12    /* a domain name pointer */
-#define DNS_RRTYPE_HINFO          13    /* host information */
-#define DNS_RRTYPE_MINFO          14    /* mailbox or mail list information */
-#define DNS_RRTYPE_MX             15    /* mail exchange */
-#define DNS_RRTYPE_TXT            16    /* text strings */
-
-/** DNS field CLASS used for "Resource Records" */
-#define DNS_RRCLASS_IN            1     /* the Internet */
-#define DNS_RRCLASS_CS            2     /* the CSNET class (Obsolete - used only for examples in some obsolete RFCs) */
-#define DNS_RRCLASS_CH            3     /* the CHAOS class */
-#define DNS_RRCLASS_HS            4     /* Hesiod [Dyer 87] */
-#define DNS_RRCLASS_FLUSH         0x800 /* Flush bit */
-
-/** Callback which is invoked when a hostname is found.
- * A function of this type must be implemented by the application using the DNS resolver.
- * @param name pointer to the name that was looked up.
- * @param ipaddr pointer to a struct ip_addr containing the IP address of the hostname,
- *        or NULL if the name could not be found (or on any other error).
- * @param callback_arg a user-specified callback argument passed to dns_gethostbyname
-*/
-typedef void (*dns_found_callback) (const char *name, struct ip_addr * ipaddr,
-                                    void *callback_arg);
-
-
-void dns_init(void);
-
-void dns_tmr(void);
-
-void dns_setserver(u8_t numdns, struct ip_addr *dnsserver);
-
-struct ip_addr dns_getserver(u8_t numdns);
-
-err_t dns_gethostbyname(const char *hostname, struct ip_addr *addr,
-                        dns_found_callback found, void *callback_arg);
-
-#if DNS_LOCAL_HOSTLIST && DNS_LOCAL_HOSTLIST_IS_DYNAMIC
-int dns_local_removehost(const char *hostname, const struct ip_addr *addr);
-err_t dns_local_addhost(const char *hostname, const struct ip_addr *addr);
-#endif                          /* DNS_LOCAL_HOSTLIST && DNS_LOCAL_HOSTLIST_IS_DYNAMIC */
-
-#endif                          /* LWIP_DNS */
-
-#endif                          /* __LWIP_DNS_H__ */
diff --git a/include/lwip/err.h b/include/lwip/err.h
deleted file mode 100644
index 3cae392..0000000
--- a/include/lwip/err.h
+++ /dev/null
@@ -1,89 +0,0 @@
-/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved. 
- * 
- * Redistribution and use in source and binary forms, with or without modification, 
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission. 
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- * 
- * Author: Adam Dunkels <adam@sics.se>
- *
- */
-#ifndef __LWIP_ERR_H__
-#define __LWIP_ERR_H__
-
-#include "lwip/opt.h"
-#include "lwip/arch.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/** Define LWIP_ERR_T in cc.h if you want to use
- *  a different type for your platform (must be signed). */
-#ifdef LWIP_ERR_T
-    typedef LWIP_ERR_T err_t;
-#else                           /* LWIP_ERR_T */
-    typedef s8_t err_t;
-#endif                          /* LWIP_ERR_T */
-
-/* Definitions for error constants. */
-
-#define ERR_OK          0       /* No error, everything OK. */
-#define ERR_MEM        -1       /* Out of memory error.     */
-#define ERR_BUF        -2       /* Buffer error.            */
-#define ERR_TIMEOUT    -3       /* Timeout.                 */
-#define ERR_RTE        -4       /* Routing problem.         */
-
-#define ERR_IS_FATAL(e) ((e) < ERR_RTE)
-
-#define ERR_ABRT       -5       /* Connection aborted.      */
-#define ERR_RST        -6       /* Connection reset.        */
-#define ERR_CLSD       -7       /* Connection closed.       */
-#define ERR_CONN       -8       /* Not connected.           */
-
-#define ERR_VAL        -9       /* Illegal value.           */
-
-#define ERR_ARG        -10      /* Illegal argument.        */
-
-#define ERR_USE        -11      /* Address in use.          */
-
-#define ERR_IF         -12      /* Low-level netif error    */
-#define ERR_ISCONN     -13      /* Already connected.       */
-
-#define ERR_INPROGRESS -14      /* Operation in progress    */
-
-
-#ifdef LWIP_DEBUG
-    extern const char *lwip_strerr(err_t err);
-#else
-#define lwip_strerr(x) ""
-#endif                          /* LWIP_DEBUG */
-
-#ifdef __cplusplus
-}
-#endif
-
-#include <errno.h>
-
-#endif                          /* __LWIP_ERR_H__ */
diff --git a/include/lwip/init.h b/include/lwip/init.h
deleted file mode 100644
index 92b6510..0000000
--- a/include/lwip/init.h
+++ /dev/null
@@ -1,165 +0,0 @@
-/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Adam Dunkels <adam@sics.se>
- *
- */
-#ifndef __LWIP_INIT_H__
-#define __LWIP_INIT_H__
-
-//#include <barrelfish/barrelfish.h>
-#include "lwip/opt.h"
-#include "lwip/err.h"
-#include <stdbool.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/** X.x.x: Major version of the stack */
-#define LWIP_VERSION_MAJOR      1U
-/** x.X.x: Minor version of the stack */
-#define LWIP_VERSION_MINOR      3U
-/** x.x.X: Revision of the stack */
-#define LWIP_VERSION_REVISION   1U
-/** For release candidates, this is set to 1..254
-  * For official releases, this is set to 255 (LWIP_RC_RELEASE)
-  * For development versions (CVS), this is set to 0 (LWIP_RC_DEVELOPMENT) */
-#define LWIP_VERSION_RC         255U
-
-/** LWIP_VERSION_RC is set to LWIP_RC_RELEASE for official releases */
-#define LWIP_RC_RELEASE         255U
-/** LWIP_VERSION_RC is set to LWIP_RC_DEVELOPMENT for CVS versions */
-#define LWIP_RC_DEVELOPMENT     0U
-
-#define LWIP_VERSION_IS_RELEASE     (LWIP_VERSION_RC == LWIP_RC_RELEASE)
-#define LWIP_VERSION_IS_DEVELOPMENT (LWIP_VERSION_RC == LWIP_RC_DEVELOPMENT)
-#define LWIP_VERSION_IS_RC          ((LWIP_VERSION_RC != LWIP_RC_RELEASE) && (LWIP_VERSION_RC != LWIP_RC_DEVELOPMENT))
-
-/** Provides the version of the stack */
-#define LWIP_VERSION   (LWIP_VERSION_MAJOR << 24   | LWIP_VERSION_MINOR << 16 | \
-                        LWIP_VERSION_REVISION << 8 | LWIP_VERSION_RC)
-
-enum net_ports_port_type_t;
-
-// FIXME: remove this
-void perform_ownership_housekeeping(uint16_t(*alloc_tcp_ptr) (void),
-                                        uint16_t(*alloc_udp_ptr) (void),
-                                        uint16_t(*bind_port_ptr) (uint16_t,
-                                                enum net_ports_port_type_t),
-                                        void (*close_port_ptr) (uint16_t,
-                                                enum net_ports_port_type_t));
-
-// global variables
-struct waitset;
-struct thread_mutex;
-
-// *********************************************************************
-// function prototypes
-// *********************************************************************
-
-// Tells if this app is special or not
-bool is_this_special_app(void);
-
-// To be called from "netd" which is responsible for ARP table
-struct netif *owner_lwip_init(char *card_name, uint64_t queueid);
-
-// initialize networkign with specific card and queue
-bool lwip_init(const char *card_name, uint64_t queueid);
-
-// initialize networking when cardname and queue is not known
-bool lwip_init_auto(void);
-
-// FIXME: remove these functions as they are not used anymore
-int is_lwip_loaded(void);
-uint64_t lwip_packet_drop_count(void);
-
-
-uint64_t wrapper_perform_lwip_work(void);
-
-void lwip_benchmark_control(int connection, uint8_t state, uint64_t trigger,
-        uint64_t cl);
-uint8_t lwip_driver_benchmark_state(int direction, uint64_t *delta,
-        uint64_t *cl);
-void lwip_debug_show_spp_status(int connection);
-
-enum Recorded_Events {
-    RE_ALL,
-    RX_ALL_PROCESS,
-    RE_REG_PBUF,
-    RE_PBUF_REPLACE,
-    RE_PBUF_REPLACE_1,
-    RE_PBUF_REPLACE_2,
-    RE_PBUF_QUEUE,
-    RE_PKT_RCV_CS,
-    RE_PBUF_REPLACE_3,
-    TX_SP,
-    TX_SP1,
-    TX_SPP_FULL,
-    TX_SN_WAIT,
-    TX_SN_SEND,
-    TX_A_SP_RN_CS,
-    TX_A_SP_RN_T,
-    TX_SND_PKT_C,
-    TX_SND_PKT_S,
-/*
-    RPC_RECV_T,
-    RPC_CALLBACK_T,
-    RPC_RECV_OUT_T,
-*/
-    RPC_CALL_T,
-    NFS_READCB_T,
-    NFS_READ_T,
-    NFS_READ_1_T,
-    NFS_READ_w_T,
-    RECORDED_EVENTS_COUNT  // MUST BE THE LAST ELEMENT!!
-};
-
-extern struct netbench_details *nb;
-void lwip_print_interesting_stats(void);
-void lwip_record_event_simple(uint8_t event_type, uint64_t ts);
-
-bool lwip_init_auto_ex(struct waitset *opt_waitset,
-                       struct thread_mutex *opt_mutex);
-bool lwip_init_ex(const char *card_name, uint64_t queueid,
-                  struct waitset *opt_waitset, struct thread_mutex *opt_mutex);
-
-// For supporting hardware features
-enum enabled_hardware_features {
-    IPv4_CHECKSUM_HW = 1,
-    IPv6_CHECKSUM_HW,
-    UDP_IPV4_CHECKSUM_HW,
-    TCP_IPV4_CHECKSUM_HW,
-};
-bool is_hw_feature_enabled(int hw_feature);
-#ifdef __cplusplus
-}
-#endif
-
-#endif // __LWIP_INIT_H__
-
diff --git a/include/lwip/mem.h b/include/lwip/mem.h
deleted file mode 100644
index d0a3fe7..0000000
--- a/include/lwip/mem.h
+++ /dev/null
@@ -1,105 +0,0 @@
-/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved. 
- * 
- * Redistribution and use in source and binary forms, with or without modification, 
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission. 
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- * 
- * Author: Adam Dunkels <adam@sics.se>
- *
- */
-#ifndef __LWIP_MEM_H__
-#define __LWIP_MEM_H__
-
-#include "lwip/opt.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#if MEM_LIBC_MALLOC
-
-#include <stddef.h>             /* for size_t */
-
-    typedef size_t mem_size_t;
-
-/* aliases for C library malloc() */
-#define mem_init()
-/* in case C library malloc() needs extra protection,
- * allow these defines to be overridden.
- */
-#ifndef mem_free
-#define mem_free free
-#endif
-#ifndef mem_malloc
-#define mem_malloc malloc
-#endif
-#ifndef mem_calloc
-#define mem_calloc calloc
-#endif
-#ifndef mem_realloc
-    static void *mem_realloc(void *mem, mem_size_t size) {
-        LWIP_UNUSED_ARG(size);
-        return mem;
-    }
-#endif
-#else                           /* MEM_LIBC_MALLOC */
-
-/* MEM_SIZE would have to be aligned, but using 64000 here instead of
- * 65535 leaves some room for alignment...
- */
-#if MEM_SIZE > 64000l
-    typedef u32_t mem_size_t;
-#else
-    typedef u16_t mem_size_t;
-#endif                          /* MEM_SIZE > 64000 */
-
-#if MEM_USE_POOLS
-/** mem_init is not used when using pools instead of a heap */
-#define mem_init()
-/** mem_realloc is not used when using pools instead of a heap:
-    we can't free part of a pool element and don't want to copy the rest */
-#define mem_realloc(mem, size) (mem)
-#else                           /* MEM_USE_POOLS */
-/* lwIP alternative malloc */
-    void mem_init(void);
-    void *mem_realloc(void *mem, mem_size_t size);
-#endif                          /* MEM_USE_POOLS */
-    void *mem_malloc(mem_size_t size);
-    void *mem_calloc(mem_size_t count, mem_size_t size);
-    void mem_free(void *mem);
-#endif                          /* MEM_LIBC_MALLOC */
-
-#ifndef LWIP_MEM_ALIGN_SIZE
-#define LWIP_MEM_ALIGN_SIZE(size) (((size) + MEM_ALIGNMENT - 1) & ~(MEM_ALIGNMENT-1))
-#endif
-
-#ifndef LWIP_MEM_ALIGN
-#define LWIP_MEM_ALIGN(addr) ((void *)(((mem_ptr_t)(addr) + MEM_ALIGNMENT - 1) & ~(mem_ptr_t)(MEM_ALIGNMENT-1)))
-#endif
-
-#ifdef __cplusplus
-}
-#endif
-#endif                          /* __LWIP_MEM_H__ */
diff --git a/include/lwip/memp.h b/include/lwip/memp.h
deleted file mode 100644
index 9d54481..0000000
--- a/include/lwip/memp.h
+++ /dev/null
@@ -1,117 +0,0 @@
-/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Adam Dunkels <adam@sics.se>
- *
- */
-
-#ifndef __LWIP_MEMP_H__
-#define __LWIP_MEMP_H__
-
-#include "lwip/opt.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* Create the list of all memory pools managed by memp. MEMP_MAX represents a NULL pool at the end */
-    typedef enum {
-#define LWIP_MEMPOOL(name,num,size,desc)  MEMP_##name,
-#include "lwip/memp_std.h"
-        MEMP_MAX
-    } memp_t;
-
-#if MEM_USE_POOLS
-/* Use a helper type to get the start and end of the user "memory pools" for mem_malloc */
-    typedef enum {
-        /* Get the first (via:
-           MEMP_POOL_HELPER_START = ((u8_t) 1*MEMP_POOL_A + 0*MEMP_POOL_B + 0*MEMP_POOL_C + 0) */
-        MEMP_POOL_HELPER_FIRST = ((u8_t)
-#define LWIP_MEMPOOL(name,num,size,desc)
-#define LWIP_MALLOC_MEMPOOL_START 1
-#define LWIP_MALLOC_MEMPOOL(num, size) * MEMP_POOL_##size + 0
-#define LWIP_MALLOC_MEMPOOL_END
-#include "lwip/memp_std.h"
-          ),
-        /* Get the last (via:
-           MEMP_POOL_HELPER_END = ((u8_t) 0 + MEMP_POOL_A*0 + MEMP_POOL_B*0 + MEMP_POOL_C*1) */
-        MEMP_POOL_HELPER_LAST = ((u8_t)
-#define LWIP_MEMPOOL(name,num,size,desc)
-#define LWIP_MALLOC_MEMPOOL_START
-#define LWIP_MALLOC_MEMPOOL(num, size) 0 + MEMP_POOL_##size *
-#define LWIP_MALLOC_MEMPOOL_END 1
-#include "lwip/memp_std.h"
-          )
-    } memp_pool_helper_t;
-
-/* The actual start and stop values are here (cast them over)
-   We use this helper type and these defines so we can avoid using const memp_t values */
-#define MEMP_POOL_FIRST ((memp_t) MEMP_POOL_HELPER_FIRST)
-#define MEMP_POOL_LAST   ((memp_t) MEMP_POOL_HELPER_LAST)
-#endif                          /* MEM_USE_POOLS */
-
-#if MEMP_MEM_MALLOC || MEM_USE_POOLS
-    extern const u16_t memp_sizes[MEMP_MAX];
-#endif                          /* MEMP_MEM_MALLOC || MEM_USE_POOLS */
-
-#if MEMP_MEM_MALLOC
-
-#include "mem.h"
-
-#define memp_init()
-#define memp_initialize_pbuf_list()
-#define memp_malloc(type)     mem_malloc(memp_sizes[type])
-#define memp_free(type, mem)  mem_free(mem)
-
-#else                           /* MEMP_MEM_MALLOC */
-
-#if MEM_USE_POOLS
-/** This structure is used to save the pool one element came from. */
-    struct memp_malloc_helper {
-        memp_t poolnr;
-    };
-#endif                          /* MEM_USE_POOLS */
-
-    void memp_init(void);
-    u16_t memp_pbuf_peek(void);
-    void memp_initialize_pbuf_list(void);
-
-#if MEMP_OVERFLOW_CHECK
-    void *memp_malloc_fn(memp_t type, const char *file, const int line);
-#define memp_malloc(t) memp_malloc_fn((t), __FILE__, __LINE__)
-#else
-    void *memp_malloc(memp_t type);
-#endif
-    void memp_free(memp_t type, void *mem);
-
-#endif                          /* MEMP_MEM_MALLOC */
-
-#ifdef __cplusplus
-}
-#endif
-#endif                          /* __LWIP_MEMP_H__ */
diff --git a/include/lwip/memp_std.h b/include/lwip/memp_std.h
deleted file mode 100644
index 4bde61b..0000000
--- a/include/lwip/memp_std.h
+++ /dev/null
@@ -1,98 +0,0 @@
-/*
- * SETUP: Make sure we define everything we will need.
- *
- * We have create three types of pools:
- *   1) MEMPOOL - standard pools
- *   2) MALLOC_MEMPOOL - to be used by mem_malloc in mem.c
- *   3) PBUF_MEMPOOL - a mempool of pbuf's, so include space for the pbuf struct
- *
- * If the include'r doesn't require any special treatment of each of the types
- * above, then will declare #2 & #3 to be just standard mempools.
- */
-#ifndef LWIP_MALLOC_MEMPOOL
-/* This treats "malloc pools" just like any other pool.
-   The pools are a little bigger to provide 'size' as the amount of user data. */
-#define LWIP_MALLOC_MEMPOOL(num, size) LWIP_MEMPOOL(POOL_##size, num, (size + sizeof(struct memp_malloc_helper)), "MALLOC_"#size)
-#define LWIP_MALLOC_MEMPOOL_START
-#define LWIP_MALLOC_MEMPOOL_END
-#endif                          /* LWIP_MALLOC_MEMPOOL */
-
-#ifndef LWIP_PBUF_MEMPOOL
-/* This treats "pbuf pools" just like any other pool.
- * Allocates buffers for a pbuf struct AND a payload size */
-#define LWIP_PBUF_MEMPOOL(name, num, payload, desc) LWIP_MEMPOOL(name, num, (MEMP_ALIGN_SIZE(sizeof(struct pbuf)) + MEMP_ALIGN_SIZE(payload)), desc)
-#endif                          /* LWIP_PBUF_MEMPOOL */
-
-
-/*
- * A list of internal pools used by LWIP.
- *
- * LWIP_MEMPOOL(pool_name, number_elements, element_size, pool_description)
- *     creates a pool name MEMP_pool_name. description is used in stats.c
- */
-#if LWIP_RAW
-LWIP_MEMPOOL(RAW_PCB, MEMP_NUM_RAW_PCB, sizeof(struct raw_pcb), "RAW_PCB")
-#endif                          /* LWIP_RAW */
-#if LWIP_UDP
-  LWIP_MEMPOOL(UDP_PCB, MEMP_NUM_UDP_PCB, sizeof(struct udp_pcb), "UDP_PCB")
-#endif                          /* LWIP_UDP */
-#if LWIP_TCP
-  LWIP_MEMPOOL(TCP_PCB, MEMP_NUM_TCP_PCB, sizeof(struct tcp_pcb), "TCP_PCB")
-  LWIP_MEMPOOL(TCP_PCB_LISTEN, MEMP_NUM_TCP_PCB_LISTEN,
-             sizeof(struct tcp_pcb_listen), "TCP_PCB_LISTEN")
-  LWIP_MEMPOOL(TCP_SEG, MEMP_NUM_TCP_SEG, sizeof(struct tcp_seg), "TCP_SEG")
-#endif                          /* LWIP_TCP */
-#if IP_REASSEMBLY
-  LWIP_MEMPOOL(REASSDATA, MEMP_NUM_REASSDATA, sizeof(struct ip_reassdata),
-             "REASSDATA")
-#endif                          /* IP_REASSEMBLY */
-#if LWIP_NETCONN
-  LWIP_MEMPOOL(NETBUF, MEMP_NUM_NETBUF, sizeof(struct netbuf), "NETBUF")
-  LWIP_MEMPOOL(NETCONN, MEMP_NUM_NETCONN, sizeof(struct netconn), "NETCONN")
-#endif                          /* LWIP_NETCONN */
-#if NO_SYS==0
-  LWIP_MEMPOOL(TCPIP_MSG_API, MEMP_NUM_TCPIP_MSG_API, sizeof(struct tcpip_msg),
-             "TCPIP_MSG_API")
-  LWIP_MEMPOOL(TCPIP_MSG_INPKT, MEMP_NUM_TCPIP_MSG_INPKT,
-             sizeof(struct tcpip_msg), "TCPIP_MSG_INPKT")
-#endif                          /* NO_SYS==0 */
-#if ARP_QUEUEING
-  LWIP_MEMPOOL(ARP_QUEUE, MEMP_NUM_ARP_QUEUE, sizeof(struct etharp_q_entry),
-             "ARP_QUEUE")
-#endif                          /* ARP_QUEUEING */
-#if LWIP_IGMP
-  LWIP_MEMPOOL(IGMP_GROUP, MEMP_NUM_IGMP_GROUP, sizeof(struct igmp_group),
-             "IGMP_GROUP")
-#endif                          /* LWIP_IGMP */
-#if NO_SYS==0
-  LWIP_MEMPOOL(SYS_TIMEOUT, MEMP_NUM_SYS_TIMEOUT, sizeof(struct sys_timeo),
-             "SYS_TIMEOUT")
-#endif                          /* NO_SYS==0 */
-/*
- * A list of pools of pbuf's used by LWIP.
- *
- * LWIP_PBUF_MEMPOOL(pool_name, number_elements, pbuf_payload_size, pool_description)
- *     creates a pool name MEMP_pool_name. description is used in stats.c
- *     This allocates enough space for the pbuf struct and a payload.
- *     (Example: pbuf_payload_size=0 allocates only size for the struct)
- */
-  LWIP_PBUF_MEMPOOL(PBUF, MEMP_NUM_PBUF + PBUF_POOL_SIZE, 0, "PBUF_REF/ROM")
-  LWIP_MEMPOOL(PBUF_POOL, PBUF_POOL_SIZE, PBUF_POOL_BUFSIZE, "PBUF_POOL")
-
-
-/*
- * Allow for user-defined pools; this must be explicitly set in lwipopts.h
- * since the default is to NOT look for lwippools.h
- */
-#if MEMP_USE_CUSTOM_POOLS
-#include "lwippools.h"
-#endif                          /* MEMP_USE_CUSTOM_POOLS */
-/*
- * REQUIRED CLEANUP: Clear up so we don't get "multiply defined" error later
- * (#undef is ignored for something that is not defined)
- */
-#undef LWIP_MEMPOOL
-#undef LWIP_MALLOC_MEMPOOL
-#undef LWIP_MALLOC_MEMPOOL_START
-#undef LWIP_MALLOC_MEMPOOL_END
-#undef LWIP_PBUF_MEMPOOL
diff --git a/include/lwip/netbuf.h b/include/lwip/netbuf.h
deleted file mode 100644
index 59a14f6..0000000
--- a/include/lwip/netbuf.h
+++ /dev/null
@@ -1,73 +0,0 @@
-/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved. 
- * 
- * Redistribution and use in source and binary forms, with or without modification, 
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission. 
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- * 
- * Author: Adam Dunkels <adam@sics.se>
- *
- */
-#ifndef __LWIP_NETBUF_H__
-#define __LWIP_NETBUF_H__
-
-#include "lwip/opt.h"
-#include "lwip/pbuf.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-    struct netbuf {
-        struct pbuf *p, *ptr;
-        struct ip_addr *addr;
-        u16_t port;
-    };
-
-/* Network buffer functions: */
-    struct netbuf *netbuf_new(void);
-    void netbuf_delete(struct netbuf *buf);
-    void *netbuf_alloc(struct netbuf *buf, u16_t size);
-    void netbuf_free(struct netbuf *buf);
-    err_t netbuf_ref(struct netbuf *buf, const void *dataptr, u16_t size);
-    void netbuf_chain(struct netbuf *head, struct netbuf *tail);
-
-    u16_t netbuf_len(struct netbuf *buf);
-    err_t netbuf_data(struct netbuf *buf, void **dataptr, u16_t * len);
-    s8_t netbuf_next(struct netbuf *buf);
-    void netbuf_first(struct netbuf *buf);
-
-
-#define netbuf_copy_partial(buf, dataptr, len, offset) \
-  pbuf_copy_partial((buf)->p, (dataptr), (len), (offset))
-#define netbuf_copy(buf,dataptr,len) netbuf_copy_partial(buf, dataptr, len, 0)
-#define netbuf_take(buf, dataptr, len) pbuf_take((buf)->p, dataptr, len)
-#define netbuf_len(buf)              ((buf)->p->tot_len)
-#define netbuf_fromaddr(buf)         ((buf)->addr)
-#define netbuf_fromport(buf)         ((buf)->port)
-
-#ifdef __cplusplus
-}
-#endif
-#endif                          /* __LWIP_NETBUF_H__ */
diff --git a/include/lwip/netdb.h b/include/lwip/netdb.h
deleted file mode 100644
index 1df6865..0000000
--- a/include/lwip/netdb.h
+++ /dev/null
@@ -1,112 +0,0 @@
-/*
- * Redistribution and use in source and binary forms, with or without modification, 
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission. 
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- * 
- * Author: Simon Goldschmidt
- *
- */
-
-#include "lwip/opt.h"
-
-#if LWIP_DNS && LWIP_SOCKET
-
-#include <stddef.h>             /* for size_t */
-
-#include "lwip/sockets.h"
-
-/* some rarely used options */
-#ifndef LWIP_DNS_API_DECLARE_H_ERRNO
-#define LWIP_DNS_API_DECLARE_H_ERRNO 1
-#endif
-
-#ifndef LWIP_DNS_API_DEFINE_ERRORS
-#define LWIP_DNS_API_DEFINE_ERRORS 1
-#endif
-
-#ifndef LWIP_DNS_API_DECLARE_STRUCTS
-#define LWIP_DNS_API_DECLARE_STRUCTS 1
-#endif
-
-#if LWIP_DNS_API_DEFINE_ERRORS
-/** Errors used by the DNS API functions, h_errno can be one of them */
-#define EAI_NONAME      200
-#define EAI_SERVICE     201
-#define EAI_FAIL        202
-#define EAI_MEMORY      203
-#define EAI_FAMILY      204
-
-#define HOST_NOT_FOUND  210
-#define NO_DATA         211
-#define NO_RECOVERY     212
-#define TRY_AGAIN       213
-#define EAI_AGAIN	TRY_AGAIN
-#endif                          /* LWIP_DNS_API_DEFINE_ERRORS */
-
-#if LWIP_DNS_API_DECLARE_STRUCTS
-struct hostent {
-    char *h_name;               /* Official name of the host. */
-    char **h_aliases;           /* A pointer to an array of pointers to alternative host names,
-                                   terminated by a null pointer. */
-    int h_addrtype;             /* Address type. */
-    int h_length;               /* The length, in bytes, of the address. */
-    char **h_addr_list;         /* A pointer to an array of pointers to network addresses (in
-                                   network byte order) for the host, terminated by a null pointer. */
-#define h_addr h_addr_list[0]   /* for backward compatibility */
-};
-
-struct addrinfo {
-    int ai_flags;               /* Input flags. */
-    int ai_family;              /* Address family of socket. */
-    int ai_socktype;            /* Socket type. */
-    int ai_protocol;            /* Protocol of socket. */
-    socklen_t ai_addrlen;       /* Length of socket address. */
-    struct sockaddr *ai_addr;   /* Socket address of socket. */
-    char *ai_canonname;         /* Canonical name of service location. */
-    struct addrinfo *ai_next;   /* Pointer to next in list. */
-};
-#endif                          /* LWIP_DNS_API_DECLARE_STRUCTS */
-
-#if LWIP_DNS_API_DECLARE_H_ERRNO
-/* application accessable error code set by the DNS API functions */
-extern int h_errno;
-#endif                          /* LWIP_DNS_API_DECLARE_H_ERRNO */
-
-struct hostent *lwip_gethostbyname(const char *name);
-int lwip_gethostbyname_r(const char *name, struct hostent *ret, char *buf,
-                         size_t buflen, struct hostent **result, int *h_errnop);
-void lwip_freeaddrinfo(struct addrinfo *ai);
-int lwip_getaddrinfo(const char *nodename,
-                     const char *servname,
-                     const struct addrinfo *hints, struct addrinfo **res);
-
-#if LWIP_COMPAT_SOCKETS
-#define gethostbyname(name) lwip_gethostbyname(name)
-#define gethostbyname_r(name, ret, buf, buflen, result, h_errnop) \
-       lwip_gethostbyname_r(name, ret, buf, buflen, result, h_errnop)
-#define freeaddrinfo(addrinfo) lwip_freeaddrinfo(a)
-#define getaddrinfo(nodname, servname, hints, res) \
-       lwip_getaddrinfo(nodname, servname, hints, res)
-#endif                          /* LWIP_COMPAT_SOCKETS */
-
-#endif                          /* LWIP_DNS && LWIP_SOCKET */
diff --git a/include/lwip/netif.h b/include/lwip/netif.h
deleted file mode 100644
index c0ca6b1..0000000
--- a/include/lwip/netif.h
+++ /dev/null
@@ -1,268 +0,0 @@
-/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved. 
- * 
- * Redistribution and use in source and binary forms, with or without modification, 
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission. 
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- * 
- * Author: Adam Dunkels <adam@sics.se>
- *
- */
-#ifndef __LWIP_NETIF_H__
-#define __LWIP_NETIF_H__
-
-#include "lwip/opt.h"
-
-#define ENABLE_LOOPBACK (LWIP_NETIF_LOOPBACK || LWIP_HAVE_LOOPIF)
-
-#include "lwip/err.h"
-
-#include "lwip/ip_addr.h"
-
-#include "lwip/inet.h"
-#include "lwip/pbuf.h"
-#if LWIP_DHCP
-struct dhcp;
-#endif
-#if LWIP_AUTOIP
-struct autoip;
-#endif
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* Throughout this file, IP addresses are expected to be in
- * the same byte order as in IP_PCB. */
-
-/** must be the maximum of all used hardware address lengths
-    across all types of interfaces in use */
-#define NETIF_MAX_HWADDR_LEN 6U
-
-/** TODO: define the use (where, when, whom) of netif flags */
-
-/** whether the network interface is 'up'. this is
- * a software flag used to control whether this network
- * interface is enabled and processes traffic.
- */
-#define NETIF_FLAG_UP           0x01U
-/** if set, the netif has broadcast capability */
-#define NETIF_FLAG_BROADCAST    0x02U
-/** if set, the netif is one end of a point-to-point connection */
-#define NETIF_FLAG_POINTTOPOINT 0x04U
-/** if set, the interface is configured using DHCP */
-#define NETIF_FLAG_DHCP         0x08U
-/** if set, the interface has an active link
- *  (set by the network interface driver) */
-#define NETIF_FLAG_LINK_UP      0x10U
-/** if set, the netif is an device using ARP */
-#define NETIF_FLAG_ETHARP       0x20U
-/** if set, the netif has IGMP capability */
-#define NETIF_FLAG_IGMP         0x40U
-
-/** Generic data structure used for all lwIP network interfaces.
- *  The following fields should be filled in by the initialization
- *  function for the device driver: hwaddr_len, hwaddr[], mtu, flags */
-
-    struct netif {
-  /** pointer to next in linked list */
-        struct netif *next;
-
-  /** IP address configuration in network byte order */
-        struct ip_addr ip_addr;
-        struct ip_addr netmask;
-        struct ip_addr gw;
-
-  /** This function is called by the network device driver
-   *  to pass a packet up the TCP/IP stack. */
-         err_t(*input) (struct pbuf * p, struct netif * inp);
-  /** This function is called by the IP module when it wants
-   *  to send a packet on the interface. This function typically
-   *  first resolves the hardware address, then sends the packet. */
-         err_t(*output) (struct netif * netif, struct pbuf * p,
-                         struct ip_addr * ipaddr);
-  /** This function is called by the ARP module when it wants
-   *  to send a packet on the interface. This function outputs
-   *  the pbuf as-is on the link medium. */
-         err_t(*linkoutput) (struct netif * netif, struct pbuf * p);
-#if LWIP_NETIF_STATUS_CALLBACK
-  /** This function is called when the netif state is set to up or down
-   */
-        void (*status_callback) (struct netif * netif);
-#endif                          /* LWIP_NETIF_STATUS_CALLBACK */
-#if LWIP_NETIF_LINK_CALLBACK
-  /** This function is called when the netif link is set to up or down
-   */
-        void (*link_callback) (struct netif * netif);
-#endif                          /* LWIP_NETIF_LINK_CALLBACK */
-  /** This field can be set by the device driver and could point
-   *  to state information for the device. */
-        void *state;
-#if LWIP_DHCP
-  /** the DHCP client state information for this netif */
-        struct dhcp *dhcp;
-#endif                          /* LWIP_DHCP */
-#if LWIP_AUTOIP
-  /** the AutoIP client state information for this netif */
-        struct autoip *autoip;
-#endif
-#if LWIP_NETIF_HOSTNAME
-        /* the hostname for this netif, NULL is a valid value */
-        char *hostname;
-#endif                          /* LWIP_NETIF_HOSTNAME */
-  /** number of bytes used in hwaddr */
-        u8_t hwaddr_len;
-  /** link level hardware address of this interface */
-        u8_t hwaddr[NETIF_MAX_HWADDR_LEN];
-  /** maximum transfer unit (in bytes) */
-        u16_t mtu;
-  /** flags (see NETIF_FLAG_ above) */
-        u8_t flags;
-  /** descriptive abbreviation */
-        char name[2];
-  /** number of this interface */
-        u8_t num;
-#if LWIP_SNMP
-  /** link type (from "snmp_ifType" enum from snmp.h) */
-        u8_t link_type;
-  /** (estimate) link speed */
-        u32_t link_speed;
-  /** timestamp at last change made (up/down) */
-        u32_t ts;
-  /** counters */
-        u32_t ifinoctets;
-        u32_t ifinucastpkts;
-        u32_t ifinnucastpkts;
-        u32_t ifindiscards;
-        u32_t ifoutoctets;
-        u32_t ifoutucastpkts;
-        u32_t ifoutnucastpkts;
-        u32_t ifoutdiscards;
-#endif                          /* LWIP_SNMP */
-#if LWIP_IGMP
-        /* This function could be called to add or delete a entry in the multicast filter table of the ethernet MAC. */
-         err_t(*igmp_mac_filter) (struct netif * netif, struct ip_addr * group,
-                                  u8_t action);
-#endif                          /* LWIP_IGMP */
-#if LWIP_NETIF_HWADDRHINT
-        u8_t *addr_hint;
-#endif                          /* LWIP_NETIF_HWADDRHINT */
-#if ENABLE_LOOPBACK
-        /* List of packets to be queued for ourselves. */
-        struct pbuf *loop_first;
-        struct pbuf *loop_last;
-#if LWIP_LOOPBACK_MAX_PBUFS
-        u16_t loop_cnt_current;
-#endif                          /* LWIP_LOOPBACK_MAX_PBUFS */
-#endif                          /* ENABLE_LOOPBACK */
-    };
-
-#if LWIP_SNMP
-#define NETIF_INIT_SNMP(netif, type, speed) \
-  /* use "snmp_ifType" enum from snmp.h for "type", snmp_ifType_ethernet_csmacd by example */ \
-  netif->link_type = type;    \
-  /* your link speed here (units: bits per second) */  \
-  netif->link_speed = speed;  \
-  netif->ts = 0;              \
-  netif->ifinoctets = 0;      \
-  netif->ifinucastpkts = 0;   \
-  netif->ifinnucastpkts = 0;  \
-  netif->ifindiscards = 0;    \
-  netif->ifoutoctets = 0;     \
-  netif->ifoutucastpkts = 0;  \
-  netif->ifoutnucastpkts = 0; \
-  netif->ifoutdiscards = 0
-#else                           /* LWIP_SNMP */
-#define NETIF_INIT_SNMP(netif, type, speed)
-#endif                          /* LWIP_SNMP */
-
-
-/** The list of network interfaces. */
-    extern struct netif *netif_list;
-/** The default network interface. */
-    extern struct netif *netif_default;
-
-#define netif_init()            /* Compatibility define, not init needed. */
-
-    struct netif *netif_add(struct netif *netif, struct ip_addr *ipaddr,
-                            struct ip_addr *netmask, struct ip_addr *gw,
-                            void *state, err_t(*init) (struct netif * netif),
-                            err_t(*input) (struct pbuf * p,
-                                           struct netif * netif));
-
-    void
-     netif_set_addr(struct netif *netif, struct ip_addr *ipaddr,
-                    struct ip_addr *netmask, struct ip_addr *gw);
-    void netif_remove(struct netif *netif);
-
-/* Returns a network interface given its name. The name is of the form
-   "et0", where the first two letters are the "name" field in the
-   netif structure, and the digit is in the num field in the same
-   structure. */
-    struct netif *netif_find(char *name);
-
-    void netif_set_default(struct netif *netif);
-
-    void netif_set_ipaddr(struct netif *netif, struct ip_addr *ipaddr);
-    void netif_set_netmask(struct netif *netif, struct ip_addr *netmask);
-    void netif_set_gw(struct netif *netif, struct ip_addr *gw);
-
-    void netif_set_up(struct netif *netif);
-    void netif_set_down(struct netif *netif);
-    u8_t netif_is_up(struct netif *netif);
-
-#if LWIP_NETIF_STATUS_CALLBACK
-/*
- * Set callback to be called when interface is brought up/down
- */
-    void netif_set_status_callback(struct netif *netif,
-                                   void (*status_callback) (struct netif *
-                                                            netif));
-#endif                          /* LWIP_NETIF_STATUS_CALLBACK */
-
-#if LWIP_NETIF_LINK_CALLBACK
-    void netif_set_link_up(struct netif *netif);
-    void netif_set_link_down(struct netif *netif);
-    u8_t netif_is_link_up(struct netif *netif);
-/*
- * Set callback to be called when link is brought up/down
- */
-    void netif_set_link_callback(struct netif *netif,
-                                 void (*link_callback) (struct netif * netif));
-#endif                          /* LWIP_NETIF_LINK_CALLBACK */
-
-#ifdef __cplusplus
-}
-#endif
-#if ENABLE_LOOPBACK
-err_t netif_loop_output(struct netif *netif, struct pbuf *p,
-                        struct ip_addr *dest_ip);
-void netif_poll(struct netif *netif);
-
-#if !LWIP_NETIF_LOOPBACK_MULTITHREADING
-void netif_poll_all(void);
-#endif                          /* !LWIP_NETIF_LOOPBACK_MULTITHREADING */
-#endif                          /* ENABLE_LOOPBACK */
-
-#endif                          /* __LWIP_NETIF_H__ */
diff --git a/include/lwip/netifapi.h b/include/lwip/netifapi.h
deleted file mode 100644
index 4b8186b..0000000
--- a/include/lwip/netifapi.h
+++ /dev/null
@@ -1,99 +0,0 @@
-/*
- * Redistribution and use in source and binary forms, with or without modification, 
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission. 
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- * 
- */
-
-#ifndef __LWIP_NETIFAPI_H__
-#define __LWIP_NETIFAPI_H__
-
-#include "lwip/opt.h"
-
-#if LWIP_NETIF_API              /* don't build if not configured for use in lwipopts.h */
-
-#include "lwip/sys.h"
-#include "lwip/netif.h"
-#include "lwip/dhcp.h"
-#include "lwip/autoip.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-    struct netifapi_msg_msg {
-#if !LWIP_TCPIP_CORE_LOCKING
-        sys_sem_t sem;
-#endif                          /* !LWIP_TCPIP_CORE_LOCKING */
-        err_t err;
-        struct netif *netif;
-        union {
-            struct {
-                struct ip_addr *ipaddr;
-                struct ip_addr *netmask;
-                struct ip_addr *gw;
-                void *state;
-                 err_t(*init) (struct netif * netif);
-                 err_t(*input) (struct pbuf * p, struct netif * netif);
-            } add;
-            struct {
-                void (*voidfunc) (struct netif * netif);
-                 err_t(*errtfunc) (struct netif * netif);
-            } common;
-        } msg;
-    };
-
-    struct netifapi_msg {
-        void (*function) (struct netifapi_msg_msg * msg);
-        struct netifapi_msg_msg msg;
-    };
-
-
-/* API for application */
-    err_t netifapi_netif_add(struct netif *netif,
-                             struct ip_addr *ipaddr,
-                             struct ip_addr *netmask,
-                             struct ip_addr *gw,
-                             void *state,
-                             err_t(*init) (struct netif * netif),
-                             err_t(*input) (struct pbuf * p,
-                                            struct netif * netif));
-
-    err_t netifapi_netif_common(struct netif *netif,
-                                void (*voidfunc) (struct netif * netif),
-                                err_t(*errtfunc) (struct netif * netif));
-
-#define netifapi_netif_remove(n)      netifapi_netif_common(n, netif_remove, NULL)
-#define netifapi_netif_set_up(n)      netifapi_netif_common(n, netif_set_up, NULL)
-#define netifapi_netif_set_down(n)    netifapi_netif_common(n, netif_set_down, NULL)
-#define netifapi_netif_set_default(n) netifapi_netif_common(n, netif_set_default, NULL)
-#define netifapi_dhcp_start(n)        netifapi_netif_common(n, NULL, dhcp_start)
-#define netifapi_dhcp_stop(n)         netifapi_netif_common(n, dhcp_stop, NULL)
-#define netifapi_autoip_start(n)      netifapi_netif_common(n, NULL, autoip_start)
-#define netifapi_autoip_stop(n)       netifapi_netif_common(n, NULL, autoip_stop)
-
-#ifdef __cplusplus
-}
-#endif
-#endif                          /* LWIP_NETIF_API */
-#endif                          /* __LWIP_NETIFAPI_H__ */
diff --git a/include/lwip/opt.h b/include/lwip/opt.h
deleted file mode 100644
index 7a46d78..0000000
--- a/include/lwip/opt.h
+++ /dev/null
@@ -1,1822 +0,0 @@
-/**
- * @file
- *
- * lwIP Options Configuration
- */
-
-/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Adam Dunkels <adam@sics.se>
- *
- */
-#ifndef __LWIP_OPT_H__
-#define __LWIP_OPT_H__
-
-/*
- * Include user defined options first. Anything not defined in these files
- * will be set to standard values. Override anything you dont like!
- */
-#include "lwipopts.h"
-#include "lwip/debug.h"
-
-/*
-   -----------------------------------------------
-   ---------- Platform specific locking ----------
-   -----------------------------------------------
-*/
-
-/**
- * SYS_LIGHTWEIGHT_PROT==1: if you want inter-task protection for certain
- * critical regions during buffer allocation, deallocation and memory
- * allocation and deallocation.
- */
-#ifndef SYS_LIGHTWEIGHT_PROT
-#define SYS_LIGHTWEIGHT_PROT            0
-#endif
-
-/**
- * NO_SYS==1: Provides VERY minimal functionality. Otherwise,
- * use lwIP facilities.
- */
-#ifndef NO_SYS
-#define NO_SYS                          0
-#endif
-
-/**
- * MEMCPY: override this if you have a faster implementation at hand than the
- * one included in your C library
- */
-#ifndef MEMCPY
-#define MEMCPY(dst,src,len)             memcpy(dst,src,len)
-#endif
-
-/**
- * SMEMCPY: override this with care! Some compilers (e.g. gcc) can inline a
- * call to memcpy() if the length is known at compile time and is small.
- */
-#ifndef SMEMCPY
-#define SMEMCPY(dst,src,len)            memcpy(dst,src,len)
-#endif
-
-/*
-   ------------------------------------
-   ---------- Memory options ----------
-   ------------------------------------
-*/
-/**
- * MEM_LIBC_MALLOC==1: Use malloc/free/realloc provided by your C-library
- * instead of the lwip internal allocator. Can save code size if you
- * already use it.
- */
-#ifndef MEM_LIBC_MALLOC
-#define MEM_LIBC_MALLOC                 0
-#endif
-
-/**
-* MEMP_MEM_MALLOC==1: Use mem_malloc/mem_free instead of the lwip pool allocator.
-* Especially useful with MEM_LIBC_MALLOC but handle with care regarding execution
-* speed and usage from interrupts!
-*/
-#ifndef MEMP_MEM_MALLOC
-#define MEMP_MEM_MALLOC                 0
-#endif
-
-/**
- * MEM_ALIGNMENT: should be set to the alignment of the CPU
- *    4 byte alignment -> #define MEM_ALIGNMENT 4
- *    2 byte alignment -> #define MEM_ALIGNMENT 2
- */
-#ifndef MEM_ALIGNMENT
-#define MEM_ALIGNMENT                   4
-#endif
-
-/**
- * MEM_SIZE: the size of the heap memory. If the application will send
- * a lot of data that needs to be copied, this should be set high.
- */
-#ifndef MEM_SIZE
-#define MEM_SIZE                        (20*1024*1024)
-#endif
-
-/**
- * MEMP_OVERFLOW_CHECK: memp overflow protection reserves a configurable
- * amount of bytes before and after each memp element in every pool and fills
- * it with a prominent default value.
- *    MEMP_OVERFLOW_CHECK == 0 no checking
- *    MEMP_OVERFLOW_CHECK == 1 checks each element when it is freed
- *    MEMP_OVERFLOW_CHECK >= 2 checks each element in every pool every time
- *      memp_malloc() or memp_free() is called (useful but slow!)
- */
-#ifndef MEMP_OVERFLOW_CHECK
-#define MEMP_OVERFLOW_CHECK             0
-#endif
-
-/**
- * MEMP_SANITY_CHECK==1: run a sanity check after each memp_free() to make
- * sure that there are no cycles in the linked lists.
- */
-#ifndef MEMP_SANITY_CHECK
-#define MEMP_SANITY_CHECK               0
-#endif
-
-/**
- * MEM_USE_POOLS==1: Use an alternative to malloc() by allocating from a set
- * of memory pools of various sizes. When mem_malloc is called, an element of
- * the smallest pool that can provide the length needed is returned.
- * To use this, MEMP_USE_CUSTOM_POOLS also has to be enabled.
- */
-#ifndef MEM_USE_POOLS
-#define MEM_USE_POOLS                   0
-#endif
-
-/**
- * MEM_USE_POOLS_TRY_BIGGER_POOL==1: if one malloc-pool is empty, try the next
- * bigger pool - WARNING: THIS MIGHT WASTE MEMORY but it can make a system more
- * reliable. */
-#ifndef MEM_USE_POOLS_TRY_BIGGER_POOL
-#define MEM_USE_POOLS_TRY_BIGGER_POOL   0
-#endif
-
-/**
- * MEMP_USE_CUSTOM_POOLS==1: whether to include a user file lwippools.h
- * that defines additional pools beyond the "standard" ones required
- * by lwIP. If you set this to 1, you must have lwippools.h in your
- * inlude path somewhere.
- */
-#ifndef MEMP_USE_CUSTOM_POOLS
-#define MEMP_USE_CUSTOM_POOLS           0
-#endif
-
-/**
- * Set this to 1 if you want to free PBUF_RAM pbufs (or call mem_free()) from
- * interrupt context (or another context that doesn't allow waiting for a
- * semaphore).
- * If set to 1, mem_malloc will be protected by a semaphore and SYS_ARCH_PROTECT,
- * while mem_free will only use SYS_ARCH_PROTECT. mem_malloc SYS_ARCH_UNPROTECTs
- * with each loop so that mem_free can run.
- *
- * ATTENTION: As you can see from the above description, this leads to dis-/
- * enabling interrupts often, which can be slow! Also, on low memory, mem_malloc
- * can need longer.
- *
- * If you don't want that, at least for NO_SYS=0, you can still use the following
- * functions to enqueue a deallocation call which then runs in the tcpip_thread
- * context:
- * - pbuf_free_callback(p);
- * - mem_free_callback(m);
- */
-#ifndef LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
-#define LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT 0
-#endif
-
-/*
-   ------------------------------------------------
-   ---------- Internal Memory Pool Sizes ----------
-   ------------------------------------------------
-*/
-/**
- * MEMP_NUM_PBUF: the number of memp struct pbufs (used for PBUF_ROM and PBUF_REF).
- * If the application sends a lot of data out of ROM (or other static memory),
- * this should be set high.
- */
-#ifndef MEMP_NUM_PBUF
-#define MEMP_NUM_PBUF                   8192
-#endif
-
-/**
- * MEMP_NUM_RAW_PCB: Number of raw connection PCBs
- * (requires the LWIP_RAW option)
- */
-#ifndef MEMP_NUM_RAW_PCB
-#define MEMP_NUM_RAW_PCB                4
-#endif
-
-/**
- * MEMP_NUM_UDP_PCB: the number of UDP protocol control blocks. One
- * per active UDP "connection".
- * (requires the LWIP_UDP option)
- */
-#ifndef MEMP_NUM_UDP_PCB
-#define MEMP_NUM_UDP_PCB                4
-#endif
-
-/**
- * MEMP_NUM_TCP_PCB: the number of simulatenously active TCP connections.
- * (requires the LWIP_TCP option)
- */
-#ifndef MEMP_NUM_TCP_PCB
-#define MEMP_NUM_TCP_PCB                5
-#endif
-
-/**
- * MEMP_NUM_TCP_PCB_LISTEN: the number of listening TCP connections.
- * (requires the LWIP_TCP option)
- */
-#ifndef MEMP_NUM_TCP_PCB_LISTEN
-#define MEMP_NUM_TCP_PCB_LISTEN         18
-#endif
-
-/**
- * MEMP_NUM_TCP_SEG: the number of simultaneously queued TCP segments.
- * (requires the LWIP_TCP option)
- */
-#ifndef MEMP_NUM_TCP_SEG
-#define MEMP_NUM_TCP_SEG                16
-#endif
-
-/**
- * MEMP_NUM_REASSDATA: the number of simultaneously IP packets queued for
- * reassembly (whole packets, not fragments!)
- */
-#ifndef MEMP_NUM_REASSDATA
-#define MEMP_NUM_REASSDATA              5
-#endif
-
-/**
- * MEMP_NUM_ARP_QUEUE: the number of simulateously queued outgoing
- * packets (pbufs) that are waiting for an ARP request (to resolve
- * their destination address) to finish.
- * (requires the ARP_QUEUEING option)
- */
-#ifndef MEMP_NUM_ARP_QUEUE
-#define MEMP_NUM_ARP_QUEUE              30
-#endif
-
-/**
- * MEMP_NUM_IGMP_GROUP: The number of multicast groups whose network interfaces
- * can be members et the same time (one per netif - allsystems group -, plus one
- * per netif membership).
- * (requires the LWIP_IGMP option)
- */
-#ifndef MEMP_NUM_IGMP_GROUP
-#define MEMP_NUM_IGMP_GROUP             8
-#endif
-
-/**
- * MEMP_NUM_SYS_TIMEOUT: the number of simulateously active timeouts.
- * (requires NO_SYS==0)
- */
-#ifndef MEMP_NUM_SYS_TIMEOUT
-#define MEMP_NUM_SYS_TIMEOUT            8
-#endif
-
-/**
- * MEMP_NUM_NETBUF: the number of struct netbufs.
- * (only needed if you use the sequential API, like api_lib.c)
- */
-#ifndef MEMP_NUM_NETBUF
-#define MEMP_NUM_NETBUF                 12
-#endif
-
-/**
- * MEMP_NUM_NETCONN: the number of struct netconns.
- * (only needed if you use the sequential API, like api_lib.c)
- */
-#ifndef MEMP_NUM_NETCONN
-#define MEMP_NUM_NETCONN                24
-#endif
-
-/**
- * MEMP_NUM_TCPIP_MSG_API: the number of struct tcpip_msg, which are used
- * for callback/timeout API communication.
- * (only needed if you use tcpip.c)
- */
-#ifndef MEMP_NUM_TCPIP_MSG_API
-#define MEMP_NUM_TCPIP_MSG_API          38
-#endif
-
-/**
- * MEMP_NUM_TCPIP_MSG_INPKT: the number of struct tcpip_msg, which are used
- * for incoming packets.
- * (only needed if you use tcpip.c)
- */
-#ifndef MEMP_NUM_TCPIP_MSG_INPKT
-#define MEMP_NUM_TCPIP_MSG_INPKT        38
-#endif
-
-/**
- * PBUF_POOL_SIZE: the number of buffers in the pbuf pool.
- */
-#ifndef PBUF_POOL_SIZE
-#define PBUF_POOL_SIZE                  65535
-#endif
-
-/*
-   ---------------------------------
-   ---------- ARP options ----------
-   ---------------------------------
-*/
-/**
- * LWIP_ARP==1: Enable ARP functionality.
- */
-#ifndef LWIP_ARP
-#define LWIP_ARP                        1
-#endif
-
-/**
- * ARP_TABLE_SIZE: Number of active MAC-IP address pairs cached.
- */
-#ifndef ARP_TABLE_SIZE
-#define ARP_TABLE_SIZE                  10
-#endif
-
-/**
- * ARP_QUEUEING==1: Outgoing packets are queued during hardware address
- * resolution.
- */
-#ifndef ARP_QUEUEING
-#define ARP_QUEUEING                    1
-#endif
-
-/**
- * ETHARP_TRUST_IP_MAC==1: Incoming IP packets cause the ARP table to be
- * updated with the source MAC and IP addresses supplied in the packet.
- * You may want to disable this if you do not trust LAN peers to have the
- * correct addresses, or as a limited approach to attempt to handle
- * spoofing. If disabled, lwIP will need to make a new ARP request if
- * the peer is not already in the ARP table, adding a little latency.
- */
-#ifndef ETHARP_TRUST_IP_MAC
-#define ETHARP_TRUST_IP_MAC             1
-#endif
-
-/*
-   --------------------------------
-   ---------- IP options ----------
-   --------------------------------
-*/
-/**
- * IP_FORWARD==1: Enables the ability to forward IP packets across network
- * interfaces. If you are going to run lwIP on a device with only one network
- * interface, define this to 0.
- */
-#ifndef IP_FORWARD
-#define IP_FORWARD                      0
-#endif
-
-/**
- * IP_OPTIONS_ALLOWED: Defines the behavior for IP options.
- *      IP_OPTIONS_ALLOWED==0: All packets with IP options are dropped.
- *      IP_OPTIONS_ALLOWED==1: IP options are allowed (but not parsed).
- */
-#ifndef IP_OPTIONS_ALLOWED
-#define IP_OPTIONS_ALLOWED              1
-#endif
-
-/**
- * IP_REASSEMBLY==1: Reassemble incoming fragmented IP packets. Note that
- * this option does not affect outgoing packet sizes, which can be controlled
- * via IP_FRAG.
- */
-#ifndef IP_REASSEMBLY
-#define IP_REASSEMBLY                   1
-#endif
-
-/**
- * IP_FRAG==1: Fragment outgoing IP packets if their size exceeds MTU. Note
- * that this option does not affect incoming packet sizes, which can be
- * controlled via IP_REASSEMBLY.
- */
-#ifndef IP_FRAG
-#define IP_FRAG                         1
-#endif
-
-/**
- * IP_REASS_MAXAGE: Maximum time (in multiples of IP_TMR_INTERVAL - so seconds, normally)
- * a fragmented IP packet waits for all fragments to arrive. If not all fragments arrived
- * in this time, the whole packet is discarded.
- */
-#ifndef IP_REASS_MAXAGE
-#define IP_REASS_MAXAGE                 3
-#endif
-
-/**
- * IP_REASS_MAX_PBUFS: Total maximum amount of pbufs waiting to be reassembled.
- * Since the received pbufs are enqueued, be sure to configure
- * PBUF_POOL_SIZE > IP_REASS_MAX_PBUFS so that the stack is still able to receive
- * packets even if the maximum amount of fragments is enqueued for reassembly!
- */
-#ifndef IP_REASS_MAX_PBUFS
-#define IP_REASS_MAX_PBUFS              10
-#endif
-
-/**
- * IP_FRAG_USES_STATIC_BUF==1: Use a static MTU-sized buffer for IP
- * fragmentation. Otherwise pbufs are allocated and reference the original
- * packet data to be fragmented.
- */
-// FIXME: commented out so that code will not use PBUF_REF
-//#ifndef IP_FRAG_USES_STATIC_BUF
-//#define IP_FRAG_USES_STATIC_BUF         1
-//#endif
-
-/**
- * IP_FRAG_MAX_MTU: Assumed max MTU on any interface for IP frag buffer
- * (requires IP_FRAG_USES_STATIC_BUF==1)
- */
-#if IP_FRAG_USES_STATIC_BUF && !defined(IP_FRAG_MAX_MTU)
-#define IP_FRAG_MAX_MTU                 1500
-#endif
-
-/**
- * IP_DEFAULT_TTL: Default value for Time-To-Live used by transport layers.
- */
-#ifndef IP_DEFAULT_TTL
-#define IP_DEFAULT_TTL                  255
-#endif
-
-/**
- * IP_SOF_BROADCAST=1: Use the SOF_BROADCAST field to enable broadcast
- * filter per pcb on udp and raw send operations. To enable broadcast filter
- * on recv operations, you also have to set IP_SOF_BROADCAST_RECV=1.
- */
-#ifndef IP_SOF_BROADCAST
-#define IP_SOF_BROADCAST                0
-#endif
-
-/**
- * IP_SOF_BROADCAST_RECV (requires IP_SOF_BROADCAST=1) enable the broadcast
- * filter on recv operations.
- */
-#ifndef IP_SOF_BROADCAST_RECV
-#define IP_SOF_BROADCAST_RECV           0
-#endif
-
-/*
-   ----------------------------------
-   ---------- ICMP options ----------
-   ----------------------------------
-*/
-/**
- * LWIP_ICMP==1: Enable ICMP module inside the IP stack.
- * Be careful, disable that make your product non-compliant to RFC1122
- */
-#ifndef LWIP_ICMP
-#define LWIP_ICMP                       1
-#endif
-
-/**
- * ICMP_TTL: Default value for Time-To-Live used by ICMP packets.
- */
-#ifndef ICMP_TTL
-#define ICMP_TTL                       (IP_DEFAULT_TTL)
-#endif
-
-/**
- * LWIP_BROADCAST_PING==1: respond to broadcast pings (default is unicast only)
- */
-#ifndef LWIP_BROADCAST_PING
-#define LWIP_BROADCAST_PING             0
-#endif
-
-/**
- * LWIP_MULTICAST_PING==1: respond to multicast pings (default is unicast only)
- */
-#ifndef LWIP_MULTICAST_PING
-#define LWIP_MULTICAST_PING             0
-#endif
-
-/*
-   ---------------------------------
-   ---------- RAW options ----------
-   ---------------------------------
-*/
-/**
- * LWIP_RAW==1: Enable application layer to hook into the IP layer itself.
- */
-#ifndef LWIP_RAW
-#define LWIP_RAW                        1
-#endif
-
-/**
- * LWIP_RAW==1: Enable application layer to hook into the IP layer itself.
- */
-#ifndef RAW_TTL
-#define RAW_TTL                        (IP_DEFAULT_TTL)
-#endif
-
-/*
-   ----------------------------------
-   ---------- DHCP options ----------
-   ----------------------------------
-*/
-/**
- * LWIP_DHCP==1: Enable DHCP module.
- */
-#ifndef LWIP_DHCP
-#define LWIP_DHCP                       0
-#endif
-
-/**
- * DHCP_DOES_ARP_CHECK==1: Do an ARP check on the offered address.
- */
-#ifndef DHCP_DOES_ARP_CHECK
-#define DHCP_DOES_ARP_CHECK             ((LWIP_DHCP) && (LWIP_ARP))
-#endif
-
-/*
-   ------------------------------------
-   ---------- AUTOIP options ----------
-   ------------------------------------
-*/
-/**
- * LWIP_AUTOIP==1: Enable AUTOIP module.
- */
-#ifndef LWIP_AUTOIP
-#define LWIP_AUTOIP                     0
-#endif
-
-/**
- * LWIP_DHCP_AUTOIP_COOP==1: Allow DHCP and AUTOIP to be both enabled on
- * the same interface at the same time.
- */
-#ifndef LWIP_DHCP_AUTOIP_COOP
-#define LWIP_DHCP_AUTOIP_COOP           0
-#endif
-
-/**
- * LWIP_DHCP_AUTOIP_COOP_TRIES: Set to the number of DHCP DISCOVER probes
- * that should be sent before falling back on AUTOIP. This can be set
- * as low as 1 to get an AutoIP address very quickly, but you should
- * be prepared to handle a changing IP address when DHCP overrides
- * AutoIP.
- */
-#ifndef LWIP_DHCP_AUTOIP_COOP_TRIES
-#define LWIP_DHCP_AUTOIP_COOP_TRIES     9
-#endif
-
-/*
-   ----------------------------------
-   ---------- SNMP options ----------
-   ----------------------------------
-*/
-/**
- * LWIP_SNMP==1: Turn on SNMP module. UDP must be available for SNMP
- * transport.
- */
-#ifndef LWIP_SNMP
-#define LWIP_SNMP                       0
-#endif
-
-/**
- * SNMP_CONCURRENT_REQUESTS: Number of concurrent requests the module will
- * allow. At least one request buffer is required.
- */
-#ifndef SNMP_CONCURRENT_REQUESTS
-#define SNMP_CONCURRENT_REQUESTS        1
-#endif
-
-/**
- * SNMP_TRAP_DESTINATIONS: Number of trap destinations. At least one trap
- * destination is required
- */
-#ifndef SNMP_TRAP_DESTINATIONS
-#define SNMP_TRAP_DESTINATIONS          1
-#endif
-
-/**
- * SNMP_PRIVATE_MIB:
- */
-#ifndef SNMP_PRIVATE_MIB
-#define SNMP_PRIVATE_MIB                0
-#endif
-
-/**
- * Only allow SNMP write actions that are 'safe' (e.g. disabeling netifs is not
- * a safe action and disabled when SNMP_SAFE_REQUESTS = 1).
- * Unsafe requests are disabled by default!
- */
-#ifndef SNMP_SAFE_REQUESTS
-#define SNMP_SAFE_REQUESTS              1
-#endif
-
-/*
-   ----------------------------------
-   ---------- IGMP options ----------
-   ----------------------------------
-*/
-/**
- * LWIP_IGMP==1: Turn on IGMP module.
- */
-#ifndef LWIP_IGMP
-#define LWIP_IGMP                       0
-#endif
-
-/*
-   ----------------------------------
-   ---------- DNS options -----------
-   ----------------------------------
-*/
-/**
- * LWIP_DNS==1: Turn on DNS module. UDP must be available for DNS
- * transport.
- */
-#ifndef LWIP_DNS
-#define LWIP_DNS                        0
-#endif
-
-/** DNS maximum number of entries to maintain locally. */
-#ifndef DNS_TABLE_SIZE
-#define DNS_TABLE_SIZE                  4
-#endif
-
-/** DNS maximum host name length supported in the name table. */
-#ifndef DNS_MAX_NAME_LENGTH
-#define DNS_MAX_NAME_LENGTH             256
-#endif
-
-/** The maximum of DNS servers */
-#ifndef DNS_MAX_SERVERS
-#define DNS_MAX_SERVERS                 2
-#endif
-
-/** DNS do a name checking between the query and the response. */
-#ifndef DNS_DOES_NAME_CHECK
-#define DNS_DOES_NAME_CHECK             1
-#endif
-
-/** DNS use a local buffer if DNS_USES_STATIC_BUF=0, a static one if
-    DNS_USES_STATIC_BUF=1, or a dynamic one if DNS_USES_STATIC_BUF=2.
-    The buffer will be of size DNS_MSG_SIZE */
-#ifndef DNS_USES_STATIC_BUF
-#define DNS_USES_STATIC_BUF             1
-#endif
-
-/** DNS message max. size. Default value is RFC compliant. */
-#ifndef DNS_MSG_SIZE
-#define DNS_MSG_SIZE                    512
-#endif
-
-/** DNS_LOCAL_HOSTLIST: Implements a local host-to-address list. If enabled,
- *  you have to define
- *    #define DNS_LOCAL_HOSTLIST_INIT {{"host1", 0x123}, {"host2", 0x234}}
- *  (an array of structs name/address, where address is an u32_t in network
- *  byte order).
- *
- *  Instead, you can also use an external function:
- *  #define DNS_LOOKUP_LOCAL_EXTERN(x) extern u32_t my_lookup_function(const char *name)
- *  that returns the IP address or INADDR_NONE if not found.
- */
-#ifndef DNS_LOCAL_HOSTLIST
-#define DNS_LOCAL_HOSTLIST              0
-#endif                          /* DNS_LOCAL_HOSTLIST */
-
-/** If this is turned on, the local host-list can be dynamically changed
- *  at runtime. */
-#ifndef DNS_LOCAL_HOSTLIST_IS_DYNAMIC
-#define DNS_LOCAL_HOSTLIST_IS_DYNAMIC   0
-#endif                          /* DNS_LOCAL_HOSTLIST_IS_DYNAMIC */
-
-/*
-   ---------------------------------
-   ---------- UDP options ----------
-   ---------------------------------
-*/
-/**
- * LWIP_UDP==1: Turn on UDP.
- */
-#ifndef LWIP_UDP
-#define LWIP_UDP                        1
-#endif
-
-/**
- * LWIP_UDPLITE==1: Turn on UDP-Lite. (Requires LWIP_UDP)
- */
-#ifndef LWIP_UDPLITE
-#define LWIP_UDPLITE                    0
-#endif
-
-/**
- * UDP_TTL: Default Time-To-Live value.
- */
-#ifndef UDP_TTL
-#define UDP_TTL                         (IP_DEFAULT_TTL)
-#endif
-
-/*
-   ---------------------------------
-   ---------- TCP options ----------
-   ---------------------------------
-*/
-/**
- * LWIP_TCP==1: Turn on TCP.
- */
-#ifndef LWIP_TCP
-#define LWIP_TCP                        1
-#endif
-
-/**
- * TCP_TTL: Default Time-To-Live value.
- */
-#ifndef TCP_TTL
-#define TCP_TTL                         (IP_DEFAULT_TTL)
-#endif
-
-/**
- * TCP_WND: The size of a TCP window.  This must be at least
- * (2 * TCP_MSS) for things to work well
- */
-#ifndef TCP_WND
-#define TCP_WND                         2048
-#endif
-
-/**
- * TCP_MAXRTX: Maximum number of retransmissions of data segments.
- */
-#ifndef TCP_MAXRTX
-#define TCP_MAXRTX                      12
-#endif
-
-/**
- * TCP_SYNMAXRTX: Maximum number of retransmissions of SYN segments.
- */
-#ifndef TCP_SYNMAXRTX
-#define TCP_SYNMAXRTX                   6
-#endif
-
-/**
- * TCP_QUEUE_OOSEQ==1: TCP will queue segments that arrive out of order.
- * Define to 0 if your device is low on memory.
- */
-#ifndef TCP_QUEUE_OOSEQ
-#define TCP_QUEUE_OOSEQ                 (LWIP_TCP)
-#endif
-
-/**
- * TCP_MSS: TCP Maximum segment size. (default is 128, a *very*
- * conservative default.)
- * For the receive side, this MSS is advertised to the remote side
- * when opening a connection. For the transmit size, this MSS sets
- * an upper limit on the MSS advertised by the remote host.
- */
-#ifndef TCP_MSS
-#define TCP_MSS                         128
-#endif
-
-/**
- * TCP_CALCULATE_EFF_SEND_MSS: "The maximum size of a segment that TCP really
- * sends, the 'effective send MSS,' MUST be the smaller of the send MSS (which
- * reflects the available reassembly buffer size at the remote host) and the
- * largest size permitted by the IP layer" (RFC 1122)
- * Setting this to 1 enables code that checks TCP_MSS against the MTU of the
- * netif used for a connection and limits the MSS if it would be too big otherwise.
- */
-#ifndef TCP_CALCULATE_EFF_SEND_MSS
-#define TCP_CALCULATE_EFF_SEND_MSS      1
-#endif
-
-
-/**
- * TCP_SND_BUF: TCP sender buffer space (bytes).
- */
-#ifndef TCP_SND_BUF
-#define TCP_SND_BUF                     256
-#endif
-
-/**
- * TCP_SND_QUEUELEN: TCP sender buffer space (pbufs). This must be at least
- * as much as (2 * TCP_SND_BUF/TCP_MSS) for things to work.
- */
-#ifndef TCP_SND_QUEUELEN
-#define TCP_SND_QUEUELEN                (4 * (TCP_SND_BUF/TCP_MSS))
-#endif
-
-/**
- * TCP_SNDLOWAT: TCP writable space (bytes). This must be less than or equal
- * to TCP_SND_BUF. It is the amount of space which must be available in the
- * TCP snd_buf for select to return writable.
- */
-#ifndef TCP_SNDLOWAT
-#define TCP_SNDLOWAT                    (TCP_SND_BUF/2)
-#endif
-
-/**
- * TCP_LISTEN_BACKLOG: Enable the backlog option for tcp listen pcb.
- */
-#ifndef TCP_LISTEN_BACKLOG
-#define TCP_LISTEN_BACKLOG              0
-#endif
-
-/**
- * The maximum allowed backlog for TCP listen netconns.
- * This backlog is used unless another is explicitly specified.
- * 0xff is the maximum (u8_t).
- */
-#ifndef TCP_DEFAULT_LISTEN_BACKLOG
-#define TCP_DEFAULT_LISTEN_BACKLOG      0xff
-#endif
-
-/**
- * LWIP_TCP_TIMESTAMPS==1: support the TCP timestamp option.
- */
-#ifndef LWIP_TCP_TIMESTAMPS
-#define LWIP_TCP_TIMESTAMPS             0
-#endif
-
-/**
- * TCP_WND_UPDATE_THRESHOLD: difference in window to trigger an
- * explicit window update
- */
-#ifndef TCP_WND_UPDATE_THRESHOLD
-#define TCP_WND_UPDATE_THRESHOLD   (TCP_WND / 4)
-#endif
-
-/**
- * LWIP_EVENT_API and LWIP_CALLBACK_API: Only one of these should be set to 1.
- *     LWIP_EVENT_API==1: The user defines lwip_tcp_event() to receive all
- *         events (accept, sent, etc) that happen in the system.
- *     LWIP_CALLBACK_API==1: The PCB callback function is called directly
- *         for the event.
- */
-#ifndef LWIP_EVENT_API
-#define LWIP_EVENT_API                  0
-#define LWIP_CALLBACK_API               1
-#else
-#define LWIP_EVENT_API                  1
-#define LWIP_CALLBACK_API               0
-#endif
-
-
-/*
-   ----------------------------------
-   ---------- Pbuf options ----------
-   ----------------------------------
-*/
-/**
- * PBUF_LINK_HLEN: the number of bytes that should be allocated for a
- * link level header. The default is 14, the standard value for
- * Ethernet.
- */
-#ifndef PBUF_LINK_HLEN
-#define PBUF_LINK_HLEN                  14
-#endif
-
-/**
- * PBUF_POOL_BUFSIZE: the size of each pbuf in the pbuf pool. The default is
- * designed to accomodate single full size TCP frame in one pbuf, including
- * TCP_MSS, IP header, and link header.
- */
-#ifndef PBUF_POOL_BUFSIZE
-#define PBUF_POOL_BUFSIZE               LWIP_MEM_ALIGN_SIZE(TCP_MSS+40+PBUF_LINK_HLEN)
-#endif
-
-/*
-   ------------------------------------------------
-   ---------- Network Interfaces options ----------
-   ------------------------------------------------
-*/
-/**
- * LWIP_NETIF_HOSTNAME==1: use DHCP_OPTION_HOSTNAME with netif's hostname
- * field.
- */
-#ifndef LWIP_NETIF_HOSTNAME
-#define LWIP_NETIF_HOSTNAME             0
-#endif
-
-/**
- * LWIP_NETIF_API==1: Support netif api (in netifapi.c)
- */
-#ifndef LWIP_NETIF_API
-#define LWIP_NETIF_API                  0
-#endif
-
-/**
- * LWIP_NETIF_STATUS_CALLBACK==1: Support a callback function whenever an interface
- * changes its up/down status (i.e., due to DHCP IP acquistion)
- */
-#ifndef LWIP_NETIF_STATUS_CALLBACK
-#define LWIP_NETIF_STATUS_CALLBACK      0
-#endif
-
-/**
- * LWIP_NETIF_LINK_CALLBACK==1: Support a callback function from an interface
- * whenever the link changes (i.e., link down)
- */
-#ifndef LWIP_NETIF_LINK_CALLBACK
-#define LWIP_NETIF_LINK_CALLBACK        0
-#endif
-
-/**
- * LWIP_NETIF_HWADDRHINT==1: Cache link-layer-address hints (e.g. table
- * indices) in struct netif. TCP and UDP can make use of this to prevent
- * scanning the ARP table for every sent packet. While this is faster for big
- * ARP tables or many concurrent connections, it might be counterproductive
- * if you have a tiny ARP table or if there never are concurrent connections.
- */
-#ifndef LWIP_NETIF_HWADDRHINT
-#define LWIP_NETIF_HWADDRHINT           0
-#endif
-
-/**
- * LWIP_NETIF_LOOPBACK==1: Support sending packets with a destination IP
- * address equal to the netif IP address, looping them back up the stack.
- */
-#ifndef LWIP_NETIF_LOOPBACK
-#define LWIP_NETIF_LOOPBACK             0
-#endif
-
-/**
- * LWIP_LOOPBACK_MAX_PBUFS: Maximum number of pbufs on queue for loopback
- * sending for each netif (0 = disabled)
- */
-#ifndef LWIP_LOOPBACK_MAX_PBUFS
-#define LWIP_LOOPBACK_MAX_PBUFS         0
-#endif
-
-/**
- * LWIP_NETIF_LOOPBACK_MULTITHREADING: Indicates whether threading is enabled in
- * the system, as netifs must change how they behave depending on this setting
- * for the LWIP_NETIF_LOOPBACK option to work.
- * Setting this is needed to avoid reentering non-reentrant functions like
- * tcp_input().
- *    LWIP_NETIF_LOOPBACK_MULTITHREADING==1: Indicates that the user is using a
- *       multithreaded environment like tcpip.c. In this case, netif->input()
- *       is called directly.
- *    LWIP_NETIF_LOOPBACK_MULTITHREADING==0: Indicates a polling (or NO_SYS) setup.
- *       The packets are put on a list and netif_poll() must be called in
- *       the main application loop.
- */
-#ifndef LWIP_NETIF_LOOPBACK_MULTITHREADING
-#define LWIP_NETIF_LOOPBACK_MULTITHREADING    (!NO_SYS)
-#endif
-
-/**
- * LWIP_NETIF_TX_SINGLE_PBUF: if this is set to 1, lwIP tries to put all data
- * to be sent into one single pbuf. This is for compatibility with DMA-enabled
- * MACs that do not support scatter-gather.
- * Beware that this might involve CPU-memcpy before transmitting that would not
- * be needed without this flag! Use this only if you need to!
- *
- * @todo: TCP and IP-frag do not work with this, yet:
- */
-#ifndef LWIP_NETIF_TX_SINGLE_PBUF
-#define LWIP_NETIF_TX_SINGLE_PBUF             0
-#endif                          /* LWIP_NETIF_TX_SINGLE_PBUF */
-
-/*
-   ------------------------------------
-   ---------- LOOPIF options ----------
-   ------------------------------------
-*/
-/**
- * LWIP_HAVE_LOOPIF==1: Support loop interface (127.0.0.1) and loopif.c
- */
-#ifndef LWIP_HAVE_LOOPIF
-#define LWIP_HAVE_LOOPIF                0
-#endif
-
-/*
-   ------------------------------------
-   ---------- SLIPIF options ----------
-   ------------------------------------
-*/
-/**
- * LWIP_HAVE_SLIPIF==1: Support slip interface and slipif.c
- */
-#ifndef LWIP_HAVE_SLIPIF
-#define LWIP_HAVE_SLIPIF                0
-#endif
-
-/*
-   ------------------------------------
-   ---------- Thread options ----------
-   ------------------------------------
-*/
-/**
- * TCPIP_THREAD_NAME: The name assigned to the main tcpip thread.
- */
-#ifndef TCPIP_THREAD_NAME
-#define TCPIP_THREAD_NAME              "tcpip_thread"
-#endif
-
-/**
- * TCPIP_THREAD_STACKSIZE: The stack size used by the main tcpip thread.
- * The stack size value itself is platform-dependent, but is passed to
- * sys_thread_new() when the thread is created.
- */
-#ifndef TCPIP_THREAD_STACKSIZE
-#define TCPIP_THREAD_STACKSIZE          0
-#endif
-
-/**
- * TCPIP_THREAD_PRIO: The priority assigned to the main tcpip thread.
- * The priority value itself is platform-dependent, but is passed to
- * sys_thread_new() when the thread is created.
- */
-#ifndef TCPIP_THREAD_PRIO
-#define TCPIP_THREAD_PRIO               1
-#endif
-
-/**
- * TCPIP_MBOX_SIZE: The mailbox size for the tcpip thread messages
- * The queue size value itself is platform-dependent, but is passed to
- * sys_mbox_new() when tcpip_init is called.
- */
-#ifndef TCPIP_MBOX_SIZE
-#define TCPIP_MBOX_SIZE                 0
-#endif
-
-/**
- * SLIPIF_THREAD_NAME: The name assigned to the slipif_loop thread.
- */
-#ifndef SLIPIF_THREAD_NAME
-#define SLIPIF_THREAD_NAME             "slipif_loop"
-#endif
-
-/**
- * SLIP_THREAD_STACKSIZE: The stack size used by the slipif_loop thread.
- * The stack size value itself is platform-dependent, but is passed to
- * sys_thread_new() when the thread is created.
- */
-#ifndef SLIPIF_THREAD_STACKSIZE
-#define SLIPIF_THREAD_STACKSIZE         0
-#endif
-
-/**
- * SLIPIF_THREAD_PRIO: The priority assigned to the slipif_loop thread.
- * The priority value itself is platform-dependent, but is passed to
- * sys_thread_new() when the thread is created.
- */
-#ifndef SLIPIF_THREAD_PRIO
-#define SLIPIF_THREAD_PRIO              1
-#endif
-
-/**
- * PPP_THREAD_NAME: The name assigned to the pppMain thread.
- */
-#ifndef PPP_THREAD_NAME
-#define PPP_THREAD_NAME                "pppMain"
-#endif
-
-/**
- * PPP_THREAD_STACKSIZE: The stack size used by the pppMain thread.
- * The stack size value itself is platform-dependent, but is passed to
- * sys_thread_new() when the thread is created.
- */
-#ifndef PPP_THREAD_STACKSIZE
-#define PPP_THREAD_STACKSIZE            0
-#endif
-
-/**
- * PPP_THREAD_PRIO: The priority assigned to the pppMain thread.
- * The priority value itself is platform-dependent, but is passed to
- * sys_thread_new() when the thread is created.
- */
-#ifndef PPP_THREAD_PRIO
-#define PPP_THREAD_PRIO                 1
-#endif
-
-/**
- * DEFAULT_THREAD_NAME: The name assigned to any other lwIP thread.
- */
-#ifndef DEFAULT_THREAD_NAME
-#define DEFAULT_THREAD_NAME            "lwIP"
-#endif
-
-/**
- * DEFAULT_THREAD_STACKSIZE: The stack size used by any other lwIP thread.
- * The stack size value itself is platform-dependent, but is passed to
- * sys_thread_new() when the thread is created.
- */
-#ifndef DEFAULT_THREAD_STACKSIZE
-#define DEFAULT_THREAD_STACKSIZE        0
-#endif
-
-/**
- * DEFAULT_THREAD_PRIO: The priority assigned to any other lwIP thread.
- * The priority value itself is platform-dependent, but is passed to
- * sys_thread_new() when the thread is created.
- */
-#ifndef DEFAULT_THREAD_PRIO
-#define DEFAULT_THREAD_PRIO             1
-#endif
-
-/**
- * DEFAULT_RAW_RECVMBOX_SIZE: The mailbox size for the incoming packets on a
- * NETCONN_RAW. The queue size value itself is platform-dependent, but is passed
- * to sys_mbox_new() when the recvmbox is created.
- */
-#ifndef DEFAULT_RAW_RECVMBOX_SIZE
-#define DEFAULT_RAW_RECVMBOX_SIZE       0
-#endif
-
-/**
- * DEFAULT_UDP_RECVMBOX_SIZE: The mailbox size for the incoming packets on a
- * NETCONN_UDP. The queue size value itself is platform-dependent, but is passed
- * to sys_mbox_new() when the recvmbox is created.
- */
-#ifndef DEFAULT_UDP_RECVMBOX_SIZE
-#define DEFAULT_UDP_RECVMBOX_SIZE       0
-#endif
-
-/**
- * DEFAULT_TCP_RECVMBOX_SIZE: The mailbox size for the incoming packets on a
- * NETCONN_TCP. The queue size value itself is platform-dependent, but is passed
- * to sys_mbox_new() when the recvmbox is created.
- */
-#ifndef DEFAULT_TCP_RECVMBOX_SIZE
-#define DEFAULT_TCP_RECVMBOX_SIZE       0
-#endif
-
-/**
- * DEFAULT_ACCEPTMBOX_SIZE: The mailbox size for the incoming connections.
- * The queue size value itself is platform-dependent, but is passed to
- * sys_mbox_new() when the acceptmbox is created.
- */
-#ifndef DEFAULT_ACCEPTMBOX_SIZE
-#define DEFAULT_ACCEPTMBOX_SIZE         0
-#endif
-
-/*
-   ----------------------------------------------
-   ---------- Sequential layer options ----------
-   ----------------------------------------------
-*/
-/**
- * LWIP_TCPIP_CORE_LOCKING: (EXPERIMENTAL!)
- * Don't use it if you're not an active lwIP project member
- */
-#ifndef LWIP_TCPIP_CORE_LOCKING
-#define LWIP_TCPIP_CORE_LOCKING         0
-#endif
-
-/**
- * LWIP_NETCONN==1: Enable Netconn API (require to use api_lib.c)
- */
-#ifndef LWIP_NETCONN
-#define LWIP_NETCONN                    1
-#endif
-
-/*
-   ------------------------------------
-   ---------- Socket options ----------
-   ------------------------------------
-*/
-/**
- * LWIP_SOCKET==1: Enable Socket API (require to use sockets.c)
- */
-#ifndef LWIP_SOCKET
-#define LWIP_SOCKET                     1
-#endif
-
-/**
- * LWIP_COMPAT_SOCKETS==1: Enable BSD-style sockets functions names.
- * (only used if you use sockets.c)
- */
-#ifndef LWIP_COMPAT_SOCKETS
-#define LWIP_COMPAT_SOCKETS             1
-#endif
-
-/**
- * LWIP_POSIX_SOCKETS_IO_NAMES==1: Enable POSIX-style sockets functions names.
- * Disable this option if you use a POSIX operating system that uses the same
- * names (read, write & close). (only used if you use sockets.c)
- */
-#ifndef LWIP_POSIX_SOCKETS_IO_NAMES
-#define LWIP_POSIX_SOCKETS_IO_NAMES     1
-#endif
-
-/**
- * LWIP_TCP_KEEPALIVE==1: Enable TCP_KEEPIDLE, TCP_KEEPINTVL and TCP_KEEPCNT
- * options processing. Note that TCP_KEEPIDLE and TCP_KEEPINTVL have to be set
- * in seconds. (does not require sockets.c, and will affect tcp.c)
- */
-#ifndef LWIP_TCP_KEEPALIVE
-#define LWIP_TCP_KEEPALIVE              0
-#endif
-
-/**
- * LWIP_SO_RCVTIMEO==1: Enable SO_RCVTIMEO processing.
- */
-#ifndef LWIP_SO_RCVTIMEO
-#define LWIP_SO_RCVTIMEO                0
-#endif
-
-/**
- * LWIP_SO_RCVBUF==1: Enable SO_RCVBUF processing.
- */
-#ifndef LWIP_SO_RCVBUF
-#define LWIP_SO_RCVBUF                  0
-#endif
-
-/**
- * If LWIP_SO_RCVBUF is used, this is the default value for recv_bufsize.
- */
-#ifndef RECV_BUFSIZE_DEFAULT
-#define RECV_BUFSIZE_DEFAULT            INT_MAX
-#endif
-
-/**
- * SO_REUSE==1: Enable SO_REUSEADDR and SO_REUSEPORT options. DO NOT USE!
- */
-#ifndef SO_REUSE
-#define SO_REUSE                        0
-#endif
-
-/*
-   ----------------------------------------
-   ---------- Statistics options ----------
-   ----------------------------------------
-*/
-/**
- * LWIP_STATS==1: Enable statistics collection in lwip_stats.
- */
-#ifndef LWIP_STATS
-#define LWIP_STATS                      1
-#endif
-
-#if LWIP_STATS
-
-/**
- * LWIP_STATS_DISPLAY==1: Compile in the statistics output functions.
- */
-#ifndef LWIP_STATS_DISPLAY
-#define LWIP_STATS_DISPLAY              0
-#endif
-
-/**
- * LINK_STATS==1: Enable link stats.
- */
-#ifndef LINK_STATS
-#define LINK_STATS                      1
-#endif
-
-/**
- * ETHARP_STATS==1: Enable etharp stats.
- */
-#ifndef ETHARP_STATS
-#define ETHARP_STATS                    (LWIP_ARP)
-#endif
-
-/**
- * IP_STATS==1: Enable IP stats.
- */
-#ifndef IP_STATS
-#define IP_STATS                        1
-#endif
-
-/**
- * IPFRAG_STATS==1: Enable IP fragmentation stats. Default is
- * on if using either frag or reass.
- */
-#ifndef IPFRAG_STATS
-#define IPFRAG_STATS                    (IP_REASSEMBLY || IP_FRAG)
-#endif
-
-/**
- * ICMP_STATS==1: Enable ICMP stats.
- */
-#ifndef ICMP_STATS
-#define ICMP_STATS                      1
-#endif
-
-/**
- * IGMP_STATS==1: Enable IGMP stats.
- */
-#ifndef IGMP_STATS
-#define IGMP_STATS                      (LWIP_IGMP)
-#endif
-
-/**
- * UDP_STATS==1: Enable UDP stats. Default is on if
- * UDP enabled, otherwise off.
- */
-#ifndef UDP_STATS
-#define UDP_STATS                       (LWIP_UDP)
-#endif
-
-/**
- * TCP_STATS==1: Enable TCP stats. Default is on if TCP
- * enabled, otherwise off.
- */
-#ifndef TCP_STATS
-#define TCP_STATS                       (LWIP_TCP)
-#endif
-
-/**
- * MEM_STATS==1: Enable mem.c stats.
- */
-#ifndef MEM_STATS
-#define MEM_STATS                       1
-#endif
-
-/**
- * MEMP_STATS==1: Enable memp.c pool stats.
- */
-#ifndef MEMP_STATS
-#define MEMP_STATS                      1
-#endif
-
-/**
- * SYS_STATS==1: Enable system stats (sem and mbox counts, etc).
- */
-#ifndef SYS_STATS
-#define SYS_STATS                       1
-#endif
-
-#else
-
-#define LINK_STATS                      0
-#define IP_STATS                        0
-#define IPFRAG_STATS                    0
-#define ICMP_STATS                      0
-#define IGMP_STATS                      0
-#define UDP_STATS                       0
-#define TCP_STATS                       0
-#define MEM_STATS                       0
-#define MEMP_STATS                      0
-#define SYS_STATS                       0
-#define LWIP_STATS_DISPLAY              0
-
-#endif                          /* LWIP_STATS */
-
-/*
-   ---------------------------------
-   ---------- PPP options ----------
-   ---------------------------------
-*/
-/**
- * PPP_SUPPORT==1: Enable PPP.
- */
-#ifndef PPP_SUPPORT
-#define PPP_SUPPORT                     0
-#endif
-
-/**
- * PPPOE_SUPPORT==1: Enable PPP Over Ethernet
- */
-#ifndef PPPOE_SUPPORT
-#define PPPOE_SUPPORT                   0
-#endif
-
-/**
- * PPPOS_SUPPORT==1: Enable PPP Over Serial
- */
-#ifndef PPPOS_SUPPORT
-#define PPPOS_SUPPORT                   PPP_SUPPORT
-#endif
-
-#if PPP_SUPPORT
-
-/**
- * NUM_PPP: Max PPP sessions.
- */
-#ifndef NUM_PPP
-#define NUM_PPP                         1
-#endif
-
-/**
- * PAP_SUPPORT==1: Support PAP.
- */
-#ifndef PAP_SUPPORT
-#define PAP_SUPPORT                     0
-#endif
-
-/**
- * CHAP_SUPPORT==1: Support CHAP.
- */
-#ifndef CHAP_SUPPORT
-#define CHAP_SUPPORT                    0
-#endif
-
-/**
- * MSCHAP_SUPPORT==1: Support MSCHAP. CURRENTLY NOT SUPPORTED! DO NOT SET!
- */
-#ifndef MSCHAP_SUPPORT
-#define MSCHAP_SUPPORT                  0
-#endif
-
-/**
- * CBCP_SUPPORT==1: Support CBCP. CURRENTLY NOT SUPPORTED! DO NOT SET!
- */
-#ifndef CBCP_SUPPORT
-#define CBCP_SUPPORT                    0
-#endif
-
-/**
- * CCP_SUPPORT==1: Support CCP. CURRENTLY NOT SUPPORTED! DO NOT SET!
- */
-#ifndef CCP_SUPPORT
-#define CCP_SUPPORT                     0
-#endif
-
-/**
- * VJ_SUPPORT==1: Support VJ header compression.
- */
-#ifndef VJ_SUPPORT
-#define VJ_SUPPORT                      0
-#endif
-
-/**
- * MD5_SUPPORT==1: Support MD5 (see also CHAP).
- */
-#ifndef MD5_SUPPORT
-#define MD5_SUPPORT                     0
-#endif
-
-/*
- * Timeouts
- */
-#ifndef FSM_DEFTIMEOUT
-#define FSM_DEFTIMEOUT                  6       /* Timeout time in seconds */
-#endif
-
-#ifndef FSM_DEFMAXTERMREQS
-#define FSM_DEFMAXTERMREQS              2       /* Maximum Terminate-Request transmissions */
-#endif
-
-#ifndef FSM_DEFMAXCONFREQS
-#define FSM_DEFMAXCONFREQS              10      /* Maximum Configure-Request transmissions */
-#endif
-
-#ifndef FSM_DEFMAXNAKLOOPS
-#define FSM_DEFMAXNAKLOOPS              5       /* Maximum number of nak loops */
-#endif
-
-#ifndef UPAP_DEFTIMEOUT
-#define UPAP_DEFTIMEOUT                 6       /* Timeout (seconds) for retransmitting req */
-#endif
-
-#ifndef UPAP_DEFREQTIME
-#define UPAP_DEFREQTIME                 30      /* Time to wait for auth-req from peer */
-#endif
-
-#ifndef CHAP_DEFTIMEOUT
-#define CHAP_DEFTIMEOUT                 6       /* Timeout time in seconds */
-#endif
-
-#ifndef CHAP_DEFTRANSMITS
-#define CHAP_DEFTRANSMITS               10      /* max # times to send challenge */
-#endif
-
-/* Interval in seconds between keepalive echo requests, 0 to disable. */
-#ifndef LCP_ECHOINTERVAL
-#define LCP_ECHOINTERVAL                0
-#endif
-
-/* Number of unanswered echo requests before failure. */
-#ifndef LCP_MAXECHOFAILS
-#define LCP_MAXECHOFAILS                3
-#endif
-
-/* Max Xmit idle time (in jiffies) before resend flag char. */
-#ifndef PPP_MAXIDLEFLAG
-#define PPP_MAXIDLEFLAG                 100
-#endif
-
-/*
- * Packet sizes
- *
- * Note - lcp shouldn't be allowed to negotiate stuff outside these
- *    limits.  See lcp.h in the pppd directory.
- * (XXX - these constants should simply be shared by lcp.c instead
- *    of living in lcp.h)
- */
-#define PPP_MTU                         1500    /* Default MTU (size of Info field) */
-#ifndef PPP_MAXMTU
-/* #define PPP_MAXMTU  65535 - (PPP_HDRLEN + PPP_FCSLEN) */
-#define PPP_MAXMTU                      1500    /* Largest MTU we allow */
-#endif
-#define PPP_MINMTU                      64
-#define PPP_MRU                         1500    /* default MRU = max length of info field */
-#define PPP_MAXMRU                      1500    /* Largest MRU we allow */
-#ifndef PPP_DEFMRU
-#define PPP_DEFMRU                      296     /* Try for this */
-#endif
-#define PPP_MINMRU                      128     /* No MRUs below this */
-
-
-#define MAXNAMELEN                      256     /* max length of hostname or name for auth */
-#define MAXSECRETLEN                    256     /* max length of password or secret */
-
-#endif                          /* PPP_SUPPORT */
-
-/*
-   --------------------------------------
-   ---------- Checksum options ----------
-   --------------------------------------
-*/
-/**
- * CHECKSUM_GEN_IP==1: Generate checksums in software for outgoing IP packets.
- */
-#ifndef CHECKSUM_GEN_IP
-#define CHECKSUM_GEN_IP                 1
-#endif
-
-/**
- * CHECKSUM_GEN_UDP==1: Generate checksums in software for outgoing UDP packets.
- */
-#ifndef CHECKSUM_GEN_UDP
-#define CHECKSUM_GEN_UDP                1
-#endif
-
-/**
- * CHECKSUM_GEN_TCP==1: Generate checksums in software for outgoing TCP packets.
- */
-#ifndef CHECKSUM_GEN_TCP
-#define CHECKSUM_GEN_TCP                1
-#endif
-
-/**
- * CHECKSUM_CHECK_IP==1: Check checksums in software for incoming IP packets.
- */
-#ifndef CHECKSUM_CHECK_IP
-#define CHECKSUM_CHECK_IP               1
-#endif
-
-/**
- * CHECKSUM_CHECK_UDP==1: Check checksums in software for incoming UDP packets.
- */
-#ifndef CHECKSUM_CHECK_UDP
-#define CHECKSUM_CHECK_UDP              1
-#endif
-
-/**
- * CHECKSUM_CHECK_TCP==1: Check checksums in software for incoming TCP packets.
- */
-#ifndef CHECKSUM_CHECK_TCP
-#define CHECKSUM_CHECK_TCP              1
-#endif
-
-/*
-   ---------------------------------------
-   ---------- Debugging options ----------
-   ---------------------------------------
-*/
-/**
- * LWIP_DBG_MIN_LEVEL: After masking, the value of the debug is
- * compared against this value. If it is smaller, then debugging
- * messages are written.
- */
-#ifndef LWIP_DBG_MIN_LEVEL
-#define LWIP_DBG_MIN_LEVEL              LWIP_DBG_LEVEL_OFF
-#endif
-
-/**
- * LWIP_DBG_TYPES_ON: A mask that can be used to globally enable/disable
- * debug messages of certain types.
- */
-#ifndef LWIP_DBG_TYPES_ON
-#define LWIP_DBG_TYPES_ON               LWIP_DBG_ON
-#endif
-
-/**
- * ETHARP_DEBUG: Enable debugging in etharp.c.
- */
-#ifndef ETHARP_DEBUG
-#define ETHARP_DEBUG                    LWIP_DBG_OFF
-#endif
-
-/**
- * NETIF_DEBUG: Enable debugging in netif.c.
- */
-#ifndef NETIF_DEBUG
-#define NETIF_DEBUG                     LWIP_DBG_OFF
-#endif
-
-/**
- * PBUF_DEBUG: Enable debugging in pbuf.c.
- */
-#ifndef PBUF_DEBUG
-#define PBUF_DEBUG                      LWIP_DBG_OFF
-#endif
-
-/**
- * API_LIB_DEBUG: Enable debugging in api_lib.c.
- */
-#ifndef API_LIB_DEBUG
-#define API_LIB_DEBUG                   LWIP_DBG_OFF
-#endif
-
-/**
- * API_MSG_DEBUG: Enable debugging in api_msg.c.
- */
-#ifndef API_MSG_DEBUG
-#define API_MSG_DEBUG                   LWIP_DBG_OFF
-#endif
-
-/**
- * SOCKETS_DEBUG: Enable debugging in sockets.c.
- */
-#ifndef SOCKETS_DEBUG
-#define SOCKETS_DEBUG                   LWIP_DBG_OFF
-#endif
-
-/**
- * ICMP_DEBUG: Enable debugging in icmp.c.
- */
-#ifndef ICMP_DEBUG
-#define ICMP_DEBUG                      LWIP_DBG_OFF
-#endif
-
-/**
- * IGMP_DEBUG: Enable debugging in igmp.c.
- */
-#ifndef IGMP_DEBUG
-#define IGMP_DEBUG                      LWIP_DBG_OFF
-#endif
-
-/**
- * INET_DEBUG: Enable debugging in inet.c.
- */
-#ifndef INET_DEBUG
-#define INET_DEBUG                      LWIP_DBG_OFF
-#endif
-
-/**
- * IP_DEBUG: Enable debugging for IP.
- */
-#ifndef IP_DEBUG
-#define IP_DEBUG                        LWIP_DBG_OFF
-#endif
-
-/**
- * IP_REASS_DEBUG: Enable debugging in ip_frag.c for both frag & reass.
- */
-#ifndef IP_REASS_DEBUG
-#define IP_REASS_DEBUG                  LWIP_DBG_OFF
-#endif
-
-/**
- * RAW_DEBUG: Enable debugging in raw.c.
- */
-#ifndef RAW_DEBUG
-#define RAW_DEBUG                       LWIP_DBG_OFF
-#endif
-
-/**
- * MEM_DEBUG: Enable debugging in mem.c.
- */
-#ifndef MEM_DEBUG
-#define MEM_DEBUG                       LWIP_DBG_OFF
-#endif
-
-/**
- * MEMP_DEBUG: Enable debugging in memp.c.
- */
-#ifndef MEMP_DEBUG
-#define MEMP_DEBUG                      LWIP_DBG_OFF
-#endif
-
-/**
- * SYS_DEBUG: Enable debugging in sys.c.
- */
-#ifndef SYS_DEBUG
-#define SYS_DEBUG                       LWIP_DBG_OFF
-#endif
-
-/**
- * TCP_DEBUG: Enable debugging for TCP.
- */
-#ifndef TCP_DEBUG
-#define TCP_DEBUG                       LWIP_DBG_OFF
-#endif
-
-/**
- * TCP_INPUT_DEBUG: Enable debugging in tcp_in.c for incoming debug.
- */
-#ifndef TCP_INPUT_DEBUG
-#define TCP_INPUT_DEBUG                 LWIP_DBG_OFF
-#endif
-
-/**
- * TCP_FR_DEBUG: Enable debugging in tcp_in.c for fast retransmit.
- */
-#ifndef TCP_FR_DEBUG
-#define TCP_FR_DEBUG                    LWIP_DBG_OFF
-#endif
-
-/**
- * TCP_RTO_DEBUG: Enable debugging in TCP for retransmit
- * timeout.
- */
-#ifndef TCP_RTO_DEBUG
-#define TCP_RTO_DEBUG                   LWIP_DBG_OFF
-#endif
-
-/**
- * TCP_CWND_DEBUG: Enable debugging for TCP congestion window.
- */
-#ifndef TCP_CWND_DEBUG
-#define TCP_CWND_DEBUG                  LWIP_DBG_OFF
-#endif
-
-/**
- * TCP_WND_DEBUG: Enable debugging in tcp_in.c for window updating.
- */
-#ifndef TCP_WND_DEBUG
-#define TCP_WND_DEBUG                   LWIP_DBG_OFF
-#endif
-
-/**
- * TCP_OUTPUT_DEBUG: Enable debugging in tcp_out.c output functions.
- */
-#ifndef TCP_OUTPUT_DEBUG
-#define TCP_OUTPUT_DEBUG                LWIP_DBG_OFF
-#endif
-
-/**
- * TCP_RST_DEBUG: Enable debugging for TCP with the RST message.
- */
-#ifndef TCP_RST_DEBUG
-#define TCP_RST_DEBUG                   LWIP_DBG_OFF
-#endif
-
-/**
- * TCP_QLEN_DEBUG: Enable debugging for TCP queue lengths.
- */
-#ifndef TCP_QLEN_DEBUG
-#define TCP_QLEN_DEBUG                  LWIP_DBG_OFF
-#endif
-
-/**
- * UDP_DEBUG: Enable debugging in UDP.
- */
-#ifndef UDP_DEBUG
-//#define UDP_DEBUG                       LWIP_DBG_ON
-#define UDP_DEBUG                       LWIP_DBG_OFF
-#endif
-
-/**
- * TCPIP_DEBUG: Enable debugging in tcpip.c.
- */
-#ifndef TCPIP_DEBUG
-#define TCPIP_DEBUG                     LWIP_DBG_OFF
-#endif
-
-/**
- * PPP_DEBUG: Enable debugging for PPP.
- */
-#ifndef PPP_DEBUG
-#define PPP_DEBUG                       LWIP_DBG_OFF
-#endif
-
-/**
- * SLIP_DEBUG: Enable debugging in slipif.c.
- */
-#ifndef SLIP_DEBUG
-#define SLIP_DEBUG                      LWIP_DBG_OFF
-#endif
-
-/**
- * DHCP_DEBUG: Enable debugging in dhcp.c.
- */
-#ifndef DHCP_DEBUG
-#define DHCP_DEBUG                      LWIP_DBG_OFF
-#endif
-
-/**
- * AUTOIP_DEBUG: Enable debugging in autoip.c.
- */
-#ifndef AUTOIP_DEBUG
-#define AUTOIP_DEBUG                    LWIP_DBG_OFF
-#endif
-
-/**
- * SNMP_MSG_DEBUG: Enable debugging for SNMP messages.
- */
-#ifndef SNMP_MSG_DEBUG
-#define SNMP_MSG_DEBUG                  LWIP_DBG_OFF
-#endif
-
-/**
- * SNMP_MIB_DEBUG: Enable debugging for SNMP MIBs.
- */
-#ifndef SNMP_MIB_DEBUG
-#define SNMP_MIB_DEBUG                  LWIP_DBG_OFF
-#endif
-
-/**
- * DNS_DEBUG: Enable debugging for DNS.
- */
-#ifndef DNS_DEBUG
-#define DNS_DEBUG                       LWIP_DBG_OFF
-#endif
-
-#endif                          /* __LWIP_OPT_H__ */
diff --git a/include/lwip/pbuf.h b/include/lwip/pbuf.h
deleted file mode 100644
index 779d364..0000000
--- a/include/lwip/pbuf.h
+++ /dev/null
@@ -1,140 +0,0 @@
-/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Adam Dunkels <adam@sics.se>
- *
- */
-
-#ifndef __LWIP_PBUF_H__
-#define __LWIP_PBUF_H__
-
-#include "lwip/opt.h"
-#include "lwip/err.h"
-
-#include <net_interfaces/flags.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* FIXME: this might be the bad place for this #define */
-#define PBUF_PKT_SIZE 2048      // NOTE: size of each pbuf struct.
-
-#define PBUF_TRANSPORT_HLEN 20
-#define PBUF_IP_HLEN        20
-
-    typedef enum {
-        PBUF_TRANSPORT,
-        PBUF_IP,
-        PBUF_LINK,
-        PBUF_RAW
-    } pbuf_layer;
-
-    typedef enum {
-        PBUF_RAM,               /* pbuf data is stored in RAM */
-        PBUF_ROM,               /* pbuf data is stored in ROM */
-        PBUF_REF,               /* pbuf comes from the pbuf pool */
-        PBUF_POOL               /* pbuf payload refers to RAM */
-    } pbuf_type;
-
-
-/** indicates this packet's data should be immediately passed to the application */
-#define PBUF_FLAG_PUSH 0x01U
-
-    struct pbuf {
-  /** next pbuf in singly linked pbuf chain */
-        struct pbuf *next;
-
-  /** pointer to the actual data in the buffer */
-        void *payload;
-
-  /**
-   * total length of this buffer and all next buffers in chain
-   * belonging to the same packet.
-   *
-   * For non-queue packet chains this is the invariant:
-   * p->tot_len == p->len + (p->next? p->next->tot_len: 0)
-   */
-        u16_t tot_len;
-
-  /** length of this buffer */
-        u16_t len;
-
-  /** pbuf_type as u8_t instead of enum to save space */
-         u8_t /*pbuf_type */ type;
-
-  /** misc flags */
-        u8_t flags;
-
-  /**
-   * the reference count always equals the number of pointers
-   * that refer to this pbuf. This can be pointers from an application,
-   * the stack itself, or pbuf->next pointers from a chain.
-   */
-        u16_t ref;
-
-        /* buff len is the size of buffer allocated to this pbuf */
-        u16_t buff_len;
-
-        uint64_t nicflags;
-    };
-
-/* Initializes the pbuf module. This call is empty for now, but may not be in future. */
-#define pbuf_init()
-
-//#define pbuf_free(a)    do{ pbuf_free_tagged((a));  } while(0)
-#define pbuf_free(a)    pbuf_free_tagged((a), (__func__), (__LINE__))
-#define pbuf_ref(a)    pbuf_ref_tagged((a), (__func__), (__LINE__))
-#define pbuf_alloc(l, len, t)    pbuf_alloc_tagged((l), (len), (t), (__func__), (__LINE__))
-
-    void pbuf_ref_tagged(struct pbuf *p, const char *func_name, int line_no);
-    struct pbuf *pbuf_alloc_tagged(pbuf_layer layer, u16_t length, pbuf_type type,
-       const char *func_name, int line_no);
-//    u8_t pbuf_free(struct pbuf *p);
-    u8_t pbuf_free_tagged(struct pbuf * p, const char *func_name, int line_no);
-
-    uint16_t free_pbuf_pool_count(void);
-    void pbuf_realloc(struct pbuf *p, u16_t size);
-    u8_t pbuf_header(struct pbuf *p, s16_t header_size);
-//    void pbuf_ref(struct pbuf *p);
-    void pbuf_ref_chain(struct pbuf *p);
-//    u8_t pbuf_free(struct pbuf *p);
-    u8_t pbuf_clen(struct pbuf *p);
-    void pbuf_cat(struct pbuf *head, struct pbuf *tail);
-    void pbuf_chain(struct pbuf *head, struct pbuf *tail);
-    struct pbuf *pbuf_dechain(struct pbuf *p);
-    err_t pbuf_copy(struct pbuf *p_to, struct pbuf *p_from);
-    u16_t pbuf_copy_partial(struct pbuf *p, void *dataptr, u16_t len,
-                            u16_t offset);
-    err_t pbuf_take(struct pbuf *buf, const void *dataptr, u16_t len);
-    struct pbuf *pbuf_coalesce(struct pbuf *p, pbuf_layer layer);
-
-#ifdef __cplusplus
-}
-#endif
-#endif                          /* __LWIP_PBUF_H__ */
diff --git a/include/lwip/raw.h b/include/lwip/raw.h
deleted file mode 100644
index 785a41e..0000000
--- a/include/lwip/raw.h
+++ /dev/null
@@ -1,95 +0,0 @@
-/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Adam Dunkels <adam@sics.se>
- *
- */
-#ifndef __LWIP_RAW_H__
-#define __LWIP_RAW_H__
-
-#include "lwip/opt.h"
-
-#if LWIP_RAW                    /* don't build if not configured for use in lwipopts.h */
-
-#include "lwip/pbuf.h"
-#include "lwip/inet.h"
-#include "lwip/ip.h"
-#include "lwip/ip_addr.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-    struct raw_pcb {
-/* Common members of all PCB types */
-        IP_PCB;
-
-        struct raw_pcb *next;
-
-        u8_t protocol;
-
-        /* receive callback function
-         * @param arg user supplied argument (raw_pcb.recv_arg)
-         * @param pcb the raw_pcb which received data
-         * @param p the packet buffer that was received
-         * @param addr the remote IP address from which the packet was received
-         * @return 1 if the packet was 'eaten' (aka. deleted),
-         *         0 if the packet lives on
-         * If returning 1, the callback is responsible for freeing the pbuf
-         * if it's not used any more.
-         */
-         u8_t(*recv) (void *arg, struct raw_pcb * pcb, struct pbuf * p,
-                      struct ip_addr * addr);
-        /* user-supplied argument for the recv callback */
-        void *recv_arg;
-    };
-
-/* The following functions is the application layer interface to the
-   RAW code. */
-    struct raw_pcb *raw_new(u8_t proto);
-    void raw_remove(struct raw_pcb *pcb);
-    err_t raw_bind(struct raw_pcb *pcb, struct ip_addr *ipaddr);
-    err_t raw_connect(struct raw_pcb *pcb, struct ip_addr *ipaddr);
-
-    void raw_recv(struct raw_pcb *pcb,
-                  u8_t(*recv) (void *arg, struct raw_pcb * pcb,
-                               struct pbuf * p,
-                               struct ip_addr * addr), void *recv_arg);
-    err_t raw_sendto(struct raw_pcb *pcb, struct pbuf *p,
-                     struct ip_addr *ipaddr);
-    err_t raw_send(struct raw_pcb *pcb, struct pbuf *p);
-
-/* The following functions are the lower layer interface to RAW. */
-    u8_t raw_input(struct pbuf *p, struct netif *inp);
-#define raw_init()              /* Compatibility define, not init needed. */
-
-#ifdef __cplusplus
-}
-#endif
-#endif                          /* LWIP_RAW */
-#endif                          /* __LWIP_RAW_H__ */
diff --git a/include/lwip/sio.h b/include/lwip/sio.h
deleted file mode 100644
index 8088dce..0000000
--- a/include/lwip/sio.h
+++ /dev/null
@@ -1,80 +0,0 @@
-/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved. 
- * 
- * Redistribution and use in source and binary forms, with or without modification, 
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission. 
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- */
-
-/*
- * This is the interface to the platform specific serial IO module
- * It needs to be implemented by those platforms which need SLIP or PPP
- */
-
-#ifndef __SIO_H__
-#define __SIO_H__
-
-#include "lwip/arch.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* If you want to define sio_fd_t elsewhere or differently,
-   define this in your cc.h file. */
-#ifndef __sio_fd_t_defined
-    typedef void *sio_fd_t;
-#endif
-
-/* The following functions can be defined to something else in your cc.h file
-   or be implemented in your custom sio.c file. */
-
-#ifndef sio_open
-    sio_fd_t sio_open(u8_t);
-#endif
-
-#ifndef sio_send
-    void sio_send(u8_t, sio_fd_t);
-#endif
-
-#ifndef sio_recv
-    u8_t sio_recv(sio_fd_t);
-#endif
-
-#ifndef sio_read
-    u32_t sio_read(sio_fd_t, u8_t *, u32_t);
-#endif
-
-#ifndef sio_write
-    u32_t sio_write(sio_fd_t, u8_t *, u32_t);
-#endif
-
-#ifndef sio_read_abort
-    void sio_read_abort(sio_fd_t);
-#endif
-
-#ifdef __cplusplus
-}
-#endif
-#endif                          /* __SIO_H__ */
diff --git a/include/lwip/snmp.h b/include/lwip/snmp.h
deleted file mode 100644
index 15f9140..0000000
--- a/include/lwip/snmp.h
+++ /dev/null
@@ -1,362 +0,0 @@
-/*
- * Copyright (c) 2001, 2002 Leon Woestenberg <leon.woestenberg@axon.tv>
- * Copyright (c) 2001, 2002 Axon Digital Design B.V., The Netherlands.
- * All rights reserved.
- * 
- * Redistribution and use in source and binary forms, with or without modification, 
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission. 
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- * 
- * Author: Leon Woestenberg <leon.woestenberg@axon.tv>
- *
- */
-#ifndef __LWIP_SNMP_H__
-#define __LWIP_SNMP_H__
-
-#include "lwip/opt.h"
-#include "lwip/netif.h"
-#include "lwip/udp.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * @see RFC1213, "MIB-II, 6. Definitions"
- */
-    enum snmp_ifType {
-        snmp_ifType_other = 1,  /* none of the following */
-        snmp_ifType_regular1822,
-        snmp_ifType_hdh1822,
-        snmp_ifType_ddn_x25,
-        snmp_ifType_rfc877_x25,
-        snmp_ifType_ethernet_csmacd,
-        snmp_ifType_iso88023_csmacd,
-        snmp_ifType_iso88024_tokenBus,
-        snmp_ifType_iso88025_tokenRing,
-        snmp_ifType_iso88026_man,
-        snmp_ifType_starLan,
-        snmp_ifType_proteon_10Mbit,
-        snmp_ifType_proteon_80Mbit,
-        snmp_ifType_hyperchannel,
-        snmp_ifType_fddi,
-        snmp_ifType_lapb,
-        snmp_ifType_sdlc,
-        snmp_ifType_ds1,        /* T-1 */
-        snmp_ifType_e1,         /* european equiv. of T-1 */
-        snmp_ifType_basicISDN,
-        snmp_ifType_primaryISDN,        /* proprietary serial */
-        snmp_ifType_propPointToPointSerial,
-        snmp_ifType_ppp,
-        snmp_ifType_softwareLoopback,
-        snmp_ifType_eon,        /* CLNP over IP [11] */
-        snmp_ifType_ethernet_3Mbit,
-        snmp_ifType_nsip,       /* XNS over IP */
-        snmp_ifType_slip,       /* generic SLIP */
-        snmp_ifType_ultra,      /* ULTRA technologies */
-        snmp_ifType_ds3,        /* T-3 */
-        snmp_ifType_sip,        /* SMDS */
-        snmp_ifType_frame_relay
-    };
-
-#if LWIP_SNMP                   /* don't build if not configured for use in lwipopts.h */
-
-/** SNMP "sysuptime" Interval */
-#define SNMP_SYSUPTIME_INTERVAL 10
-
-/** fixed maximum length for object identifier type */
-#define LWIP_SNMP_OBJ_ID_LEN 32
-
-/** internal object identifier representation */
-    struct snmp_obj_id {
-        u8_t len;
-        s32_t id[LWIP_SNMP_OBJ_ID_LEN];
-    };
-
-/* system */
-    void snmp_set_sysdesr(u8_t * str, u8_t * len);
-    void snmp_set_sysobjid(struct snmp_obj_id *oid);
-    void snmp_get_sysobjid_ptr(struct snmp_obj_id **oid);
-    void snmp_inc_sysuptime(void);
-    void snmp_add_sysuptime(u32_t value);
-    void snmp_get_sysuptime(u32_t * value);
-    void snmp_set_syscontact(u8_t * ocstr, u8_t * ocstrlen);
-    void snmp_set_sysname(u8_t * ocstr, u8_t * ocstrlen);
-    void snmp_set_syslocation(u8_t * ocstr, u8_t * ocstrlen);
-
-/* network interface */
-    void snmp_add_ifinoctets(struct netif *ni, u32_t value);
-    void snmp_inc_ifinucastpkts(struct netif *ni);
-    void snmp_inc_ifinnucastpkts(struct netif *ni);
-    void snmp_inc_ifindiscards(struct netif *ni);
-    void snmp_add_ifoutoctets(struct netif *ni, u32_t value);
-    void snmp_inc_ifoutucastpkts(struct netif *ni);
-    void snmp_inc_ifoutnucastpkts(struct netif *ni);
-    void snmp_inc_ifoutdiscards(struct netif *ni);
-    void snmp_inc_iflist(void);
-    void snmp_dec_iflist(void);
-
-/* ARP (for atTable and ipNetToMediaTable) */
-    void snmp_insert_arpidx_tree(struct netif *ni, struct ip_addr *ip);
-    void snmp_delete_arpidx_tree(struct netif *ni, struct ip_addr *ip);
-
-/* IP */
-    void snmp_inc_ipinreceives(void);
-    void snmp_inc_ipinhdrerrors(void);
-    void snmp_inc_ipinaddrerrors(void);
-    void snmp_inc_ipforwdatagrams(void);
-    void snmp_inc_ipinunknownprotos(void);
-    void snmp_inc_ipindiscards(void);
-    void snmp_inc_ipindelivers(void);
-    void snmp_inc_ipoutrequests(void);
-    void snmp_inc_ipoutdiscards(void);
-    void snmp_inc_ipoutnoroutes(void);
-    void snmp_inc_ipreasmreqds(void);
-    void snmp_inc_ipreasmoks(void);
-    void snmp_inc_ipreasmfails(void);
-    void snmp_inc_ipfragoks(void);
-    void snmp_inc_ipfragfails(void);
-    void snmp_inc_ipfragcreates(void);
-    void snmp_inc_iproutingdiscards(void);
-    void snmp_insert_ipaddridx_tree(struct netif *ni);
-    void snmp_delete_ipaddridx_tree(struct netif *ni);
-    void snmp_insert_iprteidx_tree(u8_t dflt, struct netif *ni);
-    void snmp_delete_iprteidx_tree(u8_t dflt, struct netif *ni);
-
-/* ICMP */
-    void snmp_inc_icmpinmsgs(void);
-    void snmp_inc_icmpinerrors(void);
-    void snmp_inc_icmpindestunreachs(void);
-    void snmp_inc_icmpintimeexcds(void);
-    void snmp_inc_icmpinparmprobs(void);
-    void snmp_inc_icmpinsrcquenchs(void);
-    void snmp_inc_icmpinredirects(void);
-    void snmp_inc_icmpinechos(void);
-    void snmp_inc_icmpinechoreps(void);
-    void snmp_inc_icmpintimestamps(void);
-    void snmp_inc_icmpintimestampreps(void);
-    void snmp_inc_icmpinaddrmasks(void);
-    void snmp_inc_icmpinaddrmaskreps(void);
-    void snmp_inc_icmpoutmsgs(void);
-    void snmp_inc_icmpouterrors(void);
-    void snmp_inc_icmpoutdestunreachs(void);
-    void snmp_inc_icmpouttimeexcds(void);
-    void snmp_inc_icmpoutparmprobs(void);
-    void snmp_inc_icmpoutsrcquenchs(void);
-    void snmp_inc_icmpoutredirects(void);
-    void snmp_inc_icmpoutechos(void);
-    void snmp_inc_icmpoutechoreps(void);
-    void snmp_inc_icmpouttimestamps(void);
-    void snmp_inc_icmpouttimestampreps(void);
-    void snmp_inc_icmpoutaddrmasks(void);
-    void snmp_inc_icmpoutaddrmaskreps(void);
-
-/* TCP */
-    void snmp_inc_tcpactiveopens(void);
-    void snmp_inc_tcppassiveopens(void);
-    void snmp_inc_tcpattemptfails(void);
-    void snmp_inc_tcpestabresets(void);
-    void snmp_inc_tcpinsegs(void);
-    void snmp_inc_tcpoutsegs(void);
-    void snmp_inc_tcpretranssegs(void);
-    void snmp_inc_tcpinerrs(void);
-    void snmp_inc_tcpoutrsts(void);
-
-/* UDP */
-    void snmp_inc_udpindatagrams(void);
-    void snmp_inc_udpnoports(void);
-    void snmp_inc_udpinerrors(void);
-    void snmp_inc_udpoutdatagrams(void);
-    void snmp_insert_udpidx_tree(struct udp_pcb *pcb);
-    void snmp_delete_udpidx_tree(struct udp_pcb *pcb);
-
-/* SNMP */
-    void snmp_inc_snmpinpkts(void);
-    void snmp_inc_snmpoutpkts(void);
-    void snmp_inc_snmpinbadversions(void);
-    void snmp_inc_snmpinbadcommunitynames(void);
-    void snmp_inc_snmpinbadcommunityuses(void);
-    void snmp_inc_snmpinasnparseerrs(void);
-    void snmp_inc_snmpintoobigs(void);
-    void snmp_inc_snmpinnosuchnames(void);
-    void snmp_inc_snmpinbadvalues(void);
-    void snmp_inc_snmpinreadonlys(void);
-    void snmp_inc_snmpingenerrs(void);
-    void snmp_add_snmpintotalreqvars(u8_t value);
-    void snmp_add_snmpintotalsetvars(u8_t value);
-    void snmp_inc_snmpingetrequests(void);
-    void snmp_inc_snmpingetnexts(void);
-    void snmp_inc_snmpinsetrequests(void);
-    void snmp_inc_snmpingetresponses(void);
-    void snmp_inc_snmpintraps(void);
-    void snmp_inc_snmpouttoobigs(void);
-    void snmp_inc_snmpoutnosuchnames(void);
-    void snmp_inc_snmpoutbadvalues(void);
-    void snmp_inc_snmpoutgenerrs(void);
-    void snmp_inc_snmpoutgetrequests(void);
-    void snmp_inc_snmpoutgetnexts(void);
-    void snmp_inc_snmpoutsetrequests(void);
-    void snmp_inc_snmpoutgetresponses(void);
-    void snmp_inc_snmpouttraps(void);
-    void snmp_get_snmpgrpid_ptr(struct snmp_obj_id **oid);
-    void snmp_set_snmpenableauthentraps(u8_t * value);
-    void snmp_get_snmpenableauthentraps(u8_t * value);
-
-/* LWIP_SNMP support not available */
-/* define everything to be empty */
-#else
-
-/* system */
-#define snmp_set_sysdesr(str, len)
-#define snmp_set_sysobjid(oid);
-#define snmp_get_sysobjid_ptr(oid)
-#define snmp_inc_sysuptime()
-#define snmp_add_sysuptime(value)
-#define snmp_get_sysuptime(value)
-#define snmp_set_syscontact(ocstr, ocstrlen);
-#define snmp_set_sysname(ocstr, ocstrlen);
-#define snmp_set_syslocation(ocstr, ocstrlen);
-
-/* network interface */
-#define snmp_add_ifinoctets(ni,value)
-#define snmp_inc_ifinucastpkts(ni)
-#define snmp_inc_ifinnucastpkts(ni)
-#define snmp_inc_ifindiscards(ni)
-#define snmp_add_ifoutoctets(ni,value)
-#define snmp_inc_ifoutucastpkts(ni)
-#define snmp_inc_ifoutnucastpkts(ni)
-#define snmp_inc_ifoutdiscards(ni)
-#define snmp_inc_iflist()
-#define snmp_dec_iflist()
-
-/* ARP */
-#define snmp_insert_arpidx_tree(ni,ip)
-#define snmp_delete_arpidx_tree(ni,ip)
-
-/* IP */
-#define snmp_inc_ipinreceives()
-#define snmp_inc_ipinhdrerrors()
-#define snmp_inc_ipinaddrerrors()
-#define snmp_inc_ipforwdatagrams()
-#define snmp_inc_ipinunknownprotos()
-#define snmp_inc_ipindiscards()
-#define snmp_inc_ipindelivers()
-#define snmp_inc_ipoutrequests()
-#define snmp_inc_ipoutdiscards()
-#define snmp_inc_ipoutnoroutes()
-#define snmp_inc_ipreasmreqds()
-#define snmp_inc_ipreasmoks()
-#define snmp_inc_ipreasmfails()
-#define snmp_inc_ipfragoks()
-#define snmp_inc_ipfragfails()
-#define snmp_inc_ipfragcreates()
-#define snmp_inc_iproutingdiscards()
-#define snmp_insert_ipaddridx_tree(ni)
-#define snmp_delete_ipaddridx_tree(ni)
-#define snmp_insert_iprteidx_tree(dflt, ni)
-#define snmp_delete_iprteidx_tree(dflt, ni)
-
-/* ICMP */
-#define snmp_inc_icmpinmsgs()
-#define snmp_inc_icmpinerrors()
-#define snmp_inc_icmpindestunreachs()
-#define snmp_inc_icmpintimeexcds()
-#define snmp_inc_icmpinparmprobs()
-#define snmp_inc_icmpinsrcquenchs()
-#define snmp_inc_icmpinredirects()
-#define snmp_inc_icmpinechos()
-#define snmp_inc_icmpinechoreps()
-#define snmp_inc_icmpintimestamps()
-#define snmp_inc_icmpintimestampreps()
-#define snmp_inc_icmpinaddrmasks()
-#define snmp_inc_icmpinaddrmaskreps()
-#define snmp_inc_icmpoutmsgs()
-#define snmp_inc_icmpouterrors()
-#define snmp_inc_icmpoutdestunreachs()
-#define snmp_inc_icmpouttimeexcds()
-#define snmp_inc_icmpoutparmprobs()
-#define snmp_inc_icmpoutsrcquenchs()
-#define snmp_inc_icmpoutredirects()
-#define snmp_inc_icmpoutechos()
-#define snmp_inc_icmpoutechoreps()
-#define snmp_inc_icmpouttimestamps()
-#define snmp_inc_icmpouttimestampreps()
-#define snmp_inc_icmpoutaddrmasks()
-#define snmp_inc_icmpoutaddrmaskreps()
-/* TCP */
-#define snmp_inc_tcpactiveopens()
-#define snmp_inc_tcppassiveopens()
-#define snmp_inc_tcpattemptfails()
-#define snmp_inc_tcpestabresets()
-#define snmp_inc_tcpinsegs()
-#define snmp_inc_tcpoutsegs()
-#define snmp_inc_tcpretranssegs()
-#define snmp_inc_tcpinerrs()
-#define snmp_inc_tcpoutrsts()
-
-/* UDP */
-#define snmp_inc_udpindatagrams()
-#define snmp_inc_udpnoports()
-#define snmp_inc_udpinerrors()
-#define snmp_inc_udpoutdatagrams()
-#define snmp_insert_udpidx_tree(pcb)
-#define snmp_delete_udpidx_tree(pcb)
-
-/* SNMP */
-#define snmp_inc_snmpinpkts()
-#define snmp_inc_snmpoutpkts()
-#define snmp_inc_snmpinbadversions()
-#define snmp_inc_snmpinbadcommunitynames()
-#define snmp_inc_snmpinbadcommunityuses()
-#define snmp_inc_snmpinasnparseerrs()
-#define snmp_inc_snmpintoobigs()
-#define snmp_inc_snmpinnosuchnames()
-#define snmp_inc_snmpinbadvalues()
-#define snmp_inc_snmpinreadonlys()
-#define snmp_inc_snmpingenerrs()
-#define snmp_add_snmpintotalreqvars(value)
-#define snmp_add_snmpintotalsetvars(value)
-#define snmp_inc_snmpingetrequests()
-#define snmp_inc_snmpingetnexts()
-#define snmp_inc_snmpinsetrequests()
-#define snmp_inc_snmpingetresponses()
-#define snmp_inc_snmpintraps()
-#define snmp_inc_snmpouttoobigs()
-#define snmp_inc_snmpoutnosuchnames()
-#define snmp_inc_snmpoutbadvalues()
-#define snmp_inc_snmpoutgenerrs()
-#define snmp_inc_snmpoutgetrequests()
-#define snmp_inc_snmpoutgetnexts()
-#define snmp_inc_snmpoutsetrequests()
-#define snmp_inc_snmpoutgetresponses()
-#define snmp_inc_snmpouttraps()
-#define snmp_get_snmpgrpid_ptr(oid)
-#define snmp_set_snmpenableauthentraps(value)
-#define snmp_get_snmpenableauthentraps(value)
-
-#endif                          /* LWIP_SNMP */
-
-#ifdef __cplusplus
-}
-#endif
-#endif                          /* __LWIP_SNMP_H__ */
diff --git a/include/lwip/snmp_asn1.h b/include/lwip/snmp_asn1.h
deleted file mode 100644
index 4773b46..0000000
--- a/include/lwip/snmp_asn1.h
+++ /dev/null
@@ -1,109 +0,0 @@
-/**
- * @file
- * Abstract Syntax Notation One (ISO 8824, 8825) codec.
- */
-
-/*
- * Copyright (c) 2006 Axon Digital Design B.V., The Netherlands.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * Author: Christiaan Simons <christiaan.simons@axon.tv>
- */
-
-#ifndef __LWIP_SNMP_ASN1_H__
-#define __LWIP_SNMP_ASN1_H__
-
-#include "lwip/opt.h"
-#include "lwip/err.h"
-#include "lwip/pbuf.h"
-#include "lwip/snmp.h"
-
-#if LWIP_SNMP
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#define SNMP_ASN1_UNIV   (!0x80 | !0x40)
-#define SNMP_ASN1_APPLIC (!0x80 |  0x40)
-#define SNMP_ASN1_CONTXT ( 0x80 | !0x40)
-
-#define SNMP_ASN1_CONSTR (0x20)
-#define SNMP_ASN1_PRIMIT (!0x20)
-
-/* universal tags */
-#define SNMP_ASN1_INTEG  2
-#define SNMP_ASN1_OC_STR 4
-#define SNMP_ASN1_NUL    5
-#define SNMP_ASN1_OBJ_ID 6
-#define SNMP_ASN1_SEQ    16
-
-/* application specific (SNMP) tags */
-#define SNMP_ASN1_IPADDR 0      /* octet string size(4) */
-#define SNMP_ASN1_COUNTER 1     /* u32_t */
-#define SNMP_ASN1_GAUGE 2       /* u32_t */
-#define SNMP_ASN1_TIMETICKS 3   /* u32_t */
-#define SNMP_ASN1_OPAQUE 4      /* octet string */
-
-/* context specific (SNMP) tags */
-#define SNMP_ASN1_PDU_GET_REQ 0
-#define SNMP_ASN1_PDU_GET_NEXT_REQ 1
-#define SNMP_ASN1_PDU_GET_RESP 2
-#define SNMP_ASN1_PDU_SET_REQ 3
-#define SNMP_ASN1_PDU_TRAP 4
-
-    err_t snmp_asn1_dec_type(struct pbuf *p, u16_t ofs, u8_t * type);
-    err_t snmp_asn1_dec_length(struct pbuf *p, u16_t ofs, u8_t * octets_used,
-                               u16_t * length);
-    err_t snmp_asn1_dec_u32t(struct pbuf *p, u16_t ofs, u16_t len,
-                             u32_t * value);
-    err_t snmp_asn1_dec_s32t(struct pbuf *p, u16_t ofs, u16_t len,
-                             s32_t * value);
-    err_t snmp_asn1_dec_oid(struct pbuf *p, u16_t ofs, u16_t len,
-                            struct snmp_obj_id *oid);
-    err_t snmp_asn1_dec_raw(struct pbuf *p, u16_t ofs, u16_t len, u16_t raw_len,
-                            u8_t * raw);
-
-    void snmp_asn1_enc_length_cnt(u16_t length, u8_t * octets_needed);
-    void snmp_asn1_enc_u32t_cnt(u32_t value, u16_t * octets_needed);
-    void snmp_asn1_enc_s32t_cnt(s32_t value, u16_t * octets_needed);
-    void snmp_asn1_enc_oid_cnt(u8_t ident_len, s32_t * ident,
-                               u16_t * octets_needed);
-    err_t snmp_asn1_enc_type(struct pbuf *p, u16_t ofs, u8_t type);
-    err_t snmp_asn1_enc_length(struct pbuf *p, u16_t ofs, u16_t length);
-    err_t snmp_asn1_enc_u32t(struct pbuf *p, u16_t ofs, u8_t octets_needed,
-                             u32_t value);
-    err_t snmp_asn1_enc_s32t(struct pbuf *p, u16_t ofs, u8_t octets_needed,
-                             s32_t value);
-    err_t snmp_asn1_enc_oid(struct pbuf *p, u16_t ofs, u8_t ident_len,
-                            s32_t * ident);
-    err_t snmp_asn1_enc_raw(struct pbuf *p, u16_t ofs, u8_t raw_len,
-                            u8_t * raw);
-
-#ifdef __cplusplus
-}
-#endif
-#endif                          /* LWIP_SNMP */
-#endif                          /* __LWIP_SNMP_ASN1_H__ */
diff --git a/include/lwip/snmp_msg.h b/include/lwip/snmp_msg.h
deleted file mode 100644
index 8d63807..0000000
--- a/include/lwip/snmp_msg.h
+++ /dev/null
@@ -1,307 +0,0 @@
-/**
- * @file
- * SNMP Agent message handling structures.
- */
-
-/*
- * Copyright (c) 2006 Axon Digital Design B.V., The Netherlands.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * Author: Christiaan Simons <christiaan.simons@axon.tv>
- */
-
-#ifndef __LWIP_SNMP_MSG_H__
-#define __LWIP_SNMP_MSG_H__
-
-#include "lwip/opt.h"
-#include "lwip/snmp.h"
-#include "lwip/snmp_structs.h"
-
-#if LWIP_SNMP
-
-#if SNMP_PRIVATE_MIB
-#include "private_mib.h"
-#endif
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* The listen port of the SNMP agent. Clients have to make their requests to
-   this port. Most standard clients won't work if you change this! */
-#ifndef SNMP_IN_PORT
-#define SNMP_IN_PORT 161
-#endif
-/* The remote port the SNMP agent sends traps to. Most standard trap sinks won't
-   work if you change this! */
-#ifndef SNMP_TRAP_PORT
-#define SNMP_TRAP_PORT 162
-#endif
-
-#define SNMP_ES_NOERROR 0
-#define SNMP_ES_TOOBIG 1
-#define SNMP_ES_NOSUCHNAME 2
-#define SNMP_ES_BADVALUE 3
-#define SNMP_ES_READONLY 4
-#define SNMP_ES_GENERROR 5
-
-#define SNMP_GENTRAP_COLDSTART 0
-#define SNMP_GENTRAP_WARMSTART 1
-#define SNMP_GENTRAP_AUTHFAIL 4
-#define SNMP_GENTRAP_ENTERPRISESPC 6
-
-    struct snmp_varbind {
-        /* next pointer, NULL for last in list */
-        struct snmp_varbind *next;
-        /* previous pointer, NULL for first in list */
-        struct snmp_varbind *prev;
-
-        /* object identifier length (in s32_t) */
-        u8_t ident_len;
-        /* object identifier array */
-        s32_t *ident;
-
-        /* object value ASN1 type */
-        u8_t value_type;
-        /* object value length (in u8_t) */
-        u8_t value_len;
-        /* object value */
-        void *value;
-
-        /* encoding varbind seq length length */
-        u8_t seqlenlen;
-        /* encoding object identifier length length */
-        u8_t olenlen;
-        /* encoding object value length length */
-        u8_t vlenlen;
-        /* encoding varbind seq length */
-        u16_t seqlen;
-        /* encoding object identifier length */
-        u16_t olen;
-        /* encoding object value length */
-        u16_t vlen;
-    };
-
-    struct snmp_varbind_root {
-        struct snmp_varbind *head;
-        struct snmp_varbind *tail;
-        /* number of variable bindings in list */
-        u8_t count;
-        /* encoding varbind-list seq length length */
-        u8_t seqlenlen;
-        /* encoding varbind-list seq length */
-        u16_t seqlen;
-    };
-
-/** output response message header length fields */
-    struct snmp_resp_header_lengths {
-        /* encoding error-index length length */
-        u8_t erridxlenlen;
-        /* encoding error-status length length */
-        u8_t errstatlenlen;
-        /* encoding request id length length */
-        u8_t ridlenlen;
-        /* encoding pdu length length */
-        u8_t pdulenlen;
-        /* encoding community length length */
-        u8_t comlenlen;
-        /* encoding version length length */
-        u8_t verlenlen;
-        /* encoding sequence length length */
-        u8_t seqlenlen;
-
-        /* encoding error-index length */
-        u16_t erridxlen;
-        /* encoding error-status length */
-        u16_t errstatlen;
-        /* encoding request id length */
-        u16_t ridlen;
-        /* encoding pdu length */
-        u16_t pdulen;
-        /* encoding community length */
-        u16_t comlen;
-        /* encoding version length */
-        u16_t verlen;
-        /* encoding sequence length */
-        u16_t seqlen;
-    };
-
-/** output response message header length fields */
-    struct snmp_trap_header_lengths {
-        /* encoding timestamp length length */
-        u8_t tslenlen;
-        /* encoding specific-trap length length */
-        u8_t strplenlen;
-        /* encoding generic-trap length length */
-        u8_t gtrplenlen;
-        /* encoding agent-addr length length */
-        u8_t aaddrlenlen;
-        /* encoding enterprise-id length length */
-        u8_t eidlenlen;
-        /* encoding pdu length length */
-        u8_t pdulenlen;
-        /* encoding community length length */
-        u8_t comlenlen;
-        /* encoding version length length */
-        u8_t verlenlen;
-        /* encoding sequence length length */
-        u8_t seqlenlen;
-
-        /* encoding timestamp length */
-        u16_t tslen;
-        /* encoding specific-trap length */
-        u16_t strplen;
-        /* encoding generic-trap length */
-        u16_t gtrplen;
-        /* encoding agent-addr length */
-        u16_t aaddrlen;
-        /* encoding enterprise-id length */
-        u16_t eidlen;
-        /* encoding pdu length */
-        u16_t pdulen;
-        /* encoding community length */
-        u16_t comlen;
-        /* encoding version length */
-        u16_t verlen;
-        /* encoding sequence length */
-        u16_t seqlen;
-    };
-
-/* Accepting new SNMP messages. */
-#define SNMP_MSG_EMPTY                 0
-/* Search for matching object for variable binding. */
-#define SNMP_MSG_SEARCH_OBJ            1
-/* Perform SNMP operation on in-memory object.
-   Pass-through states, for symmetry only. */
-#define SNMP_MSG_INTERNAL_GET_OBJDEF   2
-#define SNMP_MSG_INTERNAL_GET_VALUE    3
-#define SNMP_MSG_INTERNAL_SET_TEST     4
-#define SNMP_MSG_INTERNAL_GET_OBJDEF_S 5
-#define SNMP_MSG_INTERNAL_SET_VALUE    6
-/* Perform SNMP operation on object located externally.
-   In theory this could be used for building a proxy agent.
-   Practical use is for an enterprise spc. app. gateway. */
-#define SNMP_MSG_EXTERNAL_GET_OBJDEF   7
-#define SNMP_MSG_EXTERNAL_GET_VALUE    8
-#define SNMP_MSG_EXTERNAL_SET_TEST     9
-#define SNMP_MSG_EXTERNAL_GET_OBJDEF_S 10
-#define SNMP_MSG_EXTERNAL_SET_VALUE    11
-
-#define SNMP_COMMUNITY_STR_LEN 64
-    struct snmp_msg_pstat {
-        /* lwIP local port (161) binding */
-        struct udp_pcb *pcb;
-        /* source IP address */
-        struct ip_addr sip;
-        /* source UDP port */
-        u16_t sp;
-        /* request type */
-        u8_t rt;
-        /* request ID */
-        s32_t rid;
-        /* error status */
-        s32_t error_status;
-        /* error index */
-        s32_t error_index;
-        /* community name (zero terminated) */
-        u8_t community[SNMP_COMMUNITY_STR_LEN + 1];
-        /* community string length (exclusive zero term) */
-        u8_t com_strlen;
-        /* one out of MSG_EMPTY, MSG_DEMUX, MSG_INTERNAL, MSG_EXTERNAL_x */
-        u8_t state;
-        /* saved arguments for MSG_EXTERNAL_x */
-        struct mib_external_node *ext_mib_node;
-        struct snmp_name_ptr ext_name_ptr;
-        struct obj_def ext_object_def;
-        struct snmp_obj_id ext_oid;
-        /* index into input variable binding list */
-        u8_t vb_idx;
-        /* ptr into input variable binding list */
-        struct snmp_varbind *vb_ptr;
-        /* list of variable bindings from input */
-        struct snmp_varbind_root invb;
-        /* list of variable bindings to output */
-        struct snmp_varbind_root outvb;
-        /* output response lengths used in ASN encoding */
-        struct snmp_resp_header_lengths rhl;
-    };
-
-    struct snmp_msg_trap {
-        /* lwIP local port (161) binding */
-        struct udp_pcb *pcb;
-        /* destination IP address in network order */
-        struct ip_addr dip;
-
-        /* source enterprise ID (sysObjectID) */
-        struct snmp_obj_id *enterprise;
-        /* source IP address, raw network order format */
-        u8_t sip_raw[4];
-        /* generic trap code */
-        u32_t gen_trap;
-        /* specific trap code */
-        u32_t spc_trap;
-        /* timestamp */
-        u32_t ts;
-        /* list of variable bindings to output */
-        struct snmp_varbind_root outvb;
-        /* output trap lengths used in ASN encoding */
-        struct snmp_trap_header_lengths thl;
-    };
-
-/** Agent Version constant, 0 = v1 oddity */
-    extern const s32_t snmp_version;
-/** Agent default "public" community string */
-    extern const char snmp_publiccommunity[7];
-
-    extern struct snmp_msg_trap trap_msg;
-
-/** Agent setup, start listening to port 161. */
-    void snmp_init(void);
-    void snmp_trap_dst_enable(u8_t dst_idx, u8_t enable);
-    void snmp_trap_dst_ip_set(u8_t dst_idx, struct ip_addr *dst);
-
-/** Varbind-list functions. */
-    struct snmp_varbind *snmp_varbind_alloc(struct snmp_obj_id *oid, u8_t type,
-                                            u8_t len);
-    void snmp_varbind_free(struct snmp_varbind *vb);
-    void snmp_varbind_list_free(struct snmp_varbind_root *root);
-    void snmp_varbind_tail_add(struct snmp_varbind_root *root,
-                               struct snmp_varbind *vb);
-    struct snmp_varbind *snmp_varbind_tail_remove(struct snmp_varbind_root
-                                                  *root);
-
-/** Handle an internal (recv) or external (private response) event. */
-    void snmp_msg_event(u8_t request_id);
-    err_t snmp_send_response(struct snmp_msg_pstat *m_stat);
-    err_t snmp_send_trap(s8_t generic_trap, struct snmp_obj_id *eoid,
-                         s32_t specific_trap);
-    void snmp_coldstart_trap(void);
-    void snmp_authfail_trap(void);
-
-#ifdef __cplusplus
-}
-#endif
-#endif                          /* LWIP_SNMP */
-#endif                          /* __LWIP_SNMP_MSG_H__ */
diff --git a/include/lwip/snmp_structs.h b/include/lwip/snmp_structs.h
deleted file mode 100644
index a3f430d..0000000
--- a/include/lwip/snmp_structs.h
+++ /dev/null
@@ -1,273 +0,0 @@
-/**
- * @file
- * Generic MIB tree structures.
- *
- * @todo namespace prefixes
- */
-
-/*
- * Copyright (c) 2006 Axon Digital Design B.V., The Netherlands.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * Author: Christiaan Simons <christiaan.simons@axon.tv>
- */
-
-#ifndef __LWIP_SNMP_STRUCTS_H__
-#define __LWIP_SNMP_STRUCTS_H__
-
-#include "lwip/opt.h"
-
-#if LWIP_SNMP                   /* don't build if not configured for use in lwipopts.h */
-
-#include "lwip/snmp.h"
-
-#if SNMP_PRIVATE_MIB
-#include "private_mib.h"
-#endif
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* MIB object instance */
-#define MIB_OBJECT_NONE 0
-#define MIB_OBJECT_SCALAR 1
-#define MIB_OBJECT_TAB 2
-
-/* MIB object access */
-#define MIB_OBJECT_READ_ONLY 0
-#define MIB_OBJECT_READ_WRITE 1
-#define MIB_OBJECT_WRITE_ONLY 2
-#define MIB_OBJECT_NOT_ACCESSIBLE 3
-
-/** object definition returned by (get_object_def)() */
-    struct obj_def {
-        /* MIB_OBJECT_NONE (0), MIB_OBJECT_SCALAR (1), MIB_OBJECT_TAB (2) */
-        u8_t instance;
-        /* 0 read-only, 1 read-write, 2 write-only, 3 not-accessible */
-        u8_t access;
-        /* ASN type for this object */
-        u8_t asn_type;
-        /* value length (host length) */
-        u16_t v_len;
-        /* length of instance part of supplied object identifier */
-        u8_t id_inst_len;
-        /* instance part of supplied object identifier */
-        s32_t *id_inst_ptr;
-    };
-
-    struct snmp_name_ptr {
-        u8_t ident_len;
-        s32_t *ident;
-    };
-
-/** MIB const scalar (.0) node */
-#define MIB_NODE_SC 0x01
-/** MIB const array node */
-#define MIB_NODE_AR 0x02
-/** MIB array node (mem_malloced from RAM) */
-#define MIB_NODE_RA 0x03
-/** MIB list root node (mem_malloced from RAM) */
-#define MIB_NODE_LR 0x04
-/** MIB node for external objects */
-#define MIB_NODE_EX 0x05
-
-/** node "base class" layout, the mandatory fields for a node  */
-    struct mib_node {
-  /** returns struct obj_def for the given object identifier */
-        void (*get_object_def) (u8_t ident_len, s32_t * ident,
-                                struct obj_def * od);
-  /** returns object value for the given object identifier,
-     @note the caller must allocate at least len bytes for the value */
-        void (*get_value) (struct obj_def * od, u16_t len, void *value);
-  /** tests length and/or range BEFORE setting */
-         u8_t(*set_test) (struct obj_def * od, u16_t len, void *value);
-  /** sets object value, only to be called when set_test()  */
-        void (*set_value) (struct obj_def * od, u16_t len, void *value);
-  /** One out of MIB_NODE_AR, MIB_NODE_LR or MIB_NODE_EX */
-        const u8_t node_type;
-        /* array or max list length */
-        const u16_t maxlength;
-    };
-
-/** derived node for scalars .0 index */
-    typedef struct mib_node mib_scalar_node;
-
-/** derived node, points to a fixed size const array
-    of sub-identifiers plus a 'child' pointer */
-    struct mib_array_node {
-        /* inherited "base class" members */
-        void (*const get_object_def) (u8_t ident_len, s32_t * ident,
-                                      struct obj_def * od);
-        void (*const get_value) (struct obj_def * od, u16_t len, void *value);
-         u8_t(*set_test) (struct obj_def * od, u16_t len, void *value);
-        void (*set_value) (struct obj_def * od, u16_t len, void *value);
-
-        const u8_t node_type;
-        const u16_t maxlength;
-
-        /* aditional struct members */
-        const s32_t *objid;
-        struct mib_node *const *nptr;
-    };
-
-/** derived node, points to a fixed size mem_malloced array
-    of sub-identifiers plus a 'child' pointer */
-    struct mib_ram_array_node {
-        /* inherited "base class" members */
-        void (*get_object_def) (u8_t ident_len, s32_t * ident,
-                                struct obj_def * od);
-        void (*get_value) (struct obj_def * od, u16_t len, void *value);
-         u8_t(*set_test) (struct obj_def * od, u16_t len, void *value);
-        void (*set_value) (struct obj_def * od, u16_t len, void *value);
-
-        u8_t node_type;
-        u16_t maxlength;
-
-        /* aditional struct members */
-        s32_t *objid;
-        struct mib_node **nptr;
-    };
-
-    struct mib_list_node {
-        struct mib_list_node *prev;
-        struct mib_list_node *next;
-        s32_t objid;
-        struct mib_node *nptr;
-    };
-
-/** derived node, points to a doubly linked list
-    of sub-identifiers plus a 'child' pointer */
-    struct mib_list_rootnode {
-        /* inherited "base class" members */
-        void (*get_object_def) (u8_t ident_len, s32_t * ident,
-                                struct obj_def * od);
-        void (*get_value) (struct obj_def * od, u16_t len, void *value);
-         u8_t(*set_test) (struct obj_def * od, u16_t len, void *value);
-        void (*set_value) (struct obj_def * od, u16_t len, void *value);
-
-        u8_t node_type;
-        u16_t maxlength;
-
-        /* aditional struct members */
-        struct mib_list_node *head;
-        struct mib_list_node *tail;
-        /* counts list nodes in list  */
-        u16_t count;
-    };
-
-/** derived node, has access functions for mib object in external memory or device
-    using 'tree_level' and 'idx', with a range 0 .. (level_length() - 1) */
-    struct mib_external_node {
-        /* inherited "base class" members */
-        void (*get_object_def) (u8_t ident_len, s32_t * ident,
-                                struct obj_def * od);
-        void (*get_value) (struct obj_def * od, u16_t len, void *value);
-         u8_t(*set_test) (struct obj_def * od, u16_t len, void *value);
-        void (*set_value) (struct obj_def * od, u16_t len, void *value);
-
-        u8_t node_type;
-        u16_t maxlength;
-
-        /* aditional struct members */
-  /** points to an extenal (in memory) record of some sort of addressing
-      information, passed to and interpreted by the funtions below */
-        void *addr_inf;
-  /** tree levels under this node */
-        u8_t tree_levels;
-  /** number of objects at this level */
-         u16_t(*level_length) (void *addr_inf, u8_t level);
-  /** compares object sub identifier with external id
-      return zero when equal, nonzero when unequal */
-         s32_t(*ident_cmp) (void *addr_inf, u8_t level, u16_t idx,
-                            s32_t sub_id);
-        void (*get_objid) (void *addr_inf, u8_t level, u16_t idx,
-                           s32_t * sub_id);
-
-  /** async Questions */
-        void (*get_object_def_q) (void *addr_inf, u8_t rid, u8_t ident_len,
-                                  s32_t * ident);
-        void (*get_value_q) (u8_t rid, struct obj_def * od);
-        void (*set_test_q) (u8_t rid, struct obj_def * od);
-        void (*set_value_q) (u8_t rid, struct obj_def * od, u16_t len,
-                             void *value);
-  /** async Answers */
-        void (*get_object_def_a) (u8_t rid, u8_t ident_len, s32_t * ident,
-                                  struct obj_def * od);
-        void (*get_value_a) (u8_t rid, struct obj_def * od, u16_t len,
-                             void *value);
-         u8_t(*set_test_a) (u8_t rid, struct obj_def * od, u16_t len,
-                            void *value);
-        void (*set_value_a) (u8_t rid, struct obj_def * od, u16_t len,
-                             void *value);
-  /** async Panic Close (agent returns error reply, 
-      e.g. used for external transaction cleanup) */
-        void (*get_object_def_pc) (u8_t rid, u8_t ident_len, s32_t * ident);
-        void (*get_value_pc) (u8_t rid, struct obj_def * od);
-        void (*set_test_pc) (u8_t rid, struct obj_def * od);
-        void (*set_value_pc) (u8_t rid, struct obj_def * od);
-    };
-
-/** export MIB tree from mib2.c */
-    extern const struct mib_array_node internet;
-
-/** dummy function pointers for non-leaf MIB nodes from mib2.c */
-    void noleafs_get_object_def(u8_t ident_len, s32_t * ident,
-                                struct obj_def *od);
-    void noleafs_get_value(struct obj_def *od, u16_t len, void *value);
-    u8_t noleafs_set_test(struct obj_def *od, u16_t len, void *value);
-    void noleafs_set_value(struct obj_def *od, u16_t len, void *value);
-
-    void snmp_oidtoip(s32_t * ident, struct ip_addr *ip);
-    void snmp_iptooid(struct ip_addr *ip, s32_t * ident);
-    void snmp_ifindextonetif(s32_t ifindex, struct netif **netif);
-    void snmp_netiftoifindex(struct netif *netif, s32_t * ifidx);
-
-    struct mib_list_node *snmp_mib_ln_alloc(s32_t id);
-    void snmp_mib_ln_free(struct mib_list_node *ln);
-    struct mib_list_rootnode *snmp_mib_lrn_alloc(void);
-    void snmp_mib_lrn_free(struct mib_list_rootnode *lrn);
-
-    s8_t snmp_mib_node_insert(struct mib_list_rootnode *rn, s32_t objid,
-                              struct mib_list_node **insn);
-    s8_t snmp_mib_node_find(struct mib_list_rootnode *rn, s32_t objid,
-                            struct mib_list_node **fn);
-    struct mib_list_rootnode *snmp_mib_node_delete(struct mib_list_rootnode *rn,
-                                                   struct mib_list_node *n);
-
-    struct mib_node *snmp_search_tree(struct mib_node *node, u8_t ident_len,
-                                      s32_t * ident, struct snmp_name_ptr *np);
-    struct mib_node *snmp_expand_tree(struct mib_node *node, u8_t ident_len,
-                                      s32_t * ident,
-                                      struct snmp_obj_id *oidret);
-    u8_t snmp_iso_prefix_tst(u8_t ident_len, s32_t * ident);
-    u8_t snmp_iso_prefix_expand(u8_t ident_len, s32_t * ident,
-                                struct snmp_obj_id *oidret);
-
-#ifdef __cplusplus
-}
-#endif
-#endif                          /* LWIP_SNMP */
-#endif                          /* __LWIP_SNMP_STRUCTS_H__ */
diff --git a/include/lwip/sock_chan_support.h b/include/lwip/sock_chan_support.h
deleted file mode 100644
index 9dae052..0000000
--- a/include/lwip/sock_chan_support.h
+++ /dev/null
@@ -1,32 +0,0 @@
-/**
- * \file
- * \brief Barrelfish waitset and channel support for LWIP.
- */
-
-/*
- * Copyright (c) 2012, 2013, ETH Zurich.
- * All rights reserved.
- *
- * This file is distributed under the terms in the attached LICENSE file.
- * If you do not find this file, copies can be found by writing to:
- * ETH Zurich D-INFK, CAB F.78, Universitaetstr. 6, CH-8092 Zurich,
- * Attn: Systems Group.
- */
-
-#ifndef __LWIP_CHAN_SUPPORT_H__
-#define __LWIP_CHAN_SUPPORT_H__
-
-#include <barrelfish/waitset.h>
-#include <errors/errno.h>
-
-#include <stdbool.h>
-
-bool lwip_sock_ready_read(int socket);
-bool lwip_sock_ready_write(int socket);
-
-errval_t lwip_sock_waitset_deregister_read(int socket);
-errval_t lwip_sock_waitset_register_read(int socket, struct waitset *ws);
-errval_t lwip_sock_waitset_deregister_write(int socket);
-errval_t lwip_sock_waitset_register_write(int socket, struct waitset *ws);
-
-#endif /* __LWIP_CHAN_SUPPORT_H__ */
diff --git a/include/lwip/sock_serialise.h b/include/lwip/sock_serialise.h
deleted file mode 100644
index 66246d9..0000000
--- a/include/lwip/sock_serialise.h
+++ /dev/null
@@ -1,23 +0,0 @@
-#ifndef SOCK_SERIALISE_H
-#define SOCK_SERIALISE_H
-
-#include "lwip/sockets.h"
-#include "lwip/tcp.h"
-#include "lwip/api.h"
-
-// IK
-// ports are in host order
-struct lwip_sockinfo {
-    struct ip_addr local_ip;
-    u16_t local_port;
-    struct ip_addr remote_ip;
-    u16_t remote_port;
-    struct tcp_pcb tcp_state;
-    struct netconn netconn_state;
-
-};
-
-int lwip_serialise_sock(int s, struct lwip_sockinfo *si);
-int lwip_deserialise_sock(int s, struct lwip_sockinfo *si);
-
-#endif
diff --git a/include/lwip/sockets.h b/include/lwip/sockets.h
deleted file mode 100644
index fea9789..0000000
--- a/include/lwip/sockets.h
+++ /dev/null
@@ -1,349 +0,0 @@
-/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved. 
- * 
- * Redistribution and use in source and binary forms, with or without modification, 
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission. 
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- * 
- * Author: Adam Dunkels <adam@sics.se>
- *
- */
-
-
-#ifndef __LWIP_SOCKETS_H__
-#define __LWIP_SOCKETS_H__
-
-#include "lwip/opt.h"
-
-#if LWIP_SOCKET                 /* don't build if not configured for use in lwipopts.h */
-
-#include <stddef.h>             /* for size_t */
-#include <fcntl.h>
-/* We use our own verions of FD_SETSIZE, FD_SET, FD_ISSET, FD_ZERO, FD_CLR */
-#include <sys/select.h>
-
-#include "lwip/ip_addr.h"
-#include "lwip/inet.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* members are in network byte order */
-    struct sockaddr_in {
-        u8_t sin_len;
-        u8_t sin_family;
-        u16_t sin_port;
-        struct in_addr sin_addr;
-        char sin_zero[8];
-    };
-
-    struct sockaddr {
-        u8_t sa_len;
-        u8_t sa_family;
-        char sa_data[14];
-    };
-
-#ifndef socklen_t
-#define socklen_t u32_t
-#endif
-
-/* Socket protocol types (TCP/UDP/RAW) */
-#define SOCK_STREAM     1
-#define SOCK_DGRAM      2
-#define SOCK_RAW        3
-
-/*
- * Option flags per-socket. These must match the SOF_ flags in ip.h!
- */
-#define  SO_DEBUG       0x0001  /* Unimplemented: turn on debugging info recording */
-#define  SO_ACCEPTCONN  0x0002  /* socket has had listen() */
-//#define  SO_REUSEADDR   0x0004 /* Unimplemented: allow local address reuse */
-#define  SO_KEEPALIVE   0x0008  /* keep connections alive */
-#define  SO_DONTROUTE   0x0010  /* Unimplemented: just use interface addresses */
-#define  SO_BROADCAST   0x0020  /* permit to send and to receive broadcast messages (see IP_SOF_BROADCAST option) */
-#define  SO_USELOOPBACK 0x0040  /* Unimplemented: bypass hardware when possible */
-#define  SO_LINGER      0x0080  /* linger on close if data present */
-#define  SO_OOBINLINE   0x0100  /* Unimplemented: leave received OOB data in line */
-//#define  SO_REUSEPORT   0x0200 /* Unimplemented: allow local address & port reuse */
-
-#define SO_DONTLINGER   ((int)(~SO_LINGER))
-
-/*
- * Additional options, not kept in so_options.
- */
-#define SO_SNDBUF    0x1001     /* Unimplemented: send buffer size */
-#define SO_RCVBUF    0x1002     /* receive buffer size */
-#define SO_SNDLOWAT  0x1003     /* Unimplemented: send low-water mark */
-#define SO_RCVLOWAT  0x1004     /* Unimplemented: receive low-water mark */
-#define SO_SNDTIMEO  0x1005     /* Unimplemented: send timeout */
-#define SO_RCVTIMEO  0x1006     /* receive timeout */
-#define SO_ERROR     0x1007     /* get error status and clear */
-#define SO_TYPE      0x1008     /* get socket type */
-#define SO_CONTIMEO  0x1009     /* Unimplemented: connect timeout */
-#define SO_NO_CHECK  0x100a     /* don't create UDP checksum */
-
-
-/*
- * Structure used for manipulating linger option.
- */
-    struct linger {
-        int l_onoff;            /* option on/off */
-        int l_linger;           /* linger time */
-    };
-
-/*
- * Level number for (get/set)sockopt() to apply to socket itself.
- */
-#define  SOL_SOCKET  0xfff      /* options for socket level */
-
-
-#define AF_UNSPEC       0
-#define AF_INET         2
-#define PF_INET         AF_INET
-#define PF_UNSPEC       AF_UNSPEC
-
-#define IPPROTO_IP      0
-#define IPPROTO_TCP     6
-#define IPPROTO_UDP     17
-#define IPPROTO_UDPLITE 136
-
-/* Flags we can use with send and recv. */
-#define MSG_PEEK       0x01     /* Peeks at an incoming message */
-#define MSG_WAITALL    0x02     /* Unimplemented: Requests that the function block until the full amount of data requested can be returned */
-#define MSG_OOB        0x04     /* Unimplemented: Requests out-of-band data. The significance and semantics of out-of-band data are protocol-specific */
-#define MSG_DONTWAIT   0x08     /* Nonblocking i/o for this operation only */
-#define MSG_MORE       0x10     /* Sender will send more */
-
-
-/*
- * Options for level IPPROTO_IP
- */
-#define IP_TOS             1
-#define IP_TTL             2
-
-#if LWIP_TCP
-/*
- * Options for level IPPROTO_TCP
- */
-#define TCP_NODELAY    0x01     /* don't delay send to coalesce packets */
-#define TCP_KEEPALIVE  0x02     /* send KEEPALIVE probes when idle for pcb->keep_idle milliseconds */
-#define TCP_KEEPIDLE   0x03     /* set pcb->keep_idle  - Same as TCP_KEEPALIVE, but use seconds for get/setsockopt */
-#define TCP_KEEPINTVL  0x04     /* set pcb->keep_intvl - Use seconds for get/setsockopt */
-#define TCP_KEEPCNT    0x05     /* set pcb->keep_cnt   - Use number of probes sent for get/setsockopt */
-#endif                          /* LWIP_TCP */
-
-#if LWIP_UDP && LWIP_UDPLITE
-/*
- * Options for level IPPROTO_UDPLITE
- */
-#define UDPLITE_SEND_CSCOV 0x01 /* sender checksum coverage */
-#define UDPLITE_RECV_CSCOV 0x02 /* minimal receiver checksum coverage */
-#endif                          /* LWIP_UDP && LWIP_UDPLITE */
-
-
-#if LWIP_IGMP
-/*
- * Options and types for UDP multicast traffic handling
- */
-#define IP_ADD_MEMBERSHIP  3
-#define IP_DROP_MEMBERSHIP 4
-#define IP_MULTICAST_TTL   5
-#define IP_MULTICAST_IF    6
-#define IP_MULTICAST_LOOP  7
-
-    typedef struct ip_mreq {
-        struct in_addr imr_multiaddr;   /* IP multicast address of group */
-        struct in_addr imr_interface;   /* local IP address of interface */
-    } ip_mreq;
-#endif                          /* LWIP_IGMP */
-
-/*
- * The Type of Service provides an indication of the abstract
- * parameters of the quality of service desired.  These parameters are
- * to be used to guide the selection of the actual service parameters
- * when transmitting a datagram through a particular network.  Several
- * networks offer service precedence, which somehow treats high
- * precedence traffic as more important than other traffic (generally
- * by accepting only traffic above a certain precedence at time of high
- * load).  The major choice is a three way tradeoff between low-delay,
- * high-reliability, and high-throughput.
- * The use of the Delay, Throughput, and Reliability indications may
- * increase the cost (in some sense) of the service.  In many networks
- * better performance for one of these parameters is coupled with worse
- * performance on another.  Except for very unusual cases at most two
- * of these three indications should be set.
- */
-#define IPTOS_TOS_MASK          0x1E
-#define IPTOS_TOS(tos)          ((tos) & IPTOS_TOS_MASK)
-#define IPTOS_LOWDELAY          0x10
-#define IPTOS_THROUGHPUT        0x08
-#define IPTOS_RELIABILITY       0x04
-#define IPTOS_LOWCOST           0x02
-#define IPTOS_MINCOST           IPTOS_LOWCOST
-
-/*
- * The Network Control precedence designation is intended to be used
- * within a network only.  The actual use and control of that
- * designation is up to each network. The Internetwork Control
- * designation is intended for use by gateway control originators only.
- * If the actual use of these precedence designations is of concern to
- * a particular network, it is the responsibility of that network to
- * control the access to, and use of, those precedence designations.
- */
-#define IPTOS_PREC_MASK                 0xe0
-#define IPTOS_PREC(tos)                ((tos) & IPTOS_PREC_MASK)
-#define IPTOS_PREC_NETCONTROL           0xe0
-#define IPTOS_PREC_INTERNETCONTROL      0xc0
-#define IPTOS_PREC_CRITIC_ECP           0xa0
-#define IPTOS_PREC_FLASHOVERRIDE        0x80
-#define IPTOS_PREC_FLASH                0x60
-#define IPTOS_PREC_IMMEDIATE            0x40
-#define IPTOS_PREC_PRIORITY             0x20
-#define IPTOS_PREC_ROUTINE              0x00
-
-
-/*
- * Commands for ioctlsocket(),  taken from the BSD file fcntl.h.
- * lwip_ioctl only supports FIONREAD and FIONBIO, for now
- *
- * Ioctl's have the command encoded in the lower word,
- * and the size of any in or out parameters in the upper
- * word.  The high 2 bits of the upper word are used
- * to encode the in/out status of the parameter; for now
- * we restrict parameters to at most 128 bytes.
- */
-#if !defined(FIONREAD) || !defined(FIONBIO)
-#include <sys/ioccom.h>
-#endif                          /* !defined(FIONREAD) || !defined(FIONBIO) */
-
-#ifndef FIONREAD
-#define FIONREAD    _IOR('f', 127, unsigned long)       /* get # bytes to read */
-#endif
-#ifndef FIONBIO
-#define FIONBIO     _IOW('f', 126, unsigned long)       /* set/clear non-blocking i/o */
-#endif
-
-/* Socket I/O Controls: unimplemented */
-#ifndef SIOCSHIWAT
-#define SIOCSHIWAT  _IOW('s',  0, unsigned long)        /* set high watermark */
-#define SIOCGHIWAT  _IOR('s',  1, unsigned long)        /* get high watermark */
-#define SIOCSLOWAT  _IOW('s',  2, unsigned long)        /* set low watermark */
-#define SIOCGLOWAT  _IOR('s',  3, unsigned long)        /* get low watermark */
-#define SIOCATMARK  _IOR('s',  7, unsigned long)        /* at oob mark? */
-#endif
-
-/* Socket flags: */
-#ifndef O_NONBLOCK
-#define O_NONBLOCK    04000U
-#endif
-
-/* FD_SET used for lwip_select */
-#ifndef FD_SET
-#undef  FD_SETSIZE
-    /* Make FD_SETSIZE match NUM_SOCKETS in socket.c */
-#define FD_SETSIZE    MEMP_NUM_NETCONN
-#define FD_SET(n, p)  ((p)->fd_bits[(n)/8] |=  (1 << ((n) & 7)))
-#define FD_CLR(n, p)  ((p)->fd_bits[(n)/8] &= ~(1 << ((n) & 7)))
-#define FD_ISSET(n,p) ((p)->fd_bits[(n)/8] &   (1 << ((n) & 7)))
-#define FD_ZERO(p)    memset((void*)(p),0,sizeof(*(p)))
-
-    typedef struct fd_set {
-        unsigned char fd_bits[(FD_SETSIZE + 7) / 8];
-    } fd_set;
-
-#endif                          /* FD_SET */
-
-/** LWIP_TIMEVAL_PRIVATE: if you want to use the struct timeval provided
- * by your system, set this to 0 and include <sys/time.h> in cc.h */
-#ifndef LWIP_TIMEVAL_PRIVATE
-#define LWIP_TIMEVAL_PRIVATE 0
-#endif
-
-#if LWIP_TIMEVAL_PRIVATE
-    struct timeval {
-        long tv_sec;            /* seconds */
-        long tv_usec;           /* and microseconds */
-    };
-#endif                          /* LWIP_TIMEVAL_PRIVATE */
-
-    void lwip_socket_init(void);
-
-    int lwip_accept(int s, struct sockaddr *addr, socklen_t * addrlen);
-    int lwip_bind(int s, const struct sockaddr *name, socklen_t namelen);
-    int lwip_shutdown(int s, int how);
-    int lwip_getpeername(int s, struct sockaddr *name, socklen_t * namelen);
-    int lwip_getsockname(int s, struct sockaddr *name, socklen_t * namelen);
-    int lwip_getsockopt(int s, int level, int optname, void *optval,
-                        socklen_t * optlen);
-    int lwip_setsockopt(int s, int level, int optname, const void *optval,
-                        socklen_t optlen);
-    int lwip_close(int s);
-    int lwip_connect(int s, const struct sockaddr *name, socklen_t namelen);
-    int lwip_listen(int s, int backlog);
-    int lwip_recv(int s, void *mem, size_t len, int flags);
-    int lwip_read(int s, void *mem, size_t len);
-    int lwip_recvfrom(int s, void *mem, size_t len, int flags,
-                      struct sockaddr *from, socklen_t * fromlen);
-    int lwip_send(int s, const void *dataptr, size_t size, int flags);
-    int lwip_sendto(int s, const void *dataptr, size_t size, int flags,
-                    const struct sockaddr *to, socklen_t tolen);
-    int lwip_socket(int domain, int type, int protocol);
-    int lwip_write(int s, const void *dataptr, size_t size);
-    int lwip_select(int maxfdp1, fd_set * readset, fd_set * writeset,
-                    fd_set * exceptset, struct timeval *timeout);
-    int lwip_ioctl(int s, long cmd, void *argp);
-
-#if LWIP_COMPAT_SOCKETS
-#define accept(a,b,c)         lwip_accept(a,b,c)
-#define bind(a,b,c)           lwip_bind(a,b,c)
-#define shutdown(a,b)         lwip_shutdown(a,b)
-#define closesocket(s)        lwip_close(s)
-#define connect(a,b,c)        lwip_connect(a,b,c)
-#define getsockname(a,b,c)    lwip_getsockname(a,b,c)
-#define getpeername(a,b,c)    lwip_getpeername(a,b,c)
-#define setsockopt(a,b,c,d,e) lwip_setsockopt(a,b,c,d,e)
-#define getsockopt(a,b,c,d,e) lwip_getsockopt(a,b,c,d,e)
-#define listen(a,b)           lwip_listen(a,b)
-#define recv(a,b,c,d)         lwip_recv(a,b,c,d)
-#define recvfrom(a,b,c,d,e,f) lwip_recvfrom(a,b,c,d,e,f)
-#define send(a,b,c,d)         lwip_send(a,b,c,d)
-#define sendto(a,b,c,d,e,f)   lwip_sendto(a,b,c,d,e,f)
-#define socket(a,b,c)         lwip_socket(a,b,c)
-#define select(a,b,c,d,e)     lwip_select(a,b,c,d,e)
-#define ioctlsocket(a,b,c)    lwip_ioctl(a,b,c)
-
-#if LWIP_POSIX_SOCKETS_IO_NAMES
-#define read(a,b,c)           lwip_read(a,b,c)
-#define write(a,b,c)          lwip_write(a,b,c)
-#define close(s)              lwip_close(s)
-#endif                          /* LWIP_POSIX_SOCKETS_IO_NAMES */
-
-#endif                          /* LWIP_COMPAT_SOCKETS */
-
-#ifdef __cplusplus
-}
-#endif
-#endif                          /* LWIP_SOCKET */
-#endif                          /* __LWIP_SOCKETS_H__ */
diff --git a/include/lwip/stats.h b/include/lwip/stats.h
deleted file mode 100644
index a46a577..0000000
--- a/include/lwip/stats.h
+++ /dev/null
@@ -1,282 +0,0 @@
-/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved. 
- * 
- * Redistribution and use in source and binary forms, with or without modification, 
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission. 
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- * 
- * Author: Adam Dunkels <adam@sics.se>
- *
- */
-#ifndef __LWIP_STATS_H__
-#define __LWIP_STATS_H__
-
-#include "lwip/opt.h"
-
-#include "lwip/mem.h"
-#include "lwip/memp.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#if LWIP_STATS
-
-#ifndef LWIP_STATS_LARGE
-#define LWIP_STATS_LARGE 0
-#endif
-
-#if LWIP_STATS_LARGE
-#define STAT_COUNTER     u32_t
-#define STAT_COUNTER_F   U32_F
-#else
-#define STAT_COUNTER     u16_t
-#define STAT_COUNTER_F   U16_F
-#endif
-
-    struct stats_proto {
-        STAT_COUNTER xmit;      /* Transmitted packets. */
-        STAT_COUNTER recv;      /* Received packets. */
-        STAT_COUNTER fw;        /* Forwarded packets. */
-        STAT_COUNTER drop;      /* Dropped packets. */
-        STAT_COUNTER chkerr;    /* Checksum error. */
-        STAT_COUNTER lenerr;    /* Invalid length error. */
-        STAT_COUNTER memerr;    /* Out of memory error. */
-        STAT_COUNTER rterr;     /* Routing error. */
-        STAT_COUNTER proterr;   /* Protocol error. */
-        STAT_COUNTER opterr;    /* Error in options. */
-        STAT_COUNTER err;       /* Misc error. */
-        STAT_COUNTER cachehit;
-    };
-
-    struct stats_igmp {
-        STAT_COUNTER lenerr;    /* Invalid length error. */
-        STAT_COUNTER chkerr;    /* Checksum error. */
-        STAT_COUNTER v1_rxed;   /* */
-        STAT_COUNTER join_sent; /* */
-        STAT_COUNTER leave_sent;        /* */
-        STAT_COUNTER unicast_query;     /* */
-        STAT_COUNTER report_sent;       /* */
-        STAT_COUNTER report_rxed;       /* */
-        STAT_COUNTER group_query_rxed;  /* */
-    };
-
-    struct stats_mem {
-        mem_size_t avail;
-        mem_size_t used;
-        mem_size_t max;
-        STAT_COUNTER err;
-        STAT_COUNTER illegal;
-    };
-
-    struct stats_syselem {
-        STAT_COUNTER used;
-        STAT_COUNTER max;
-        STAT_COUNTER err;
-    };
-
-    struct stats_sys {
-        struct stats_syselem sem;
-        struct stats_syselem mbox;
-    };
-
-    struct stats_ {
-#if LINK_STATS
-        struct stats_proto link;
-#endif
-#if ETHARP_STATS
-        struct stats_proto etharp;
-#endif
-#if IPFRAG_STATS
-        struct stats_proto ip_frag;
-#endif
-#if IP_STATS
-        struct stats_proto ip;
-#endif
-#if ICMP_STATS
-        struct stats_proto icmp;
-#endif
-#if IGMP_STATS
-        struct stats_igmp igmp;
-#endif
-#if UDP_STATS
-        struct stats_proto udp;
-#endif
-#if TCP_STATS
-        struct stats_proto tcp;
-#endif
-#if MEM_STATS
-        struct stats_mem mem;
-#endif
-#if MEMP_STATS
-        struct stats_mem memp[MEMP_MAX];
-#endif
-#if SYS_STATS
-        struct stats_sys sys;
-#endif
-    };
-
-    extern struct stats_ lwip_stats;
-
-#define stats_init()            /* Compatibility define, not init needed. */
-
-#define STATS_INC(x) ++lwip_stats.x
-#define STATS_DEC(x) --lwip_stats.x
-#else
-#define stats_init()
-#define STATS_INC(x)
-#define STATS_DEC(x)
-#endif                          /* LWIP_STATS */
-
-#if TCP_STATS
-#define TCP_STATS_INC(x) STATS_INC(x)
-#define TCP_STATS_DISPLAY() stats_display_proto(&lwip_stats.tcp, "TCP")
-#else
-#define TCP_STATS_INC(x)
-#define TCP_STATS_DISPLAY()
-#endif
-
-#if UDP_STATS
-#define UDP_STATS_INC(x) STATS_INC(x)
-#define UDP_STATS_DISPLAY() stats_display_proto(&lwip_stats.udp, "UDP")
-#else
-#define UDP_STATS_INC(x)
-#define UDP_STATS_DISPLAY()
-#endif
-
-#if ICMP_STATS
-#define ICMP_STATS_INC(x) STATS_INC(x)
-#define ICMP_STATS_DISPLAY() stats_display_proto(&lwip_stats.icmp, "ICMP")
-#else
-#define ICMP_STATS_INC(x)
-#define ICMP_STATS_DISPLAY()
-#endif
-
-#if IGMP_STATS
-#define IGMP_STATS_INC(x) STATS_INC(x)
-#define IGMP_STATS_DISPLAY() stats_display_igmp(&lwip_stats.igmp)
-#else
-#define IGMP_STATS_INC(x)
-#define IGMP_STATS_DISPLAY()
-#endif
-
-#if IP_STATS
-#define IP_STATS_INC(x) STATS_INC(x)
-#define IP_STATS_DISPLAY() stats_display_proto(&lwip_stats.ip, "IP")
-#else
-#define IP_STATS_INC(x)
-#define IP_STATS_DISPLAY()
-#endif
-
-#if IPFRAG_STATS
-#define IPFRAG_STATS_INC(x) STATS_INC(x)
-#define IPFRAG_STATS_DISPLAY() stats_display_proto(&lwip_stats.ip_frag, "IP_FRAG")
-#else
-#define IPFRAG_STATS_INC(x)
-#define IPFRAG_STATS_DISPLAY()
-#endif
-
-#if ETHARP_STATS
-#define ETHARP_STATS_INC(x) STATS_INC(x)
-#define ETHARP_STATS_DISPLAY() stats_display_proto(&lwip_stats.etharp, "ETHARP")
-#else
-#define ETHARP_STATS_INC(x)
-#define ETHARP_STATS_DISPLAY()
-#endif
-
-#if LINK_STATS
-#define LINK_STATS_INC(x) STATS_INC(x)
-#define LINK_STATS_DISPLAY() stats_display_proto(&lwip_stats.link, "LINK")
-#else
-#define LINK_STATS_INC(x)
-#define LINK_STATS_DISPLAY()
-#endif
-
-#if MEM_STATS
-#define MEM_STATS_AVAIL(x, y) lwip_stats.mem.x = y
-#define MEM_STATS_INC(x) STATS_INC(mem.x)
-#define MEM_STATS_INC_USED(x, y) do { lwip_stats.mem.used += y; \
-                                    if (lwip_stats.mem.max < lwip_stats.mem.used) { \
-                                        lwip_stats.mem.max = lwip_stats.mem.used; \
-                                    } \
-                                 } while(0)
-#define MEM_STATS_DEC_USED(x, y) lwip_stats.mem.x -= y
-#define MEM_STATS_DISPLAY() stats_display_mem(&lwip_stats.mem, "HEAP")
-#else
-#define MEM_STATS_AVAIL(x, y)
-#define MEM_STATS_INC(x)
-#define MEM_STATS_INC_USED(x, y)
-#define MEM_STATS_DEC_USED(x, y)
-#define MEM_STATS_DISPLAY()
-#endif
-
-#if MEMP_STATS
-#define MEMP_STATS_AVAIL(x, i, y) lwip_stats.memp[i].x = y
-#define MEMP_STATS_INC(x, i) STATS_INC(memp[i].x)
-#define MEMP_STATS_DEC(x, i) STATS_DEC(memp[i].x)
-#define MEMP_STATS_INC_USED(x, i) do { ++lwip_stats.memp[i].used; \
-                                    if (lwip_stats.memp[i].max < lwip_stats.memp[i].used) { \
-                                        lwip_stats.memp[i].max = lwip_stats.memp[i].used; \
-                                    } \
-                                 } while(0)
-#define MEMP_STATS_DISPLAY(i) stats_display_memp(&lwip_stats.memp[i], i)
-#else
-#define MEMP_STATS_AVAIL(x, i, y)
-#define MEMP_STATS_INC(x, i)
-#define MEMP_STATS_DEC(x, i)
-#define MEMP_STATS_INC_USED(x, i)
-#define MEMP_STATS_DISPLAY(i)
-#endif
-
-#if SYS_STATS
-#define SYS_STATS_INC(x) STATS_INC(sys.x)
-#define SYS_STATS_DEC(x) STATS_DEC(sys.x)
-#define SYS_STATS_DISPLAY() stats_display_sys(&lwip_stats.sys)
-#else
-#define SYS_STATS_INC(x)
-#define SYS_STATS_DEC(x)
-#define SYS_STATS_DISPLAY()
-#endif
-
-/* Display of statistics */
-#if LWIP_STATS_DISPLAY
-    void stats_display(void);
-    void stats_display_proto(struct stats_proto *proto, char *name);
-    void stats_display_igmp(struct stats_igmp *igmp);
-    void stats_display_mem(struct stats_mem *mem, char *name);
-    void stats_display_memp(struct stats_mem *mem, int index);
-    void stats_display_sys(struct stats_sys *sys);
-#else
-#define stats_display()
-#define stats_display_proto(proto, name)
-#define stats_display_igmp(igmp)
-#define stats_display_mem(mem, name)
-#define stats_display_memp(mem, index)
-#define stats_display_sys(sys)
-#endif                          /* LWIP_STATS_DISPLAY */
-
-#ifdef __cplusplus
-}
-#endif
-#endif                          /* __LWIP_STATS_H__ */
diff --git a/include/lwip/sys.h b/include/lwip/sys.h
deleted file mode 100644
index 28a6a51..0000000
--- a/include/lwip/sys.h
+++ /dev/null
@@ -1,250 +0,0 @@
-/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved. 
- * 
- * Redistribution and use in source and binary forms, with or without modification, 
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission. 
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- * 
- * Author: Adam Dunkels <adam@sics.se>
- *
- */
-#ifndef __LWIP_SYS_H__
-#define __LWIP_SYS_H__
-
-#include "lwip/opt.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#if NO_SYS
-
-/* For a totally minimal and standalone system, we provide null
-   definitions of the sys_ functions. */
-    typedef u8_t sys_sem_t;
-    typedef u8_t sys_mbox_t;
-    struct sys_timeo {
-        u8_t dummy;
-    };
-
-#define sys_init()
-#define sys_timeout(m,h,a)
-#define sys_untimeout(m,a)
-#define sys_sem_new(c) c
-#define sys_sem_signal(s)
-#define sys_sem_wait(s)
-#define sys_sem_wait_timeout(s,t)
-#define sys_arch_sem_wait(s,t)
-#define sys_sem_free(s)
-#define sys_mbox_new(s) 0
-#define sys_mbox_fetch(m,d)
-#define sys_mbox_tryfetch(m,d)
-#define sys_mbox_post(m,d)
-#define sys_mbox_trypost(m,d)
-#define sys_mbox_free(m)
-
-#define sys_thread_new(n,t,a,s,p)
-
-#else                           /* NO_SYS */
-
-/** Return code for timeouts from sys_arch_mbox_fetch and sys_arch_sem_wait */
-#define SYS_ARCH_TIMEOUT 0xffffffffUL
-
-/* sys_mbox_tryfetch returns SYS_MBOX_EMPTY if appropriate.
- * For now we use the same magic value, but we allow this to change in future.
- */
-#define SYS_MBOX_EMPTY SYS_ARCH_TIMEOUT
-
-#include "lwip/err.h"
-#include "arch/sys_arch.h"
-
-    typedef void (*sys_timeout_handler) (void *arg);
-
-    struct sys_timeo {
-        struct sys_timeo *next;
-        u32_t time;
-        sys_timeout_handler h;
-        void *arg;
-    };
-
-    struct sys_timeouts {
-        struct sys_timeo *next;
-    };
-
-/* sys_init() must be called before anthing else. */
-    void sys_init(void);
-
-/*
- * sys_timeout():
- *
- * Schedule a timeout a specified amount of milliseconds in the
- * future. When the timeout occurs, the specified timeout handler will
- * be called. The handler will be passed the "arg" argument when
- * called.
- *
- */
-    void sys_timeout(u32_t msecs, sys_timeout_handler h, void *arg);
-    void sys_untimeout(sys_timeout_handler h, void *arg);
-    struct sys_timeouts *sys_arch_timeouts(void);
-
-/* Semaphore functions. */
-    sys_sem_t sys_sem_new(u8_t count);
-    void sys_sem_signal(sys_sem_t sem);
-    u32_t sys_arch_sem_wait(sys_sem_t sem, u32_t timeout);
-    void sys_sem_free(sys_sem_t sem);
-    void sys_sem_wait(sys_sem_t sem);
-    int sys_sem_wait_timeout(sys_sem_t sem, u32_t timeout);
-
-/* Time functions. */
-#ifndef sys_msleep
-    void sys_msleep(u32_t ms);  /* only has a (close to) 1 jiffy resolution. */
-#endif
-#ifndef sys_jiffies
-    u32_t sys_jiffies(void);    /* since power up. */
-#endif
-
-/* Mailbox functions. */
-    sys_mbox_t sys_mbox_new(int size);
-    void sys_mbox_post(sys_mbox_t mbox, void *msg);
-    err_t sys_mbox_trypost(sys_mbox_t mbox, void *msg);
-    u32_t sys_arch_mbox_fetch(sys_mbox_t mbox, void **msg, u32_t timeout);
-#ifndef sys_arch_mbox_tryfetch  /* Allow port to override with a macro */
-    u32_t sys_arch_mbox_tryfetch(sys_mbox_t mbox, void **msg);
-#endif
-/* For now, we map straight to sys_arch implementation. */
-#define sys_mbox_tryfetch(mbox, msg) sys_arch_mbox_tryfetch(mbox, msg)
-    void sys_mbox_free(sys_mbox_t mbox);
-    void sys_mbox_fetch(sys_mbox_t mbox, void **msg);
-
-/* Thread functions. */
-    sys_thread_t sys_thread_new(char *name, void (*thread) (void *arg),
-                                void *arg, int stacksize, int prio);
-
-#endif                          /* NO_SYS */
-
-/** Returns the current time in milliseconds. */
-    u32_t sys_now(void);
-
-/* Critical Region Protection */
-/* These functions must be implemented in the sys_arch.c file.
-   In some implementations they can provide a more light-weight protection
-   mechanism than using semaphores. Otherwise semaphores can be used for
-   implementation */
-#ifndef SYS_ARCH_PROTECT
-/** SYS_LIGHTWEIGHT_PROT
- * define SYS_LIGHTWEIGHT_PROT in lwipopts.h if you want inter-task protection
- * for certain critical regions during buffer allocation, deallocation and memory
- * allocation and deallocation.
- */
-#if SYS_LIGHTWEIGHT_PROT
-
-/** SYS_ARCH_DECL_PROTECT
- * declare a protection variable. This macro will default to defining a variable of
- * type sys_prot_t. If a particular port needs a different implementation, then
- * this macro may be defined in sys_arch.h.
- */
-#define SYS_ARCH_DECL_PROTECT(lev) sys_prot_t lev
-/** SYS_ARCH_PROTECT
- * Perform a "fast" protect. This could be implemented by
- * disabling interrupts for an embedded system or by using a semaphore or
- * mutex. The implementation should allow calling SYS_ARCH_PROTECT when
- * already protected. The old protection level is returned in the variable
- * "lev". This macro will default to calling the sys_arch_protect() function
- * which should be implemented in sys_arch.c. If a particular port needs a
- * different implementation, then this macro may be defined in sys_arch.h
- */
-#define SYS_ARCH_PROTECT(lev) lev = sys_arch_protect()
-/** SYS_ARCH_UNPROTECT
- * Perform a "fast" set of the protection level to "lev". This could be
- * implemented by setting the interrupt level to "lev" within the MACRO or by
- * using a semaphore or mutex.  This macro will default to calling the
- * sys_arch_unprotect() function which should be implemented in
- * sys_arch.c. If a particular port needs a different implementation, then
- * this macro may be defined in sys_arch.h
- */
-#define SYS_ARCH_UNPROTECT(lev) sys_arch_unprotect(lev)
-    sys_prot_t sys_arch_protect(void);
-    void sys_arch_unprotect(sys_prot_t pval);
-
-#else
-
-#define SYS_ARCH_DECL_PROTECT(lev)
-#define SYS_ARCH_PROTECT(lev)
-#define SYS_ARCH_UNPROTECT(lev)
-
-#endif                          /* SYS_LIGHTWEIGHT_PROT */
-
-#endif                          /* SYS_ARCH_PROTECT */
-
-/*
- * Macros to set/get and increase/decrease variables in a thread-safe way.
- * Use these for accessing variable that are used from more than one thread.
- */
-
-#ifndef SYS_ARCH_INC
-#define SYS_ARCH_INC(var, val) do { \
-                                SYS_ARCH_DECL_PROTECT(old_level); \
-                                SYS_ARCH_PROTECT(old_level); \
-                                var += val; \
-                                SYS_ARCH_UNPROTECT(old_level); \
-                              } while(0)
-#endif                          /* SYS_ARCH_INC */
-
-#ifndef SYS_ARCH_DEC
-#define SYS_ARCH_DEC(var, val) do { \
-                                SYS_ARCH_DECL_PROTECT(old_level); \
-                                SYS_ARCH_PROTECT(old_level); \
-                                var -= val; \
-                                SYS_ARCH_UNPROTECT(old_level); \
-                              } while(0)
-#endif                          /* SYS_ARCH_DEC */
-
-#ifndef SYS_ARCH_GET
-#define SYS_ARCH_GET(var, ret) do { \
-                                SYS_ARCH_DECL_PROTECT(old_level); \
-                                SYS_ARCH_PROTECT(old_level); \
-                                ret = var; \
-                                SYS_ARCH_UNPROTECT(old_level); \
-                              } while(0)
-#endif                          /* SYS_ARCH_GET */
-
-#ifndef SYS_ARCH_SET
-#define SYS_ARCH_SET(var, val) do { \
-                                SYS_ARCH_DECL_PROTECT(old_level); \
-                                SYS_ARCH_PROTECT(old_level); \
-                                var = val; \
-                                SYS_ARCH_UNPROTECT(old_level); \
-                              } while(0)
-#endif                          /* SYS_ARCH_SET */
-
-
-#ifdef __cplusplus
-}
-#endif
-extern struct thread_mutex *lwip_mutex;
-
-void lwip_mutex_lock(void);
-void lwip_mutex_unlock(void);
-
-#endif                          /* __LWIP_SYS_H__ */
diff --git a/include/lwip/tcp.h b/include/lwip/tcp.h
deleted file mode 100644
index bf4bdca..0000000
--- a/include/lwip/tcp.h
+++ /dev/null
@@ -1,695 +0,0 @@
-/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved. 
- * 
- * Redistribution and use in source and binary forms, with or without modification, 
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission. 
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- * 
- * Author: Adam Dunkels <adam@sics.se>
- *
- */
-#ifndef __LWIP_TCP_H__
-#define __LWIP_TCP_H__
-
-#include "lwip/opt.h"
-
-#if LWIP_TCP                    /* don't build if not configured for use in lwipopts.h */
-
-#include "lwip/sys.h"
-#include "lwip/mem.h"
-#include "lwip/pbuf.h"
-#include "lwip/ip.h"
-#include "lwip/icmp.h"
-#include "lwip/err.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-    struct tcp_pcb;
-
-/* Functions for interfacing with TCP: */
-
-/* Lower layer interface to TCP: */
-#define tcp_init()              /* Compatibility define, not init needed. */
-    void tcp_tmr(void);         /* Must be called every
-                                   TCP_TMR_INTERVAL
-                                   ms. (Typically 250 ms). */
-/* Application program's interface: */
-    struct tcp_pcb *tcp_new(void);
-    struct tcp_pcb *tcp_alloc(u8_t prio);
-
-    void tcp_arg(struct tcp_pcb *pcb, void *arg);
-    void tcp_accept(struct tcp_pcb *pcb,
-                    err_t(*accept) (void *arg, struct tcp_pcb * newpcb,
-                                    err_t err));
-    void tcp_recv(struct tcp_pcb *pcb,
-                  err_t(*recv) (void *arg, struct tcp_pcb * tpcb,
-                                struct pbuf * p, err_t err));
-    void tcp_sent(struct tcp_pcb *pcb,
-                  err_t(*sent) (void *arg, struct tcp_pcb * tpcb, u16_t len));
-    void tcp_poll(struct tcp_pcb *pcb,
-                  err_t(*poll) (void *arg, struct tcp_pcb * tpcb),
-                  u8_t interval);
-    void tcp_err(struct tcp_pcb *pcb, void (*err) (void *arg, err_t err));
-
-#define          tcp_mss(pcb)      ((pcb)->mss)
-#define          tcp_sndbuf(pcb)   ((pcb)->snd_buf)
-
-#if TCP_LISTEN_BACKLOG
-#define          tcp_accepted(pcb) (((struct tcp_pcb_listen *)(pcb))->accepts_pending--)
-#else                           /* TCP_LISTEN_BACKLOG */
-#define          tcp_accepted(pcb)
-#endif                          /* TCP_LISTEN_BACKLOG */
-
-    void tcp_recved(struct tcp_pcb *pcb, u16_t len);
-    err_t tcp_bind(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port);
-    err_t tcp_redirect(struct tcp_pcb *pcb,
-                       struct ip_addr *local_ip,
-                       u16_t local_port,
-                       struct ip_addr *remote_ip, u16_t remote_port);
-     err_t
-      tcp_pause(struct tcp_pcb *pcb, struct ip_addr *local_ip, u16_t local_port,
-                struct ip_addr *remote_ip, u16_t remote_port);
-    err_t tcp_connect(struct tcp_pcb *pcb, struct ip_addr *ipaddr,
-                      u16_t port, err_t(*connected) (void *arg,
-                                                     struct tcp_pcb * tpcb,
-                                                     err_t err));
-
-    struct tcp_pcb *tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog);
-#define          tcp_listen(pcb) tcp_listen_with_backlog(pcb, TCP_DEFAULT_LISTEN_BACKLOG)
-
-    void tcp_abandon(struct tcp_pcb *pcb, int reset);
-#define          tcp_abort(pcb) tcp_abandon((pcb), 1)
-    err_t tcp_close(struct tcp_pcb *pcb);
-
-/* Flags for "apiflags" parameter in tcp_write and tcp_enqueue */
-#define TCP_WRITE_FLAG_COPY 0x01
-#define TCP_WRITE_FLAG_MORE 0x02
-
-    err_t tcp_write(struct tcp_pcb *pcb, const void *dataptr, u16_t len,
-                    u8_t apiflags);
-
-    void tcp_setprio(struct tcp_pcb *pcb, u8_t prio);
-
-#define TCP_PRIO_MIN    1
-#define TCP_PRIO_NORMAL 64
-#define TCP_PRIO_MAX    127
-
-/* It is also possible to call these two functions at the right
-   intervals (instead of calling tcp_tmr()). */
-    void tcp_slowtmr(void);
-    void tcp_fasttmr(void);
-
-
-/* Only used by IP to pass a TCP segment to TCP: */
-    void tcp_input(struct pbuf *p, struct netif *inp);
-/* Used within the TCP code only: */
-    err_t tcp_output(struct tcp_pcb *pcb);
-    void tcp_rexmit(struct tcp_pcb *pcb);
-    void tcp_rexmit_rto(struct tcp_pcb *pcb);
-    u32_t tcp_update_rcv_ann_wnd(struct tcp_pcb *pcb);
-
-/**
- * This is the Nagle algorithm: try to combine user data to send as few TCP
- * segments as possible. Only send if
- * - no previously transmitted data on the connection remains unacknowledged or
- * - the TF_NODELAY flag is set (nagle algorithm turned off for this pcb) or
- * - the only unsent segment is at least pcb->mss bytes long (or there is more
- *   than one unsent segment - with lwIP, this can happen although unsent->len < mss)
- */
-#define tcp_do_output_nagle(tpcb) ((((tpcb)->unacked == NULL) || \
-                            ((tpcb)->flags & TF_NODELAY) || \
-                            (((tpcb)->unsent != NULL) && (((tpcb)->unsent->next != NULL) || \
-                              ((tpcb)->unsent->len >= (tpcb)->mss))) \
-                            ) ? 1 : 0)
-#define tcp_output_nagle(tpcb) (tcp_do_output_nagle(tpcb) ? tcp_output(tpcb) : ERR_OK)
-
-
-#define TCP_SEQ_LT(a,b)     ((s32_t)((a)-(b)) < 0)
-#define TCP_SEQ_LEQ(a,b)    ((s32_t)((a)-(b)) <= 0)
-#define TCP_SEQ_GT(a,b)     ((s32_t)((a)-(b)) > 0)
-#define TCP_SEQ_GEQ(a,b)    ((s32_t)((a)-(b)) >= 0)
-/* is b<=a<=c? */
-#if 0                           /* see bug #10548 */
-#define TCP_SEQ_BETWEEN(a,b,c) ((c)-(b) >= (a)-(b))
-#endif
-#define TCP_SEQ_BETWEEN(a,b,c) (TCP_SEQ_GEQ(a,b) && TCP_SEQ_LEQ(a,c))
-#define TCP_FIN 0x01U
-#define TCP_SYN 0x02U
-#define TCP_RST 0x04U
-#define TCP_PSH 0x08U
-#define TCP_ACK 0x10U
-#define TCP_URG 0x20U
-#define TCP_ECE 0x40U
-#define TCP_CWR 0x80U
-
-#define TCP_FLAGS 0x3fU
-
-/* Length of the TCP header, excluding options. */
-#define TCP_HLEN 20
-
-#ifndef TCP_TMR_INTERVAL
-#define TCP_TMR_INTERVAL       250      /* The TCP timer interval in milliseconds. */
-#endif                          /* TCP_TMR_INTERVAL */
-
-#ifndef TCP_FAST_INTERVAL
-#define TCP_FAST_INTERVAL      TCP_TMR_INTERVAL /* the fine grained timeout in milliseconds */
-#endif                          /* TCP_FAST_INTERVAL */
-
-#ifndef TCP_SLOW_INTERVAL
-#define TCP_SLOW_INTERVAL      (2*TCP_TMR_INTERVAL)     /* the coarse grained timeout in milliseconds */
-#endif                          /* TCP_SLOW_INTERVAL */
-
-#define TCP_FIN_WAIT_TIMEOUT 20000      /* milliseconds */
-#define TCP_SYN_RCVD_TIMEOUT 20000      /* milliseconds */
-
-#define TCP_OOSEQ_TIMEOUT        6U     /* x RTO */
-
-#ifndef TCP_MSL
-#define TCP_MSL 60000UL         /* The maximum segment lifetime in milliseconds */
-#endif
-
-/* Keepalive values, compliant with RFC 1122. Don't change this unless you know what you're doing */
-#ifndef  TCP_KEEPIDLE_DEFAULT
-#define  TCP_KEEPIDLE_DEFAULT     7200000UL     /* Default KEEPALIVE timer in milliseconds */
-#endif
-
-#ifndef  TCP_KEEPINTVL_DEFAULT
-#define  TCP_KEEPINTVL_DEFAULT    75000UL       /* Default Time between KEEPALIVE probes in milliseconds */
-#endif
-
-#ifndef  TCP_KEEPCNT_DEFAULT
-#define  TCP_KEEPCNT_DEFAULT      9U    /* Default Counter for KEEPALIVE probes */
-#endif
-
-#define  TCP_MAXIDLE              TCP_KEEPCNT_DEFAULT * TCP_KEEPINTVL_DEFAULT   /* Maximum KEEPALIVE probe time */
-
-/* Fields are (of course) in network byte order.
- * Some fields are converted to host byte order in tcp_input().
- */
-#ifdef PACK_STRUCT_USE_INCLUDES
-#include "arch/bpstruct.h"
-#endif
-     PACK_STRUCT_BEGIN struct tcp_hdr {
-        PACK_STRUCT_FIELD(u16_t src);
-        PACK_STRUCT_FIELD(u16_t dest);
-        PACK_STRUCT_FIELD(u32_t seqno);
-        PACK_STRUCT_FIELD(u32_t ackno);
-        PACK_STRUCT_FIELD(u16_t _hdrlen_rsvd_flags);
-        PACK_STRUCT_FIELD(u16_t wnd);
-        PACK_STRUCT_FIELD(u16_t chksum);
-        PACK_STRUCT_FIELD(u16_t urgp);
-    } PACK_STRUCT_STRUCT;
-     PACK_STRUCT_END
-#ifdef PACK_STRUCT_USE_INCLUDES
-#include "arch/epstruct.h"
-#endif
-#define TCPH_OFFSET(phdr) (ntohs((phdr)->_hdrlen_rsvd_flags) >> 8)
-#define TCPH_HDRLEN(phdr) (ntohs((phdr)->_hdrlen_rsvd_flags) >> 12)
-#define TCPH_FLAGS(phdr)  (ntohs((phdr)->_hdrlen_rsvd_flags) & TCP_FLAGS)
-#define TCPH_OFFSET_SET(phdr, offset) (phdr)->_hdrlen_rsvd_flags = htons(((offset) << 8) | TCPH_FLAGS(phdr))
-#define TCPH_HDRLEN_SET(phdr, len) (phdr)->_hdrlen_rsvd_flags = htons(((len) << 12) | TCPH_FLAGS(phdr))
-#define TCPH_FLAGS_SET(phdr, flags) (phdr)->_hdrlen_rsvd_flags = htons((ntohs((phdr)->_hdrlen_rsvd_flags) & ~TCP_FLAGS) | (flags))
-#define TCPH_SET_FLAG(phdr, flags ) (phdr)->_hdrlen_rsvd_flags = htons(ntohs((phdr)->_hdrlen_rsvd_flags) | (flags))
-#define TCPH_UNSET_FLAG(phdr, flags) (phdr)->_hdrlen_rsvd_flags = htons(ntohs((phdr)->_hdrlen_rsvd_flags) | (TCPH_FLAGS(phdr) & ~(flags)) )
-#define TCP_TCPLEN(seg) ((seg)->len + ((TCPH_FLAGS((seg)->tcphdr) & TCP_FIN || \
-          TCPH_FLAGS((seg)->tcphdr) & TCP_SYN)? 1: 0))
-      enum tcp_state {
-        CLOSED = 0,
-        LISTEN = 1,
-        SYN_SENT = 2,
-        SYN_RCVD = 3,
-        ESTABLISHED = 4,
-        FIN_WAIT_1 = 5,
-        FIN_WAIT_2 = 6,
-        CLOSE_WAIT = 7,
-        CLOSING = 8,
-        LAST_ACK = 9,
-        TIME_WAIT = 10
-    };
-
-/** Flags used on input processing, not on pcb->flags
-*/
-#define TF_RESET     (u8_t)0x08U        /* Connection was reset. */
-#define TF_CLOSED    (u8_t)0x10U        /* Connection was sucessfully closed. */
-#define TF_GOT_FIN   (u8_t)0x20U        /* Connection was closed by the remote end. */
-
-
-#if LWIP_CALLBACK_API
-    /* Function to call when a listener has been connected.
-     * @param arg user-supplied argument (tcp_pcb.callback_arg)
-     * @param pcb a new tcp_pcb that now is connected
-     * @param err an error argument (TODO: that is current always ERR_OK?)
-     * @return ERR_OK: accept the new connection,
-     *                 any other err_t abortsthe new connection
-     */
-#define DEF_ACCEPT_CALLBACK  err_t (* accept)(void *arg, struct tcp_pcb *newpcb, err_t err)
-#else                           /* LWIP_CALLBACK_API */
-#define DEF_ACCEPT_CALLBACK
-#endif                          /* LWIP_CALLBACK_API */
-
-/**
- * members common to struct tcp_pcb and struct tcp_listen_pcb
- */
-#define TCP_PCB_COMMON(type) \
-  type *next; /* for the linked list */ \
-  enum tcp_state state; /* TCP state */ \
-  u8_t prio; \
-  void *callback_arg; \
-  /* ports are in host byte order */ \
-  u16_t local_port; \
-  /* the accept callback for listen- and normal pcbs, if LWIP_CALLBACK_API */ \
-  DEF_ACCEPT_CALLBACK
-
-
-/* the TCP protocol control block */
-    struct tcp_pcb {
-/** common PCB members */
-        IP_PCB;
-/** protocol specific PCB members */
-        TCP_PCB_COMMON(struct tcp_pcb);
-
-        /* ports are in host byte order */
-        u16_t remote_port;
-
-        u8_t flags;
-#define TF_ACK_DELAY   ((u8_t)0x01U)    /* Delayed ACK. */
-#define TF_ACK_NOW     ((u8_t)0x02U)    /* Immediate ACK. */
-#define TF_INFR        ((u8_t)0x04U)    /* In fast recovery. */
-#define TF_TIMESTAMP   ((u8_t)0x08U)    /* Timestamp option enabled */
-#define TF_FIN         ((u8_t)0x20U)    /* Connection was closed locally (FIN segment enqueued). */
-#define TF_NODELAY     ((u8_t)0x40U)    /* Disable Nagle algorithm */
-#define TF_NAGLEMEMERR ((u8_t)0x80U)    /* nagle enabled, memerr, try to output to prevent delayed ACK to happen */
-
-        /* the rest of the fields are in host byte order
-           as we have to do some math with them */
-        /* receiver variables */
-        u32_t rcv_nxt;          /* next seqno expected */
-        u16_t rcv_wnd;          /* receiver window available */
-        u16_t rcv_ann_wnd;      /* receiver window to announce */
-        u32_t rcv_ann_right_edge;       /* announced right edge of window */
-
-        /* Timers */
-        u32_t tmr;
-        u8_t polltmr, pollinterval;
-
-        /* Retransmission timer. */
-        s16_t rtime;
-
-        u16_t mss;              /* maximum segment size */
-
-        /* RTT (round trip time) estimation variables */
-        u32_t rttest;           /* RTT estimate in 500ms ticks */
-        u32_t rtseq;            /* sequence number being timed */
-        s16_t sa, sv;           /* @todo document this */
-
-        s16_t rto;              /* retransmission time-out */
-        u8_t nrtx;              /* number of retransmissions */
-
-        /* fast retransmit/recovery */
-        u32_t lastack;          /* Highest acknowledged seqno. */
-        u8_t dupacks;
-
-        /* congestion avoidance/control variables */
-        u16_t cwnd;
-        u16_t ssthresh;
-
-        /* sender variables */
-        u32_t snd_nxt;          /* next new seqno to be sent */
-        u16_t snd_wnd;          /* sender window */
-        u32_t snd_wl1, snd_wl2; /* Sequence and acknowledgement numbers of last
-                                   window update. */
-        u32_t snd_lbb;          /* Sequence number of next byte to be buffered. */
-
-        u16_t acked;
-
-        u16_t snd_buf;          /* Available buffer space for sending (in bytes). */
-#define TCP_SNDQUEUELEN_OVERFLOW (0xffff-3)
-        u16_t snd_queuelen;     /* Available buffer space for sending (in tcp_segs). */
-
-
-        /* These are ordered by sequence number: */
-        struct tcp_seg *unsent; /* Unsent (queued) segments. */
-        struct tcp_seg *unacked;        /* Sent but unacknowledged segments. */
-#if TCP_QUEUE_OOSEQ
-        struct tcp_seg *ooseq;  /* Received out of sequence segments. */
-#endif                          /* TCP_QUEUE_OOSEQ */
-
-        struct pbuf *refused_data;      /* Data previously received but not yet taken by upper layer */
-
-#if LWIP_CALLBACK_API
-        /* Function to be called when more send buffer space is available.
-         * @param arg user-supplied argument (tcp_pcb.callback_arg)
-         * @param pcb the tcp_pcb which has send buffer space available
-         * @param space the amount of bytes available
-         * @return ERR_OK: try to send some data by calling tcp_output
-         */
-         err_t(*sent) (void *arg, struct tcp_pcb * pcb, u16_t space);
-
-        /* Function to be called when (in-sequence) data has arrived.
-         * @param arg user-supplied argument (tcp_pcb.callback_arg)
-         * @param pcb the tcp_pcb for which data has arrived
-         * @param p the packet buffer which arrived
-         * @param err an error argument (TODO: that is current always ERR_OK?)
-         * @return ERR_OK: try to send some data by calling tcp_output
-         */
-         err_t(*recv) (void *arg, struct tcp_pcb * pcb, struct pbuf * p,
-                       err_t err);
-
-        /* Function to be called when a connection has been set up.
-         * @param arg user-supplied argument (tcp_pcb.callback_arg)
-         * @param pcb the tcp_pcb that now is connected
-         * @param err an error argument (TODO: that is current always ERR_OK?)
-         * @return value is currently ignored
-         */
-         err_t(*connected) (void *arg, struct tcp_pcb * pcb, err_t err);
-
-        /* Function which is called periodically.
-         * The period can be adjusted in multiples of the TCP slow timer interval
-         * by changing tcp_pcb.polltmr.
-         * @param arg user-supplied argument (tcp_pcb.callback_arg)
-         * @param pcb the tcp_pcb to poll for
-         * @return ERR_OK: try to send some data by calling tcp_output
-         */
-         err_t(*poll) (void *arg, struct tcp_pcb * pcb);
-
-        /* Function to be called whenever a fatal error occurs.
-         * There is no pcb parameter since most of the times, the pcb is
-         * already deallocated (or there is no pcb) when this function is called.
-         * @param arg user-supplied argument (tcp_pcb.callback_arg)
-         * @param err an indication why the error callback is called:
-         *            ERR_ABRT: aborted through tcp_abort or by a TCP timer
-         *            ERR_RST: the connection was reset by the remote host
-         */
-        void (*errf) (void *arg, err_t err);
-#endif                          /* LWIP_CALLBACK_API */
-
-#if LWIP_TCP_TIMESTAMPS
-        u32_t ts_lastacksent;
-        u32_t ts_recent;
-#endif                          /* LWIP_TCP_TIMESTAMPS */
-
-        /* idle time before KEEPALIVE is sent */
-        u32_t keep_idle;
-#if LWIP_TCP_KEEPALIVE
-        u32_t keep_intvl;
-        u32_t keep_cnt;
-#endif                          /* LWIP_TCP_KEEPALIVE */
-
-        /* Persist timer counter */
-        u32_t persist_cnt;
-        /* Persist timer back-off */
-        u8_t persist_backoff;
-
-        /* KEEPALIVE counter */
-        u8_t keep_cnt_sent;
-    };
-
-    struct tcp_pcb_listen {
-/* Common members of all PCB types */
-        IP_PCB;
-/* Protocol specific PCB members */
-        TCP_PCB_COMMON(struct tcp_pcb_listen);
-
-#if TCP_LISTEN_BACKLOG
-        u8_t backlog;
-        u8_t accepts_pending;
-#endif                          /* TCP_LISTEN_BACKLOG */
-    };
-
-#if LWIP_EVENT_API
-
-    enum lwip_event {
-        LWIP_EVENT_ACCEPT,
-        LWIP_EVENT_SENT,
-        LWIP_EVENT_RECV,
-        LWIP_EVENT_CONNECTED,
-        LWIP_EVENT_POLL,
-        LWIP_EVENT_ERR
-    };
-
-    err_t lwip_tcp_event(void *arg, struct tcp_pcb *pcb,
-                         enum lwip_event,
-                         struct pbuf *p, u16_t size, err_t err);
-
-#define TCP_EVENT_ACCEPT(pcb,err,ret)    ret = lwip_tcp_event((pcb)->callback_arg, (pcb),\
-                LWIP_EVENT_ACCEPT, NULL, 0, err)
-#define TCP_EVENT_SENT(pcb,space,ret) ret = lwip_tcp_event((pcb)->callback_arg, (pcb),\
-                   LWIP_EVENT_SENT, NULL, space, ERR_OK)
-#define TCP_EVENT_RECV(pcb,p,err,ret) ret = lwip_tcp_event((pcb)->callback_arg, (pcb),\
-                LWIP_EVENT_RECV, (p), 0, (err))
-#define TCP_EVENT_CONNECTED(pcb,err,ret) ret = lwip_tcp_event((pcb)->callback_arg, (pcb),\
-                LWIP_EVENT_CONNECTED, NULL, 0, (err))
-#define TCP_EVENT_POLL(pcb,ret)       ret = lwip_tcp_event((pcb)->callback_arg, (pcb),\
-                LWIP_EVENT_POLL, NULL, 0, ERR_OK)
-#define TCP_EVENT_ERR(errf,arg,err)  lwip_tcp_event((arg), NULL, \
-                LWIP_EVENT_ERR, NULL, 0, (err))
-#else                           /* LWIP_EVENT_API */
-
-#define TCP_EVENT_ACCEPT(pcb,err,ret)                          \
-  do {                                                         \
-    if((pcb)->accept != NULL)                                  \
-      (ret) = (pcb)->accept((pcb)->callback_arg,(pcb),(err));  \
-    else (ret) = ERR_OK;                                       \
-  } while (0)
-
-#define TCP_EVENT_SENT(pcb,space,ret)                          \
-  do {                                                         \
-    if((pcb)->sent != NULL)                                    \
-      (ret) = (pcb)->sent((pcb)->callback_arg,(pcb),(space));  \
-    else (ret) = ERR_OK;                                       \
-  } while (0)
-
-#define TCP_EVENT_RECV(pcb,p,err,ret)                           \
-  do {                                                          \
-    if((pcb)->recv != NULL) {                                   \
-      (ret) = (pcb)->recv((pcb)->callback_arg,(pcb),(p),(err)); \
-    } else {                                                    \
-      (ret) = ERR_OK;                                           \
-      if (p != NULL)                                            \
-        pbuf_free(p);                                           \
-    }                                                           \
-  } while (0)
-
-#define TCP_EVENT_CONNECTED(pcb,err,ret)                         \
-  do {                                                           \
-    if((pcb)->connected != NULL)                                 \
-      (ret) = (pcb)->connected((pcb)->callback_arg,(pcb),(err)); \
-    else (ret) = ERR_OK;                                         \
-  } while (0)
-
-#define TCP_EVENT_POLL(pcb,ret)                                \
-  do {                                                         \
-    if((pcb)->poll != NULL)                                    \
-      (ret) = (pcb)->poll((pcb)->callback_arg,(pcb));          \
-    else (ret) = ERR_OK;                                       \
-  } while (0)
-
-#define TCP_EVENT_ERR(errf,arg,err)                            \
-  do {                                                         \
-    if((errf) != NULL)                                         \
-      (errf)((arg),(err));                                     \
-  } while (0)
-
-#endif                          /* LWIP_EVENT_API */
-
-/* This structure represents a TCP segment on the unsent and unacked queues */
-    struct tcp_seg {
-        struct tcp_seg *next;   /* used when putting segements on a queue */
-        struct pbuf *p;         /* buffer containing data + TCP header */
-        void *dataptr;          /* pointer to the TCP data in the pbuf */
-        u16_t len;              /* the TCP length of this segment */
-        u8_t flags;
-#define TF_SEG_OPTS_MSS   (u8_t)0x01U   /* Include MSS option. */
-#define TF_SEG_OPTS_TS    (u8_t)0x02U   /* Include timestamp option. */
-        struct tcp_hdr *tcphdr; /* the TCP header */
-    };
-
-#define LWIP_TCP_OPT_LENGTH(flags)              \
-  (flags & TF_SEG_OPTS_MSS ? 4  : 0) +          \
-  (flags & TF_SEG_OPTS_TS  ? 12 : 0)
-
-/** This returns a TCP header option for MSS in an u32_t */
-#define TCP_BUILD_MSS_OPTION(x) (x) = htonl(((u32_t)2 << 24) |          \
-                                            ((u32_t)4 << 16) |          \
-                                            (((u32_t)TCP_MSS / 256) << 8) | \
-                                            (TCP_MSS & 255))
-
-/* Internal functions and global variables: */
-    struct tcp_pcb *tcp_pcb_copy(struct tcp_pcb *pcb);
-    void tcp_pcb_purge(struct tcp_pcb *pcb);
-    void tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb);
-
-    u8_t tcp_segs_free(struct tcp_seg *seg);
-    u8_t tcp_seg_free(struct tcp_seg *seg);
-    struct tcp_seg *tcp_seg_copy(struct tcp_seg *seg);
-
-#define tcp_ack(pcb)                               \
-  do {                                             \
-    if((pcb)->flags & TF_ACK_DELAY) {              \
-      (pcb)->flags &= ~TF_ACK_DELAY;               \
-      (pcb)->flags |= TF_ACK_NOW;                  \
-      tcp_output(pcb);                             \
-    }                                              \
-    else {                                         \
-      (pcb)->flags |= TF_ACK_DELAY;                \
-    }                                              \
-  } while (0)
-
-#define tcp_ack_now(pcb)                           \
-  do {                                             \
-    (pcb)->flags |= TF_ACK_NOW;                    \
-    tcp_output(pcb);                               \
-  } while (0)
-
-    err_t tcp_send_ctrl(struct tcp_pcb *pcb, u8_t flags);
-    err_t tcp_enqueue(struct tcp_pcb *pcb, void *dataptr, u16_t len,
-                      u8_t flags, u8_t apiflags, u8_t optflags);
-
-    void tcp_rexmit_seg(struct tcp_pcb *pcb, struct tcp_seg *seg);
-
-    void tcp_rst(u32_t seqno, u32_t ackno,
-                 struct ip_addr *local_ip, struct ip_addr *remote_ip,
-                 u16_t local_port, u16_t remote_port);
-
-    u32_t tcp_next_iss(void);
-
-    void tcp_keepalive(struct tcp_pcb *pcb);
-    void tcp_zero_window_probe(struct tcp_pcb *pcb);
-
-#if TCP_CALCULATE_EFF_SEND_MSS
-    u16_t tcp_eff_send_mss(u16_t sendmss, struct ip_addr *addr);
-#endif                          /* TCP_CALCULATE_EFF_SEND_MSS */
-
-    extern struct tcp_pcb *tcp_input_pcb;
-    extern u32_t tcp_ticks;
-
-#if TCP_DEBUG || TCP_INPUT_DEBUG || TCP_OUTPUT_DEBUG
-    void tcp_debug_print(struct tcp_hdr *tcphdr);
-    void tcp_debug_print_flags(u8_t flags);
-    void tcp_debug_print_state(enum tcp_state s);
-    void tcp_debug_print_pcbs(void);
-    s16_t tcp_pcbs_sane(void);
-#else
-#define tcp_debug_print(tcphdr)
-#define tcp_debug_print_flags(flags)
-#define tcp_debug_print_state(s)
-#define tcp_debug_print_pcbs()
-#define tcp_pcbs_sane() 1
-#endif                          /* TCP_DEBUG */
-
-#if NO_SYS
-#define tcp_timer_needed()
-#else
-    void tcp_timer_needed(void);
-#endif
-
-/* The TCP PCB lists. */
-    union tcp_listen_pcbs_t {   /* List of all TCP PCBs in LISTEN state. */
-        struct tcp_pcb_listen *listen_pcbs;
-        struct tcp_pcb *pcbs;
-    };
-    extern union tcp_listen_pcbs_t tcp_listen_pcbs;
-    extern struct tcp_pcb *tcp_active_pcbs;     /* List of all TCP PCBs that are in a
-                                                   state in which they accept or send
-                                                   data. */
-    extern struct tcp_pcb *tcp_tw_pcbs; /* List of all TCP PCBs in TIME-WAIT. */
-
-    extern struct tcp_pcb *tcp_tmp_pcb; /* Only used for temporary storage. */
-
-/* Axioms about the above lists:   
-   1) Every TCP PCB that is not CLOSED is in one of the lists.
-   2) A PCB is only in one of the lists.
-   3) All PCBs in the tcp_listen_pcbs list is in LISTEN state.
-   4) All PCBs in the tcp_tw_pcbs list is in TIME-WAIT state.
-*/
-
-/* Define two macros, TCP_REG and TCP_RMV that registers a TCP PCB
-   with a PCB list or removes a PCB from a list, respectively. */
-#if 0
-#define TCP_REG(pcbs, npcb) do {\
-                            LWIP_DEBUGF(TCP_DEBUG, ("TCP_REG %p local port %d\n", npcb, npcb->local_port)); \
-                            for(tcp_tmp_pcb = *pcbs; \
-          tcp_tmp_pcb != NULL; \
-        tcp_tmp_pcb = tcp_tmp_pcb->next) { \
-                                LWIP_ASSERT("TCP_REG: already registered\n", tcp_tmp_pcb != npcb); \
-                            } \
-                            LWIP_ASSERT("TCP_REG: pcb->state != CLOSED", npcb->state != CLOSED); \
-                            npcb->next = *pcbs; \
-                            LWIP_ASSERT("TCP_REG: npcb->next != npcb", npcb->next != npcb); \
-                            *(pcbs) = npcb; \
-                            LWIP_ASSERT("TCP_RMV: tcp_pcbs sane", tcp_pcbs_sane()); \
-              tcp_timer_needed(); \
-                            } while(0)
-#define TCP_RMV(pcbs, npcb) do { \
-                            LWIP_ASSERT("TCP_RMV: pcbs != NULL", *pcbs != NULL); \
-                            LWIP_DEBUGF(TCP_DEBUG, ("TCP_RMV: removing %p from %p\n", npcb, *pcbs)); \
-                            if(*pcbs == npcb) { \
-                               *pcbs = (*pcbs)->next; \
-                            } else for(tcp_tmp_pcb = *pcbs; tcp_tmp_pcb != NULL; tcp_tmp_pcb = tcp_tmp_pcb->next) { \
-                               if(tcp_tmp_pcb->next != NULL && tcp_tmp_pcb->next == npcb) { \
-                                  tcp_tmp_pcb->next = npcb->next; \
-                                  break; \
-                               } \
-                            } \
-                            npcb->next = NULL; \
-                            LWIP_ASSERT("TCP_RMV: tcp_pcbs sane", tcp_pcbs_sane()); \
-                            LWIP_DEBUGF(TCP_DEBUG, ("TCP_RMV: removed %p from %p\n", npcb, *pcbs)); \
-                            } while(0)
-
-#else                           /* LWIP_DEBUG */
-
-#define TCP_REG(pcbs, npcb)                        \
-  do {                                             \
-    npcb->next = *pcbs;                            \
-    *(pcbs) = npcb;                                \
-    tcp_timer_needed();                            \
-  } while (0)
-
-#define TCP_RMV(pcbs, npcb)                        \
-  do {                                             \
-    if(*(pcbs) == npcb) {                          \
-      (*(pcbs)) = (*pcbs)->next;                   \
-    }                                              \
-    else {                                         \
-      for(tcp_tmp_pcb = *pcbs;                                         \
-          tcp_tmp_pcb != NULL;                                         \
-          tcp_tmp_pcb = tcp_tmp_pcb->next) {                           \
-        if(tcp_tmp_pcb->next != NULL && tcp_tmp_pcb->next == npcb) {   \
-          tcp_tmp_pcb->next = npcb->next;          \
-          break;                                   \
-        }                                          \
-      }                                            \
-    }                                              \
-    npcb->next = NULL;                             \
-  } while(0)
-
-#endif                          /* LWIP_DEBUG */
-
-#ifdef __cplusplus
-}
-#endif
-#endif                          /* LWIP_TCP */
-#endif                          /* __LWIP_TCP_H__ */
diff --git a/include/lwip/tcpip.h b/include/lwip/tcpip.h
deleted file mode 100644
index acd6fbc..0000000
--- a/include/lwip/tcpip.h
+++ /dev/null
@@ -1,141 +0,0 @@
-/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Adam Dunkels <adam@sics.se>
- *
- */
-#ifndef __LWIP_TCPIP_H__
-#define __LWIP_TCPIP_H__
-
-#include "lwip/opt.h"
-
-#if !NO_SYS                     /* don't build if not configured for use in lwipopts.h */
-
-#include "lwip/api_msg.h"
-#include "lwip/netifapi.h"
-#include "lwip/pbuf.h"
-#include "lwip/api.h"
-#include "lwip/sys.h"
-#include "lwip/netif.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#if LWIP_TCPIP_CORE_LOCKING
-/** The global semaphore to lock the stack. */
-    extern sys_sem_t lock_tcpip_core;
-#define LOCK_TCPIP_CORE()     sys_sem_wait(lock_tcpip_core)
-#define UNLOCK_TCPIP_CORE()   sys_sem_signal(lock_tcpip_core)
-#define TCPIP_APIMSG(m)       tcpip_apimsg_lock(m)
-#define TCPIP_APIMSG_ACK(m)
-#define TCPIP_NETIFAPI(m)     tcpip_netifapi_lock(m)
-#define TCPIP_NETIFAPI_ACK(m)
-#else
-#define LOCK_TCPIP_CORE()
-#define UNLOCK_TCPIP_CORE()
-#define TCPIP_APIMSG(m)       tcpip_apimsg(m)
-#define TCPIP_APIMSG_ACK(m)   sys_sem_signal(m->conn->op_completed)
-#define TCPIP_NETIFAPI(m)     tcpip_netifapi(m)
-#define TCPIP_NETIFAPI_ACK(m) sys_sem_signal(m->sem)
-#endif                          /* LWIP_TCPIP_CORE_LOCKING */
-
-    void tcpip_init(void (*tcpip_init_done) (void *),
-                    void *arg);
-
-#if LWIP_NETCONN
-    err_t tcpip_apimsg(struct api_msg *apimsg);
-#if LWIP_TCPIP_CORE_LOCKING
-    err_t tcpip_apimsg_lock(struct api_msg *apimsg);
-#endif                          /* LWIP_TCPIP_CORE_LOCKING */
-#endif                          /* LWIP_NETCONN */
-
-    err_t tcpip_input(struct pbuf *p, struct netif *inp);
-
-#if LWIP_NETIF_API
-    err_t tcpip_netifapi(struct netifapi_msg *netifapimsg);
-#if LWIP_TCPIP_CORE_LOCKING
-    err_t tcpip_netifapi_lock(struct netifapi_msg *netifapimsg);
-#endif                          /* LWIP_TCPIP_CORE_LOCKING */
-#endif                          /* LWIP_NETIF_API */
-
-    err_t tcpip_callback_with_block(void (*f) (void *ctx), void *ctx,
-                                    u8_t block);
-#define tcpip_callback(f, ctx)              tcpip_callback_with_block(f, ctx, 1)
-
-/* free pbufs or heap memory from another context without blocking */
-    err_t pbuf_free_callback(struct pbuf *p);
-    err_t mem_free_callback(void *m);
-
-    err_t tcpip_timeout(u32_t msecs, sys_timeout_handler h, void *arg);
-    err_t tcpip_untimeout(sys_timeout_handler h, void *arg);
-
-    enum tcpip_msg_type {
-#if LWIP_NETCONN
-        TCPIP_MSG_API,
-#endif                          /* LWIP_NETCONN */
-        TCPIP_MSG_INPKT,
-#if LWIP_NETIF_API
-        TCPIP_MSG_NETIFAPI,
-#endif                          /* LWIP_NETIF_API */
-        TCPIP_MSG_CALLBACK,
-        TCPIP_MSG_TIMEOUT,
-        TCPIP_MSG_UNTIMEOUT
-    };
-
-    struct tcpip_msg {
-        enum tcpip_msg_type type;
-        sys_sem_t *sem;
-        union {
-#if LWIP_NETCONN
-            struct api_msg *apimsg;
-#endif                          /* LWIP_NETCONN */
-#if LWIP_NETIF_API
-            struct netifapi_msg *netifapimsg;
-#endif                          /* LWIP_NETIF_API */
-            struct {
-                struct pbuf *p;
-                struct netif *netif;
-            } inp;
-            struct {
-                void (*f) (void *ctx);
-                void *ctx;
-            } cb;
-            struct {
-                u32_t msecs;
-                sys_timeout_handler h;
-                void *arg;
-            } tmo;
-        } msg;
-    };
-
-#ifdef __cplusplus
-}
-#endif
-#endif                          /* !NO_SYS */
-#endif                          /* __LWIP_TCPIP_H__ */
diff --git a/include/lwip/udp.h b/include/lwip/udp.h
deleted file mode 100644
index 77b04c5..0000000
--- a/include/lwip/udp.h
+++ /dev/null
@@ -1,145 +0,0 @@
-/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved. 
- * 
- * Redistribution and use in source and binary forms, with or without modification, 
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission. 
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- * 
- * Author: Adam Dunkels <adam@sics.se>
- *
- */
-#ifndef __LWIP_UDP_H__
-#define __LWIP_UDP_H__
-
-#include "lwip/opt.h"
-
-#if LWIP_UDP                    /* don't build if not configured for use in lwipopts.h */
-
-#include "lwip/pbuf.h"
-#include "lwip/netif.h"
-#include "lwip/ip_addr.h"
-#include "lwip/ip.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#define UDP_HLEN 8
-
-/* Fields are (of course) in network byte order. */
-#ifdef PACK_STRUCT_USE_INCLUDES
-#include "arch/bpstruct.h"
-#endif
-    PACK_STRUCT_BEGIN struct udp_hdr {
-        PACK_STRUCT_FIELD(u16_t src);
-        PACK_STRUCT_FIELD(u16_t dest);  /* src/dest UDP ports */
-        PACK_STRUCT_FIELD(u16_t len);
-        PACK_STRUCT_FIELD(u16_t chksum);
-    } PACK_STRUCT_STRUCT;
-     PACK_STRUCT_END
-#ifdef PACK_STRUCT_USE_INCLUDES
-#include "arch/epstruct.h"
-#endif
-#define UDP_FLAGS_NOCHKSUM 0x01U
-#define UDP_FLAGS_UDPLITE  0x02U
-#define UDP_FLAGS_CONNECTED  0x04U
-      struct udp_pcb {
-/* Common members of all PCB types */
-        IP_PCB;
-
-/* Protocol specific PCB members */
-
-        struct udp_pcb *next;
-
-        u8_t flags;
-        /* ports are in host byte order */
-        u16_t local_port, remote_port;
-
-#if LWIP_IGMP
-        /* outgoing network interface for multicast packets */
-        struct ip_addr multicast_ip;
-#endif                          /* LWIP_IGMP */
-
-#if LWIP_UDPLITE
-        /* used for UDP_LITE only */
-        u16_t chksum_len_rx, chksum_len_tx;
-#endif                          /* LWIP_UDPLITE */
-
-        /* receive callback function
-         * addr and port are in same byte order as in the pcb
-         * The callback is responsible for freeing the pbuf
-         * if it's not used any more.
-         *
-         * @param arg user supplied argument (udp_pcb.recv_arg)
-         * @param pcb the udp_pcb which received data
-         * @param p the packet buffer that was received
-         * @param addr the remote IP address from which the packet was received
-         * @param port the remote port from which the packet was received
-         */
-        void (*recv) (void *arg, struct udp_pcb * pcb, struct pbuf * p,
-                      struct ip_addr * addr, u16_t port);
-        /* user-supplied argument for the recv callback */
-        void *recv_arg;
-    };
-/* udp_pcbs export for exernal reference (e.g. SNMP agent) */
-    extern struct udp_pcb *udp_pcbs;
-
-/* The following functions is the application layer interface to the
-   UDP code. */
-    struct udp_pcb *udp_new(void);
-    void udp_remove(struct udp_pcb *pcb);
-    err_t udp_bind(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port);
-    err_t udp_connect(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port);
-    void udp_disconnect(struct udp_pcb *pcb);
-    void udp_recv(struct udp_pcb *pcb,
-                  void (*recv) (void *arg, struct udp_pcb * upcb,
-                                struct pbuf * p,
-                                struct ip_addr * addr,
-                                u16_t port), void *recv_arg);
-    err_t udp_sendto_if(struct udp_pcb *pcb, struct pbuf *p,
-                        struct ip_addr *dst_ip, u16_t dst_port,
-                        struct netif *netif);
-    err_t udp_sendto(struct udp_pcb *pcb, struct pbuf *p,
-                     struct ip_addr *dst_ip, u16_t dst_port);
-    err_t udp_send(struct udp_pcb *pcb, struct pbuf *p);
-
-#define          udp_flags(pcb)  ((pcb)->flags)
-#define          udp_setflags(pcb, f)  ((pcb)->flags = (f))
-
-/* The following functions are the lower layer interface to UDP. */
-    void udp_input(struct pbuf *p, struct netif *inp);
-
-#define udp_init()              /* Compatibility define, not init needed. */
-
-#if UDP_DEBUG
-    void udp_debug_print(struct udp_hdr *udphdr);
-#else
-#define udp_debug_print(udphdr)
-#endif
-
-#ifdef __cplusplus
-}
-#endif
-#endif                          /* LWIP_UDP */
-#endif                          /* __LWIP_UDP_H__ */
diff --git a/include/lwipopts.h b/include/lwipopts.h
deleted file mode 100644
index f34e082..0000000
--- a/include/lwipopts.h
+++ /dev/null
@@ -1,115 +0,0 @@
-/**
- * \file
- * \brief lwIP configuration file for Barrelfish.
- */
-
-/*
- * Copyright (c) 2007, 2008, 2009, 2011, ETH Zurich.
- * All rights reserved.
- *
- * This file is distributed under the terms in the attached LICENSE file.
- * If you do not find this file, copies can be found by writing to:
- * ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich. Attn: Systems Group.
- */
-
-#ifndef LWIPOPTS_H
-#define LWIPOPTS_H
-
-#include <barrelfish/net_constants.h>
-/// Build DHCP client
-#define LWIP_DHCP               1
-
-/// Build DNS client
-#define LWIP_DNS		1
-
-/// Don't want lwip POSIX socket wrappers
-#define LWIP_POSIX_SOCKETS_IO_NAMES     0
-
-/// We do not want LWIP to provide POSIX errno
-#undef LWIP_PROVIDE_ERRNO
-
-/// Don't want socket functions overriden by lwIP. We provide our own.
-#define LWIP_COMPAT_SOCKETS     0
-
-/// Use malloc() from libc
-//#define MEM_LIBC_MALLOC         1
-
-/// We want to be informed about interface up/down
-#define LWIP_NETIF_STATUS_CALLBACK      1
-
-/// Don't do ARP lookup to test IP
-#define DHCP_DOES_ARP_CHECK     0
-
-/// Disable locks (we lock the whole stack)
-#define SYS_LIGHTWEIGHT_PROT    0
-
-
-/// Number of simultaneously active TCP connections
-#define MEMP_NUM_TCP_PCB        200
-//#define MEMP_NUM_TCP_PCB        512
-
-
-
-/// Number of TCP segments
-#define MEMP_NUM_TCP_SEG        512
-//#define MEMP_NUM_TCP_SEG        1024
-//#define MEMP_NUM_TCP_SEG            4096
-
-/// TCP window size
-#define TCP_WND                 11680
-
-/// TCP maximum segment size
-#define TCP_MSS                 1460
-
-/// TCP send buffer size
-#define TCP_SND_BUF             8192
-
-/// TCP send queue length (pbufs)
-#define TCP_SND_QUEUELEN       (16 * (TCP_SND_BUF/TCP_MSS))
-
-/// Enable debugging
-// #define LWIP_DEBUG              1
-
-/// Enable have loopif (localhost hostname translation)
-#define LWIP_HAVE_LOOPIF 1
-
-/* Place to control the LWIP debugging.
- Enable debugging of these subsystems */
-
-#define ETHARP_DEBUG     LWIP_DBG_ON
-#define NETIF_DEBUG      LWIP_DBG_ON
-// #define PBUF_DEBUG       LWIP_DBG_ON
-#define DHCP_DEBUG       LWIP_DBG_ON
-#define UDP_DEBUG        LWIP_DBG_ON
-#define IP_DEBUG         LWIP_DBG_ON
-// #define TCP_DEBUG        LWIP_DBG_ON
-// #define TCPIP_DEBUG      LWIP_DBG_ON
-// #define TCP_INPUT_DEBUG  LWIP_DBG_ON
-// #define TCP_OUTPUT_DEBUG LWIP_DBG_ON
-#define SOCKETS_DEBUG    LWIP_DBG_ON
-
-#ifndef CHECKSUM_GEN_IP
-#define CHECKSUM_GEN_IP                 1
-#endif
-
-#ifndef CHECKSUM_GEN_UDP
-#define CHECKSUM_GEN_UDP                1
-#endif
-
-#ifndef CHECKSUM_GEN_TCP
-#define CHECKSUM_GEN_TCP                1
-#endif
-
-#ifndef CHECKSUM_CHECK_IP
-#define CHECKSUM_CHECK_IP               1
-#endif
-
-#ifndef CHECKSUM_CHECK_UDP
-#define CHECKSUM_CHECK_UDP              1
-#endif
-
-#ifndef CHECKSUM_CHECK_TCP
-#define CHECKSUM_CHECK_TCP              1
-#endif
-
-#endif
diff --git a/include/netdb.h b/include/netdb.h
index f71e30e..7f30116 100644
--- a/include/netdb.h
+++ b/include/netdb.h
@@ -74,6 +74,16 @@
 __BEGIN_DECLS
 
 /*
+ * Error return codes from getaddrinfo()
+ */ 
+#define EAI_BADFLAGS     3      /* invalid value for ai_flags */
+#define EAI_SOCKTYPE    10      /* ai_socktype not supported */
+#define EAI_SYSTEM      11      /* system error returned in errno */
+#define EAI_BADHINTS    12      /* invalid value for hints */
+#define EAI_PROTOCOL    13      /* resolved protocol is unknown */
+#define EAI_OVERFLOW    14      /* argument buffer overflow */
+
+/*
  * Flag values for getaddrinfo()
  */
 #define AI_PASSIVE  0x00000001 /* get address to use bind() */
@@ -92,6 +102,24 @@ __BEGIN_DECLS
 /* special recommended flags for getipnodebyname */
 #define AI_DEFAULT  (AI_V4MAPPED_CFG | AI_ADDRCONFIG)
 
+/*
+ * Constants for getnameinfo()
+ */
+#define NI_MAXHOST      1025
+#define NI_MAXSERV      32
+
+/*
+ * Flag values for getnameinfo()
+ */
+#define NI_NOFQDN       0x00000001
+#define NI_NUMERICHOST  0x00000002
+#define NI_NAMEREQD     0x00000004
+#define NI_NUMERICSERV  0x00000008
+#define NI_DGRAM        0x00000010
+#if 0 /* obsolete */
+#define NI_WITHSCOPEID  0x00000020
+#endif
+
 struct hostent *gethostbyname(const char *name);
 struct hostent *gethostbyaddr(const void *addr, socklen_t len, int type);
 int getaddrinfo(const char *nodename,
diff --git a/include/netif/bfeth.h b/include/netif/bfeth.h
deleted file mode 100644
index 8d030bc..0000000
--- a/include/netif/bfeth.h
+++ /dev/null
@@ -1,19 +0,0 @@
-/*
- * Copyright (c) 2007, 2008, 2009, ETH Zurich.
- * All rights reserved.
- *
- * This file is distributed under the terms in the attached LICENSE file.
- * If you do not find this file, copies can be found by writing to:
- * ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich. Attn: Systems Group.
- */
-
-#ifndef BFETH_H
-#define BFETH_H
-
-#include <lwip/netif.h>
-
-void bfeth_input(struct netif *netif, uint64_t pbuf_id, uint64_t paddr,
-        uint64_t len, uint64_t packet_len, struct pbuf *pp);
-err_t bfeth_init(struct netif *netif);
-
-#endif
diff --git a/include/netif/etharp.h b/include/netif/etharp.h
deleted file mode 100644
index 6342c16..0000000
--- a/include/netif/etharp.h
+++ /dev/null
@@ -1,180 +0,0 @@
-/*
- * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
- * Copyright (c) 2003-2004 Leon Woestenberg <leon.woestenberg@axon.tv>
- * Copyright (c) 2003-2004 Axon Digital Design B.V., The Netherlands.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Adam Dunkels <adam@sics.se>
- *
- */
-
-#ifndef __NETIF_ETHARP_H__
-#define __NETIF_ETHARP_H__
-
-#include "lwip/opt.h"
-
-#if LWIP_ARP                    /* don't build if not configured for use in lwipopts.h */
-
-#include "lwip/pbuf.h"
-#include "lwip/ip_addr.h"
-#include "lwip/netif.h"
-#include "lwip/ip.h"
-#include <stdbool.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#ifndef ETH_PAD_SIZE
-#define ETH_PAD_SIZE          0
-#endif
-
-#ifndef ETHARP_HWADDR_LEN
-#define ETHARP_HWADDR_LEN     6
-#endif
-
-#ifdef PACK_STRUCT_USE_INCLUDES
-#include "arch/bpstruct.h"
-#endif
-    PACK_STRUCT_BEGIN struct eth_addr {
-        PACK_STRUCT_FIELD(u8_t addr[ETHARP_HWADDR_LEN]);
-    } PACK_STRUCT_STRUCT;
-     PACK_STRUCT_END
-#ifdef PACK_STRUCT_USE_INCLUDES
-#include "arch/epstruct.h"
-#endif
-#ifdef PACK_STRUCT_USE_INCLUDES
-#include "arch/bpstruct.h"
-#endif
-     PACK_STRUCT_BEGIN struct eth_hdr {
-#if ETH_PAD_SIZE
-        PACK_STRUCT_FIELD(u8_t padding[ETH_PAD_SIZE]);
-#endif
-        PACK_STRUCT_FIELD(struct eth_addr dest);
-         PACK_STRUCT_FIELD(struct eth_addr src);
-         PACK_STRUCT_FIELD(u16_t type);
-    } PACK_STRUCT_STRUCT;
-     PACK_STRUCT_END
-#ifdef PACK_STRUCT_USE_INCLUDES
-#include "arch/epstruct.h"
-#endif
-#ifdef PACK_STRUCT_USE_INCLUDES
-#include "arch/bpstruct.h"
-#endif
-     PACK_STRUCT_BEGIN
-/** the ARP message */
-      struct etharp_hdr {
-        PACK_STRUCT_FIELD(struct eth_hdr ethhdr);
-         PACK_STRUCT_FIELD(u16_t hwtype);
-         PACK_STRUCT_FIELD(u16_t proto);
-         PACK_STRUCT_FIELD(u16_t _hwlen_protolen);
-         PACK_STRUCT_FIELD(u16_t opcode);
-         PACK_STRUCT_FIELD(struct eth_addr shwaddr);
-         PACK_STRUCT_FIELD(struct ip_addr2 sipaddr);
-         PACK_STRUCT_FIELD(struct eth_addr dhwaddr);
-         PACK_STRUCT_FIELD(struct ip_addr2 dipaddr);
-    } PACK_STRUCT_STRUCT;
-     PACK_STRUCT_END
-#ifdef PACK_STRUCT_USE_INCLUDES
-#include "arch/epstruct.h"
-#endif
-#ifdef PACK_STRUCT_USE_INCLUDES
-#include "arch/bpstruct.h"
-#endif
-     PACK_STRUCT_BEGIN struct ethip_hdr {
-        PACK_STRUCT_FIELD(struct eth_hdr eth);
-         PACK_STRUCT_FIELD(struct ip_hdr ip);
-    } PACK_STRUCT_STRUCT;
-     PACK_STRUCT_END
-#ifdef PACK_STRUCT_USE_INCLUDES
-#include "arch/epstruct.h"
-#endif
-/** 5 seconds period */
-#define ARP_TMR_INTERVAL 5000
-#define ETHTYPE_ARP       0x0806
-#define ETHTYPE_IP        0x0800
-#define ETHTYPE_PPPOEDISC 0x8863        /* PPP Over Ethernet Discovery Stage */
-#define ETHTYPE_PPPOE     0x8864        /* PPP Over Ethernet Session Stage */
-/** ARP message types (opcodes) */
-#define ARP_REQUEST 1
-#define ARP_REPLY   2
-#if ARP_QUEUEING
-/** struct for queueing outgoing packets for unknown address
-  * defined here to be accessed by memp.h
-  */
-      struct etharp_q_entry {
-        struct etharp_q_entry *next;
-        struct pbuf *p;
-    };
-#endif                          /* ARP_QUEUEING */
-
-#define etharp_init()           /* Compatibility define, not init needed. */
-    void etharp_tmr(void);
-    s8_t etharp_find_addr(struct netif *netif, struct ip_addr *ipaddr,
-                          struct eth_addr **eth_ret, struct ip_addr **ip_ret);
-    void etharp_ip_input(struct netif *netif, struct pbuf *p);
-    void etharp_arp_input(struct netif *netif, struct eth_addr *ethaddr,
-                          struct pbuf *p);
-    err_t etharp_output(struct netif *netif, struct pbuf *q,
-                        struct ip_addr *ipaddr);
-    err_t etharp_query(struct netif *netif, struct ip_addr *ipaddr,
-                       struct pbuf *q);
-
-
-    struct eth_addr convert_uint64_to_eth_addr(uint64_t given_mac);
-    bool is_ip_present_in_arp_cache(struct ip_addr *ipaddr);
-    uint64_t find_ip_arp_cache(struct ip_addr *ipaddr);
-
-
-
-    err_t etharp_request(struct netif *netif, struct ip_addr *ipaddr);
-/** For Ethernet network interfaces, we might want to send "gratuitous ARP";
- *  this is an ARP packet sent by a node in order to spontaneously cause other
- *  nodes to update an entry in their ARP cache.
- *  From RFC 3220 "IP Mobility Support for IPv4" section 4.6. */
-#define etharp_gratuitous(netif) etharp_request((netif), &(netif)->ip_addr)
-
-    err_t ethernet_input(struct pbuf *p, struct netif *netif);
-
-#if LWIP_AUTOIP
-    err_t etharp_raw(struct netif *netif, const struct eth_addr *ethsrc_addr,
-                     const struct eth_addr *ethdst_addr,
-                     const struct eth_addr *hwsrc_addr,
-                     const struct ip_addr *ipsrc_addr,
-                     const struct eth_addr *hwdst_addr,
-                     const struct ip_addr *ipdst_addr, const u16_t opcode);
-#endif                          /* LWIP_AUTOIP */
-
-#define eth_addr_cmp(addr1, addr2) (memcmp((addr1)->addr, (addr2)->addr, ETHARP_HWADDR_LEN) == 0)
-
-    extern const struct eth_addr ethbroadcast, ethzero;
-
-#ifdef __cplusplus
-}
-#endif
-#endif                          /* LWIP_ARP */
-#endif                          /* __NETIF_ARP_H__ */
diff --git a/include/netif/loopif.h b/include/netif/loopif.h
deleted file mode 100644
index 5303592..0000000
--- a/include/netif/loopif.h
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved. 
- * 
- * Redistribution and use in source and binary forms, with or without modification, 
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission. 
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- * 
- * Author: Adam Dunkels <adam@sics.se>
- *
- */
-#ifndef __NETIF_LOOPIF_H__
-#define __NETIF_LOOPIF_H__
-
-#include "lwip/opt.h"
-#include "lwip/netif.h"
-#include "lwip/err.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#if !LWIP_NETIF_LOOPBACK_MULTITHREADING
-#define loopif_poll netif_poll
-#endif                          /* !LWIP_NETIF_LOOPBACK_MULTITHREADING */
-
-    err_t loopif_init(struct netif *netif);
-
-#ifdef __cplusplus
-}
-#endif
-#endif                          /* __NETIF_LOOPIF_H__ */
diff --git a/include/netif/slipif.h b/include/netif/slipif.h
deleted file mode 100644
index a764d87..0000000
--- a/include/netif/slipif.h
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Copyright (c) 2001, Swedish Institute of Computer Science.
- * All rights reserved. 
- *
- * Redistribution and use in source and binary forms, with or without 
- * modification, are permitted provided that the following conditions 
- * are met: 
- * 1. Redistributions of source code must retain the above copyright 
- *    notice, this list of conditions and the following disclaimer. 
- * 2. Redistributions in binary form must reproduce the above copyright 
- *    notice, this list of conditions and the following disclaimer in the 
- *    documentation and/or other materials provided with the distribution. 
- * 3. Neither the name of the Institute nor the names of its contributors 
- *    may be used to endorse or promote products derived from this software 
- *    without specific prior written permission. 
- *
- * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND 
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE 
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS 
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY 
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
- * SUCH DAMAGE. 
- *
- * This file is part of the lwIP TCP/IP stack.
- * 
- * Author: Adam Dunkels <adam@sics.se>
- *
- */
-#ifndef __NETIF_SLIPIF_H__
-#define __NETIF_SLIPIF_H__
-
-#include "lwip/netif.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-    err_t slipif_init(struct netif *netif);
-
-#ifdef __cplusplus
-}
-#endif
-#endif
diff --git a/include/netinet/in.h b/include/netinet/in.h
index b564e5a..7b3864a 100644
--- a/include/netinet/in.h
+++ b/include/netinet/in.h
@@ -52,10 +52,20 @@
 typedef int_least16_t in_port_t;
 typedef int_least32_t in_addr_t;
 
+#define IPPROTO_IPV6            41              /* IP6 header */
+#define INET_ADDRSTRLEN         16
+
 /*
  * Ports < IPPORT_RESERVED are reserved for
  * privileged processes (e.g. root).         (IP_PORTRANGE_LOW)
  */
 #define	IPPORT_RESERVED		1024
 
+/* INET6 stuff */
+#if __POSIX_VISIBLE >= 200112
+#define __KAME_NETINET_IN_H_INCLUDED_
+#include <netinet6/in6.h>
+#undef __KAME_NETINET_IN_H_INCLUDED_
+#endif
+
 #endif //_NETINET_IN_H_
diff --git a/include/netinet6/in6.h b/include/netinet6/in6.h
new file mode 100644
index 0000000..f0cf4f4
--- /dev/null
+++ b/include/netinet6/in6.h
@@ -0,0 +1,716 @@
+/*-
+ * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	$KAME: in6.h,v 1.89 2001/05/27 13:28:35 itojun Exp $
+ */
+
+/*-
+ * Copyright (c) 1982, 1986, 1990, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)in.h	8.3 (Berkeley) 1/3/94
+ * $FreeBSD$
+ */
+
+#ifndef __KAME_NETINET_IN_H_INCLUDED_
+#error "do not include netinet6/in6.h directly, include netinet/in.h.  see RFC2553"
+#endif
+
+#ifndef _NETINET6_IN6_H_
+#define _NETINET6_IN6_H_
+
+/*
+ * Identification of the network protocol stack
+ * for *BSD-current/release: http://www.kame.net/dev/cvsweb.cgi/kame/COVERAGE
+ * has the table of implementation/integration differences.
+ */
+#define __KAME__
+#define __KAME_VERSION		"FreeBSD"
+
+/*
+ * IPv6 port allocation rules should mirror the IPv4 rules and are controlled
+ * by the net.inet.ip.portrange sysctl tree. The following defines exist
+ * for compatibility with userland applications that need them.
+ */
+#if __BSD_VISIBLE
+#define	IPV6PORT_RESERVED	1024
+#define	IPV6PORT_ANONMIN	49152
+#define	IPV6PORT_ANONMAX	65535
+#define	IPV6PORT_RESERVEDMIN	600
+#define	IPV6PORT_RESERVEDMAX	(IPV6PORT_RESERVED-1)
+#endif
+
+/*
+ * IPv6 address
+ */
+struct in6_addr {
+	union {
+		uint8_t		__u6_addr8[16];
+		uint16_t	__u6_addr16[8];
+		uint32_t	__u6_addr32[4];
+	} __u6_addr;			/* 128-bit IP6 address */
+};
+
+#define s6_addr   __u6_addr.__u6_addr8
+#ifdef _KERNEL	/* XXX nonstandard */
+#define s6_addr8  __u6_addr.__u6_addr8
+#define s6_addr16 __u6_addr.__u6_addr16
+#define s6_addr32 __u6_addr.__u6_addr32
+#endif
+
+#define INET6_ADDRSTRLEN	46
+
+/*
+ * XXX missing POSIX.1-2001 macro IPPROTO_IPV6.
+ */
+
+/*
+ * Socket address for IPv6
+ */
+#if __BSD_VISIBLE
+#define SIN6_LEN
+#endif
+
+struct sockaddr_in6 {
+	uint8_t		sin6_len;	/* length of this struct */
+	sa_family_t	sin6_family;	/* AF_INET6 */
+	in_port_t	sin6_port;	/* Transport layer port # */
+	uint32_t	sin6_flowinfo;	/* IP6 flow information */
+	struct in6_addr	sin6_addr;	/* IP6 address */
+	uint32_t	sin6_scope_id;	/* scope zone index */
+};
+
+/*
+ * Local definition for masks
+ */
+#ifdef _KERNEL	/* XXX nonstandard */
+#define IN6MASK0	{{{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }}}
+#define IN6MASK32	{{{ 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, \
+			    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }}}
+#define IN6MASK64	{{{ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, \
+			    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }}}
+#define IN6MASK96	{{{ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, \
+			    0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00 }}}
+#define IN6MASK128	{{{ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, \
+			    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff }}}
+#endif
+
+#ifdef _KERNEL
+extern const struct sockaddr_in6 sa6_any;
+
+extern const struct in6_addr in6mask0;
+extern const struct in6_addr in6mask32;
+extern const struct in6_addr in6mask64;
+extern const struct in6_addr in6mask96;
+extern const struct in6_addr in6mask128;
+#endif /* _KERNEL */
+
+/*
+ * Macros started with IPV6_ADDR is KAME local
+ */
+#ifdef _KERNEL	/* XXX nonstandard */
+#if _BYTE_ORDER == _BIG_ENDIAN
+#define IPV6_ADDR_INT32_ONE	1
+#define IPV6_ADDR_INT32_TWO	2
+#define IPV6_ADDR_INT32_MNL	0xff010000
+#define IPV6_ADDR_INT32_MLL	0xff020000
+#define IPV6_ADDR_INT32_SMP	0x0000ffff
+#define IPV6_ADDR_INT16_ULL	0xfe80
+#define IPV6_ADDR_INT16_USL	0xfec0
+#define IPV6_ADDR_INT16_MLL	0xff02
+#elif _BYTE_ORDER == _LITTLE_ENDIAN
+#define IPV6_ADDR_INT32_ONE	0x01000000
+#define IPV6_ADDR_INT32_TWO	0x02000000
+#define IPV6_ADDR_INT32_MNL	0x000001ff
+#define IPV6_ADDR_INT32_MLL	0x000002ff
+#define IPV6_ADDR_INT32_SMP	0xffff0000
+#define IPV6_ADDR_INT16_ULL	0x80fe
+#define IPV6_ADDR_INT16_USL	0xc0fe
+#define IPV6_ADDR_INT16_MLL	0x02ff
+#endif
+#endif
+
+/*
+ * Definition of some useful macros to handle IP6 addresses
+ */
+#if __BSD_VISIBLE
+#define IN6ADDR_ANY_INIT \
+	{{{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
+	    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }}}
+#define IN6ADDR_LOOPBACK_INIT \
+	{{{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
+	    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 }}}
+#define IN6ADDR_NODELOCAL_ALLNODES_INIT \
+	{{{ 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
+	    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 }}}
+#define IN6ADDR_INTFACELOCAL_ALLNODES_INIT \
+	{{{ 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
+	    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 }}}
+#define IN6ADDR_LINKLOCAL_ALLNODES_INIT \
+	{{{ 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
+	    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 }}}
+#define IN6ADDR_LINKLOCAL_ALLROUTERS_INIT \
+	{{{ 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
+	    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02 }}}
+#define IN6ADDR_LINKLOCAL_ALLV2ROUTERS_INIT \
+	{{{ 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
+	    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16 }}}
+#endif
+
+extern const struct in6_addr in6addr_any;
+extern const struct in6_addr in6addr_loopback;
+#if __BSD_VISIBLE
+extern const struct in6_addr in6addr_nodelocal_allnodes;
+extern const struct in6_addr in6addr_linklocal_allnodes;
+extern const struct in6_addr in6addr_linklocal_allrouters;
+extern const struct in6_addr in6addr_linklocal_allv2routers;
+#endif
+
+/*
+ * Equality
+ * NOTE: Some of kernel programming environment (for example, openbsd/sparc)
+ * does not supply memcmp().  For userland memcmp() is preferred as it is
+ * in ANSI standard.
+ */
+#ifdef _KERNEL
+#define IN6_ARE_ADDR_EQUAL(a, b)			\
+    (bcmp(&(a)->s6_addr[0], &(b)->s6_addr[0], sizeof(struct in6_addr)) == 0)
+#else
+#if __BSD_VISIBLE
+#define IN6_ARE_ADDR_EQUAL(a, b)			\
+    (memcmp(&(a)->s6_addr[0], &(b)->s6_addr[0], sizeof(struct in6_addr)) == 0)
+#endif
+#endif
+
+/*
+ * Unspecified
+ */
+#define IN6_IS_ADDR_UNSPECIFIED(a)	\
+	((a)->__u6_addr.__u6_addr32[0] == 0 &&	\
+	 (a)->__u6_addr.__u6_addr32[1] == 0 &&	\
+	 (a)->__u6_addr.__u6_addr32[2] == 0 &&	\
+	 (a)->__u6_addr.__u6_addr32[3] == 0)
+
+/*
+ * Loopback
+ */
+#define IN6_IS_ADDR_LOOPBACK(a)		\
+	((a)->__u6_addr.__u6_addr32[0] == 0 &&	\
+	 (a)->__u6_addr.__u6_addr32[1] == 0 &&	\
+	 (a)->__u6_addr.__u6_addr32[2] == 0 &&	\
+	 (a)->__u6_addr.__u6_addr32[3] == ntohl(1))
+
+/*
+ * IPv4 compatible
+ */
+#define IN6_IS_ADDR_V4COMPAT(a)		\
+	((a)->__u6_addr.__u6_addr32[0] == 0 &&	\
+	 (a)->__u6_addr.__u6_addr32[1] == 0 &&	\
+	 (a)->__u6_addr.__u6_addr32[2] == 0 &&	\
+	 (a)->__u6_addr.__u6_addr32[3] != 0 &&	\
+	 (a)->__u6_addr.__u6_addr32[3] != ntohl(1))
+
+/*
+ * Mapped
+ */
+#define IN6_IS_ADDR_V4MAPPED(a)		      \
+	((a)->__u6_addr.__u6_addr32[0] == 0 &&	\
+	 (a)->__u6_addr.__u6_addr32[1] == 0 &&	\
+	 (a)->__u6_addr.__u6_addr32[2] == ntohl(0x0000ffff))
+
+/*
+ * KAME Scope Values
+ */
+
+#ifdef _KERNEL	/* XXX nonstandard */
+#define IPV6_ADDR_SCOPE_NODELOCAL	0x01
+#define IPV6_ADDR_SCOPE_INTFACELOCAL	0x01
+#define IPV6_ADDR_SCOPE_LINKLOCAL	0x02
+#define IPV6_ADDR_SCOPE_SITELOCAL	0x05
+#define IPV6_ADDR_SCOPE_ORGLOCAL	0x08	/* just used in this file */
+#define IPV6_ADDR_SCOPE_GLOBAL		0x0e
+#else
+#define __IPV6_ADDR_SCOPE_NODELOCAL	0x01
+#define __IPV6_ADDR_SCOPE_INTFACELOCAL	0x01
+#define __IPV6_ADDR_SCOPE_LINKLOCAL	0x02
+#define __IPV6_ADDR_SCOPE_SITELOCAL	0x05
+#define __IPV6_ADDR_SCOPE_ORGLOCAL	0x08	/* just used in this file */
+#define __IPV6_ADDR_SCOPE_GLOBAL	0x0e
+#endif
+
+/*
+ * Unicast Scope
+ * Note that we must check topmost 10 bits only, not 16 bits (see RFC2373).
+ */
+#define IN6_IS_ADDR_LINKLOCAL(a)	\
+	(((a)->s6_addr[0] == 0xfe) && (((a)->s6_addr[1] & 0xc0) == 0x80))
+#define IN6_IS_ADDR_SITELOCAL(a)	\
+	(((a)->s6_addr[0] == 0xfe) && (((a)->s6_addr[1] & 0xc0) == 0xc0))
+
+/*
+ * Multicast
+ */
+#define IN6_IS_ADDR_MULTICAST(a)	((a)->s6_addr[0] == 0xff)
+
+#ifdef _KERNEL	/* XXX nonstandard */
+#define IPV6_ADDR_MC_SCOPE(a)		((a)->s6_addr[1] & 0x0f)
+#else
+#define __IPV6_ADDR_MC_SCOPE(a)		((a)->s6_addr[1] & 0x0f)
+#endif
+
+/*
+ * Multicast Scope
+ */
+#ifdef _KERNEL	/* refers nonstandard items */
+#define IN6_IS_ADDR_MC_NODELOCAL(a)	\
+	(IN6_IS_ADDR_MULTICAST(a) &&	\
+	 (IPV6_ADDR_MC_SCOPE(a) == IPV6_ADDR_SCOPE_NODELOCAL))
+#define IN6_IS_ADDR_MC_INTFACELOCAL(a)	\
+	(IN6_IS_ADDR_MULTICAST(a) &&	\
+	 (IPV6_ADDR_MC_SCOPE(a) == IPV6_ADDR_SCOPE_INTFACELOCAL))
+#define IN6_IS_ADDR_MC_LINKLOCAL(a)	\
+	(IN6_IS_ADDR_MULTICAST(a) &&	\
+	 (IPV6_ADDR_MC_SCOPE(a) == IPV6_ADDR_SCOPE_LINKLOCAL))
+#define IN6_IS_ADDR_MC_SITELOCAL(a)	\
+	(IN6_IS_ADDR_MULTICAST(a) &&	\
+	 (IPV6_ADDR_MC_SCOPE(a) == IPV6_ADDR_SCOPE_SITELOCAL))
+#define IN6_IS_ADDR_MC_ORGLOCAL(a)	\
+	(IN6_IS_ADDR_MULTICAST(a) &&	\
+	 (IPV6_ADDR_MC_SCOPE(a) == IPV6_ADDR_SCOPE_ORGLOCAL))
+#define IN6_IS_ADDR_MC_GLOBAL(a)	\
+	(IN6_IS_ADDR_MULTICAST(a) &&	\
+	 (IPV6_ADDR_MC_SCOPE(a) == IPV6_ADDR_SCOPE_GLOBAL))
+#else
+#define IN6_IS_ADDR_MC_NODELOCAL(a)	\
+	(IN6_IS_ADDR_MULTICAST(a) &&	\
+	 (__IPV6_ADDR_MC_SCOPE(a) == __IPV6_ADDR_SCOPE_NODELOCAL))
+#define IN6_IS_ADDR_MC_LINKLOCAL(a)	\
+	(IN6_IS_ADDR_MULTICAST(a) &&	\
+	 (__IPV6_ADDR_MC_SCOPE(a) == __IPV6_ADDR_SCOPE_LINKLOCAL))
+#define IN6_IS_ADDR_MC_SITELOCAL(a)	\
+	(IN6_IS_ADDR_MULTICAST(a) &&	\
+	 (__IPV6_ADDR_MC_SCOPE(a) == __IPV6_ADDR_SCOPE_SITELOCAL))
+#define IN6_IS_ADDR_MC_ORGLOCAL(a)	\
+	(IN6_IS_ADDR_MULTICAST(a) &&	\
+	 (__IPV6_ADDR_MC_SCOPE(a) == __IPV6_ADDR_SCOPE_ORGLOCAL))
+#define IN6_IS_ADDR_MC_GLOBAL(a)	\
+	(IN6_IS_ADDR_MULTICAST(a) &&	\
+	 (__IPV6_ADDR_MC_SCOPE(a) == __IPV6_ADDR_SCOPE_GLOBAL))
+#endif
+
+#ifdef _KERNEL	/* nonstandard */
+/*
+ * KAME Scope
+ */
+#define IN6_IS_SCOPE_LINKLOCAL(a)	\
+	((IN6_IS_ADDR_LINKLOCAL(a)) ||	\
+	 (IN6_IS_ADDR_MC_LINKLOCAL(a)))
+#define	IN6_IS_SCOPE_EMBED(a)			\
+	((IN6_IS_ADDR_LINKLOCAL(a)) ||		\
+	 (IN6_IS_ADDR_MC_LINKLOCAL(a)) ||	\
+	 (IN6_IS_ADDR_MC_INTFACELOCAL(a)))
+
+#define IFA6_IS_DEPRECATED(a) \
+	((a)->ia6_lifetime.ia6t_pltime != ND6_INFINITE_LIFETIME && \
+	 (u_int32_t)((time_second - (a)->ia6_updatetime)) > \
+	 (a)->ia6_lifetime.ia6t_pltime)
+#define IFA6_IS_INVALID(a) \
+	((a)->ia6_lifetime.ia6t_vltime != ND6_INFINITE_LIFETIME && \
+	 (u_int32_t)((time_second - (a)->ia6_updatetime)) > \
+	 (a)->ia6_lifetime.ia6t_vltime)
+#endif /* _KERNEL */
+
+/*
+ * IP6 route structure
+ */
+#if __BSD_VISIBLE
+struct route_in6 {
+	struct	rtentry *ro_rt;
+	struct	llentry *ro_lle;
+	struct	in6_addr *ro_ia6;
+	int		ro_flags;
+	struct	sockaddr_in6 ro_dst;
+};
+#endif
+
+/*
+ * Options for use with [gs]etsockopt at the IPV6 level.
+ * First word of comment is data type; bool is stored in int.
+ */
+/* no hdrincl */
+#if 0 /* the followings are relic in IPv4 and hence are disabled */
+#define IPV6_OPTIONS		1  /* buf/ip6_opts; set/get IP6 options */
+#define IPV6_RECVOPTS		5  /* bool; receive all IP6 opts w/dgram */
+#define IPV6_RECVRETOPTS	6  /* bool; receive IP6 opts for response */
+#define IPV6_RECVDSTADDR	7  /* bool; receive IP6 dst addr w/dgram */
+#define IPV6_RETOPTS		8  /* ip6_opts; set/get IP6 options */
+#endif
+#define IPV6_SOCKOPT_RESERVED1	3  /* reserved for future use */
+#define IPV6_UNICAST_HOPS	4  /* int; IP6 hops */
+#define IPV6_MULTICAST_IF	9  /* u_int; set/get IP6 multicast i/f  */
+#define IPV6_MULTICAST_HOPS	10 /* int; set/get IP6 multicast hops */
+#define IPV6_MULTICAST_LOOP	11 /* u_int; set/get IP6 multicast loopback */
+#define IPV6_JOIN_GROUP		12 /* ipv6_mreq; join a group membership */
+#define IPV6_LEAVE_GROUP	13 /* ipv6_mreq; leave a group membership */
+#define IPV6_PORTRANGE		14 /* int; range to choose for unspec port */
+#define ICMP6_FILTER		18 /* icmp6_filter; icmp6 filter */
+/* RFC2292 options */
+#ifdef _KERNEL
+#define IPV6_2292PKTINFO	19 /* bool; send/recv if, src/dst addr */
+#define IPV6_2292HOPLIMIT	20 /* bool; hop limit */
+#define IPV6_2292NEXTHOP	21 /* bool; next hop addr */
+#define IPV6_2292HOPOPTS	22 /* bool; hop-by-hop option */
+#define IPV6_2292DSTOPTS	23 /* bool; destinaion option */
+#define IPV6_2292RTHDR		24 /* bool; routing header */
+#define IPV6_2292PKTOPTIONS	25 /* buf/cmsghdr; set/get IPv6 options */
+#endif
+
+#define IPV6_CHECKSUM		26 /* int; checksum offset for raw socket */
+#define IPV6_V6ONLY		27 /* bool; make AF_INET6 sockets v6 only */
+#ifndef _KERNEL
+#define IPV6_BINDV6ONLY		IPV6_V6ONLY
+#endif
+
+#if 1 /* IPSEC */
+#define IPV6_IPSEC_POLICY	28 /* struct; get/set security policy */
+#endif /* IPSEC */
+
+#define IPV6_FAITH		29 /* bool; accept FAITH'ed connections */
+
+#if 1 /* IPV6FIREWALL */
+#define IPV6_FW_ADD		30 /* add a firewall rule to chain */
+#define IPV6_FW_DEL		31 /* delete a firewall rule from chain */
+#define IPV6_FW_FLUSH		32 /* flush firewall rule chain */
+#define IPV6_FW_ZERO		33 /* clear single/all firewall counter(s) */
+#define IPV6_FW_GET		34 /* get entire firewall rule chain */
+#endif
+
+/* new socket options introduced in RFC3542 */
+#define IPV6_RTHDRDSTOPTS	35 /* ip6_dest; send dst option before rthdr */
+
+#define IPV6_RECVPKTINFO	36 /* bool; recv if, dst addr */
+#define IPV6_RECVHOPLIMIT	37 /* bool; recv hop limit */
+#define IPV6_RECVRTHDR		38 /* bool; recv routing header */
+#define IPV6_RECVHOPOPTS	39 /* bool; recv hop-by-hop option */
+#define IPV6_RECVDSTOPTS	40 /* bool; recv dst option after rthdr */
+#ifdef _KERNEL
+#define IPV6_RECVRTHDRDSTOPTS	41 /* bool; recv dst option before rthdr */
+#endif
+
+#define IPV6_USE_MIN_MTU	42 /* bool; send packets at the minimum MTU */
+#define IPV6_RECVPATHMTU	43 /* bool; notify an according MTU */
+
+#define IPV6_PATHMTU		44 /* mtuinfo; get the current path MTU (sopt),
+				      4 bytes int; MTU notification (cmsg) */
+#if 0 /*obsoleted during 2292bis -> 3542*/
+#define IPV6_REACHCONF		45 /* no data; ND reachability confirm
+				      (cmsg only/not in of RFC3542) */
+#endif
+
+/* more new socket options introduced in RFC3542 */
+#define IPV6_PKTINFO		46 /* in6_pktinfo; send if, src addr */
+#define IPV6_HOPLIMIT		47 /* int; send hop limit */
+#define IPV6_NEXTHOP		48 /* sockaddr; next hop addr */
+#define IPV6_HOPOPTS		49 /* ip6_hbh; send hop-by-hop option */
+#define IPV6_DSTOPTS		50 /* ip6_dest; send dst option befor rthdr */
+#define IPV6_RTHDR		51 /* ip6_rthdr; send routing header */
+#if 0
+#define IPV6_PKTOPTIONS		52 /* buf/cmsghdr; set/get IPv6 options */
+				   /* obsoleted by RFC3542 */
+#endif
+
+#define IPV6_RECVTCLASS		57 /* bool; recv traffic class values */
+
+#define IPV6_AUTOFLOWLABEL	59 /* bool; attach flowlabel automagically */
+
+#define IPV6_TCLASS		61 /* int; send traffic class value */
+#define IPV6_DONTFRAG		62 /* bool; disable IPv6 fragmentation */
+
+#define IPV6_PREFER_TEMPADDR	63 /* int; prefer temporary addresses as
+				    * the source address.
+				    */
+
+#define	IPV6_BINDANY		64 /* bool: allow bind to any address */
+
+/*
+ * The following option is private; do not use it from user applications.
+ * It is deliberately defined to the same value as IP_MSFILTER.
+ */
+#define	IPV6_MSFILTER		74 /* struct __msfilterreq;
+				    * set/get multicast source filter list.
+				    */
+
+/* to define items, should talk with KAME guys first, for *BSD compatibility */
+
+#define IPV6_RTHDR_LOOSE     0 /* this hop need not be a neighbor. XXX old spec */
+#define IPV6_RTHDR_STRICT    1 /* this hop must be a neighbor. XXX old spec */
+#define IPV6_RTHDR_TYPE_0    0 /* IPv6 routing header type 0 */
+
+/*
+ * Defaults and limits for options
+ */
+#define IPV6_DEFAULT_MULTICAST_HOPS 1	/* normally limit m'casts to 1 hop */
+#define IPV6_DEFAULT_MULTICAST_LOOP 1	/* normally hear sends if a member */
+
+/*
+ * The im6o_membership vector for each socket is now dynamically allocated at
+ * run-time, bounded by USHRT_MAX, and is reallocated when needed, sized
+ * according to a power-of-two increment.
+ */
+#define	IPV6_MIN_MEMBERSHIPS	31
+#define	IPV6_MAX_MEMBERSHIPS	4095
+
+/*
+ * Default resource limits for IPv6 multicast source filtering.
+ * These may be modified by sysctl.
+ */
+#define	IPV6_MAX_GROUP_SRC_FILTER	512	/* sources per group */
+#define	IPV6_MAX_SOCK_SRC_FILTER	128	/* sources per socket/group */
+
+/*
+ * Argument structure for IPV6_JOIN_GROUP and IPV6_LEAVE_GROUP.
+ */
+struct ipv6_mreq {
+	struct in6_addr	ipv6mr_multiaddr;
+	unsigned int	ipv6mr_interface;
+};
+
+/*
+ * IPV6_PKTINFO: Packet information(RFC2292 sec 5)
+ */
+struct in6_pktinfo {
+	struct in6_addr	ipi6_addr;	/* src/dst IPv6 address */
+	unsigned int	ipi6_ifindex;	/* send/recv interface index */
+};
+
+/*
+ * Control structure for IPV6_RECVPATHMTU socket option.
+ */
+struct ip6_mtuinfo {
+	struct sockaddr_in6 ip6m_addr;	/* or sockaddr_storage? */
+	uint32_t ip6m_mtu;
+};
+
+/*
+ * Argument for IPV6_PORTRANGE:
+ * - which range to search when port is unspecified at bind() or connect()
+ */
+#define	IPV6_PORTRANGE_DEFAULT	0	/* default range */
+#define	IPV6_PORTRANGE_HIGH	1	/* "high" - request firewall bypass */
+#define	IPV6_PORTRANGE_LOW	2	/* "low" - vouchsafe security */
+
+#if __BSD_VISIBLE
+/*
+ * Definitions for inet6 sysctl operations.
+ *
+ * Third level is protocol number.
+ * Fourth level is desired variable within that protocol.
+ */
+#define IPV6PROTO_MAXID	(IPPROTO_PIM + 1)	/* don't list to IPV6PROTO_MAX */
+
+/*
+ * Names for IP sysctl objects
+ */
+#define IPV6CTL_FORWARDING	1	/* act as router */
+#define IPV6CTL_SENDREDIRECTS	2	/* may send redirects when forwarding*/
+#define IPV6CTL_DEFHLIM		3	/* default Hop-Limit */
+#ifdef notyet
+#define IPV6CTL_DEFMTU		4	/* default MTU */
+#endif
+#define IPV6CTL_FORWSRCRT	5	/* forward source-routed dgrams */
+#define IPV6CTL_STATS		6	/* stats */
+#define IPV6CTL_MRTSTATS	7	/* multicast forwarding stats */
+#define IPV6CTL_MRTPROTO	8	/* multicast routing protocol */
+#define IPV6CTL_MAXFRAGPACKETS	9	/* max packets reassembly queue */
+#define IPV6CTL_SOURCECHECK	10	/* verify source route and intf */
+#define IPV6CTL_SOURCECHECK_LOGINT 11	/* minimume logging interval */
+#define IPV6CTL_ACCEPT_RTADV	12
+#define IPV6CTL_KEEPFAITH	13
+#define IPV6CTL_LOG_INTERVAL	14
+#define IPV6CTL_HDRNESTLIMIT	15
+#define IPV6CTL_DAD_COUNT	16
+#define IPV6CTL_AUTO_FLOWLABEL	17
+#define IPV6CTL_DEFMCASTHLIM	18
+#define IPV6CTL_GIF_HLIM	19	/* default HLIM for gif encap packet */
+#define IPV6CTL_KAME_VERSION	20
+#define IPV6CTL_USE_DEPRECATED	21	/* use deprecated addr (RFC2462 5.5.4) */
+#define IPV6CTL_RR_PRUNE	22	/* walk timer for router renumbering */
+#if 0	/* obsolete */
+#define IPV6CTL_MAPPED_ADDR	23
+#endif
+#define IPV6CTL_V6ONLY		24
+#define IPV6CTL_RTEXPIRE	25	/* cloned route expiration time */
+#define IPV6CTL_RTMINEXPIRE	26	/* min value for expiration time */
+#define IPV6CTL_RTMAXCACHE	27	/* trigger level for dynamic expire */
+
+#define IPV6CTL_USETEMPADDR	32	/* use temporary addresses (RFC3041) */
+#define IPV6CTL_TEMPPLTIME	33	/* preferred lifetime for tmpaddrs */
+#define IPV6CTL_TEMPVLTIME	34	/* valid lifetime for tmpaddrs */
+#define IPV6CTL_AUTO_LINKLOCAL	35	/* automatic link-local addr assign */
+#define IPV6CTL_RIP6STATS	36	/* raw_ip6 stats */
+#define IPV6CTL_PREFER_TEMPADDR	37	/* prefer temporary addr as src */
+#define IPV6CTL_ADDRCTLPOLICY	38	/* get/set address selection policy */
+#define IPV6CTL_USE_DEFAULTZONE	39	/* use default scope zone */
+
+#define IPV6CTL_MAXFRAGS	41	/* max fragments */
+#if 0
+#define IPV6CTL_IFQ		42	/* ip6intrq node */
+#define IPV6CTL_ISATAPRTR	43	/* isatap router */
+#endif
+#define IPV6CTL_MCAST_PMTU	44	/* enable pMTU discovery for multicast? */
+
+/* New entries should be added here from current IPV6CTL_MAXID value. */
+/* to define items, should talk with KAME guys first, for *BSD compatibility */
+#define IPV6CTL_STEALTH		45
+
+#define	ICMPV6CTL_ND6_ONLINKNSRFC4861	47
+#define	IPV6CTL_NO_RADR		48	/* No defroute from RA */
+#define	IPV6CTL_NORBIT_RAIF	49	/* Disable R-bit in NA on RA
+					 * receiving IF. */
+#define	IPV6CTL_RFC6204W3	50	/* Accept defroute even when forwarding
+					   enabled */
+#define	IPV6CTL_MAXID		51
+#endif /* __BSD_VISIBLE */
+
+/*
+ * Redefinition of mbuf flags
+ */
+#define	M_AUTHIPHDR	M_PROTO2
+#define	M_DECRYPTED	M_PROTO3
+#define	M_LOOP		M_PROTO4
+#define	M_AUTHIPDGM	M_PROTO5
+#define	M_RTALERT_MLD	M_PROTO6
+
+#ifdef _KERNEL
+struct cmsghdr;
+
+int	in6_cksum __P((struct mbuf *, u_int8_t, u_int32_t, u_int32_t));
+int	in6_localaddr __P((struct in6_addr *));
+int	in6_localip(struct in6_addr *);
+int	in6_addrscope __P((struct in6_addr *));
+struct	in6_ifaddr *in6_ifawithifp __P((struct ifnet *, struct in6_addr *));
+extern void in6_if_up __P((struct ifnet *));
+struct sockaddr;
+extern	u_char	ip6_protox[];
+
+void	in6_sin6_2_sin __P((struct sockaddr_in *sin,
+			    struct sockaddr_in6 *sin6));
+void	in6_sin_2_v4mapsin6 __P((struct sockaddr_in *sin,
+				 struct sockaddr_in6 *sin6));
+void	in6_sin6_2_sin_in_sock __P((struct sockaddr *nam));
+void	in6_sin_2_v4mapsin6_in_sock __P((struct sockaddr **nam));
+extern void addrsel_policy_init __P((void));
+
+#define	satosin6(sa)	((struct sockaddr_in6 *)(sa))
+#define	sin6tosa(sin6)	((struct sockaddr *)(sin6))
+#define	ifatoia6(ifa)	((struct in6_ifaddr *)(ifa))
+
+extern int	(*faithprefix_p)(struct in6_addr *);
+#endif /* _KERNEL */
+
+#ifndef _SIZE_T_DECLARED
+typedef	__size_t	size_t;
+#define	_SIZE_T_DECLARED
+#endif
+
+#ifndef _SOCKLEN_T_DECLARED
+typedef	__socklen_t	socklen_t;
+#define	_SOCKLEN_T_DECLARED
+#endif
+
+#if __BSD_VISIBLE
+
+__BEGIN_DECLS
+struct cmsghdr;
+
+extern int inet6_option_space __P((int));
+extern int inet6_option_init __P((void *, struct cmsghdr **, int));
+extern int inet6_option_append __P((struct cmsghdr *, const uint8_t *,
+	int, int));
+extern uint8_t *inet6_option_alloc __P((struct cmsghdr *, int, int, int));
+extern int inet6_option_next __P((const struct cmsghdr *, uint8_t **));
+extern int inet6_option_find __P((const struct cmsghdr *, uint8_t **, int));
+
+extern size_t inet6_rthdr_space __P((int, int));
+extern struct cmsghdr *inet6_rthdr_init __P((void *, int));
+extern int inet6_rthdr_add __P((struct cmsghdr *, const struct in6_addr *,
+	unsigned int));
+extern int inet6_rthdr_lasthop __P((struct cmsghdr *, unsigned int));
+#if 0 /* not implemented yet */
+extern int inet6_rthdr_reverse __P((const struct cmsghdr *, struct cmsghdr *));
+#endif
+extern int inet6_rthdr_segments __P((const struct cmsghdr *));
+extern struct in6_addr *inet6_rthdr_getaddr __P((struct cmsghdr *, int));
+extern int inet6_rthdr_getflags __P((const struct cmsghdr *, int));
+
+extern int inet6_opt_init __P((void *, socklen_t));
+extern int inet6_opt_append __P((void *, socklen_t, int, uint8_t, socklen_t,
+	uint8_t, void **));
+extern int inet6_opt_finish __P((void *, socklen_t, int));
+extern int inet6_opt_set_val __P((void *, int, void *, socklen_t));
+
+extern int inet6_opt_next __P((void *, socklen_t, int, uint8_t *, socklen_t *,
+	void **));
+extern int inet6_opt_find __P((void *, socklen_t, int, uint8_t, socklen_t *,
+	void **));
+extern int inet6_opt_get_val __P((void *, int, void *, socklen_t));
+extern socklen_t inet6_rth_space __P((int, int));
+extern void *inet6_rth_init __P((void *, socklen_t, int, int));
+extern int inet6_rth_add __P((void *, const struct in6_addr *));
+extern int inet6_rth_reverse __P((const void *, void *));
+extern int inet6_rth_segments __P((const void *));
+extern struct in6_addr *inet6_rth_getaddr __P((const void *, int));
+__END_DECLS
+
+#endif /* __BSD_VISIBLE */
+
+#endif /* !_NETINET6_IN6_H_ */
diff --git a/include/pcre.h b/include/pcre.h
new file mode 100644
index 0000000..42a109a
--- /dev/null
+++ b/include/pcre.h
@@ -0,0 +1,370 @@
+/*************************************************
+*       Perl-Compatible Regular Expressions      *
+*************************************************/
+
+/* This is the public header file for the PCRE library, to be #included by
+applications that call the PCRE functions.
+
+           Copyright (c) 1997-2011 University of Cambridge
+
+-----------------------------------------------------------------------------
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+    * Neither the name of the University of Cambridge nor the names of its
+      contributors may be used to endorse or promote products derived from
+      this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+-----------------------------------------------------------------------------
+*/
+
+#ifndef _PCRE_H
+#define _PCRE_H
+
+/* The current PCRE version information. */
+
+#define PCRE_MAJOR          8
+#define PCRE_MINOR          20
+#define PCRE_PRERELEASE     
+#define PCRE_DATE           2011-10-21
+
+/* When an application links to a PCRE DLL in Windows, the symbols that are
+imported have to be identified as such. When building PCRE, the appropriate
+export setting is defined in pcre_internal.h, which includes this file. So we
+don't change existing definitions of PCRE_EXP_DECL and PCRECPP_EXP_DECL. */
+
+#if defined(_WIN32) && !defined(PCRE_STATIC)
+#  ifndef PCRE_EXP_DECL
+#    define PCRE_EXP_DECL  extern __declspec(dllimport)
+#  endif
+#  ifdef __cplusplus
+#    ifndef PCRECPP_EXP_DECL
+#      define PCRECPP_EXP_DECL  extern __declspec(dllimport)
+#    endif
+#    ifndef PCRECPP_EXP_DEFN
+#      define PCRECPP_EXP_DEFN  __declspec(dllimport)
+#    endif
+#  endif
+#endif
+
+/* By default, we use the standard "extern" declarations. */
+
+#ifndef PCRE_EXP_DECL
+#  ifdef __cplusplus
+#    define PCRE_EXP_DECL  extern "C"
+#  else
+#    define PCRE_EXP_DECL  extern
+#  endif
+#endif
+
+#ifdef __cplusplus
+#  ifndef PCRECPP_EXP_DECL
+#    define PCRECPP_EXP_DECL  extern
+#  endif
+#  ifndef PCRECPP_EXP_DEFN
+#    define PCRECPP_EXP_DEFN
+#  endif
+#endif
+
+/* Have to include stdlib.h in order to ensure that size_t is defined;
+it is needed here for malloc. */
+
+#include <stdlib.h>
+
+/* Allow for C++ users */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Options. Some are compile-time only, some are run-time only, and some are
+both, so we keep them all distinct. However, almost all the bits in the options
+word are now used. In the long run, we may have to re-use some of the
+compile-time only bits for runtime options, or vice versa. */
+
+#define PCRE_CASELESS           0x00000001  /* Compile */
+#define PCRE_MULTILINE          0x00000002  /* Compile */
+#define PCRE_DOTALL             0x00000004  /* Compile */
+#define PCRE_EXTENDED           0x00000008  /* Compile */
+#define PCRE_ANCHORED           0x00000010  /* Compile, exec, DFA exec */
+#define PCRE_DOLLAR_ENDONLY     0x00000020  /* Compile */
+#define PCRE_EXTRA              0x00000040  /* Compile */
+#define PCRE_NOTBOL             0x00000080  /* Exec, DFA exec */
+#define PCRE_NOTEOL             0x00000100  /* Exec, DFA exec */
+#define PCRE_UNGREEDY           0x00000200  /* Compile */
+#define PCRE_NOTEMPTY           0x00000400  /* Exec, DFA exec */
+#define PCRE_UTF8               0x00000800  /* Compile */
+#define PCRE_NO_AUTO_CAPTURE    0x00001000  /* Compile */
+#define PCRE_NO_UTF8_CHECK      0x00002000  /* Compile, exec, DFA exec */
+#define PCRE_AUTO_CALLOUT       0x00004000  /* Compile */
+#define PCRE_PARTIAL_SOFT       0x00008000  /* Exec, DFA exec */
+#define PCRE_PARTIAL            0x00008000  /* Backwards compatible synonym */
+#define PCRE_DFA_SHORTEST       0x00010000  /* DFA exec */
+#define PCRE_DFA_RESTART        0x00020000  /* DFA exec */
+#define PCRE_FIRSTLINE          0x00040000  /* Compile */
+#define PCRE_DUPNAMES           0x00080000  /* Compile */
+#define PCRE_NEWLINE_CR         0x00100000  /* Compile, exec, DFA exec */
+#define PCRE_NEWLINE_LF         0x00200000  /* Compile, exec, DFA exec */
+#define PCRE_NEWLINE_CRLF       0x00300000  /* Compile, exec, DFA exec */
+#define PCRE_NEWLINE_ANY        0x00400000  /* Compile, exec, DFA exec */
+#define PCRE_NEWLINE_ANYCRLF    0x00500000  /* Compile, exec, DFA exec */
+#define PCRE_BSR_ANYCRLF        0x00800000  /* Compile, exec, DFA exec */
+#define PCRE_BSR_UNICODE        0x01000000  /* Compile, exec, DFA exec */
+#define PCRE_JAVASCRIPT_COMPAT  0x02000000  /* Compile */
+#define PCRE_NO_START_OPTIMIZE  0x04000000  /* Compile, exec, DFA exec */
+#define PCRE_NO_START_OPTIMISE  0x04000000  /* Synonym */
+#define PCRE_PARTIAL_HARD       0x08000000  /* Exec, DFA exec */
+#define PCRE_NOTEMPTY_ATSTART   0x10000000  /* Exec, DFA exec */
+#define PCRE_UCP                0x20000000  /* Compile */
+
+/* Exec-time and get/set-time error codes */
+
+#define PCRE_ERROR_NOMATCH         (-1)
+#define PCRE_ERROR_NULL            (-2)
+#define PCRE_ERROR_BADOPTION       (-3)
+#define PCRE_ERROR_BADMAGIC        (-4)
+#define PCRE_ERROR_UNKNOWN_OPCODE  (-5)
+#define PCRE_ERROR_UNKNOWN_NODE    (-5)  /* For backward compatibility */
+#define PCRE_ERROR_NOMEMORY        (-6)
+#define PCRE_ERROR_NOSUBSTRING     (-7)
+#define PCRE_ERROR_MATCHLIMIT      (-8)
+#define PCRE_ERROR_CALLOUT         (-9)  /* Never used by PCRE itself */
+#define PCRE_ERROR_BADUTF8        (-10)
+#define PCRE_ERROR_BADUTF8_OFFSET (-11)
+#define PCRE_ERROR_PARTIAL        (-12)
+#define PCRE_ERROR_BADPARTIAL     (-13)
+#define PCRE_ERROR_INTERNAL       (-14)
+#define PCRE_ERROR_BADCOUNT       (-15)
+#define PCRE_ERROR_DFA_UITEM      (-16)
+#define PCRE_ERROR_DFA_UCOND      (-17)
+#define PCRE_ERROR_DFA_UMLIMIT    (-18)
+#define PCRE_ERROR_DFA_WSSIZE     (-19)
+#define PCRE_ERROR_DFA_RECURSE    (-20)
+#define PCRE_ERROR_RECURSIONLIMIT (-21)
+#define PCRE_ERROR_NULLWSLIMIT    (-22)  /* No longer actually used */
+#define PCRE_ERROR_BADNEWLINE     (-23)
+#define PCRE_ERROR_BADOFFSET      (-24)
+#define PCRE_ERROR_SHORTUTF8      (-25)
+#define PCRE_ERROR_RECURSELOOP    (-26)
+#define PCRE_ERROR_JIT_STACKLIMIT (-27)
+
+/* Specific error codes for UTF-8 validity checks */
+
+#define PCRE_UTF8_ERR0               0
+#define PCRE_UTF8_ERR1               1
+#define PCRE_UTF8_ERR2               2
+#define PCRE_UTF8_ERR3               3
+#define PCRE_UTF8_ERR4               4
+#define PCRE_UTF8_ERR5               5
+#define PCRE_UTF8_ERR6               6
+#define PCRE_UTF8_ERR7               7
+#define PCRE_UTF8_ERR8               8
+#define PCRE_UTF8_ERR9               9
+#define PCRE_UTF8_ERR10             10
+#define PCRE_UTF8_ERR11             11
+#define PCRE_UTF8_ERR12             12
+#define PCRE_UTF8_ERR13             13
+#define PCRE_UTF8_ERR14             14
+#define PCRE_UTF8_ERR15             15
+#define PCRE_UTF8_ERR16             16
+#define PCRE_UTF8_ERR17             17
+#define PCRE_UTF8_ERR18             18
+#define PCRE_UTF8_ERR19             19
+#define PCRE_UTF8_ERR20             20
+#define PCRE_UTF8_ERR21             21
+
+/* Request types for pcre_fullinfo() */
+
+#define PCRE_INFO_OPTIONS            0
+#define PCRE_INFO_SIZE               1
+#define PCRE_INFO_CAPTURECOUNT       2
+#define PCRE_INFO_BACKREFMAX         3
+#define PCRE_INFO_FIRSTBYTE          4
+#define PCRE_INFO_FIRSTCHAR          4  /* For backwards compatibility */
+#define PCRE_INFO_FIRSTTABLE         5
+#define PCRE_INFO_LASTLITERAL        6
+#define PCRE_INFO_NAMEENTRYSIZE      7
+#define PCRE_INFO_NAMECOUNT          8
+#define PCRE_INFO_NAMETABLE          9
+#define PCRE_INFO_STUDYSIZE         10
+#define PCRE_INFO_DEFAULT_TABLES    11
+#define PCRE_INFO_OKPARTIAL         12
+#define PCRE_INFO_JCHANGED          13
+#define PCRE_INFO_HASCRORLF         14
+#define PCRE_INFO_MINLENGTH         15
+#define PCRE_INFO_JIT               16
+
+/* Request types for pcre_config(). Do not re-arrange, in order to remain
+compatible. */
+
+#define PCRE_CONFIG_UTF8                    0
+#define PCRE_CONFIG_NEWLINE                 1
+#define PCRE_CONFIG_LINK_SIZE               2
+#define PCRE_CONFIG_POSIX_MALLOC_THRESHOLD  3
+#define PCRE_CONFIG_MATCH_LIMIT             4
+#define PCRE_CONFIG_STACKRECURSE            5
+#define PCRE_CONFIG_UNICODE_PROPERTIES      6
+#define PCRE_CONFIG_MATCH_LIMIT_RECURSION   7
+#define PCRE_CONFIG_BSR                     8
+#define PCRE_CONFIG_JIT                     9
+
+/* Request types for pcre_study(). Do not re-arrange, in order to remain
+compatible. */
+
+#define PCRE_STUDY_JIT_COMPILE            0x0001
+
+/* Bit flags for the pcre_extra structure. Do not re-arrange or redefine
+these bits, just add new ones on the end, in order to remain compatible. */
+
+#define PCRE_EXTRA_STUDY_DATA             0x0001
+#define PCRE_EXTRA_MATCH_LIMIT            0x0002
+#define PCRE_EXTRA_CALLOUT_DATA           0x0004
+#define PCRE_EXTRA_TABLES                 0x0008
+#define PCRE_EXTRA_MATCH_LIMIT_RECURSION  0x0010
+#define PCRE_EXTRA_MARK                   0x0020
+#define PCRE_EXTRA_EXECUTABLE_JIT         0x0040
+
+/* Types */
+
+struct real_pcre;                 /* declaration; the definition is private  */
+typedef struct real_pcre pcre;
+
+struct real_pcre_jit_stack;       /* declaration; the definition is private  */
+typedef struct real_pcre_jit_stack pcre_jit_stack;
+
+/* When PCRE is compiled as a C++ library, the subject pointer type can be
+replaced with a custom type. For conventional use, the public interface is a
+const char *. */
+
+#ifndef PCRE_SPTR
+#define PCRE_SPTR const char *
+#endif
+
+/* The structure for passing additional data to pcre_exec(). This is defined in
+such as way as to be extensible. Always add new fields at the end, in order to
+remain compatible. */
+
+typedef struct pcre_extra {
+  unsigned long int flags;        /* Bits for which fields are set */
+  void *study_data;               /* Opaque data from pcre_study() */
+  unsigned long int match_limit;  /* Maximum number of calls to match() */
+  void *callout_data;             /* Data passed back in callouts */
+  const unsigned char *tables;    /* Pointer to character tables */
+  unsigned long int match_limit_recursion; /* Max recursive calls to match() */
+  unsigned char **mark;           /* For passing back a mark pointer */
+  void *executable_jit;           /* Contains a pointer to a compiled jit code */
+} pcre_extra;
+
+/* The structure for passing out data via the pcre_callout_function. We use a
+structure so that new fields can be added on the end in future versions,
+without changing the API of the function, thereby allowing old clients to work
+without modification. */
+
+typedef struct pcre_callout_block {
+  int          version;           /* Identifies version of block */
+  /* ------------------------ Version 0 ------------------------------- */
+  int          callout_number;    /* Number compiled into pattern */
+  int         *offset_vector;     /* The offset vector */
+  PCRE_SPTR    subject;           /* The subject being matched */
+  int          subject_length;    /* The length of the subject */
+  int          start_match;       /* Offset to start of this match attempt */
+  int          current_position;  /* Where we currently are in the subject */
+  int          capture_top;       /* Max current capture */
+  int          capture_last;      /* Most recently closed capture */
+  void        *callout_data;      /* Data passed in with the call */
+  /* ------------------- Added for Version 1 -------------------------- */
+  int          pattern_position;  /* Offset to next item in the pattern */
+  int          next_item_length;  /* Length of next item in the pattern */
+  /* ------------------- Added for Version 2 -------------------------- */
+  const unsigned char *mark;      /* Pointer to current mark or NULL    */
+  /* ------------------------------------------------------------------ */
+} pcre_callout_block;
+
+/* Indirection for store get and free functions. These can be set to
+alternative malloc/free functions if required. Special ones are used in the
+non-recursive case for "frames". There is also an optional callout function
+that is triggered by the (?) regex item. For Virtual Pascal, these definitions
+have to take another form. */
+
+#ifndef VPCOMPAT
+PCRE_EXP_DECL void *(*pcre_malloc)(size_t);
+PCRE_EXP_DECL void  (*pcre_free)(void *);
+PCRE_EXP_DECL void *(*pcre_stack_malloc)(size_t);
+PCRE_EXP_DECL void  (*pcre_stack_free)(void *);
+PCRE_EXP_DECL int   (*pcre_callout)(pcre_callout_block *);
+#else   /* VPCOMPAT */
+PCRE_EXP_DECL void *pcre_malloc(size_t);
+PCRE_EXP_DECL void  pcre_free(void *);
+PCRE_EXP_DECL void *pcre_stack_malloc(size_t);
+PCRE_EXP_DECL void  pcre_stack_free(void *);
+PCRE_EXP_DECL int   pcre_callout(pcre_callout_block *);
+#endif  /* VPCOMPAT */
+
+/* User defined callback which provides a stack just before the match starts. */
+
+typedef pcre_jit_stack *(*pcre_jit_callback)(void *);
+
+/* Exported PCRE functions */
+
+PCRE_EXP_DECL pcre *pcre_compile(const char *, int, const char **, int *,
+                  const unsigned char *);
+PCRE_EXP_DECL pcre *pcre_compile2(const char *, int, int *, const char **,
+                  int *, const unsigned char *);
+PCRE_EXP_DECL int  pcre_config(int, void *);
+PCRE_EXP_DECL int  pcre_copy_named_substring(const pcre *, const char *,
+                  int *, int, const char *, char *, int);
+PCRE_EXP_DECL int  pcre_copy_substring(const char *, int *, int, int, char *,
+                  int);
+PCRE_EXP_DECL int  pcre_dfa_exec(const pcre *, const pcre_extra *,
+                  const char *, int, int, int, int *, int , int *, int);
+PCRE_EXP_DECL int  pcre_exec(const pcre *, const pcre_extra *, PCRE_SPTR,
+                   int, int, int, int *, int);
+PCRE_EXP_DECL void pcre_free_substring(const char *);
+PCRE_EXP_DECL void pcre_free_substring_list(const char **);
+PCRE_EXP_DECL int  pcre_fullinfo(const pcre *, const pcre_extra *, int,
+                  void *);
+PCRE_EXP_DECL int  pcre_get_named_substring(const pcre *, const char *,
+                  int *, int, const char *, const char **);
+PCRE_EXP_DECL int  pcre_get_stringnumber(const pcre *, const char *);
+PCRE_EXP_DECL int  pcre_get_stringtable_entries(const pcre *, const char *,
+                  char **, char **);
+PCRE_EXP_DECL int  pcre_get_substring(const char *, int *, int, int,
+                  const char **);
+PCRE_EXP_DECL int  pcre_get_substring_list(const char *, int *, int,
+                  const char ***);
+PCRE_EXP_DECL int  pcre_info(const pcre *, int *, int *);
+PCRE_EXP_DECL const unsigned char *pcre_maketables(void);
+PCRE_EXP_DECL int  pcre_refcount(pcre *, int);
+PCRE_EXP_DECL pcre_extra *pcre_study(const pcre *, int, const char **);
+PCRE_EXP_DECL void pcre_free_study(pcre_extra *);
+PCRE_EXP_DECL const char *pcre_version(void);
+
+/* JIT compiler related functions. */
+
+PCRE_EXP_DECL pcre_jit_stack *pcre_jit_stack_alloc(int, int);
+PCRE_EXP_DECL void pcre_jit_stack_free(pcre_jit_stack *);
+PCRE_EXP_DECL void pcre_assign_jit_stack(pcre_extra *, pcre_jit_callback, void *);
+
+#ifdef __cplusplus
+}  /* extern "C" */
+#endif
+
+#endif /* End of pcre.h */
diff --git a/include/pcre/pcreposix.h b/include/pcre/pcreposix.h
deleted file mode 100644
index b90e2ec..0000000
--- a/include/pcre/pcreposix.h
+++ /dev/null
@@ -1,146 +0,0 @@
-/*************************************************
-*       Perl-Compatible Regular Expressions      *
-*************************************************/
-
-#ifndef _PCREPOSIX_H
-#define _PCREPOSIX_H
-
-/* This is the header for the POSIX wrapper interface to the PCRE Perl-
-Compatible Regular Expression library. It defines the things POSIX says should
-be there. I hope.
-
-            Copyright (c) 1997-2009 University of Cambridge
-
------------------------------------------------------------------------------
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-    * Redistributions of source code must retain the above copyright notice,
-      this list of conditions and the following disclaimer.
-
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-
-    * Neither the name of the University of Cambridge nor the names of its
-      contributors may be used to endorse or promote products derived from
-      this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
-LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGE.
------------------------------------------------------------------------------
-*/
-
-/* Have to include stdlib.h in order to ensure that size_t is defined. */
-
-#include <stdlib.h>
-
-/* Allow for C++ users */
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* Options, mostly defined by POSIX, but with some extras. */
-
-#define REG_ICASE     0x0001   /* Maps to PCRE_CASELESS */
-#define REG_NEWLINE   0x0002   /* Maps to PCRE_MULTILINE */
-#define REG_NOTBOL    0x0004   /* Maps to PCRE_NOTBOL */
-#define REG_NOTEOL    0x0008   /* Maps to PCRE_NOTEOL */
-#define REG_DOTALL    0x0010   /* NOT defined by POSIX; maps to PCRE_DOTALL */
-#define REG_NOSUB     0x0020   /* Maps to PCRE_NO_AUTO_CAPTURE */
-#define REG_UTF8      0x0040   /* NOT defined by POSIX; maps to PCRE_UTF8 */
-#define REG_STARTEND  0x0080   /* BSD feature: pass subject string by so,eo */
-#define REG_NOTEMPTY  0x0100   /* NOT defined by POSIX; maps to PCRE_NOTEMPTY */
-#define REG_UNGREEDY  0x0200   /* NOT defined by POSIX; maps to PCRE_UNGREEDY */
-#define REG_UCP       0x0400   /* NOT defined by POSIX; maps to PCRE_UCP */
-
-/* This is not used by PCRE, but by defining it we make it easier
-to slot PCRE into existing programs that make POSIX calls. */
-
-#define REG_EXTENDED  0
-
-/* Error values. Not all these are relevant or used by the wrapper. */
-
-enum {
-  REG_ASSERT = 1,  /* internal error ? */
-  REG_BADBR,       /* invalid repeat counts in {} */
-  REG_BADPAT,      /* pattern error */
-  REG_BADRPT,      /* ? * + invalid */
-  REG_EBRACE,      /* unbalanced {} */
-  REG_EBRACK,      /* unbalanced [] */
-  REG_ECOLLATE,    /* collation error - not relevant */
-  REG_ECTYPE,      /* bad class */
-  REG_EESCAPE,     /* bad escape sequence */
-  REG_EMPTY,       /* empty expression */
-  REG_EPAREN,      /* unbalanced () */
-  REG_ERANGE,      /* bad range inside [] */
-  REG_ESIZE,       /* expression too big */
-  REG_ESPACE,      /* failed to get memory */
-  REG_ESUBREG,     /* bad back reference */
-  REG_INVARG,      /* bad argument */
-  REG_NOMATCH      /* match failed */
-};
-
-
-/* The structure representing a compiled regular expression. */
-
-typedef struct {
-  void *re_pcre;
-  size_t re_nsub;
-  size_t re_erroffset;
-} regex_t;
-
-/* The structure in which a captured offset is returned. */
-
-typedef int regoff_t;
-
-typedef struct {
-  regoff_t rm_so;
-  regoff_t rm_eo;
-} regmatch_t;
-
-/* When an application links to a PCRE DLL in Windows, the symbols that are
-imported have to be identified as such. When building PCRE, the appropriate
-export settings are needed, and are set in pcreposix.c before including this
-file. */
-
-#if defined(_WIN32) && !defined(PCRE_STATIC) && !defined(PCREPOSIX_EXP_DECL)
-#  define PCREPOSIX_EXP_DECL  extern __declspec(dllimport)
-#  define PCREPOSIX_EXP_DEFN  __declspec(dllimport)
-#endif
-
-/* By default, we use the standard "extern" declarations. */
-
-#ifndef PCREPOSIX_EXP_DECL
-#  ifdef __cplusplus
-#    define PCREPOSIX_EXP_DECL  extern "C"
-#    define PCREPOSIX_EXP_DEFN  extern "C"
-#  else
-#    define PCREPOSIX_EXP_DECL  extern
-#    define PCREPOSIX_EXP_DEFN  extern
-#  endif
-#endif
-
-/* The functions */
-
-PCREPOSIX_EXP_DECL int regcomp(regex_t *, const char *, int);
-PCREPOSIX_EXP_DECL int regexec(const regex_t *, const char *, size_t,
-                     regmatch_t *, int);
-PCREPOSIX_EXP_DECL size_t regerror(int, const regex_t *, char *, size_t);
-PCREPOSIX_EXP_DECL void regfree(regex_t *);
-
-#ifdef __cplusplus
-}   /* extern "C" */
-#endif
-
-#endif /* End of pcreposix.h */
diff --git a/include/pcreposix.h b/include/pcreposix.h
new file mode 100644
index 0000000..b90e2ec
--- /dev/null
+++ b/include/pcreposix.h
@@ -0,0 +1,146 @@
+/*************************************************
+*       Perl-Compatible Regular Expressions      *
+*************************************************/
+
+#ifndef _PCREPOSIX_H
+#define _PCREPOSIX_H
+
+/* This is the header for the POSIX wrapper interface to the PCRE Perl-
+Compatible Regular Expression library. It defines the things POSIX says should
+be there. I hope.
+
+            Copyright (c) 1997-2009 University of Cambridge
+
+-----------------------------------------------------------------------------
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+    * Neither the name of the University of Cambridge nor the names of its
+      contributors may be used to endorse or promote products derived from
+      this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+-----------------------------------------------------------------------------
+*/
+
+/* Have to include stdlib.h in order to ensure that size_t is defined. */
+
+#include <stdlib.h>
+
+/* Allow for C++ users */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Options, mostly defined by POSIX, but with some extras. */
+
+#define REG_ICASE     0x0001   /* Maps to PCRE_CASELESS */
+#define REG_NEWLINE   0x0002   /* Maps to PCRE_MULTILINE */
+#define REG_NOTBOL    0x0004   /* Maps to PCRE_NOTBOL */
+#define REG_NOTEOL    0x0008   /* Maps to PCRE_NOTEOL */
+#define REG_DOTALL    0x0010   /* NOT defined by POSIX; maps to PCRE_DOTALL */
+#define REG_NOSUB     0x0020   /* Maps to PCRE_NO_AUTO_CAPTURE */
+#define REG_UTF8      0x0040   /* NOT defined by POSIX; maps to PCRE_UTF8 */
+#define REG_STARTEND  0x0080   /* BSD feature: pass subject string by so,eo */
+#define REG_NOTEMPTY  0x0100   /* NOT defined by POSIX; maps to PCRE_NOTEMPTY */
+#define REG_UNGREEDY  0x0200   /* NOT defined by POSIX; maps to PCRE_UNGREEDY */
+#define REG_UCP       0x0400   /* NOT defined by POSIX; maps to PCRE_UCP */
+
+/* This is not used by PCRE, but by defining it we make it easier
+to slot PCRE into existing programs that make POSIX calls. */
+
+#define REG_EXTENDED  0
+
+/* Error values. Not all these are relevant or used by the wrapper. */
+
+enum {
+  REG_ASSERT = 1,  /* internal error ? */
+  REG_BADBR,       /* invalid repeat counts in {} */
+  REG_BADPAT,      /* pattern error */
+  REG_BADRPT,      /* ? * + invalid */
+  REG_EBRACE,      /* unbalanced {} */
+  REG_EBRACK,      /* unbalanced [] */
+  REG_ECOLLATE,    /* collation error - not relevant */
+  REG_ECTYPE,      /* bad class */
+  REG_EESCAPE,     /* bad escape sequence */
+  REG_EMPTY,       /* empty expression */
+  REG_EPAREN,      /* unbalanced () */
+  REG_ERANGE,      /* bad range inside [] */
+  REG_ESIZE,       /* expression too big */
+  REG_ESPACE,      /* failed to get memory */
+  REG_ESUBREG,     /* bad back reference */
+  REG_INVARG,      /* bad argument */
+  REG_NOMATCH      /* match failed */
+};
+
+
+/* The structure representing a compiled regular expression. */
+
+typedef struct {
+  void *re_pcre;
+  size_t re_nsub;
+  size_t re_erroffset;
+} regex_t;
+
+/* The structure in which a captured offset is returned. */
+
+typedef int regoff_t;
+
+typedef struct {
+  regoff_t rm_so;
+  regoff_t rm_eo;
+} regmatch_t;
+
+/* When an application links to a PCRE DLL in Windows, the symbols that are
+imported have to be identified as such. When building PCRE, the appropriate
+export settings are needed, and are set in pcreposix.c before including this
+file. */
+
+#if defined(_WIN32) && !defined(PCRE_STATIC) && !defined(PCREPOSIX_EXP_DECL)
+#  define PCREPOSIX_EXP_DECL  extern __declspec(dllimport)
+#  define PCREPOSIX_EXP_DEFN  __declspec(dllimport)
+#endif
+
+/* By default, we use the standard "extern" declarations. */
+
+#ifndef PCREPOSIX_EXP_DECL
+#  ifdef __cplusplus
+#    define PCREPOSIX_EXP_DECL  extern "C"
+#    define PCREPOSIX_EXP_DEFN  extern "C"
+#  else
+#    define PCREPOSIX_EXP_DECL  extern
+#    define PCREPOSIX_EXP_DEFN  extern
+#  endif
+#endif
+
+/* The functions */
+
+PCREPOSIX_EXP_DECL int regcomp(regex_t *, const char *, int);
+PCREPOSIX_EXP_DECL int regexec(const regex_t *, const char *, size_t,
+                     regmatch_t *, int);
+PCREPOSIX_EXP_DECL size_t regerror(int, const regex_t *, char *, size_t);
+PCREPOSIX_EXP_DECL void regfree(regex_t *);
+
+#ifdef __cplusplus
+}   /* extern "C" */
+#endif
+
+#endif /* End of pcreposix.h */
diff --git a/include/pthread.h b/include/pthread.h
new file mode 100644
index 0000000..71e337b
--- /dev/null
+++ b/include/pthread.h
@@ -0,0 +1,298 @@
+/*
+ * Copyright (c) 1993, 1994 by Chris Provenzano, proven@mit.edu
+ * Copyright (c) 1995-1998 by John Birrell <jb@cimlogic.com.au>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *  This product includes software developed by Chris Provenzano.
+ * 4. The name of Chris Provenzano may not be used to endorse or promote 
+ *	  products derived from this software without specific prior written
+ *	  permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY CHRIS PROVENZANO ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL CHRIS PROVENZANO BE LIABLE FOR ANY 
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD$
+ */
+#ifndef _PTHREAD_H_
+#define _PTHREAD_H_
+
+/*
+ * Header files.
+ */
+#include <sys/cdefs.h>
+#include <sys/_pthreadtypes.h>
+#include <machine/_limits.h>
+#include <sys/_types.h>
+#include <sys/_sigset.h>
+#include <sys/types.h>
+#include <sched.h>
+#include <time.h>
+
+/*
+ * Run-time invariant values:
+ */
+#define PTHREAD_DESTRUCTOR_ITERATIONS		4
+#define PTHREAD_KEYS_MAX			256
+#define PTHREAD_STACK_MIN			__MINSIGSTKSZ
+#define PTHREAD_THREADS_MAX			__ULONG_MAX
+#define PTHREAD_BARRIER_SERIAL_THREAD		-1
+
+/*
+ * Flags for threads and thread attributes.
+ */
+#define PTHREAD_DETACHED            0x1
+#define PTHREAD_SCOPE_SYSTEM        0x2
+#define PTHREAD_INHERIT_SCHED       0x4
+#define PTHREAD_NOFLOAT             0x8
+
+#define PTHREAD_CREATE_DETACHED     PTHREAD_DETACHED
+#define PTHREAD_CREATE_JOINABLE     0
+#define PTHREAD_SCOPE_PROCESS       0
+#define PTHREAD_EXPLICIT_SCHED      0
+
+/*
+ * Flags for read/write lock attributes
+ */
+#define PTHREAD_PROCESS_PRIVATE     0
+#define PTHREAD_PROCESS_SHARED      1	
+
+/*
+ * Flags for cancelling threads
+ */
+#define PTHREAD_CANCEL_ENABLE		0
+#define PTHREAD_CANCEL_DISABLE		1
+#define PTHREAD_CANCEL_DEFERRED		0
+#define PTHREAD_CANCEL_ASYNCHRONOUS	2
+#define PTHREAD_CANCELED		((void *) 1)
+
+/*
+ * Flags for once initialization.
+ */
+#define PTHREAD_NEEDS_INIT  0
+#define PTHREAD_DONE_INIT   1
+
+/*
+ * Static once initialization values. 
+ */
+#define PTHREAD_ONCE_INIT   { PTHREAD_NEEDS_INIT, NULL }
+
+/*
+ * Static initialization values. 
+ */
+#define PTHREAD_MUTEX_INITIALIZER	NULL
+#define PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP	((pthread_mutex_t)1)
+#define PTHREAD_COND_INITIALIZER	NULL
+#define PTHREAD_RWLOCK_INITIALIZER	NULL
+
+/*
+ * Default attribute arguments (draft 4, deprecated).
+ */
+#ifndef PTHREAD_KERNEL
+#define pthread_condattr_default    NULL
+#define pthread_mutexattr_default   NULL
+#define pthread_attr_default        NULL
+#endif
+
+#define PTHREAD_PRIO_NONE	0
+#define PTHREAD_PRIO_INHERIT	1
+#define PTHREAD_PRIO_PROTECT	2
+
+/*
+ * Mutex types (Single UNIX Specification, Version 2, 1997).
+ *
+ * Note that a mutex attribute with one of the following types:
+ *
+ *	PTHREAD_MUTEX_NORMAL
+ *	PTHREAD_MUTEX_RECURSIVE
+ *
+ * will deviate from POSIX specified semantics.
+ */
+enum pthread_mutextype {
+	PTHREAD_MUTEX_ERRORCHECK	= 1,	/* Default POSIX mutex */
+	PTHREAD_MUTEX_RECURSIVE		= 2,	/* Recursive mutex */
+	PTHREAD_MUTEX_NORMAL		= 3,	/* No error checking */
+	PTHREAD_MUTEX_ADAPTIVE_NP	= 4,	/* Adaptive mutex, spins briefly before blocking on lock */
+	PTHREAD_MUTEX_TYPE_MAX
+};
+
+#define PTHREAD_MUTEX_DEFAULT		PTHREAD_MUTEX_ERRORCHECK
+
+struct _pthread_cleanup_info {
+	__uintptr_t	pthread_cleanup_pad[8];
+};
+
+/*
+ * Thread function prototype definitions:
+ */
+__BEGIN_DECLS
+int		pthread_atfork(void (*)(void), void (*)(void), void (*)(void));
+int		pthread_attr_destroy(pthread_attr_t *);
+int		pthread_attr_getstack(const pthread_attr_t * __restrict, 
+			void ** __restrict, size_t * __restrict);
+int		pthread_attr_getstacksize(const pthread_attr_t *, size_t *);
+int		pthread_attr_getguardsize(const pthread_attr_t *, size_t *);
+int		pthread_attr_getstackaddr(const pthread_attr_t *, void **);
+int		pthread_attr_getdetachstate(const pthread_attr_t *, int *);
+int		pthread_attr_init(pthread_attr_t *);
+int		pthread_attr_setstacksize(pthread_attr_t *, size_t);
+int		pthread_attr_setguardsize(pthread_attr_t *, size_t);
+int		pthread_attr_setstack(pthread_attr_t *, void *, size_t);
+int		pthread_attr_setstackaddr(pthread_attr_t *, void *);
+int		pthread_attr_setdetachstate(pthread_attr_t *, int);
+int		pthread_barrier_destroy(pthread_barrier_t *);
+int		pthread_barrier_init(pthread_barrier_t *,
+			const pthread_barrierattr_t *, unsigned);
+int		pthread_barrier_wait(pthread_barrier_t *);
+int		pthread_barrierattr_destroy(pthread_barrierattr_t *);
+int		pthread_barrierattr_getpshared(const pthread_barrierattr_t *,
+			int *);
+int		pthread_barrierattr_init(pthread_barrierattr_t *);
+int		pthread_barrierattr_setpshared(pthread_barrierattr_t *, int);
+
+#define		pthread_cleanup_push(cleanup_routine, cleanup_arg)		\
+		{								\
+			struct _pthread_cleanup_info __cleanup_info__;		\
+			__pthread_cleanup_push_imp(cleanup_routine, cleanup_arg,\
+				&__cleanup_info__);				\
+			{
+
+#define		pthread_cleanup_pop(execute)					\
+			}							\
+			__pthread_cleanup_pop_imp(execute);			\
+		}
+
+int		pthread_condattr_destroy(pthread_condattr_t *);
+int		pthread_condattr_getclock(const pthread_condattr_t *,
+			clockid_t *);
+int		pthread_condattr_getpshared(const pthread_condattr_t *, int *);
+int		pthread_condattr_init(pthread_condattr_t *);
+int		pthread_condattr_setclock(pthread_condattr_t *, clockid_t);
+int		pthread_condattr_setpshared(pthread_condattr_t *, int);
+int		pthread_cond_broadcast(pthread_cond_t *);
+int		pthread_cond_destroy(pthread_cond_t *);
+int		pthread_cond_init(pthread_cond_t *,
+			const pthread_condattr_t *);
+int		pthread_cond_signal(pthread_cond_t *);
+int		pthread_cond_timedwait(pthread_cond_t *,
+			pthread_mutex_t *, const struct timespec *);
+int		pthread_cond_wait(pthread_cond_t *, pthread_mutex_t *);
+int		pthread_create(pthread_t *, const pthread_attr_t *,
+			void *(*) (void *), void *);
+int		pthread_detach(pthread_t);
+int		pthread_equal(pthread_t, pthread_t);
+void		pthread_exit(void *) __dead2;
+void		*pthread_getspecific(pthread_key_t);
+int		pthread_getcpuclockid(pthread_t, clockid_t *);
+int		pthread_join(pthread_t, void **);
+int		pthread_key_create(pthread_key_t *,
+			void (*) (void *));
+int		pthread_key_delete(pthread_key_t);
+int		pthread_mutexattr_init(pthread_mutexattr_t *);
+int		pthread_mutexattr_destroy(pthread_mutexattr_t *);
+int		pthread_mutexattr_getpshared(const pthread_mutexattr_t *,
+			int *);
+int		pthread_mutexattr_gettype(pthread_mutexattr_t *, int *);
+int		pthread_mutexattr_settype(pthread_mutexattr_t *, int);
+int		pthread_mutexattr_setpshared(pthread_mutexattr_t *, int);
+int		pthread_mutex_destroy(pthread_mutex_t *);
+int		pthread_mutex_init(pthread_mutex_t *,
+			const pthread_mutexattr_t *);
+int		pthread_mutex_lock(pthread_mutex_t *);
+int		pthread_mutex_trylock(pthread_mutex_t *);
+int		pthread_mutex_timedlock(pthread_mutex_t *,
+			const struct timespec *);
+int		pthread_mutex_unlock(pthread_mutex_t *);
+int		pthread_once(pthread_once_t *, void (*) (void));
+int		pthread_rwlock_destroy(pthread_rwlock_t *);
+int		pthread_rwlock_init(pthread_rwlock_t *,
+			const pthread_rwlockattr_t *);
+int		pthread_rwlock_rdlock(pthread_rwlock_t *);
+int		pthread_rwlock_timedrdlock(pthread_rwlock_t *,
+			const struct timespec *);
+int		pthread_rwlock_timedwrlock(pthread_rwlock_t *,
+			const struct timespec *);
+int		pthread_rwlock_tryrdlock(pthread_rwlock_t *);
+int		pthread_rwlock_trywrlock(pthread_rwlock_t *);
+int		pthread_rwlock_unlock(pthread_rwlock_t *);
+int		pthread_rwlock_wrlock(pthread_rwlock_t *);
+int		pthread_rwlockattr_destroy(pthread_rwlockattr_t *);
+int		pthread_rwlockattr_getkind_np(const pthread_rwlockattr_t *,
+			int *);
+int		pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *,
+			int *);
+int		pthread_rwlockattr_init(pthread_rwlockattr_t *);
+int		pthread_rwlockattr_setkind_np(pthread_rwlockattr_t *, int);
+int		pthread_rwlockattr_setpshared(pthread_rwlockattr_t *, int);
+pthread_t	pthread_self(void);
+int		pthread_setspecific(pthread_key_t, const void *);
+
+int		pthread_spin_init(pthread_spinlock_t *, int);
+int		pthread_spin_destroy(pthread_spinlock_t *);
+int		pthread_spin_lock(pthread_spinlock_t *);
+int		pthread_spin_trylock(pthread_spinlock_t *);
+int		pthread_spin_unlock(pthread_spinlock_t *);
+int		pthread_cancel(pthread_t);
+int		pthread_setcancelstate(int, int *);
+int		pthread_setcanceltype(int, int *);
+void		pthread_testcancel(void);
+
+#if __BSD_VISIBLE
+int		pthread_getprio(pthread_t);
+int		pthread_setprio(pthread_t, int);
+void		pthread_yield(void);
+#endif
+
+int		pthread_mutexattr_getprioceiling(pthread_mutexattr_t *,
+			int *);
+int		pthread_mutexattr_setprioceiling(pthread_mutexattr_t *,
+			int);
+int		pthread_mutex_getprioceiling(pthread_mutex_t *, int *);
+int		pthread_mutex_setprioceiling(pthread_mutex_t *, int, int *);
+
+int		pthread_mutexattr_getprotocol(pthread_mutexattr_t *, int *);
+int		pthread_mutexattr_setprotocol(pthread_mutexattr_t *, int);
+
+int		pthread_attr_getinheritsched(const pthread_attr_t *, int *);
+int		pthread_attr_getschedparam(const pthread_attr_t *,
+			struct sched_param *);
+int		pthread_attr_getschedpolicy(const pthread_attr_t *, int *);
+int		pthread_attr_getscope(const pthread_attr_t *, int *);
+int		pthread_attr_setinheritsched(pthread_attr_t *, int);
+int		pthread_attr_setschedparam(pthread_attr_t *,
+			const struct sched_param *);
+int		pthread_attr_setschedpolicy(pthread_attr_t *, int);
+int		pthread_attr_setscope(pthread_attr_t *, int);
+int		pthread_getschedparam(pthread_t pthread, int *,
+			struct sched_param *);
+int		pthread_setschedparam(pthread_t, int,
+			const struct sched_param *);
+#if __XSI_VISIBLE
+int		pthread_getconcurrency(void);
+int		pthread_setconcurrency(int);
+#endif
+
+void		__pthread_cleanup_push_imp(void (*)(void *), void *,
+			struct _pthread_cleanup_info *);
+void		__pthread_cleanup_pop_imp(int);
+__END_DECLS
+
+#endif
diff --git a/include/signal.h b/include/signal.h
index e8df812..f6b6e95 100644
--- a/include/signal.h
+++ b/include/signal.h
@@ -93,10 +93,31 @@ __BEGIN_DECLS
 
 #define NSIG            32      /* number of old signals (counting 0) */
 
-#define SIG_ERR ((void *) -1)
-#define SIG_DFL ((void *) 0)
-#define SIG_IGN ((void *) 1)
-#define SIG_HOLD ((void *)3)
+#if __POSIX_VISIBLE || __XSI_VISIBLE
+#define SA_NOCLDSTOP    0x0008  /* do not generate SIGCHLD on child stop */
+#endif /* __POSIX_VISIBLE || __XSI_VISIBLE */
+
+#if __XSI_VISIBLE
+#define SA_ONSTACK      0x0001  /* take signal on signal stack */
+#define SA_RESTART      0x0002  /* restart system call on signal return */
+#define SA_RESETHAND    0x0004  /* reset to SIG_DFL when taking signal */
+#define SA_NODEFER      0x0010  /* don't mask the signal we're delivering */
+#define SA_NOCLDWAIT    0x0020  /* don't keep zombies around */
+#define SA_SIGINFO      0x0040  /* signal handler with SA_SIGINFO args */
+#endif
+
+/* Adjusted to linux, has unused sa_restorer field and unsigned long
+   sa_flags; relatively unimportant though.  */
+/* Type of a signal handler.  */
+typedef void (*__sighandler_t)(int);
+
+/* The type used in newlib sources.  */
+typedef __sighandler_t _sig_func_ptr;
+
+#define SIG_ERR ((_sig_func_ptr) -1)
+#define SIG_DFL ((_sig_func_ptr) 0)
+#define SIG_IGN ((_sig_func_ptr) 1)
+#define SIG_HOLD ((_sig_func_ptr)3)
 
 #ifndef _PID_T_DECLARED
 typedef	__pid_t		pid_t;
@@ -110,6 +131,79 @@ typedef void (*signalhandler_t)(int);
 typedef __sigset_t      sigset_t;
 #endif
 
+union sigval {
+        /* Members as suggested by Annex C of POSIX 1003.1b. */
+        int     sival_int;
+        void    *sival_ptr;
+        /* 6.0 compatibility */
+        int     sigval_int;
+        void    *sigval_ptr;
+};
+
+typedef struct __siginfo {
+        int     si_signo;               /* signal number */
+        int     si_errno;               /* errno association */
+        /*
+         * Cause of signal, one of the SI_ macros or signal-specific
+         * values, i.e. one of the FPE_... values for SIGFPE.  This
+         * value is equivalent to the second argument to an old-style
+         * FreeBSD signal handler.
+         */
+        int     si_code;                /* signal code */
+        __pid_t si_pid;                 /* sending process */
+        __uid_t si_uid;                 /* sender's ruid */
+        int     si_status;              /* exit value */
+        void    *si_addr;               /* faulting instruction */
+        union sigval si_value;          /* signal value */
+        union   {
+                struct {
+                        int     _trapno;/* machine specific trap code */
+                } _fault;                                               
+                struct { 
+                        int     _timerid;
+                        int     _overrun;
+                } _timer;                
+                struct { 
+                        int     _mqd;
+                } _mesgq;            
+                struct { 
+                        long    _band;          /* band event for SIGPOLL */
+                } _poll;                        /* was this ever used ? */  
+                struct {                                                  
+                        long    __spare1__;
+                        int     __spare2__[7];
+                } __spare__;                  
+        } _reason;
+} siginfo_t;
+
+#define si_trapno       _reason._fault._trapno
+#define si_timerid      _reason._timer._timerid
+#define si_overrun      _reason._timer._overrun
+#define si_mqd          _reason._mesgq._mqd
+#define si_band         _reason._poll._band
+
+/* struct sigaction notes from POSIX:
+ *
+ *  (1) Routines stored in sa_handler should take a single int as
+ *      their argument although the POSIX standard does not require this.
+ *  (2) The fields sa_handler and sa_sigaction may overlap, and a conforming
+ *      application should not use both simultaneously.
+ */
+
+struct sigaction {
+  int         sa_flags;       /* Special flags to affect behavior of signal */
+  sigset_t    sa_mask;        /* Additional set of signals to be blocked */
+                              /*   during execution of signal-catching */
+                              /*   function. */
+  union {
+    _sig_func_ptr _handler;  /* SIG_DFL, SIG_IGN, or pointer to a function */
+    void      (*_sigaction)( int, siginfo_t *, void * );
+  } _signal_handlers;
+};
+
+#define sa_handler    _signal_handlers._handler
+#define sa_sigaction  _signal_handlers._sigaction
+
 /*
  * Flags for sigprocmask:
  */
@@ -126,7 +220,9 @@ int sigdelset(sigset_t *set, int signo);
 int sigemptyset(sigset_t *set);
 int sigfillset(sigset_t *set);
 int sigismember(const sigset_t *set, int signo);
-
+int sigaction(int signum, const struct sigaction *act,
+              struct sigaction *oldact);
+int raise(int sig);
 __END_DECLS
 
 #endif // BARRELFISH_SIGNAL_H_
diff --git a/include/spawndomain/spawndomain.h b/include/spawndomain/spawndomain.h
index 1808a9e..8ebf9b9 100644
--- a/include/spawndomain/spawndomain.h
+++ b/include/spawndomain/spawndomain.h
@@ -41,6 +41,9 @@ struct spawninfo {
 
     // vspace of spawned domain
     struct vspace *vspace;
+    struct vregion *vregion[16];
+    genvaddr_t base[16];
+    unsigned int vregions;
 
     dispatcher_handle_t handle;
     enum cpu_type cpu_type;
diff --git a/include/sys/_iovec.h b/include/sys/_iovec.h
index af4d365..44d4049 100644
--- a/include/sys/_iovec.h
+++ b/include/sys/_iovec.h
@@ -47,6 +47,7 @@ typedef	__size_t	size_t;
 struct iovec {
 	void	*iov_base;	/* Base address. */
 	size_t	 iov_len;	/* Length. */
+        void    *iov_opaque;	/* XXX: Arranet extension. */
 };
 
 #endif /* !_SYS__IOVEC_H_ */
diff --git a/include/sys/_pthreadtypes.h b/include/sys/_pthreadtypes.h
new file mode 100644
index 0000000..76049ee
--- /dev/null
+++ b/include/sys/_pthreadtypes.h
@@ -0,0 +1,98 @@
+/*
+ * Copyright (c) 1993, 1994 by Chris Provenzano, proven@mit.edu
+ * Copyright (c) 1995-1998 by John Birrell <jb@cimlogic.com.au>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *  This product includes software developed by Chris Provenzano.
+ * 4. The name of Chris Provenzano may not be used to endorse or promote 
+ *	  products derived from this software without specific prior written
+ *	  permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY CHRIS PROVENZANO ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL CHRIS PROVENZANO BE LIABLE FOR ANY 
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD$
+ */
+
+#ifndef _SYS__PTHREADTYPES_H_
+#define _SYS__PTHREADTYPES_H_
+
+/*
+ * Forward structure definitions.
+ *
+ * These are mostly opaque to the user.
+ */
+struct pthread;
+struct pthread_attr;
+struct pthread_cond;
+struct pthread_cond_attr;
+struct pthread_mutex;
+struct pthread_mutex_attr;
+struct pthread_once;
+struct pthread_rwlock;
+struct pthread_rwlockattr;
+struct pthread_barrier;
+struct pthread_barrier_attr;
+struct pthread_spinlock;
+
+/*
+ * Primitive system data type definitions required by P1003.1c.
+ *
+ * Note that P1003.1c specifies that there are no defined comparison
+ * or assignment operators for the types pthread_attr_t, pthread_cond_t,
+ * pthread_condattr_t, pthread_mutex_t, pthread_mutexattr_t.
+ */
+#ifndef _PTHREAD_T_DECLARED
+typedef struct	pthread			*pthread_t;
+#define	_PTHREAD_T_DECLARED
+#endif
+typedef struct	pthread_attr		*pthread_attr_t;
+typedef struct	pthread_mutex		*pthread_mutex_t;
+typedef struct	pthread_mutex_attr	*pthread_mutexattr_t;
+typedef struct	pthread_cond		*pthread_cond_t;
+typedef struct	pthread_cond_attr	*pthread_condattr_t;
+typedef int     			pthread_key_t;
+typedef struct	pthread_once		pthread_once_t;
+typedef struct	pthread_rwlock		*pthread_rwlock_t;
+typedef struct	pthread_rwlockattr	*pthread_rwlockattr_t;
+typedef struct	pthread_barrier		*pthread_barrier_t;
+typedef struct	pthread_barrierattr	*pthread_barrierattr_t;
+typedef struct	pthread_spinlock	*pthread_spinlock_t;
+
+/*
+ * Additional type definitions:
+ *
+ * Note that P1003.1c reserves the prefixes pthread_ and PTHREAD_ for
+ * use in header symbols.
+ */
+typedef void	*pthread_addr_t;
+typedef void	*(*pthread_startroutine_t)(void *);
+
+/*
+ * Once definitions.
+ */
+struct pthread_once {
+	int		state;
+	pthread_mutex_t	mutex;
+};
+
+#endif /* ! _SYS__PTHREADTYPES_H_ */
diff --git a/include/sys/_sockaddr_storage.h b/include/sys/_sockaddr_storage.h
new file mode 100644
index 0000000..5c0048b
--- /dev/null
+++ b/include/sys/_sockaddr_storage.h
@@ -0,0 +1,54 @@
+/*-
+ * Copyright (c) 1982, 1985, 1986, 1988, 1993, 1994
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)socket.h	8.4 (Berkeley) 2/21/94
+ * $FreeBSD$
+ */
+
+#ifndef _SYS__SOCKADDR_STORAGE_H_
+#define	_SYS__SOCKADDR_STORAGE_H_
+
+/*
+ * RFC 2553: protocol-independent placeholder for socket addresses
+ */
+#define	_SS_MAXSIZE	128U
+#define	_SS_ALIGNSIZE	(sizeof(__int64_t))
+#define	_SS_PAD1SIZE	(_SS_ALIGNSIZE - sizeof(unsigned char) - \
+			    sizeof(sa_family_t))
+#define	_SS_PAD2SIZE	(_SS_MAXSIZE - sizeof(unsigned char) - \
+			    sizeof(sa_family_t) - _SS_PAD1SIZE - _SS_ALIGNSIZE)
+
+struct sockaddr_storage {
+	unsigned char	ss_len;		/* address length */
+	sa_family_t	ss_family;	/* address family */
+	char		__ss_pad1[_SS_PAD1SIZE];
+	__int64_t	__ss_align;	/* force desired struct alignment */
+	char		__ss_pad2[_SS_PAD2SIZE];
+};
+
+#endif /* !_SYS__SOCKADDR_STORAGE_H_ */
diff --git a/include/sys/_types.h b/include/sys/_types.h
index e42f433..ce651ef 100644
--- a/include/sys/_types.h
+++ b/include/sys/_types.h
@@ -42,6 +42,7 @@ typedef int8_t          __int8_t;
 typedef int16_t         __int16_t;
 typedef int32_t         __int32_t;
 typedef int64_t         __int64_t;
+typedef uintptr_t       __uintptr_t;
 
 typedef __uint8_t       u_int8_t;       /* unsigned integrals (deprecated) */
 typedef __uint16_t      u_int16_t;
@@ -49,6 +50,7 @@ typedef __uint32_t      u_int32_t;
 typedef __uint64_t      u_int64_t;
 
 typedef __uint8_t       __sa_family_t;
+typedef __uint32_t	__socklen_t;
 
 typedef va_list         __va_list;
 typedef size_t          __size_t;
@@ -56,6 +58,7 @@ typedef size_t          __size_t;
 typedef __uint32_t	__gid_t;
 typedef __uint32_t	__uid_t;
 typedef __int32_t	__clock_t;
+typedef __int32_t       __clockid_t;    /* clock_gettime()... */
 
 typedef int             __ct_rune_t;    /* arg type for ctype funcs */
 typedef __ct_rune_t     __rune_t;       /* rune_t (see above) */
@@ -65,6 +68,9 @@ typedef __ct_rune_t     __wint_t;       /* wint_t (see above) */
 typedef __uint16_t      __mode_t;       /* permissions */
 typedef __int64_t       __off_t;        /* file offset */
 typedef __int32_t       __pid_t;        /* process [group] */
+typedef __int64_t       __rlim_t;       /* resource limit - intentionally */
+                                        /* signed, because of legacy code */
+                                        /* that uses -1 for RLIM_INFINITY */
 #define _HAVE_SYSTYPES
 typedef long            __key_t;        /* IPC key (for Sys V IPC) */
 
diff --git a/include/sys/epoll.h b/include/sys/epoll.h
new file mode 100644
index 0000000..952bf06
--- /dev/null
+++ b/include/sys/epoll.h
@@ -0,0 +1,86 @@
+/*
+ * Copyright (c) 2013, ETH Zurich.
+ * All rights reserved.
+ *
+ * This file is distributed under the terms in the attached LICENSE file.
+ * If you do not find this file, copies can be found by writing to:
+ * ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich. Attn: Systems Group.
+ */
+
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *  * Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+#ifndef _SYS_EPOLL_H_
+#define _SYS_EPOLL_H_
+
+#include <stdint.h>
+
+#define EPOLL_CLOEXEC    02000000
+#define EPOLL_NONBLOCK   04000
+
+#define EPOLLIN          0x00000001
+#define EPOLLPRI         0x00000002
+#define EPOLLOUT         0x00000004
+#define EPOLLERR         0x00000008
+#define EPOLLHUP         0x00000010
+#define EPOLLRDNORM      0x00000040
+#define EPOLLRDBAND      0x00000080
+#define EPOLLWRNORM      0x00000100
+#define EPOLLWRBAND      0x00000200
+#define EPOLLMSG         0x00000400
+#define EPOLLRDHUP       0x00002000
+#define EPOLLWAKEUP      0x20000000
+#define EPOLLONESHOT     0x40000000
+#define EPOLLET          0x80000000
+
+#define EPOLL_CTL_ADD    1
+#define EPOLL_CTL_DEL    2
+#define EPOLL_CTL_MOD    3
+
+typedef union epoll_data
+{
+  void *ptr;
+  int fd;
+  uint32_t u32;
+  uint64_t u64;
+} epoll_data_t;
+
+struct epoll_event
+{
+  uint32_t events;	/* Epoll events */
+  epoll_data_t data;	/* User data variable */
+} __attribute__ ((__packed__));
+
+int epoll_create(int size);
+int epoll_create1(int flags);
+int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
+int epoll_wait(int epfd, struct epoll_event *events,
+               int max, int timeout);
+int epoll_pwait(int epfd, struct epoll_event *events,
+                int max, int timeout, const sigset_t *sigmask);
+
+#endif
diff --git a/include/sys/mman.h b/include/sys/mman.h
new file mode 100644
index 0000000..a178d7c
--- /dev/null
+++ b/include/sys/mman.h
@@ -0,0 +1,251 @@
+/*-
+ * Copyright (c) 1982, 1986, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)mman.h	8.2 (Berkeley) 1/9/95
+ * $FreeBSD$
+ */
+
+#ifndef _SYS_MMAN_H_
+#define _SYS_MMAN_H_
+
+#include <sys/cdefs.h>
+#include <sys/_types.h>
+
+#if __BSD_VISIBLE
+/*
+ * Inheritance for minherit()
+ */
+#define INHERIT_SHARE	0
+#define INHERIT_COPY	1
+#define INHERIT_NONE	2
+#endif
+
+/*
+ * Protections are chosen from these bits, or-ed together
+ */
+#define	PROT_NONE	0x00	/* no permissions */
+#define	PROT_READ	0x01	/* pages can be read */
+#define	PROT_WRITE	0x02	/* pages can be written */
+#define	PROT_EXEC	0x04	/* pages can be executed */
+
+/*
+ * Flags contain sharing type and options.
+ * Sharing types; choose one.
+ */
+#define	MAP_SHARED	0x0001		/* share changes */
+#define	MAP_PRIVATE	0x0002		/* changes are private */
+#if __BSD_VISIBLE
+#define	MAP_COPY	MAP_PRIVATE	/* Obsolete */
+#endif
+
+/*
+ * Other flags
+ */
+#define	MAP_FIXED	 0x0010	/* map addr must be exactly as requested */
+
+#if __BSD_VISIBLE
+#define	MAP_RENAME	 0x0020	/* Sun: rename private pages to file */
+#define	MAP_NORESERVE	 0x0040	/* Sun: don't reserve needed swap area */
+#define	MAP_RESERVED0080 0x0080	/* previously misimplemented MAP_INHERIT */
+#define	MAP_RESERVED0100 0x0100	/* previously unimplemented MAP_NOEXTEND */
+#define	MAP_HASSEMAPHORE 0x0200	/* region may contain semaphores */
+#define	MAP_STACK	 0x0400	/* region grows down, like a stack */
+#define	MAP_NOSYNC	 0x0800 /* page to but do not sync underlying file */
+
+/*
+ * Mapping type
+ */
+#define	MAP_FILE	 0x0000	/* map from file (default) */
+#define	MAP_ANON	 0x1000	/* allocated from memory, swap space */
+#ifndef _KERNEL
+#define	MAP_ANONYMOUS	 MAP_ANON /* For compatibility. */
+#endif /* !_KERNEL */
+
+/*
+ * Extended flags
+ */
+#define	MAP_NOCORE	 0x00020000 /* dont include these pages in a coredump */
+#define	MAP_PREFAULT_READ 0x00040000 /* prefault mapping for reading */
+#endif /* __BSD_VISIBLE */
+
+#if __POSIX_VISIBLE >= 199309
+/*
+ * Process memory locking
+ */
+#define MCL_CURRENT	0x0001	/* Lock only current memory */
+#define MCL_FUTURE	0x0002	/* Lock all future memory as well */
+#endif
+
+/*
+ * Error return from mmap()
+ */
+#define MAP_FAILED	((void *)-1)
+
+/*
+ * msync() flags
+ */
+#define	MS_SYNC		0x0000	/* msync synchronously */
+#define MS_ASYNC	0x0001	/* return immediately */
+#define MS_INVALIDATE	0x0002	/* invalidate all cached data */
+
+/*
+ * Advice to madvise
+ */
+#define	_MADV_NORMAL	0	/* no further special treatment */
+#define	_MADV_RANDOM	1	/* expect random page references */
+#define	_MADV_SEQUENTIAL 2	/* expect sequential page references */
+#define	_MADV_WILLNEED	3	/* will need these pages */
+#define	_MADV_DONTNEED	4	/* dont need these pages */
+
+#if __BSD_VISIBLE
+#define	MADV_NORMAL	_MADV_NORMAL
+#define	MADV_RANDOM	_MADV_RANDOM
+#define	MADV_SEQUENTIAL _MADV_SEQUENTIAL
+#define	MADV_WILLNEED	_MADV_WILLNEED
+#define	MADV_DONTNEED	_MADV_DONTNEED
+#define	MADV_FREE	5	/* dont need these pages, and junk contents */
+#define	MADV_NOSYNC	6	/* try to avoid flushes to physical media */
+#define	MADV_AUTOSYNC	7	/* revert to default flushing strategy */
+#define	MADV_NOCORE	8	/* do not include these pages in a core file */
+#define	MADV_CORE	9	/* revert to including pages in a core file */
+#define	MADV_PROTECT	10	/* protect process from pageout kill */
+
+/*
+ * Return bits from mincore
+ */
+#define	MINCORE_INCORE	 	 0x1 /* Page is incore */
+#define	MINCORE_REFERENCED	 0x2 /* Page has been referenced by us */
+#define	MINCORE_MODIFIED	 0x4 /* Page has been modified by us */
+#define	MINCORE_REFERENCED_OTHER 0x8 /* Page has been referenced */
+#define	MINCORE_MODIFIED_OTHER	0x10 /* Page has been modified */
+#define	MINCORE_SUPER		0x20 /* Page is a "super" page */
+
+/*
+ * Anonymous object constant for shm_open().
+ */
+#define	SHM_ANON		((char *)1)
+#endif /* __BSD_VISIBLE */
+
+/*
+ * XXX missing POSIX_TYPED_MEM_* macros and
+ * posix_typed_mem_info structure.
+ */
+#if __POSIX_VISIBLE >= 200112
+#define	POSIX_MADV_NORMAL	_MADV_NORMAL
+#define	POSIX_MADV_RANDOM	_MADV_RANDOM
+#define	POSIX_MADV_SEQUENTIAL	_MADV_SEQUENTIAL
+#define	POSIX_MADV_WILLNEED	_MADV_WILLNEED
+#define	POSIX_MADV_DONTNEED	_MADV_DONTNEED
+#endif
+
+#ifndef _MODE_T_DECLARED
+typedef	__mode_t	mode_t;
+#define	_MODE_T_DECLARED
+#endif
+
+#ifndef _OFF_T_DECLARED
+typedef	__off_t		off_t;
+#define	_OFF_T_DECLARED
+#endif
+
+#ifndef _SIZE_T_DECLARED
+typedef	__size_t	size_t;
+#define	_SIZE_T_DECLARED
+#endif
+
+#if defined(_KERNEL) || defined(_WANT_FILE)
+#include <vm/vm.h>
+
+struct file;
+
+struct shmfd {
+	size_t		shm_size;
+	vm_object_t	shm_object;
+	int		shm_refs;
+	uid_t		shm_uid;
+	gid_t		shm_gid;
+	mode_t		shm_mode;
+	int		shm_kmappings;
+
+	/*
+	 * Values maintained solely to make this a better-behaved file
+	 * descriptor for fstat() to run on.
+	 */
+	struct timespec	shm_atime;
+	struct timespec	shm_mtime;
+	struct timespec	shm_ctime;
+	struct timespec	shm_birthtime;
+
+	struct label	*shm_label;		/* MAC label */
+	const char	*shm_path;
+};
+#endif
+
+#ifdef _KERNEL
+int	shm_mmap(struct shmfd *shmfd, vm_size_t objsize, vm_ooffset_t foff,
+	    vm_object_t *obj);
+int	shm_map(struct file *fp, size_t size, off_t offset, void **memp);
+int	shm_unmap(struct file *fp, void *mem, size_t size);
+void	shm_path(struct shmfd *shmfd, char *path, size_t size);
+
+#else /* !_KERNEL */
+
+__BEGIN_DECLS
+/*
+ * XXX not yet implemented: posix_mem_offset(), posix_typed_mem_get_info(),
+ * posix_typed_mem_open().
+ */
+#if __BSD_VISIBLE
+int	getpagesizes(size_t *, int);
+int	madvise(void *, size_t, int);
+int	mincore(const void *, size_t, char *);
+int	minherit(void *, size_t, int);
+#endif
+int	mlock(const void *, size_t);
+#ifndef _MMAP_DECLARED
+#define	_MMAP_DECLARED
+void *	mmap(void *, size_t, int, int, int, off_t);
+#endif
+int	mprotect(const void *, size_t, int);
+int	msync(void *, size_t, int);
+int	munlock(const void *, size_t);
+int	munmap(void *, size_t);
+#if __POSIX_VISIBLE >= 200112
+int	posix_madvise(void *, size_t, int);
+#endif
+#if __POSIX_VISIBLE >= 199309
+int	mlockall(int);
+int	munlockall(void);
+int	shm_open(const char *, int, mode_t);
+int	shm_unlink(const char *);
+#endif
+__END_DECLS
+
+#endif /* !_KERNEL */
+
+#endif /* !_SYS_MMAN_H_ */
diff --git a/include/sys/resource.h b/include/sys/resource.h
new file mode 100644
index 0000000..0d604f2
--- /dev/null
+++ b/include/sys/resource.h
@@ -0,0 +1,176 @@
+/*-
+ * Copyright (c) 1982, 1986, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)resource.h	8.4 (Berkeley) 1/9/95
+ * $FreeBSD$
+ */
+
+#ifndef _SYS_RESOURCE_H_
+#define	_SYS_RESOURCE_H_
+
+#include <sys/cdefs.h>
+#include <sys/time.h>
+#include <sys/_types.h>
+
+/*
+ * Process priority specifications to get/setpriority.
+ */
+#define	PRIO_MIN	-20
+#define	PRIO_MAX	20
+
+#define	PRIO_PROCESS	0
+#define	PRIO_PGRP	1
+#define	PRIO_USER	2
+
+/*
+ * Resource utilization information.
+ *
+ * All fields are only modified by curthread and
+ * no locks are required to read.
+ */
+
+#define	RUSAGE_SELF	0
+#define	RUSAGE_CHILDREN	-1
+#define	RUSAGE_THREAD	1
+
+struct rusage {
+	struct timeval ru_utime;	/* user time used */
+	struct timeval ru_stime;	/* system time used */
+	long	ru_maxrss;		/* max resident set size */
+#define	ru_first	ru_ixrss
+	long	ru_ixrss;		/* integral shared memory size */
+	long	ru_idrss;		/* integral unshared data " */
+	long	ru_isrss;		/* integral unshared stack " */
+	long	ru_minflt;		/* page reclaims */
+	long	ru_majflt;		/* page faults */
+	long	ru_nswap;		/* swaps */
+	long	ru_inblock;		/* block input operations */
+	long	ru_oublock;		/* block output operations */
+	long	ru_msgsnd;		/* messages sent */
+	long	ru_msgrcv;		/* messages received */
+	long	ru_nsignals;		/* signals received */
+	long	ru_nvcsw;		/* voluntary context switches */
+	long	ru_nivcsw;		/* involuntary " */
+#define	ru_last		ru_nivcsw
+};
+
+/*
+ * Resource limits
+ */
+#define	RLIMIT_CPU	0		/* maximum cpu time in seconds */
+#define	RLIMIT_FSIZE	1		/* maximum file size */
+#define	RLIMIT_DATA	2		/* data size */
+#define	RLIMIT_STACK	3		/* stack size */
+#define	RLIMIT_CORE	4		/* core file size */
+#define	RLIMIT_RSS	5		/* resident set size */
+#define	RLIMIT_MEMLOCK	6		/* locked-in-memory address space */
+#define	RLIMIT_NPROC	7		/* number of processes */
+#define	RLIMIT_NOFILE	8		/* number of open files */
+#define	RLIMIT_SBSIZE	9		/* maximum size of all socket buffers */
+#define	RLIMIT_VMEM	10		/* virtual process size (incl. mmap) */
+#define	RLIMIT_AS	RLIMIT_VMEM	/* standard name for RLIMIT_VMEM */
+#define	RLIMIT_NPTS	11		/* pseudo-terminals */
+#define	RLIMIT_SWAP	12		/* swap used */
+
+#define	RLIM_NLIMITS	13		/* number of resource limits */
+
+#define	RLIM_INFINITY	((rlim_t)(((uint64_t)1 << 63) - 1))
+/* XXX Missing: RLIM_SAVED_MAX, RLIM_SAVED_CUR */
+
+
+/*
+ * Resource limit string identifiers
+ */
+
+#ifdef _RLIMIT_IDENT
+static const char *rlimit_ident[RLIM_NLIMITS] = {
+	"cpu",
+	"fsize",
+	"data",
+	"stack",
+	"core",
+	"rss",
+	"memlock",
+	"nproc",
+	"nofile",
+	"sbsize",
+	"vmem",
+	"npts",
+	"swap",
+};
+#endif
+
+#ifndef _RLIM_T_DECLARED
+typedef	__rlim_t	rlim_t;
+#define	_RLIM_T_DECLARED
+#endif
+
+struct rlimit {
+	rlim_t	rlim_cur;		/* current (soft) limit */
+	rlim_t	rlim_max;		/* maximum value for rlim_cur */
+};
+
+#if __BSD_VISIBLE
+
+struct orlimit {
+	__int32_t	rlim_cur;	/* current (soft) limit */
+	__int32_t	rlim_max;	/* maximum value for rlim_cur */
+};
+
+struct loadavg {
+	__fixpt_t	ldavg[3];
+	long		fscale;
+};
+
+#define	CP_USER		0
+#define	CP_NICE		1
+#define	CP_SYS		2
+#define	CP_INTR		3
+#define	CP_IDLE		4
+#define	CPUSTATES	5
+
+#endif	/* __BSD_VISIBLE */
+
+#ifdef _KERNEL
+
+extern struct loadavg averunnable;
+void	read_cpu_time(long *cp_time);	/* Writes array of CPUSTATES */
+
+#else
+
+__BEGIN_DECLS
+/* XXX 2nd arg to [gs]etpriority() should be an id_t */
+int	getpriority(int, int);
+int	getrlimit(int, struct rlimit *);
+int	getrusage(int, struct rusage *);
+int	setpriority(int, int, int);
+int	setrlimit(int, const struct rlimit *);
+__END_DECLS
+
+#endif	/* _KERNEL */
+#endif	/* !_SYS_RESOURCE_H_ */
diff --git a/include/sys/signal.h b/include/sys/signal.h
new file mode 100644
index 0000000..2e602da
--- /dev/null
+++ b/include/sys/signal.h
@@ -0,0 +1 @@
+#include <signal.h>
diff --git a/include/sys/socket.h b/include/sys/socket.h
index dad3207..8051208 100644
--- a/include/sys/socket.h
+++ b/include/sys/socket.h
@@ -35,27 +35,96 @@
 
 #include <sys/cdefs.h>
 #include <lwip/sockets.h>
+#include <sys/_iovec.h>
+
+/*
+ * Message header for recvmsg and sendmsg calls.
+ * Used value-result for recvmsg, value only for sendmsg.
+ */
+struct msghdr {
+        void            *msg_name;              /* optional address */
+        socklen_t        msg_namelen;           /* size of address */
+        struct iovec    *msg_iov;               /* scatter/gather array */
+        int              msg_iovlen;            /* # elements in msg_iov */
+        void            *msg_control;           /* ancillary data, see below */
+        socklen_t        msg_controllen;        /* ancillary data buffer len */
+        int              msg_flags;             /* flags on received message */
+};
 
 #if __BSD_VISIBLE
 #define AF_LOCAL        AF_UNIX         /* local to host (pipes, portals) */
 #endif
 #define AF_UNIX         1               /* standardized name for AF_LOCAL */
+#define AF_INET6        28              /* IPv6 */
 #if __BSD_VISIBLE
 #define AF_MAX          38
 #endif
 
+#if __BSD_VISIBLE
+/*
+ * Protocol families, same as address families for now.
+ */
+#define PF_UNSPEC       AF_UNSPEC
+#define PF_LOCAL        AF_LOCAL
+#define PF_UNIX         PF_LOCAL        /* backward compatibility */
+#define PF_INET         AF_INET
+#define PF_IMPLINK      AF_IMPLINK
+#define PF_PUP          AF_PUP
+#define PF_CHAOS        AF_CHAOS
+#define PF_NETBIOS      AF_NETBIOS
+#define PF_ISO          AF_ISO
+#define PF_OSI          AF_ISO
+#define PF_ECMA         AF_ECMA
+#define PF_DATAKIT      AF_DATAKIT
+#define PF_CCITT        AF_CCITT
+#define PF_SNA          AF_SNA
+#define PF_DECnet       AF_DECnet
+#define PF_DLI          AF_DLI
+#define PF_LAT          AF_LAT
+#define PF_HYLINK       AF_HYLINK
+#define PF_APPLETALK    AF_APPLETALK
+#define PF_ROUTE        AF_ROUTE
+#define PF_LINK         AF_LINK
+#define PF_XTP          pseudo_AF_XTP   /* really just proto family, no AF */
+#define PF_COIP         AF_COIP
+#define PF_CNT          AF_CNT
+#define PF_SIP          AF_SIP
+#define PF_IPX          AF_IPX
+#define PF_RTIP         pseudo_AF_RTIP  /* same format as AF_INET */
+#define PF_PIP          pseudo_AF_PIP
+#define PF_ISDN         AF_ISDN
+#define PF_KEY          pseudo_AF_KEY
+#define PF_INET6        AF_INET6
+#define PF_NATM         AF_NATM
+#define PF_ATM          AF_ATM
+#define PF_NETGRAPH     AF_NETGRAPH
+#define PF_SLOW         AF_SLOW
+#define PF_SCLUSTER     AF_SCLUSTER
+#define PF_ARP          AF_ARP
+#define PF_BLUETOOTH    AF_BLUETOOTH
+#define PF_IEEE80211    AF_IEEE80211
+#define PF_INET_SDP     AF_INET_SDP
+#define PF_INET6_SDP    AF_INET6_SDP
+
+#define PF_MAX          AF_MAX
+#endif
+
 #ifndef _SA_FAMILY_T_DECLARED
 typedef __sa_family_t	sa_family_t;
 #define _SA_FAMILY_T_DECLARED
 #endif
 
+#include <sys/_sockaddr_storage.h>
+
 __BEGIN_DECLS
 ssize_t recv(int sockfd, void *buf, size_t len, int flags);
 ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,
                  struct sockaddr *src_addr, socklen_t *addrlen);
+ssize_t recvmsg(int, struct msghdr *, int);
 ssize_t send(int sockfd, const void *buf, size_t len, int flags);
 ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,
                const struct sockaddr *dest_addr, socklen_t addrlen);
+ssize_t sendmsg(int, const struct msghdr *, int);
 int socket(int domain, int type, int protocol);
 int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
 int listen(int sockfd, int backlog);
diff --git a/include/sys/stat.h b/include/sys/stat.h
index b645182..0693e42 100644
--- a/include/sys/stat.h
+++ b/include/sys/stat.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2007, 2008, 2009, 2011, 2012, ETH Zurich.
+ * Copyright (c) 2007, 2008, 2009, 2011, 2012, 2013, ETH Zurich.
  * All rights reserved.
  *
  * This file is distributed under the terms in the attached LICENSE file.
@@ -69,6 +69,7 @@ __BEGIN_DECLS
 mode_t umask(mode_t mask);
 int chmod(const char *path, mode_t mode);
 int mkdir(const char *pathname, int mode);
+int mkfifo(const char *pathname, mode_t mode);
 int stat(const char *pathname, struct stat *buf);
 int fstat(int fd, struct stat*buf);
 int lstat(const char *path, struct stat *buf);
diff --git a/include/sys/syslog.h b/include/sys/syslog.h
new file mode 100644
index 0000000..6f12831
--- /dev/null
+++ b/include/sys/syslog.h
@@ -0,0 +1,203 @@
+/*-
+ * Copyright (c) 1982, 1986, 1988, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)syslog.h	8.1 (Berkeley) 6/2/93
+ * $FreeBSD$
+ */
+
+#ifndef _SYS_SYSLOG_H_
+#define _SYS_SYSLOG_H_
+
+#define	_PATH_LOG	"/var/run/log"
+#define	_PATH_LOG_PRIV	"/var/run/logpriv"
+#define	_PATH_OLDLOG	"/dev/log"	/* backward compatibility */
+
+/*
+ * priorities/facilities are encoded into a single 32-bit quantity, where the
+ * bottom 3 bits are the priority (0-7) and the top 28 bits are the facility
+ * (0-big number).  Both the priorities and the facilities map roughly
+ * one-to-one to strings in the syslogd(8) source code.  This mapping is
+ * included in this file.
+ *
+ * priorities (these are ordered)
+ */
+#define	LOG_EMERG	0	/* system is unusable */
+#define	LOG_ALERT	1	/* action must be taken immediately */
+#define	LOG_CRIT	2	/* critical conditions */
+#define	LOG_ERR		3	/* error conditions */
+#define	LOG_WARNING	4	/* warning conditions */
+#define	LOG_NOTICE	5	/* normal but significant condition */
+#define	LOG_INFO	6	/* informational */
+#define	LOG_DEBUG	7	/* debug-level messages */
+
+#define	LOG_PRIMASK	0x07	/* mask to extract priority part (internal) */
+				/* extract priority */
+#define	LOG_PRI(p)	((p) & LOG_PRIMASK)
+#define	LOG_MAKEPRI(fac, pri)	((fac) | (pri))
+
+#ifdef SYSLOG_NAMES
+#define	INTERNAL_NOPRI	0x10	/* the "no priority" priority */
+				/* mark "facility" */
+#define	INTERNAL_MARK	LOG_MAKEPRI((LOG_NFACILITIES<<3), 0)
+typedef struct _code {
+	const char	*c_name;
+	int		c_val;
+} CODE;
+
+CODE prioritynames[] = {
+	{ "alert",	LOG_ALERT,	},
+	{ "crit",	LOG_CRIT,	},
+	{ "debug",	LOG_DEBUG,	},
+	{ "emerg",	LOG_EMERG,	},
+	{ "err",	LOG_ERR,	},
+	{ "error",	LOG_ERR,	},	/* DEPRECATED */
+	{ "info",	LOG_INFO,	},
+	{ "none",	INTERNAL_NOPRI,	},	/* INTERNAL */
+	{ "notice",	LOG_NOTICE,	},
+	{ "panic", 	LOG_EMERG,	},	/* DEPRECATED */
+	{ "warn",	LOG_WARNING,	},	/* DEPRECATED */
+	{ "warning",	LOG_WARNING,	},
+	{ NULL,		-1,		}
+};
+#endif
+
+/* facility codes */
+#define	LOG_KERN	(0<<3)	/* kernel messages */
+#define	LOG_USER	(1<<3)	/* random user-level messages */
+#define	LOG_MAIL	(2<<3)	/* mail system */
+#define	LOG_DAEMON	(3<<3)	/* system daemons */
+#define	LOG_AUTH	(4<<3)	/* authorization messages */
+#define	LOG_SYSLOG	(5<<3)	/* messages generated internally by syslogd */
+#define	LOG_LPR		(6<<3)	/* line printer subsystem */
+#define	LOG_NEWS	(7<<3)	/* network news subsystem */
+#define	LOG_UUCP	(8<<3)	/* UUCP subsystem */
+#define	LOG_CRON	(9<<3)	/* clock daemon */
+#define	LOG_AUTHPRIV	(10<<3)	/* authorization messages (private) */
+				/* Facility #10 clashes in DEC UNIX, where */
+				/* it's defined as LOG_MEGASAFE for AdvFS  */
+				/* event logging.                          */
+#define	LOG_FTP		(11<<3)	/* ftp daemon */
+#define	LOG_NTP		(12<<3)	/* NTP subsystem */
+#define	LOG_SECURITY	(13<<3) /* security subsystems (firewalling, etc.) */
+#define	LOG_CONSOLE	(14<<3) /* /dev/console output */
+
+	/* other codes through 15 reserved for system use */
+#define	LOG_LOCAL0	(16<<3)	/* reserved for local use */
+#define	LOG_LOCAL1	(17<<3)	/* reserved for local use */
+#define	LOG_LOCAL2	(18<<3)	/* reserved for local use */
+#define	LOG_LOCAL3	(19<<3)	/* reserved for local use */
+#define	LOG_LOCAL4	(20<<3)	/* reserved for local use */
+#define	LOG_LOCAL5	(21<<3)	/* reserved for local use */
+#define	LOG_LOCAL6	(22<<3)	/* reserved for local use */
+#define	LOG_LOCAL7	(23<<3)	/* reserved for local use */
+
+#define	LOG_NFACILITIES	24	/* current number of facilities */
+#define	LOG_FACMASK	0x03f8	/* mask to extract facility part */
+				/* facility of pri */
+#define	LOG_FAC(p)	(((p) & LOG_FACMASK) >> 3)
+
+#ifdef SYSLOG_NAMES
+CODE facilitynames[] = {
+	{ "auth",	LOG_AUTH,	},
+	{ "authpriv",	LOG_AUTHPRIV,	},
+	{ "console", 	LOG_CONSOLE,	},
+	{ "cron", 	LOG_CRON,	},
+	{ "daemon",	LOG_DAEMON,	},
+	{ "ftp",	LOG_FTP,	},
+	{ "kern",	LOG_KERN,	},
+	{ "lpr",	LOG_LPR,	},
+	{ "mail",	LOG_MAIL,	},
+	{ "mark", 	INTERNAL_MARK,	},	/* INTERNAL */
+	{ "news",	LOG_NEWS,	},
+	{ "ntp",	LOG_NTP,	},
+	{ "security",	LOG_SECURITY,	},
+	{ "syslog",	LOG_SYSLOG,	},
+	{ "user",	LOG_USER,	},
+	{ "uucp",	LOG_UUCP,	},
+	{ "local0",	LOG_LOCAL0,	},
+	{ "local1",	LOG_LOCAL1,	},
+	{ "local2",	LOG_LOCAL2,	},
+	{ "local3",	LOG_LOCAL3,	},
+	{ "local4",	LOG_LOCAL4,	},
+	{ "local5",	LOG_LOCAL5,	},
+	{ "local6",	LOG_LOCAL6,	},
+	{ "local7",	LOG_LOCAL7,	},
+	{ NULL,		-1,		}
+};
+#endif
+
+#ifdef _KERNEL
+#define	LOG_PRINTF	-1	/* pseudo-priority to indicate use of printf */
+#endif
+
+/*
+ * arguments to setlogmask.
+ */
+#define	LOG_MASK(pri)	(1 << (pri))		/* mask for one priority */
+#define	LOG_UPTO(pri)	((1 << ((pri)+1)) - 1)	/* all priorities through pri */
+
+/*
+ * Option flags for openlog.
+ *
+ * LOG_ODELAY no longer does anything.
+ * LOG_NDELAY is the inverse of what it used to be.
+ */
+#define	LOG_PID		0x01	/* log the pid with each message */
+#define	LOG_CONS	0x02	/* log on the console if errors in sending */
+#define	LOG_ODELAY	0x04	/* delay open until first syslog() (default) */
+#define	LOG_NDELAY	0x08	/* don't delay open */
+#define	LOG_NOWAIT	0x10	/* don't wait for console forks: DEPRECATED */
+#define	LOG_PERROR	0x20	/* log to stderr as well */
+
+#ifdef _KERNEL
+
+#else /* not _KERNEL */
+
+/*
+ * Don't use va_list in the vsyslog() prototype.   Va_list is typedef'd in two
+ * places (<machine/varargs.h> and <machine/stdarg.h>), so if we include one
+ * of them here we may collide with the utility's includes.  It's unreasonable
+ * for utilities to have to include one of them to include syslog.h, so we get
+ * __va_list from <sys/_types.h> and use it.
+ */
+#include <sys/cdefs.h>
+#include <sys/_types.h>
+
+__BEGIN_DECLS
+void	closelog(void);
+void	openlog(const char *, int, int);
+int	setlogmask(int);
+void	syslog(int, const char *, ...) __printflike(2, 3);
+#if __BSD_VISIBLE
+void	vsyslog(int, const char *, __va_list) __printflike(2, 0);
+#endif
+__END_DECLS
+
+#endif /* !_KERNEL */
+
+#endif
diff --git a/include/sys/types.h b/include/sys/types.h
index 93c82b8..d5edefd 100644
--- a/include/sys/types.h
+++ b/include/sys/types.h
@@ -67,6 +67,9 @@ typedef unsigned int    uint;           /* Sys V compatibility */
 #endif
 #endif
 
+typedef char *          caddr_t;        /* core address */
+typedef const char *    c_caddr_t;      /* core address, pointer to const */
+
 //typedef int fd_set;
 typedef long ino_t;
 typedef long dev_t;
@@ -91,11 +94,21 @@ typedef __clock_t clock_t;
 #define _CLOCK_T_DECLARED
 #endif
 
+#ifndef _CLOCKID_T_DECLARED
+typedef __clockid_t     clockid_t;
+#define _CLOCKID_T_DECLARED
+#endif
+
 #ifndef _TIME_T_DECLARED
 typedef __time_t  time_t;
 #define _TIME_T_DECLARED
 #endif
 
+struct timespec {
+    time_t  tv_sec;         /* seconds */
+    long    tv_nsec;        /* and nanoseconds */
+};
+
 #ifndef _UID_T_DECLARED
 typedef __uid_t   uid_t;
 #define _UID_T_DECLARED
@@ -106,6 +119,11 @@ typedef __gid_t gid_t;
 #define _GID_T_DECLARED
 #endif
 
+#ifndef _SA_FAMILY_T_DECLARED
+typedef __sa_family_t	sa_family_t;
+#define _SA_FAMILY_T_DECLARED
+#endif
+
 typedef unsigned long useconds_t;
 typedef long suseconds_t;
 
diff --git a/include/sysexits.h b/include/sysexits.h
new file mode 100644
index 0000000..e52bb5b
--- /dev/null
+++ b/include/sysexits.h
@@ -0,0 +1,116 @@
+/*
+ * Copyright (c) 1987, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)sysexits.h	8.1 (Berkeley) 6/2/93
+ *
+ * $FreeBSD$
+ */
+
+#ifndef	_SYSEXITS_H_
+#define	_SYSEXITS_H_
+
+/*
+ *  SYSEXITS.H -- Exit status codes for system programs.
+ *
+ *	This include file attempts to categorize possible error
+ *	exit statuses for system programs, notably delivermail
+ *	and the Berkeley network.
+ *
+ *	Error numbers begin at EX__BASE to reduce the possibility of
+ *	clashing with other exit statuses that random programs may
+ *	already return.  The meaning of the codes is approximately
+ *	as follows:
+ *
+ *	EX_USAGE -- The command was used incorrectly, e.g., with
+ *		the wrong number of arguments, a bad flag, a bad
+ *		syntax in a parameter, or whatever.
+ *	EX_DATAERR -- The input data was incorrect in some way.
+ *		This should only be used for user's data & not
+ *		system files.
+ *	EX_NOINPUT -- An input file (not a system file) did not
+ *		exist or was not readable.  This could also include
+ *		errors like "No message" to a mailer (if it cared
+ *		to catch it).
+ *	EX_NOUSER -- The user specified did not exist.  This might
+ *		be used for mail addresses or remote logins.
+ *	EX_NOHOST -- The host specified did not exist.  This is used
+ *		in mail addresses or network requests.
+ *	EX_UNAVAILABLE -- A service is unavailable.  This can occur
+ *		if a support program or file does not exist.  This
+ *		can also be used as a catchall message when something
+ *		you wanted to do doesn't work, but you don't know
+ *		why.
+ *	EX_SOFTWARE -- An internal software error has been detected.
+ *		This should be limited to non-operating system related
+ *		errors as possible.
+ *	EX_OSERR -- An operating system error has been detected.
+ *		This is intended to be used for such things as "cannot
+ *		fork", "cannot create pipe", or the like.  It includes
+ *		things like getuid returning a user that does not
+ *		exist in the passwd file.
+ *	EX_OSFILE -- Some system file (e.g., /etc/passwd, /etc/utmp,
+ *		etc.) does not exist, cannot be opened, or has some
+ *		sort of error (e.g., syntax error).
+ *	EX_CANTCREAT -- A (user specified) output file cannot be
+ *		created.
+ *	EX_IOERR -- An error occurred while doing I/O on some file.
+ *	EX_TEMPFAIL -- temporary failure, indicating something that
+ *		is not really an error.  In sendmail, this means
+ *		that a mailer (e.g.) could not create a connection,
+ *		and the request should be reattempted later.
+ *	EX_PROTOCOL -- the remote system returned something that
+ *		was "not possible" during a protocol exchange.
+ *	EX_NOPERM -- You did not have sufficient permission to
+ *		perform the operation.  This is not intended for
+ *		file system problems, which should use NOINPUT or
+ *		CANTCREAT, but rather for higher level permissions.
+ */
+
+#define EX_OK		0	/* successful termination */
+
+#define EX__BASE	64	/* base value for error messages */
+
+#define EX_USAGE	64	/* command line usage error */
+#define EX_DATAERR	65	/* data format error */
+#define EX_NOINPUT	66	/* cannot open input */
+#define EX_NOUSER	67	/* addressee unknown */
+#define EX_NOHOST	68	/* host name unknown */
+#define EX_UNAVAILABLE	69	/* service unavailable */
+#define EX_SOFTWARE	70	/* internal software error */
+#define EX_OSERR	71	/* system error (e.g., can't fork) */
+#define EX_OSFILE	72	/* critical OS file missing */
+#define EX_CANTCREAT	73	/* can't create (user) output file */
+#define EX_IOERR	74	/* input/output error */
+#define EX_TEMPFAIL	75	/* temp failure; user is invited to retry */
+#define EX_PROTOCOL	76	/* remote error in protocol */
+#define EX_NOPERM	77	/* permission denied */
+#define EX_CONFIG	78	/* configuration error */
+
+#define EX__MAX	78	/* maximum listed value */
+
+#endif /* !_SYSEXITS_H_ */
diff --git a/include/syslog.h b/include/syslog.h
new file mode 100644
index 0000000..830b492
--- /dev/null
+++ b/include/syslog.h
@@ -0,0 +1 @@
+#include <sys/syslog.h>
diff --git a/include/unistd.h b/include/unistd.h
index ab92fa5..1a7a77e 100644
--- a/include/unistd.h
+++ b/include/unistd.h
@@ -49,6 +49,8 @@
 #include <pwd.h>
 #include <fcntl.h> // for pid_t
 #include <sys/socket.h>
+#include <sys/select.h>
+#include <getopt.h>
 
 #define	R_OK 4
 #define	W_OK 2
@@ -253,6 +255,8 @@ long         sysconf(int name);
 char        *ttyname(int fd);
 int          unlink(const char*pathname);
 int          write(int fd, const void *buf, size_t len);
+int          usleep(useconds_t usec);
+unsigned int sleep(unsigned int seconds);
 __END_DECLS
 
 #endif // __BF_UNISTD_H
diff --git a/include/vfs/fdtab.h b/include/vfs/fdtab.h
index aca427d..feda23b 100644
--- a/include/vfs/fdtab.h
+++ b/include/vfs/fdtab.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2007, 2008, 2009, 2011, 2012, ETH Zurich.
+ * Copyright (c) 2007, 2008, 2009, 2011, 2013, ETH Zurich.
  * All rights reserved.
  *
  * This file is distributed under the terms in the attached LICENSE file.
@@ -16,7 +16,8 @@
 __BEGIN_DECLS
 
 #define MIN_FD  0
-#define MAX_FD  132
+//#define MAX_FD  132
+#define MAX_FD  4096
 
 enum fdtab_type {
     FDTAB_TYPE_AVAILABLE,
@@ -26,10 +27,20 @@ enum fdtab_type {
     FDTAB_TYPE_STDOUT,
     FDTAB_TYPE_STDERR,
     FDTAB_TYPE_LWIP_SOCKET,
+    FDTAB_TYPE_EPOLL_INSTANCE,
     FDTAB_TYPE_PTM,         ///< master side of pseudo-terminal
     FDTAB_TYPE_PTS,         ///< slave side of pseudo-terminal
 };
 
+#include <signal.h>
+#include <sys/epoll.h>
+
+struct _epoll_events_list {
+    struct _epoll_events_list *prev, *next;
+    struct epoll_event event;
+    int fd;
+};
+
 struct fdtab_entry {
     enum fdtab_type     type;
 //    union {
@@ -37,6 +48,8 @@ struct fdtab_entry {
         int             fd;
         int             inherited;
 //    };
+    int epoll_fd;
+    struct _epoll_events_list epoll_events;
 };
 
 int fdtab_alloc(struct fdtab_entry *h);
diff --git a/kernel/arch/x86/perfmon.c b/kernel/arch/x86/perfmon.c
index 3cc5b1b..1edfa99 100644
--- a/kernel/arch/x86/perfmon.c
+++ b/kernel/arch/x86/perfmon.c
@@ -4,7 +4,7 @@
  */
 
 /*
- * Copyright (c) 2007, 2008, 2009, 2010, ETH Zurich.
+ * Copyright (c) 2007, 2008, 2009, 2010, 2013, ETH Zurich.
  * All rights reserved.
  *
  * This file is distributed under the terms in the attached LICENSE file.
@@ -23,13 +23,13 @@
 #include <arch/x86/perfmon.h>
 #include <arch/x86/apic.h>
 
-static bool perfmon_amd = false;
-static bool perfmon_intel = false;
+static bool perfmon_amd = false, perfmon_intel = false;
 /* static bool perfmon_measurement_running = false; */
 /* static bool perfmon_apic_activated = false; */
 static uint64_t perfmon_cntr_init = 0;
-struct capability perfmon_callback_ep;
-
+struct capability perfmon_callback_ep = {
+    .type = ObjType_Null,
+};
 
 void perfmon_init(void) 
 {
@@ -75,13 +75,18 @@ void perfmon_measure_start(uint8_t event, uint8_t umask,
         }
     }
 
-    // Activate performance measurement for Intel
     if(perfmon_amd) {
-        
         perfmon_amd_measure_write(ctr*-1, 0);
         perfmon_amd_measure_start(event, umask, kernel, counter_id, ctr!=0);
-        perfmon_cntr_init = ctr;
     }
+
+    // Activate performance measurement for Intel
+    if(perfmon_intel) {
+        perfmon_intel_measure_write(ctr*-1);
+        perfmon_intel_measure_start(event, umask, kernel, counter_id, ctr!=0);
+    }
+
+    perfmon_cntr_init = ctr;
 }
 
 /*
@@ -93,8 +98,11 @@ void perfmon_measure_reset(void)
     if(perfmon_amd) {
         perfmon_amd_measure_write(perfmon_cntr_init*-1, 0);
     }
+    if(perfmon_intel) {
+        perfmon_intel_reset();
+        perfmon_intel_measure_write(perfmon_cntr_init*-1);
+    }
 }
-    
 
 uint64_t perfmon_measure_read(void)
 {
@@ -130,8 +138,6 @@ void perfmon_measure_stop(void)
 {
     if(perfmon_amd) {
         perfmon_amd_measure_stop(0);
-    } else if(perfmon_intel) {
-        panic("Intel performance monitoring not supported yet.");
     }
 
     // Mask out performance counter overflow interrupts on APIC
diff --git a/kernel/arch/x86/perfmon_intel.c b/kernel/arch/x86/perfmon_intel.c
index 25ce071..b421b8b 100644
--- a/kernel/arch/x86/perfmon_intel.c
+++ b/kernel/arch/x86/perfmon_intel.c
@@ -4,7 +4,7 @@
  */
 
 /*
- * Copyright (c) 2007, 2008, 2009, 2010, ETH Zurich.
+ * Copyright (c) 2007, 2008, 2009, 2010, 2013, ETH Zurich.
  * All rights reserved.
  *
  * This file is distributed under the terms in the attached LICENSE file.
@@ -36,30 +36,46 @@ errval_t perfmon_intel_init(void)
 
     cpuid_apm_gen_t apmgen = cpuid_apm_gen_rd(&mycpuid);
 
-    printf("Architectural Performance Monitoring version %d, # counters %d, "
-           "# events %d\n", apmgen.version, apmgen.num_counters,
+    printf("Architectural Performance Monitoring version %d, # counters %d "
+           "(%d bits wide), # events %d\n",
+           apmgen.version, apmgen.num_counters, apmgen.width,
            apmgen.vec_length);
 
-    if(apmgen.version == 2) {
+    if(apmgen.version >= 2) {
         cpuid_apm_fixed_t apmfixed = cpuid_apm_fixed_rd(&mycpuid);
-
-        printf("# fixed function counters %d\n", apmfixed.num);
+        printf("# fixed function counters %d (%d bits wide)\n",
+               apmfixed.num, apmfixed.width);
     }
 
     char str[256];
     cpuid_apm_feat_pr(str, 256, &mycpuid);
     printf("Supported events:\n%s\n", str);
 
+    uint32_t apmfeat = cpuid_apm_feat_rd_raw(&mycpuid);
+    printf("Supported events: %x\n", apmfeat);
+
+    uint32_t status = ia32_perf_global_ctrl_rd(&ia32);
+    printf("Enabling counter %d, old val %x\n", 0, status);
+    ia32_perf_global_ctrl_pmc0_wrf(&ia32, 1);
+
     return SYS_ERR_OK;
 }
 
-void perfmon_intel_measure_start(uint8_t event, uint8_t umask)
+void perfmon_intel_reset(void)
+{
+    uint32_t status = ia32_perf_global_status_rd(&ia32);
+    ia32_perf_global_over_wr(&ia32, status);
+}
+
+void perfmon_intel_measure_start(uint8_t event, uint8_t umask, bool os, 
+                                 uint8_t idx, bool intr)
 {
     ia32_perfevtsel_t sel0 = ia32_perfevtsel_default;
     sel0 = ia32_perfevtsel_evsel_insert(sel0, event);
     sel0 = ia32_perfevtsel_umask_insert(sel0, umask);
-    sel0 = ia32_perfevtsel_usr_insert  (sel0, 1);
-    sel0 = ia32_perfevtsel_os_insert   (sel0, 0);
+    sel0 = ia32_perfevtsel_usr_insert(sel0, 1);
+    sel0 = ia32_perfevtsel_os_insert(sel0, os ? 1 : 0);
+    sel0 = ia32_perfevtsel_intr_insert(sel0, intr ? 1 : 0);
     sel0 = ia32_perfevtsel_en_insert   (sel0, 1);
     ia32_perfevtsel0_wr(&ia32, sel0);
 }
diff --git a/kernel/arch/x86_64/irq.c b/kernel/arch/x86_64/irq.c
index 8b1b75c..fd6a3b5 100644
--- a/kernel/arch/x86_64/irq.c
+++ b/kernel/arch/x86_64/irq.c
@@ -426,8 +426,8 @@ static void send_user_interrupt(int irq)
         if (err_no(err) == SYS_ERR_LMP_BUF_OVERFLOW) {
             struct dispatcher_shared_generic *disp =
                 get_dispatcher_shared_generic(cap->u.endpoint.listener->disp);
-            printk(LOG_DEBUG, "%.*s: IRQ message buffer overflow\n",
-                   DISP_NAME_LEN, disp->name);
+            printk(LOG_DEBUG, "%.*s: IRQ message buffer overflow on IRQ %d\n",
+                   DISP_NAME_LEN, disp->name, irq);
         } else {
             printk(LOG_ERR, "Unexpected error delivering IRQ\n");
         }
@@ -818,10 +818,10 @@ static __attribute__ ((used)) void handle_irq(int vector)
     // APIC timer interrupt: handle in kernel and reschedule
     if (vector == APIC_TIMER_INTERRUPT_VECTOR) {
         apic_eoi();
-        assert(kernel_ticks_enabled);
-        update_kernel_now();
-        trace_event(TRACE_SUBSYS_KERNEL, TRACE_EVENT_KERNEL_TIMER, kernel_now);
-        wakeup_check(kernel_now);
+	assert(kernel_ticks_enabled);
+	update_kernel_now();
+	trace_event(TRACE_SUBSYS_KERNEL, TRACE_EVENT_KERNEL_TIMER, kernel_now);
+	wakeup_check(kernel_now);
     } else if (vector == APIC_PERFORMANCE_INTERRUPT_VECTOR) {
         // Handle performance counter overflow
         // Reset counters
@@ -840,19 +840,19 @@ static __attribute__ ((used)) void handle_irq(int vector)
             };
             strncpy(data.name, disp->name, PERFMON_DISP_NAME_LEN);
 
-            // Call overflow handler represented by endpoint
+                // Call overflow handler represented by endpoint
             extern struct capability perfmon_callback_ep;
-            errval_t err;
-            size_t payload_len = sizeof(struct perfmon_overflow_data)/
-                sizeof(uintptr_t)+1;
-            err = lmp_deliver_payload(&perfmon_callback_ep,
-                                      NULL,
-                                      (uintptr_t*) &data,
-                                      payload_len,
-                                      false);
-
-            // Make sure delivery was okay. SYS_ERR_LMP_BUF_OVERFLOW is okay for now
-            assert(err_is_ok(err) || err_no(err)==SYS_ERR_LMP_BUF_OVERFLOW);
+	    errval_t err;
+	    size_t payload_len = sizeof(struct perfmon_overflow_data)/
+	      sizeof(uintptr_t)+1;
+	    err = lmp_deliver_payload(&perfmon_callback_ep,
+				      NULL,
+				      (uintptr_t*) &data,
+				      payload_len,
+				      false);
+
+                // Make sure delivery was okay. SYS_ERR_LMP_BUF_OVERFLOW is okay for now
+                assert(err_is_ok(err) || err_no(err)==SYS_ERR_LMP_BUF_OVERFLOW);
         } else {
             // This should never happen, as interrupts are disabled in kernel
             printf("Performance counter overflow interrupt from "
@@ -917,7 +917,7 @@ static __attribute__ ((used)) void handle_irq(int vector)
  * \param cpu_save_area  Pointer to save area for registers stacked by CPU
  * \param disp_save_area Pointer to save area in dispatcher
  */
-static __attribute__ ((used)) void
+static __attribute__ ((used, noreturn)) void
 generic_handle_irq(int vector,
                    uintptr_t * NONNULL COUNT(X86_SAVE_AREA_SIZE) cpu_save_area,
                    struct registers_x86_64 *disp_save_area)
@@ -942,6 +942,7 @@ generic_handle_irq(int vector,
     }
 
     handle_irq(vector);
+    resume(disp_save_area);
 }
 
 /* Utility function for code below; initialises a gate_descriptor */
diff --git a/kernel/arch/x86_64/startup_arch.c b/kernel/arch/x86_64/startup_arch.c
index 0d268e6..b363976 100644
--- a/kernel/arch/x86_64/startup_arch.c
+++ b/kernel/arch/x86_64/startup_arch.c
@@ -418,7 +418,10 @@ static void create_phys_caps(lpaddr_t init_alloc_addr)
                 debug(SUBSYS_STARTUP, "RAM %lx--%lx\n", base_addr, end_addr);
                 err = create_caps_to_cnode(base_addr, end_addr - base_addr,
                                            RegionType_Empty, &spawn_state, bootinfo);
-                assert(err_is_ok(err));
+                if(err_is_fail(err)) {
+		    printk(LOG_WARN, "Skipping RAM %lx--%lx...\n", base_addr, end_addr);
+                }
+                /* assert(err_is_ok(err)); */
             }
         } else if (mmap->base_addr > local_phys_to_gen_phys(init_alloc_addr)) {
             /* XXX: The multiboot spec just says that mapping types other than
diff --git a/kernel/arch/x86_64/syscall.c b/kernel/arch/x86_64/syscall.c
index 88fcb68..dcfe04b 100644
--- a/kernel/arch/x86_64/syscall.c
+++ b/kernel/arch/x86_64/syscall.c
@@ -33,6 +33,7 @@
 #include <arch/x86/timing.h>
 #include <fpu.h>
 #include <arch/x86/ipi_notify.h>
+#include <amd_vmcb_dev.h>
 
 #define MIN(a,b)        ((a) < (b) ? (a) : (b))
 
@@ -900,6 +901,11 @@ struct sysret sys_syscall(uint64_t syscall, uint64_t arg0, uint64_t arg1,
                     save_area = &disp->enabled_save_area;
                 }
 
+		// Should be enabled. Else, how do we do an invocation??
+		if(dcb_current->disabled) {
+		  panic("Dispatcher needs to be enabled for this invocation");
+		}
+
                 // save calling dispatcher's registers, so that when the dispatcher
                 // next runs, it has a valid state in the relevant save area.
                 // Save RIP, RFLAGS, RSP and set RAX (return value) for later resume
@@ -908,17 +914,25 @@ struct sysret sys_syscall(uint64_t syscall, uint64_t arg0, uint64_t arg1,
                 save_area->eflags = rflags;
                 save_area->rsp = user_stack_save;
 
-                /* save and zero FS/GS selectors (they're unmodified by the syscall path) */
-                __asm ("mov     %%fs, %[fs]     \n\t"
-                       "mov     %%gs, %[gs]     \n\t"
-                       "mov     %[zero], %%fs   \n\t"
-                       "mov     %[zero], %%gs   \n\t"
-                       : /* No output */
-                       :
-                       [fs] "m" (save_area->fs),
-                       [gs] "m" (save_area->gs),
-                       [zero] "r" (0)
-                       );
+		if(!dcb_current->is_vm_guest) {
+		  /* save and zero FS/GS selectors (they're unmodified by the syscall path) */
+		  __asm ("mov     %%fs, %[fs]     \n\t"
+			 "mov     %%gs, %[gs]     \n\t"
+			 "mov     %[zero], %%fs   \n\t"
+			 "mov     %[zero], %%gs   \n\t"
+			 : /* No output */
+			 :
+			 [fs] "m" (save_area->fs),
+			 [gs] "m" (save_area->gs),
+			 [zero] "r" (0)
+			 );
+		} else {
+		  lpaddr_t lpaddr = gen_phys_to_local_phys(dcb_current->guest_desc.vmcb.cap.u.frame.base);
+		  amd_vmcb_t vmcb;
+		  amd_vmcb_initialize(&vmcb, (void *)local_phys_to_mem(lpaddr));
+		  save_area->fs = amd_vmcb_fs_selector_rd(&vmcb);
+		  save_area->gs = amd_vmcb_gs_selector_rd(&vmcb);
+		}
 
                 dispatch(to->u.endpoint.listener);
                 panic("dispatch returned");
@@ -1007,6 +1021,10 @@ struct sysret sys_syscall(uint64_t syscall, uint64_t arg0, uint64_t arg1,
             retval.value = timing_get_apic_ticks_per_sec();
             break;
 
+        case DEBUG_GET_APIC_ID:
+            retval.value = apic_get_id();
+            break;
+
         default:
             printk(LOG_ERR, "invalid sys_debug msg type\n");
         }
diff --git a/kernel/arch/x86_64/vmkit.c b/kernel/arch/x86_64/vmkit.c
index e9a7310..878f910 100644
--- a/kernel/arch/x86_64/vmkit.c
+++ b/kernel/arch/x86_64/vmkit.c
@@ -20,6 +20,7 @@
 #include <dispatch.h>
 #include <exec.h>
 #include <barrelfish_kpi/vmkit.h>
+#include <barrelfish_kpi/syscalls.h>
 
 #include <amd_vmcb_dev.h>
 
@@ -214,6 +215,33 @@ vmkit_switch_from (struct dcb *dcb)
 }
 
 void __attribute__ ((noreturn))
+vmkit_vmexec (struct dcb *dcb, lvaddr_t entry)
+{
+  dispatcher_handle_t handle = dcb->disp;
+  struct dispatcher_shared_generic *disp = get_dispatcher_shared_generic(handle);
+  lpaddr_t lpaddr = gen_phys_to_local_phys(dcb->guest_desc.ctrl.cap.u.frame.base);
+  struct guest_control *ctrl = (void *)local_phys_to_mem(lpaddr);
+  lpaddr = gen_phys_to_local_phys(dcb->guest_desc.vmcb.cap.u.frame.base);
+  amd_vmcb_t vmcb;
+  amd_vmcb_initialize(&vmcb, (void *)local_phys_to_mem(lpaddr));
+
+  memset(&ctrl->regs, 0, sizeof(struct registers_x86_64));
+  ctrl->regs.rdi = disp->udisp;
+  amd_vmcb_rip_wr(&vmcb, disp->dispatcher_run);
+  amd_vmcb_rsp_wr(&vmcb, 0);
+  amd_vmcb_rax_wr(&vmcb, 0);
+  amd_vmcb_rflags_wr_raw(&vmcb, USER_RFLAGS);
+  amd_vmcb_fs_selector_wr(&vmcb, 0);
+  amd_vmcb_gs_selector_wr(&vmcb, 0);
+  vmkit_vmenter(dcb);
+}
+
+struct sysret sys_syscall(uint64_t syscall, uint64_t arg0, uint64_t arg1,
+                          uint64_t *args, uint64_t rflags, uint64_t rip);
+
+extern uint64_t user_stack_save;
+
+void __attribute__ ((noreturn))
 vmkit_vmenter (struct dcb *dcb)
 {
     lpaddr_t lpaddr = gen_phys_to_local_phys(dcb->guest_desc.ctrl.cap.u.frame.base);
@@ -237,28 +265,88 @@ vmkit_vmenter (struct dcb *dcb)
         amd_vmcb_cr3_wr(&vmcb, dcb->vspace);
     }
 
+ vmenter_loop:
+
+    /* printf("vmenter IN\n"); */
+
     // Enter the guest
     vmkit_switch_to(dcb);
     vm_exec(dcb);
     vmkit_switch_from(dcb);
 
+    /* printf("vmenter OUT\n"); */
+
     // Here we exited the guest due to some intercept triggered a vm exit
     // our state is automatically restored by SVM
 
     uint64_t ec = amd_vmcb_exitcode_rd(&vmcb);
     /* We treat exits due to pysical interrupts (INTR, NMI, SMI) specially since
      * they need to be processed by the kernel interrupt service routines */
-    if (ec == VMEXIT_INTR || ec == VMEXIT_NMI || ec == VMEXIT_SMI) {
+    switch(ec) {
+    case VMEXIT_INTR:
+    case VMEXIT_NMI:
+    case VMEXIT_SMI:
+      {
+	arch_registers_state_t *area = NULL;
+
+	/* printf("INT at %" PRIx64 "\n", amd_vmcb_rip_rd(&vmcb)); */
 
         ctrl->num_vm_exits_without_monitor_invocation++;
+
+	// Store user state into corresponding save area
+	if(dispatcher_is_disabled_ip(dcb->disp, amd_vmcb_rip_rd(&vmcb))) {
+	  area = dispatcher_get_disabled_save_area(dcb->disp);
+	  dcb->disabled = true;
+	} else {
+	  area = dispatcher_get_enabled_save_area(dcb->disp);
+	  dcb->disabled = false;
+	}
+	memcpy(area, &ctrl->regs, sizeof(arch_registers_state_t));
+	area->rax = amd_vmcb_rax_rd(&vmcb);
+	area->rip = amd_vmcb_rip_rd(&vmcb);
+	area->rsp = amd_vmcb_rsp_rd(&vmcb);
+	area->eflags = amd_vmcb_rflags_rd_raw(&vmcb);
+	area->fs = amd_vmcb_fs_selector_rd(&vmcb);
+	area->gs = amd_vmcb_gs_selector_rd(&vmcb);
+
         // wait for interrupt will enable interrupts and therefore trigger their
         // corresponding handlers (which may be the monitor)
         wait_for_interrupt();
-    } else {
+      }
+      break;
+
+    case VMEXIT_VMMCALL:
+      {
+	// Translate this to a SYSCALL
+	struct registers_x86_64 *regs = &ctrl->regs;
+	uint64_t args[10] = {
+	  regs->r10, regs->r8, regs->r9, regs->r12, regs->r13, regs->r14,
+	  regs->r15, amd_vmcb_rax_rd(&vmcb), regs->rbp, regs->rbx
+	};
+
+	/* printf("VMMCALL\n"); */
+
+	// Advance guest RIP to next instruction
+	amd_vmcb_rip_wr(&vmcb, amd_vmcb_rip_rd(&vmcb) + 3);
+	user_stack_save = amd_vmcb_rsp_rd(&vmcb);
+
+	struct sysret ret =
+	  sys_syscall(regs->rdi, regs->rsi, regs->rdx, args,
+		      amd_vmcb_rflags_rd_raw(&vmcb),
+		      amd_vmcb_rip_rd(&vmcb));
+
+	amd_vmcb_rax_wr(&vmcb, ret.error);
+	regs->rdx = ret.value;
+      }
+      goto vmenter_loop;
+
+    default:
         ctrl->num_vm_exits_with_monitor_invocation++;
         /* the guest exited not due to an interrupt but some condition the
          * monitor has to handle, therefore notify the monitor */
 
+	/* printf("OTHER\n"); */
+
         assert(dcb->is_vm_guest);
 
         // disable the domain
@@ -267,10 +355,11 @@ vmkit_vmenter (struct dcb *dcb)
         // call the monitor
         errval_t err = lmp_deliver_notification(&dcb->guest_desc.monitor_ep.cap);
         if (err_is_fail(err)) {
-            printk(LOG_ERR, "Unexpected error delivering VMM call");
+            printk(LOG_ERR, "Unexpected error delivering VMEXIT");
         }
 
         // run the monitor
         dispatch(dcb->guest_desc.monitor_ep.cap.u.endpoint.listener);
+	break;
     }
 }
diff --git a/kernel/dispatch.c b/kernel/dispatch.c
index 2c8cdc5..779f8db 100644
--- a/kernel/dispatch.c
+++ b/kernel/dispatch.c
@@ -4,7 +4,7 @@
  */
 
 /*
- * Copyright (c) 2007, 2008, 2009, 2010, 2011, ETH Zurich.
+ * Copyright (c) 2007, 2008, 2009, 2010, 2011, 2013, ETH Zurich.
  * All rights reserved.
  *
  * This file is distributed under the terms in the attached LICENSE file.
@@ -230,12 +230,6 @@ void __attribute__ ((noreturn)) dispatch(struct dcb *dcb)
     }
 
     assert(dcb != NULL);
-#ifdef __x86_64__
-    if (dcb->is_vm_guest) {
-        vmkit_vmenter(dcb);
-        panic("vmkit_vmenter unexpectedly returned");
-    }
-#endif
 
     dispatcher_handle_t handle = dcb->disp;
     struct dispatcher_shared_generic *disp =
@@ -250,12 +244,24 @@ void __attribute__ ((noreturn)) dispatch(struct dcb *dcb)
               disp->name, (uint64_t)registers_get_ip(disabled_area));
         assert(dispatcher_is_disabled_ip(handle,
                                          registers_get_ip(disabled_area)));
-        resume(disabled_area);
+	if(!dcb->is_vm_guest) {
+	  resume(disabled_area);
+#ifdef __x86_64__
+	} else {
+	  vmkit_vmenter(dcb);
+#endif
+	}
     } else {
         debug(SUBSYS_DISPATCH, "dispatch %.*s\n", DISP_NAME_LEN, disp->name);
         assert(disp->dispatcher_run != 0);
         disp->disabled = 1;
-        execute(disp->dispatcher_run);
+	if(!dcb->is_vm_guest) {
+	  execute(disp->dispatcher_run);
+#ifdef __x86_64__
+	} else {
+	  vmkit_vmexec(dcb, disp->dispatcher_run);
+#endif
+	}
     }
 } // end function: dispatch
 
diff --git a/kernel/include/arch/x86/perfmon_intel.h b/kernel/include/arch/x86/perfmon_intel.h
index a464a49..0297a84 100644
--- a/kernel/include/arch/x86/perfmon_intel.h
+++ b/kernel/include/arch/x86/perfmon_intel.h
@@ -4,7 +4,7 @@
  */
 
 /*
- * Copyright (c) 2007, 2008, 2009, 2010, ETH Zurich.
+ * Copyright (c) 2007, 2008, 2009, 2010, 2013, ETH Zurich.
  * All rights reserved.
  *
  * This file is distributed under the terms in the attached LICENSE file.
@@ -18,8 +18,10 @@
 
 errval_t perfmon_intel_init(void);
 
-void perfmon_intel_measure_start(uint8_t event, uint8_t umask);
+void perfmon_intel_measure_start(uint8_t event, uint8_t umask, bool os, 
+                                 uint8_t idx, bool intr);
 uint64_t perfmon_intel_measure_read(void);
 void perfmon_intel_measure_write(uint64_t val);
+void perfmon_intel_reset(void);
 
 #endif
diff --git a/kernel/include/arch/x86_64/vmkit.h b/kernel/include/arch/x86_64/vmkit.h
index 97b4037..aeb9279 100644
--- a/kernel/include/arch/x86_64/vmkit.h
+++ b/kernel/include/arch/x86_64/vmkit.h
@@ -4,7 +4,7 @@
  */
 
 /*
- * Copyright (c) 2009, ETH Zurich.
+ * Copyright (c) 2009, 2013, ETH Zurich.
  * All rights reserved.
  *
  * This file is distributed under the terms in the attached LICENSE file.
@@ -21,5 +21,6 @@
 errval_t vmkit_enable_virtualization (void);
 int vmkit_disable_virtualization (void);
 void __attribute__ ((noreturn)) vmkit_vmenter (struct dcb *dcb);
+void __attribute__ ((noreturn)) vmkit_vmexec (struct dcb *dcb, lvaddr_t entry);
 
 #endif // _VMKIT_H
diff --git a/lib/arranet/Hakefile b/lib/arranet/Hakefile
new file mode 100644
index 0000000..82c0329
--- /dev/null
+++ b/lib/arranet/Hakefile
@@ -0,0 +1,17 @@
+--------------------------------------------------------------------------
+-- Copyright (c) 2007-2009, 2011, 2012, 2013, ETH Zurich.
+-- All rights reserved.
+--
+-- This file is distributed under the terms in the attached LICENSE file.
+-- If you do not find this file, copies can be found by writing to:
+-- ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich. Attn: Systems Group.
+--
+-- Hakefile for lib/arranet
+-- 
+--------------------------------------------------------------------------
+
+[ build library { target = "arranet",
+                  cFiles = [ "arranet.c", "inet_chksum.c", "ip_addr.c" ],
+                  flounderDefs = [ "net_queue_manager" ]
+                }
+]
diff --git a/lib/arranet/arranet.c b/lib/arranet/arranet.c
new file mode 100644
index 0000000..fa06720
--- /dev/null
+++ b/lib/arranet/arranet.c
@@ -0,0 +1,2740 @@
+/*
+ * Copyright (c) 2014, ETH Zurich.
+ * All rights reserved.
+ *
+ * This file is distributed under the terms in the attached LICENSE file.
+ * If you do not find this file, copies can be found by writing to:
+ * ETH Zurich D-INFK, CAB F.78, Universitaetstr. 6, CH-8092 Zurich. 
+ * Attn: Systems Group.
+ */
+
+/**
+ * \file
+ * \brief Arranet library code
+ */
+
+#include <stdio.h>
+#include <assert.h>
+#include <barrelfish/barrelfish.h>
+#include <barrelfish/inthandler.h>
+#include <sys/socket.h>
+#include <netif/e1000.h>
+#include <limits.h>
+#include <barrelfish/waitset.h>
+#include <barrelfish/waitset_chan.h>
+#include <lwip/sock_chan_support.h>
+#include <netdb.h>
+#include <arranet.h>
+#include <arranet_impl.h>
+
+#include "inet_chksum.h"
+
+#include <arranet_debug.h>
+
+static ether_terminate_queue ether_terminate_queue_ptr = NULL;
+static ether_get_mac_address_t ether_get_mac_address_ptr = NULL;
+static ether_transmit_pbuf_list_t ether_transmit_pbuf_list_ptr = NULL;
+static ether_get_tx_free_slots tx_free_slots_fn_ptr = NULL;
+static ether_handle_free_TX_slot handle_free_tx_slot_fn_ptr = NULL;
+static ether_rx_register_buffer rx_register_buffer_fn_ptr = NULL;
+static ether_rx_get_free_slots rx_get_free_slots_fn_ptr = NULL;
+
+uint64_t interrupt_counter = 0;
+uint64_t total_rx_p_count = 0;
+uint64_t total_rx_datasize = 0;
+struct client_closure *g_cl = NULL;
+
+//#define MAX_PACKETS     1024
+#define MAX_PACKETS     2000
+#define PACKET_SIZE     2048
+
+#define MAX_PEERS       256
+
+struct peer {
+    uint32_t ip;
+    struct eth_addr mac;
+};
+
+// Configure static ARP entries here
+// IP addresses are in network byte order!
+static struct peer peers[MAX_PEERS] = {
+    {
+        .ip = 0x0102000a,       // 10.0.2.1
+        .mac.addr = "\x86\x86\x0b\xda\x22\xd7",
+    },
+    {
+        .ip = 0xaf06d080,       // 128.208.6.175 - swingout2
+        .mac.addr = "\x90\xe2\xba\x3a\x2e\xdd",
+    },
+    {
+        .ip = 0xec06d080,       // 128.208.6.236 - swingout3
+        .mac.addr = "\xa0\x36\x9f\x0f\xfb\xe2",
+    },
+    {
+        .ip = 0x8106d080,       // 128.208.6.129 - swingout4
+        .mac.addr = "\xa0\x36\x9f\x10\x01\x6e",
+    },
+    {
+        .ip = 0x8206d080,       // 128.208.6.130 - swingout5
+        .mac.addr = "\xa0\x36\x9f\x10\x00\xa2",
+    },
+    {
+        .ip = 0xc506d080,       // 128.208.6.197 - swingout6
+        .mac.addr = "\xa0\x36\x9f\x10\x03\x52",
+    },
+};
+static int peers_alloc = 6;             // Set number of static ARP here!
+
+#ifdef DEBUG_LATENCIES
+static int rx_packets_available = MAX_PACKETS;
+#endif
+
+struct socket {
+    struct socket *prev, *next;
+    int fd;
+    bool passive, nonblocking, connected, hangup, shutdown;
+    struct sockaddr_in bound_addr;
+    struct sockaddr_in peer_addr;
+    uint32_t my_seq, peer_seq, next_ack;
+};
+
+struct pkt_udp_headers {
+    struct eth_hdr eth;
+    struct ip_hdr ip;
+    struct udp_hdr udp;
+} __attribute__ ((packed));
+
+struct pkt_tcp_headers {
+    struct eth_hdr eth;
+    struct ip_hdr ip;
+    struct tcp_hdr tcp;
+} __attribute__ ((packed));
+
+// All known connections and those in progress
+static struct socket *connections = NULL;
+
+static struct socket sockets[MAX_FD];
+static struct packet rx_packets[MAX_PACKETS];
+
+// XXX: Needs to be per socket later on
+static struct waitset_chanstate recv_chanstate;
+static struct waitset_chanstate send_chanstate;
+
+static struct packet *inpkt = NULL;
+
+#ifdef DEBUG_LATENCIES
+static size_t memcache_packets_received = 0;
+static size_t output_pipeline_stalled = 0;
+static size_t port_cnt[65536];
+static int lwip_send_time[POSIX_TRANSA];       // Time until packet was delivered to network interface
+static size_t lwip_send_transactions = 0;
+int posix_recv_time[POSIX_TRANSA];       // Time until packet at exit of recvfrom
+size_t posix_recv_transactions = 0;
+static int posix_send_time[POSIX_TRANSA];       // Time until packet at entry to sendto
+static size_t posix_send_transactions = 0;
+
+int memcache_times[20][POSIX_TRANSA];       // Time until packet was delivered to network interface
+size_t memcache_transactions[20];
+
+size_t hash_option1 = 0;
+size_t hash_option2 = 0;
+size_t hash_option3 = 0;
+size_t hash_length = 0;
+size_t hash_calls = 0;
+size_t hash_aligned = 0;
+size_t hash_unaligned = 0;
+#endif
+
+static bool arranet_udp_accepted = false;
+static bool arranet_tcp_accepted = false;
+
+//#define TCP_LOCAL_PORT_RANGE_START        0xc000
+#define TCP_LOCAL_PORT_RANGE_START        8081
+#define TCP_LOCAL_PORT_RANGE_END          0xffff
+
+static uint16_t free_tcp_ports[TCP_LOCAL_PORT_RANGE_END - TCP_LOCAL_PORT_RANGE_START + 1];
+static uint16_t free_tcp_tail = TCP_LOCAL_PORT_RANGE_END - TCP_LOCAL_PORT_RANGE_START,
+    free_tcp_free = TCP_LOCAL_PORT_RANGE_END - TCP_LOCAL_PORT_RANGE_START + 1;
+
+#ifdef SENDMSG_WITH_COPY
+static uint16_t free_tcp_head = 0;
+
+// In network byte order
+static uint16_t tcp_new_port(void)
+{
+  if(free_tcp_free > 0) {
+      free_tcp_free--;
+      u16_t new_port = free_tcp_ports[free_tcp_head];
+      free_tcp_head = (free_tcp_head + 1) % (TCP_LOCAL_PORT_RANGE_END - TCP_LOCAL_PORT_RANGE_START + 1);
+      /* printf("Allocating port %d\n", new_port); */
+      return new_port;
+  } else {
+      printf("No more free ports!\n");
+      return 0;
+  }
+}
+#endif
+
+static void tcp_free_port(uint16_t port)
+{
+    /* if(pcb->local_port == 8080) { */
+    /*     return; */
+    /* } */
+    /* if(pcb->local_port == 8080) { */
+    /*     printf("Freeing 8080 from %p %p %p\n", */
+    /*            __builtin_return_address(0), */
+    /*            __builtin_return_address(1), */
+    /*            __builtin_return_address(2)); */
+    /* } */
+    /* assert(pcb->local_port != 8080); */
+    assert(free_tcp_free < TCP_LOCAL_PORT_RANGE_END - TCP_LOCAL_PORT_RANGE_START + 1);
+
+    /* printf("Freeing port %d\n", pcb->local_port); */
+
+    /* for(int i = 0; i < free_tcp_free; i++) { */
+    /*     u16_t entry = free_tcp_ports[(i + free_tcp_head) % (TCP_LOCAL_PORT_RANGE_END - TCP_LOCAL_PORT_RANGE_START + 1)]; */
+    /*     assert(entry != pcb->local_port); */
+    /* } */
+
+    free_tcp_free++;
+    free_tcp_tail = (free_tcp_tail + 1) % (TCP_LOCAL_PORT_RANGE_END - TCP_LOCAL_PORT_RANGE_START + 1);
+    free_tcp_ports[free_tcp_tail] = port;
+}
+
+static struct socket *free_sockets_queue[MAX_FD];
+static int free_sockets_head = 0, free_sockets_tail = MAX_FD - 1,
+    free_sockets = MAX_FD;
+
+static struct socket *alloc_socket(void)
+{
+    if(free_sockets == 0) {
+        return NULL;
+    }
+
+    free_sockets--;
+    struct socket *new_socket = free_sockets_queue[free_sockets_head];
+    // Reset all fields except FD
+    int fd_save = new_socket->fd;
+    uint32_t seq_save = new_socket->my_seq;
+    memset(new_socket, 0, sizeof(struct socket));
+    new_socket->fd = fd_save;
+    new_socket->my_seq = seq_save + 1000;
+    free_sockets_head = (free_sockets_head + 1) % MAX_FD;
+    /* printf("alloc_socket: returned %p\n", new_socket); */
+    return new_socket;
+}
+
+static void free_socket(struct socket *sock)
+{
+    /* printf("free_socket: %p\n", sock); */
+    assert(sock != NULL);
+    assert(free_sockets < MAX_FD);
+    free_sockets++;
+    free_sockets_tail = (free_sockets_tail + 1) % MAX_FD;
+    free_sockets_queue[free_sockets_tail] = sock;
+}
+
+/******** IP config *********/
+
+struct mac2ip {
+    uint8_t mac[ETHARP_HWADDR_LEN];
+    uint32_t ip;
+};
+
+static struct mac2ip ip_config[] = {
+    {   // QEMU
+        .mac = "\x52\x54\x00\x12\x34\x56",
+        .ip = 0x0a00020f,       // 10.0.2.15
+    },
+    {
+        // QEMU2
+        .mac = "\x52\x54\x00\x12\x34\x57",
+        .ip = 0xc0a80102,       // 192.168.1.2
+    },
+    {   // swingout1 (and swingout1-vf0)
+        .mac = "\xa0\x36\x9f\x10\x00\xa6",
+        .ip = 0x80d00643,       // 128.208.6.67
+    },
+    {   // swingout1-vf1
+        .mac = "\x22\xc9\xfc\x96\x83\xfc",
+        .ip = 0x80d00644,       // 128.208.6.68
+    },
+    {   // swingout1-vf2
+        .mac = "\xce\x43\x5b\xf7\x3e\x60",
+        .ip = 0x80d00602,       // 128.208.6.2
+    },
+    {   // swingout1-vf3
+        .mac = "\x6a\xb0\x62\xf6\xa7\x21",
+        .ip = 0x80d00603,       // 128.208.6.3
+    },
+    {   // swingout1-vf4
+        .mac = "\xb2\xdf\xf9\x39\xc6\x10",
+        .ip = 0x80d00604,       // 128.208.6.4
+    },
+    {   // swingout1-vf5
+        .mac = "\x92\x77\xe7\x3f\x80\x30",
+        .ip = 0x80d0060c,       // 128.208.6.12
+    },
+    {   // swingout5
+        .mac = "\xa0\x36\x9f\x10\x00\xa2",
+        .ip = 0x80d00682,       // 128.208.6.130
+    },
+};
+
+static uint8_t arranet_mymac[ETHARP_HWADDR_LEN];
+static uint32_t arranet_myip = 0;
+
+/******** NYI *********/
+
+struct thread_mutex *lwip_mutex = NULL;
+struct waitset *lwip_waitset = NULL;
+
+void lwip_mutex_lock(void)
+{
+}
+
+void lwip_mutex_unlock(void)
+{
+}
+
+int lwip_read(int s, void *mem, size_t len)
+{
+    assert(!"NYI");
+}
+
+int lwip_write(int s, const void *data, size_t size)
+{
+    assert(!"NYI");
+}
+
+int lwip_fcntl(int s, int cmd, int val)
+{
+    struct socket *sock = &sockets[s];
+    int retval = 0;
+
+    switch(cmd) {
+    case F_GETFL:
+        retval = sock->nonblocking ? O_NONBLOCK : 0;
+        break;
+
+    case F_SETFL:
+        sock->nonblocking = val & O_NONBLOCK ? true : false;
+        break;
+
+    default:
+        assert(!"NYI");
+        retval = -1;
+        break;
+    }
+
+    return retval;
+}
+
+int lwip_listen(int s, int backlog)
+{
+    struct socket *sock = &sockets[s];
+    sock->passive = true;
+    return 0;
+}
+
+int lwip_getsockopt(int s, int level, int optname, void *optval, socklen_t *optlen)
+{
+    int retval = 0;
+
+    switch(level) {
+    case SOL_SOCKET:
+        switch(optname) {
+        case SO_SNDBUF:
+            {
+                assert(*optlen >= sizeof(int));
+                int *ret = optval;
+                *ret = PACKET_SIZE;
+                *optlen = sizeof(int);
+            }
+            break;
+
+        case SO_ERROR:
+            {
+                assert(*optlen >= sizeof(int));
+                int *ret = optval;
+                struct socket *sock = &sockets[s];
+                assert(sock != NULL);
+                *ret = sock->connected ? 0 : EINPROGRESS;
+                *optlen = sizeof(int);
+            }
+            break;
+
+        default:
+            assert(!"NYI");
+            retval = -1;
+            break;
+        }
+        break;
+
+    default:
+        assert(!"NYI");
+        retval = -1;
+        break;
+    }
+
+    return retval;
+}
+
+int lwip_setsockopt(int s, int level, int optname, const void *optval, socklen_t optlen)
+{
+    int retval = 0;
+
+    switch(level) {
+    case SOL_SOCKET:
+        switch(optname) {
+        case SO_REUSEADDR:
+        case SO_REUSEPORT:
+            // No-op
+            break;
+
+        case SO_SNDBUF:
+            {
+                int len = *(const int *)optval;
+                if(len > PACKET_SIZE) {
+                    retval = -1;
+                }
+            }
+            break;
+
+        default:
+            printf("%d, %d\n", level, optname);
+            assert(!"NYI");
+            retval = -1;
+            break;
+        }
+        break;
+
+    case IPPROTO_TCP:
+        switch(optname) {
+        case TCP_NODELAY:
+            // XXX: No-op. We don't support Nagling anyway.
+            break;
+        }
+        break;
+
+    default:
+        assert(!"NYI");
+        retval = -1;
+        break;
+    }
+
+    return retval;
+}
+
+int lwip_getsockname(int s, struct sockaddr *name, socklen_t *namelen)
+{
+    struct socket *sock = &sockets[s];
+    assert(sock != NULL);
+    assert(*namelen >= sizeof(struct sockaddr_in));
+
+    memcpy(name, &sock->bound_addr, sizeof(struct sockaddr_in));
+    *namelen = sizeof(struct sockaddr_in);
+
+    return 0;
+}
+
+struct hostent *lwip_gethostbyname(const char *name)
+{
+    assert(!"NYI");
+}
+
+int lwip_getaddrinfo(const char *nodename, const char *servname,
+                     const struct addrinfo *hints, struct addrinfo **res)
+{
+    struct addrinfo *r = calloc(1, sizeof(struct addrinfo));
+    struct sockaddr_in *sa = calloc(1, sizeof(struct sockaddr_in));
+
+    assert(hints != NULL);
+
+    sa->sin_family = AF_INET;
+    sa->sin_port = htons(atoi(servname));
+    sa->sin_addr.s_addr = INADDR_ANY;
+
+    // Return dummy UDP socket address
+    r->ai_flags = AI_PASSIVE;
+    r->ai_family = AF_INET;
+    r->ai_socktype = SOCK_DGRAM;
+    r->ai_protocol = hints->ai_protocol;
+    r->ai_addrlen = sizeof(struct sockaddr_in);
+    r->ai_addr = (struct sockaddr *)sa;
+    r->ai_canonname = NULL;
+    r->ai_next = NULL;
+
+    *res = r;
+    return 0;
+}
+
+void lwip_freeaddrinfo(struct addrinfo *ai)
+{
+    for(struct addrinfo *i = ai; i != NULL;) {
+        struct addrinfo *oldi = i;
+        free(i->ai_addr);
+        i = i->ai_next;
+        free(oldi);
+    }
+}
+
+int lwip_getpeername (int s, struct sockaddr *name, socklen_t *namelen)
+{
+    assert(!"NYI");
+}
+
+/* The following 2 are #defined in lwIP 1.4.1, but not in 1.3.1, duplicating them here */
+
+int inet_aton(const char *cp, struct in_addr *addr)
+{
+    return ipaddr_aton(cp, (ip_addr_t *)addr);
+}
+
+u32_t inet_addr(const char *cp)
+{
+    return ipaddr_addr(cp);
+}
+
+/***** lwIP-compatibility functions, so that NFS and RPC code compiles *****/
+
+u8_t pbuf_free_tagged(struct pbuf *p, const char *func_name, int line_no)
+{
+    assert(!"NYI");
+}
+
+u8_t pbuf_header(struct pbuf *p, s16_t header_size_increment)
+{
+    assert(!"NYI");
+}
+
+struct udp_pcb;
+
+err_t udp_send(struct udp_pcb *pcb, struct pbuf *p);
+err_t udp_send(struct udp_pcb *pcb, struct pbuf *p)
+{
+    assert(!"NYI");
+}
+
+struct udp_pcb *udp_new(void);
+struct udp_pcb *udp_new(void)
+{
+    assert(!"NYI");
+}
+
+void udp_recv(struct udp_pcb *pcb,
+              void (*recvfn) (void *arg, struct udp_pcb * upcb,
+                            struct pbuf * p,
+                            struct ip_addr * addr,
+                            u16_t port), void *recv_arg);
+void udp_recv(struct udp_pcb *pcb,
+              void (*recvfn) (void *arg, struct udp_pcb * upcb,
+                            struct pbuf * p,
+                            struct ip_addr * addr,
+                            u16_t port), void *recv_arg)
+{
+    assert(!"NYI");
+}
+
+void udp_remove(struct udp_pcb *pcb);
+void udp_remove(struct udp_pcb *pcb)
+{
+    assert(!"NYI");
+}
+
+err_t udp_connect(struct udp_pcb *pcb, ip_addr_t *ipaddr, u16_t port);
+err_t udp_connect(struct udp_pcb *pcb, ip_addr_t *ipaddr, u16_t port)
+{
+    assert(!"NYI");
+}
+
+struct pbuf *pbuf_alloc_tagged(pbuf_layer layer, u16_t length, pbuf_type type, const char *func_name, int line_no)
+{
+    assert(!"NYI");
+}
+
+void lwip_record_event_simple(uint8_t event_type, uint64_t ts);
+void lwip_record_event_simple(uint8_t event_type, uint64_t ts)
+{
+    assert(!"NYI");
+}
+
+uint64_t wrapper_perform_lwip_work(void);
+uint64_t wrapper_perform_lwip_work(void)
+{
+    assert(!"NYI");
+}
+
+bool lwip_init_auto(void);
+bool lwip_init_auto(void)
+{
+    assert(!"NYI");
+}
+
+/******** NYI END *********/
+
+void ethernetif_backend_init(char *service_name, uint64_t queueid,
+                             ether_get_mac_address_t get_mac_ptr,
+                             ether_terminate_queue terminate_queue_ptr,
+                             ether_transmit_pbuf_list_t transmit_ptr,
+                             ether_get_tx_free_slots tx_free_slots_ptr,
+                             ether_handle_free_TX_slot handle_free_tx_slot_ptr,
+                             size_t rx_bufsz,
+                             ether_rx_register_buffer rx_register_buffer_ptr,
+                             ether_rx_get_free_slots rx_get_free_slots_ptr)
+{
+    ether_terminate_queue_ptr = terminate_queue_ptr;
+    ether_get_mac_address_ptr = get_mac_ptr;
+    ether_transmit_pbuf_list_ptr = transmit_ptr;
+    tx_free_slots_fn_ptr = tx_free_slots_ptr;
+    handle_free_tx_slot_fn_ptr = handle_free_tx_slot_ptr;
+    rx_register_buffer_fn_ptr = rx_register_buffer_ptr;
+    rx_get_free_slots_fn_ptr = rx_get_free_slots_ptr;
+    /* printf("PBUF_POOL_BUFSIZE = %u, rx buffer size = %zu\n", PBUF_POOL_BUFSIZE, */
+    /*        rx_bufsz); */
+}
+
+#define MAX_DRIVER_BUFS         16
+
+static genpaddr_t rx_pbase = 0;
+static genvaddr_t rx_vbase = 0;
+
+static struct packet tx_packets[MAX_PACKETS];
+static uint8_t tx_bufs[MAX_PACKETS][PACKET_SIZE];
+static unsigned int tx_idx = 0;
+/* static ssize_t tx_packets_available = MAX_PACKETS; */
+
+static void packet_output(struct packet *p)
+{
+    struct driver_buffer bufs[MAX_DRIVER_BUFS];
+    int n = 0;
+
+#ifdef DEBUG_LATENCIES
+    if(memcache_transactions[6] < POSIX_TRANSA) {
+        if(p->next == NULL) {
+            assert(p->next == NULL && p->len >= sizeof(protocol_binary_request_no_extras));
+            protocol_binary_request_no_extras *mypayload = (void *)p->payload + SIZEOF_ETH_HDR + 20 + sizeof(struct udp_hdr) + UDP_HEADLEN;
+            memcache_times[6][memcache_transactions[6]] = get_time() - mypayload->message.header.request.opaque;
+            memcache_transactions[6]++;
+        } else {
+            protocol_binary_request_no_extras *mypayload = (void *)p->next->payload + UDP_HEADLEN;
+            memcache_times[6][memcache_transactions[6]] = get_time() - mypayload->message.header.request.opaque;
+            memcache_transactions[6]++;
+        }
+    }
+#endif
+
+    for (struct packet *q = p; q != NULL; q = q->next) {
+        struct driver_buffer *buf = &bufs[n];
+
+        /* if(q->payload < &tx_bufs[0][0] || q->payload >= &tx_bufs[MAX_PACKETS][PACKET_SIZE]) { */
+        /*     printf("Called from %p %p\n", */
+        /*            __builtin_return_address(0), */
+        /*            __builtin_return_address(1)); */
+        /*     assert(q->payload >= &tx_bufs[0][0] && q->payload < &tx_bufs[MAX_PACKETS][PACKET_SIZE]); */
+        /* } */
+
+        /* Send the data from the pbuf to the interface, one pbuf at a
+           time. The size of the data in each pbuf is kept in the ->len
+           variable. */
+        assert(q->len > 0);
+
+        // Check if it's from the RX region
+        if(((genvaddr_t)q->payload) >= rx_vbase &&
+           ((genvaddr_t)q->payload) < rx_vbase + (MAX_PACKETS * PACKET_SIZE + 4096)) {
+            buf->pa = rx_pbase + ((genvaddr_t)q->payload - rx_vbase);
+        } else {
+            // Check if it's in morecore's region
+            struct morecore_state *mc_state = get_morecore_state();
+            struct vspace_mmu_aware *mmu_state = &mc_state->mmu_state;
+            genvaddr_t base = vregion_get_base_addr(&mmu_state->vregion);
+            struct memobj_frame_list *i;
+
+            // Walk frame list
+            for(i = mmu_state->memobj.frame_list; i != NULL; i = i->next) {
+                // If address is completely within frame, we can resolve
+                // XXX: Everything else would be easier with an IOMMU
+                if(base + i->offset <= (genvaddr_t)q->payload &&
+                   ((genvaddr_t)q->payload) + q->len < base + i->offset + i->size) {
+                    assert(i->pa != 0);
+
+                    /* buf->pa = id.base + ((genvaddr_t)q->payload - base - i->offset); */
+                    buf->pa = i->pa + ((genvaddr_t)q->payload - base - i->offset);
+                    break;
+                }
+            }
+
+            if(i == NULL) {
+                // Check if it's in text/data region
+                int entry;
+                for(entry = 0; entry < mc_state->v2p_entries; entry++) {
+                    struct v2pmap *pmap = &mc_state->v2p_mappings[entry];
+
+                    if(pmap->va <= (genvaddr_t)q->payload &&
+                       ((genvaddr_t)q->payload) + q->len < pmap->va + pmap->size) {
+                        buf->pa = pmap->pa + ((genvaddr_t)q->payload - pmap->va);
+                        break;
+                    }
+                }
+
+                if(entry == mc_state->v2p_entries) {
+                    printf("Called from %p %p\n",
+                           __builtin_return_address(0),
+                           __builtin_return_address(1));
+
+                    USER_PANIC("Invalid pbuf! payload = %p, pa = %p\n", q->payload, buf->pa);
+                }
+            }
+        }
+
+        /* printf("Sending: '%s'\n", (char *)q->payload); */
+
+        buf->va = q->payload;
+        buf->len = q->len;
+#ifndef SENDMSG_WITH_COPY
+        buf->opaque = q->opaque;
+#else
+        buf->opaque = q;
+#endif
+        buf->flags = q->flags;
+
+        n++;
+    }
+
+#ifdef DEBUG_LATENCIES
+    if(lwip_send_transactions < POSIX_TRANSA) {
+        struct ip_hdr *iphdr = (struct ip_hdr *)(p->payload + SIZEOF_ETH_HDR);
+
+        if(IPH_PROTO(iphdr) == IP_PROTO_UDP) {
+            struct udp_hdr *udphdr = (struct udp_hdr *)(p->payload + SIZEOF_ETH_HDR + (IPH_HL(iphdr) * 4));
+            if(htons(udphdr->src) == 11212 || htons(udphdr->src) == 11211) {
+                protocol_binary_response_no_extras *mypayload;
+                if(p->next != NULL) {
+                    mypayload = (void *)p->next->next->payload;
+                } else {
+                    mypayload = (void *)p->payload + sizeof(struct pkt_udp_headers) + UDP_HEADLEN;
+                }
+                lwip_send_time[lwip_send_transactions] = get_time() - mypayload->message.header.response.opaque;
+                lwip_send_transactions++;
+            } else if (htons(udphdr->src) == 1234) {
+                protocol_binary_request_no_extras *mypayload;
+                if(p->next == NULL) {
+                    mypayload = (void *)p->payload + sizeof(struct pkt_udp_headers) + UDP_HEADLEN;
+                } else {
+                    mypayload = (void *)p->next->payload + UDP_HEADLEN;
+                }
+                lwip_send_time[lwip_send_transactions] = get_time() - mypayload->message.header.request.opaque;
+                lwip_send_transactions++;
+            }
+        }
+    }
+#endif
+
+    errval_t err = ether_transmit_pbuf_list_ptr(bufs, n);
+    assert(err_is_ok(err));
+}
+
+void arranet_recv_free(struct packet *p)
+{
+    assert(p >= rx_packets && p < &rx_packets[MAX_PACKETS]);
+
+#ifdef DEBUG_LATENCIES
+    rx_packets_available++;
+#endif
+    errval_t err = rx_register_buffer_fn_ptr(p->pa, p->payload, p);
+    assert(err_is_ok(err));
+}
+
+struct recv_udp_args {
+    void *buf;
+    size_t len;
+    int recv_len;
+    struct sockaddr *src_addr;
+    socklen_t *addrlen;
+    struct packet **inpkt;
+};
+
+struct recv_tcp_args {
+    void *buf;
+    size_t len;
+    int recv_len;
+    struct sockaddr *src_addr;
+    socklen_t *addrlen;
+    struct packet **inpkt;
+    bool syn, for_me;
+    uint32_t in_seqno;
+    struct socket *sock;
+};
+
+#define MIN(a,b)        ((a) < (b) ? (a) : (b))
+
+static void sock_recved_udp_packet(void *arg)
+{
+    struct recv_udp_args *args = arg;
+    assert(inpkt != NULL);
+    assert(inpkt->next == NULL);
+
+    // Process headers
+    struct ip_hdr *iphdr = (struct ip_hdr *)(inpkt->payload + SIZEOF_ETH_HDR);
+
+    assert(IPH_PROTO(iphdr) == IP_PROTO_UDP);
+
+    struct udp_hdr *udphdr = (struct udp_hdr *)(inpkt->payload + SIZEOF_ETH_HDR + (IPH_HL(iphdr) * 4));
+    size_t hdr_len = SIZEOF_ETH_HDR + (IPH_HL(iphdr) * 4) + sizeof(struct udp_hdr);
+    uint8_t *payload = inpkt->payload + hdr_len;
+    uint16_t pkt_len = htons(udphdr->len) - sizeof(struct udp_hdr);
+    assert(args->buf != NULL);      // No accept() allowed
+
+    // Fill in src_addr if provided
+    if(args->src_addr != NULL) {
+        struct sockaddr_in *addr = (struct sockaddr_in *)args->src_addr;
+
+        assert(*args->addrlen >= sizeof(struct sockaddr_in));
+        memset(addr, 0, sizeof(struct sockaddr_in));
+        addr->sin_len = sizeof(struct sockaddr_in);
+        addr->sin_family = AF_INET;
+        addr->sin_port = udphdr->src;
+        addr->sin_addr.s_addr = iphdr->src.addr;
+        *args->addrlen = sizeof(struct sockaddr_in);
+    }
+
+    // It's a recvfrom!
+    if(args->len != 0) {
+#ifdef DEBUG_LATENCIES
+    if(memcache_transactions[0] < POSIX_TRANSA) {
+        protocol_binary_request_no_extras *mypayload = (void *)payload + UDP_HEADLEN;
+        memcache_times[0][memcache_transactions[0]] = get_time() - mypayload->message.header.request.opaque;
+        memcache_transactions[0]++;
+    }
+#endif
+
+        args->recv_len = MIN(args->len, pkt_len);
+        memcpy(args->buf, payload, args->recv_len);
+
+#ifdef DEBUG_LATENCIES
+    if(memcache_transactions[1] < POSIX_TRANSA) {
+        protocol_binary_request_no_extras *mypayload = (void *)payload + UDP_HEADLEN;
+        memcache_times[1][memcache_transactions[1]] = get_time() - mypayload->message.header.request.opaque;
+        memcache_transactions[1]++;
+    }
+#endif
+
+#ifdef DEBUG_LATENCIES
+        rx_packets_available++;
+#endif
+        errval_t err = rx_register_buffer_fn_ptr(inpkt->pa, inpkt->payload, inpkt);
+        assert(err_is_ok(err));
+    } else {
+        args->recv_len = pkt_len;
+        *((void **)args->buf) = payload;
+        *args->inpkt = inpkt;
+    }
+
+    // Input packet is consumed in stack
+    inpkt = NULL;
+}
+
+static void sock_recved_tcp_packet(void *arg)
+{
+    struct recv_tcp_args *args = arg;
+
+    // Received only a FIN?
+    if(inpkt == NULL) {
+        args->recv_len = 0;
+        args->for_me = true;
+        return;
+    }
+    assert(inpkt != NULL);
+    assert(inpkt->next == NULL);
+
+    // Process headers
+    struct ip_hdr *iphdr = (struct ip_hdr *)(inpkt->payload + SIZEOF_ETH_HDR);
+    assert(IPH_PROTO(iphdr) == IP_PROTO_TCP);
+    struct tcp_hdr *tcphdr = (struct tcp_hdr *)(inpkt->payload + SIZEOF_ETH_HDR + (IPH_HL(iphdr) * 4));
+    size_t hdr_len = SIZEOF_ETH_HDR + (IPH_HL(iphdr) * 4) + (TCPH_HDRLEN(tcphdr) * 4);
+    uint8_t *payload = inpkt->payload + hdr_len;
+    uint16_t pkt_len = htons(IPH_LEN(iphdr)) - (TCPH_HDRLEN(tcphdr) * 4) - (IPH_HL(iphdr) * 4);
+
+    args->in_seqno = tcphdr->seqno;
+    args->for_me = true;
+
+    // Is this from an accept() call?
+    if(args->buf == NULL) {
+        if(TCPH_FLAGS(tcphdr) & TCP_SYN) {
+            args->syn = true;
+        } else {
+            // Don't consume packet
+            args->for_me = false;
+            return;
+        }
+    } else {    // From a recv() call
+        if(TCPH_FLAGS(tcphdr) & TCP_SYN) {
+            // Don't consume packet
+            args->syn = true;
+            args->for_me = false;
+            return;
+        } else {
+            assert(args->sock != NULL);
+            // Is this for the socket that's calling?
+            if(tcphdr->dest != args->sock->bound_addr.sin_port ||
+               tcphdr->src != args->sock->peer_addr.sin_port) {
+                // Don't consume packet
+                args->for_me = false;
+                return;
+            }
+
+            if(args->len != 0) {
+                assert(args->len >= pkt_len);
+                args->recv_len = MIN(args->len, pkt_len);
+                memcpy(args->buf, payload, args->recv_len);
+            } else {
+                assert(!"NYI");
+                args->recv_len = pkt_len;
+                *((void **)args->buf) = payload;
+                *args->inpkt = inpkt;
+            }
+        }
+    }
+
+    // Fill in src_addr if provided
+    if(args->src_addr != NULL) {
+        struct sockaddr_in *addr = (struct sockaddr_in *)args->src_addr;
+
+        assert(*args->addrlen >= sizeof(struct sockaddr_in));
+        memset(addr, 0, sizeof(struct sockaddr_in));
+        addr->sin_len = sizeof(struct sockaddr_in);
+        addr->sin_family = AF_INET;
+        addr->sin_port = tcphdr->src;
+        addr->sin_addr.s_addr = iphdr->src.addr;
+        *args->addrlen = sizeof(struct sockaddr_in);
+    }
+
+#ifdef DEBUG_LATENCIES
+    rx_packets_available++;
+#endif
+    errval_t err = rx_register_buffer_fn_ptr(inpkt->pa, inpkt->payload, inpkt);
+    assert(err_is_ok(err));
+
+    // Input packet is consumed in stack
+    inpkt = NULL;
+}
+
+int lwip_recv(int s, void *mem, size_t len, int flags)
+{
+    /* printf("lwip_recv(%d)\n", s); */
+    assert(arranet_tcp_accepted);
+    struct socket *sock = &sockets[s];
+    struct recv_tcp_args args = {
+        .buf = mem,
+        .len = len,
+        .src_addr = NULL,
+        .syn = false,
+        .sock = sock,
+    };
+    struct waitset ws;
+    waitset_init(&ws);
+
+    errval_t err = waitset_chan_register_polled(&ws, &recv_chanstate,
+                                                MKCLOSURE(sock_recved_tcp_packet, &args));
+    assert(err_is_ok(err));
+
+    /* if socket is ready, trigger event right away */
+    if (lwip_sock_ready_read(s)) {
+        err = waitset_chan_trigger(&recv_chanstate);
+        assert(err_is_ok(err));
+    }
+
+    if(sock->nonblocking) {
+        err = event_dispatch_non_block(&ws);
+        if(err_no(err) == LIB_ERR_NO_EVENT || !args.for_me) {
+            err = waitset_chan_deregister(&recv_chanstate);
+            assert(err_is_ok(err) ||
+                   (err_no(err) == LIB_ERR_CHAN_NOT_REGISTERED && !args.for_me));
+            errno = EAGAIN;
+            args.recv_len = -1;
+        } else {
+            errno = 0;
+            assert(err_is_ok(err));
+        }
+    } else {
+        err = event_dispatch(&ws);
+        assert(err_is_ok(err));
+        if(args.syn) {
+            assert(!"Will block forever");
+        }
+        errno = 0;
+    }
+
+    if(errno != EAGAIN) {
+        sock->peer_seq = htonl(args.in_seqno);
+        sock->next_ack = sock->peer_seq + args.recv_len;
+        /* printf("lwip_recv: Assigning %p, %x\n", sock, sock->next_ack); */
+    } else {
+        // Did it shutdown?
+        if(sock->hangup) {
+            errno = 0;
+            args.recv_len = 0;
+        }
+    }
+
+#ifdef DEBUG_LATENCIES
+    if(posix_recv_transactions < POSIX_TRANSA) {
+        protocol_binary_request_no_extras *mypayload = mem + UDP_HEADLEN;
+        posix_recv_time[posix_recv_transactions] = get_time() - mypayload->message.header.request.opaque;
+        posix_recv_transactions++;
+    }
+#endif
+
+    // Packet is now in buffer
+    /* printf("lwip_recv returned %d\n", args.recv_len); */
+    return args.recv_len;
+}
+
+int lwip_sendto(int s, const void *data, size_t size, int flags,
+                const struct sockaddr *to, socklen_t tolen)
+{
+    struct iovec io = {
+        .iov_base = (void *)data,
+        .iov_len = size,
+    };
+
+    struct msghdr msg = {
+        .msg_name = (void *)to,
+        .msg_namelen = tolen,
+        .msg_iov = &io,
+        .msg_iovlen = 1,
+        .msg_flags = 0,
+    };
+
+    return lwip_sendmsg(s, &msg, flags);
+}
+
+int lwip_socket(int domain, int type, int protocol)
+{
+    // XXX: Accept UDP or TCP, based on created sockets
+    switch(type) {
+    case SOCK_STREAM:
+        assert(!arranet_udp_accepted);
+        arranet_tcp_accepted = true;
+        break;
+
+    case SOCK_DGRAM:
+        assert(!arranet_tcp_accepted);
+        arranet_udp_accepted = true;
+        break;
+    }
+
+    struct socket *sock = alloc_socket();
+    assert(sock != NULL);
+    /* printf("lwip_socket() = %d\n", sock->fd); */
+    return sock->fd;
+}
+
+int lwip_bind(int s, const struct sockaddr *name, socklen_t namelen)
+{
+    struct socket *sock = &sockets[s];
+    assert(name->sa_family == AF_INET);
+    assert(namelen >= sizeof(struct sockaddr_in));
+    sock->bound_addr = *(struct sockaddr_in *)name;
+    return 0;
+}
+
+int lwip_recvfrom(int sockfd, void *buf, size_t len, int flags,
+                  struct sockaddr *src_addr, socklen_t *addrlen)
+{
+    assert(arranet_udp_accepted);
+    struct socket *sock = &sockets[sockfd];
+    struct recv_udp_args args = {
+        .buf = buf,
+        .len = len,
+        .src_addr = src_addr,
+        .addrlen = addrlen,
+    };
+    struct waitset ws;
+    waitset_init(&ws);
+
+    errval_t err = waitset_chan_register_polled(&ws, &recv_chanstate,
+                                                MKCLOSURE(sock_recved_udp_packet, &args));
+    assert(err_is_ok(err));
+
+    /* if socket is ready, trigger event right away */
+    if (lwip_sock_ready_read(sockfd)) {
+        err = waitset_chan_trigger(&recv_chanstate);
+        assert(err_is_ok(err));
+    }
+
+    if(sock->nonblocking) {
+        err = event_dispatch_non_block(&ws);
+        if(err_no(err) == LIB_ERR_NO_EVENT) {
+            err = waitset_chan_deregister(&recv_chanstate);
+            assert(err_is_ok(err));
+            errno = EAGAIN;
+            args.recv_len = -1;
+        } else {
+            assert(err_is_ok(err));
+        }
+    } else {
+        err = event_dispatch(&ws);
+        assert(err_is_ok(err));
+    }
+
+/* #ifdef DEBUG_LATENCIES */
+/*     if(posix_recv_transactions < POSIX_TRANSA) { */
+/*         protocol_binary_request_no_extras *mypayload = buf + UDP_HEADLEN; */
+/*         posix_recv_time[posix_recv_transactions] = get_time() - mypayload->message.header.request.opaque; */
+/*         posix_recv_transactions++; */
+/*     } */
+/* #endif */
+
+    // Packet is now in buffer
+    return args.recv_len;
+}
+
+int recvfrom_arranet(int sockfd, void **buf, struct packet **p,
+                     struct sockaddr *src_addr, socklen_t *addrlen)
+{
+    assert(arranet_udp_accepted);
+    struct fdtab_entry *e = fdtab_get(sockfd);
+    struct socket *sock = &sockets[e->fd];
+    struct recv_udp_args args = {
+        .buf = buf,
+        .len = 0,
+        .src_addr = src_addr,
+        .addrlen = addrlen,
+        .inpkt = p,
+        .recv_len = 0,
+    };
+    struct waitset ws;
+    waitset_init(&ws);
+
+    errval_t err = waitset_chan_register_polled(&ws, &recv_chanstate,
+                                                MKCLOSURE(sock_recved_udp_packet, &args));
+    assert(err_is_ok(err));
+
+    /* if socket is ready, trigger event right away */
+    if (lwip_sock_ready_read(e->fd)) {
+        err = waitset_chan_trigger(&recv_chanstate);
+        assert(err_is_ok(err));
+    }
+
+    if(sock->nonblocking) {
+        err = event_dispatch_non_block(&ws);
+        if(err_no(err) == LIB_ERR_NO_EVENT) {
+            err = waitset_chan_deregister(&recv_chanstate);
+            assert(err_is_ok(err));
+            errno = EAGAIN;
+            args.recv_len = -1;
+        } else {
+            assert(err_is_ok(err));
+        }
+    } else {
+        err = event_dispatch(&ws);
+        assert(err_is_ok(err));
+    }
+
+/* #ifdef DEBUG_LATENCIES */
+/*     if(posix_recv_transactions < POSIX_TRANSA) { */
+/*         protocol_binary_request_no_extras *mypayload = (*buf) + UDP_HEADLEN; */
+/*         posix_recv_time[posix_recv_transactions] = get_time() - mypayload->message.header.request.opaque; */
+/*         posix_recv_transactions++; */
+/*     } */
+/* #endif */
+
+    // XXX: Assert dword alignment
+    assert(((long)*buf) % 8 == 0);
+
+    // Packet is now in buffer
+    return args.recv_len;
+}
+
+static struct pkt_udp_headers packet_udp_header;
+static struct pkt_tcp_headers packet_tcp_header;
+
+static struct peer *peers_get_from_ip(uint32_t ip)
+{
+    for(int i = 0; i < MAX_PEERS; i++) {
+        if(ip == peers[i].ip) {
+            return &peers[i];
+        }
+    }
+
+    /* printf("NOT FOUND: %x\n", ip); */
+
+    return NULL;
+}
+
+static struct peer *peers_get_next_free(void)
+{
+    if(peers_alloc < MAX_PEERS) {
+        return &peers[peers_alloc++];
+    } else {
+        return NULL;
+    }
+}
+
+#define MAX_SENDMSG     16
+
+int sendmsg_arranet(int sockfd, const struct msghdr *msg)
+{
+    assert(arranet_udp_accepted);
+    struct fdtab_entry *e = fdtab_get(sockfd);
+    struct socket *sock = &sockets[e->fd];
+    ssize_t short_size = 0;
+    struct packet packets[MAX_SENDMSG];
+    struct packet hdrpkt;
+    struct packet *oldp = NULL;
+
+#ifdef DEBUG_LATENCIES
+    if(posix_send_transactions < POSIX_TRANSA) {
+        if(msg->msg_iovlen > 1 && msg->msg_iov[1].iov_len == sizeof(protocol_binary_response_no_extras)) {
+            protocol_binary_response_no_extras *mypayload = msg->msg_iov[1].iov_base;
+            posix_send_time[posix_send_transactions] = get_time() - mypayload->message.header.response.opaque;
+            posix_send_transactions++;
+        } else if(msg->msg_iov[0].iov_len >= sizeof(protocol_binary_request_no_extras)) {
+            protocol_binary_request_no_extras *mypayload = msg->msg_iov[0].iov_base;
+            posix_send_time[posix_send_transactions] = get_time() - mypayload->message.header.request.opaque;
+            posix_send_transactions++;
+        }
+    }
+#endif
+
+    assert(msg->msg_iovlen < MAX_SENDMSG);
+
+    for(int i = 0; i < msg->msg_iovlen; i++) {
+        struct packet *newp = &packets[i];
+
+        newp->payload = (uint8_t *)msg->msg_iov[i].iov_base;
+        newp->len = msg->msg_iov[i].iov_len;
+        newp->next = NULL;
+        newp->flags = 0;
+        if(oldp != NULL) {
+            oldp->next = newp;
+        }
+        short_size += msg->msg_iov[i].iov_len;
+        oldp = newp;
+    }
+
+    // Slap UDP/IP/Ethernet headers in front
+    struct pkt_udp_headers myhdr = packet_udp_header;
+    hdrpkt.payload = (uint8_t *)&myhdr;
+    struct pkt_udp_headers *p = (struct pkt_udp_headers *)hdrpkt.payload;
+    hdrpkt.len = sizeof(struct pkt_udp_headers);
+    hdrpkt.next = packets;
+
+    // Fine-tune headers
+    assert(msg->msg_name != NULL);
+    struct sockaddr_in *saddr = msg->msg_name;
+    assert(saddr->sin_family == AF_INET);
+    p->ip.dest.addr = saddr->sin_addr.s_addr;
+    p->udp.dest = saddr->sin_port;
+    struct peer *peer = peers_get_from_ip(p->ip.dest.addr);
+    p->eth.dest = peer->mac;
+    assert(sock->bound_addr.sin_port != 0);
+    p->udp.src = sock->bound_addr.sin_port;
+    p->udp.len = htons(short_size + sizeof(struct udp_hdr));
+    p->ip._len = htons(short_size + sizeof(struct udp_hdr) + IP_HLEN);
+#ifdef CONFIG_QEMU_NETWORK
+    p->ip._chksum = inet_chksum(&p->ip, IP_HLEN);
+    hdrpkt.flags = 0;
+#else
+    // Hardware IP header checksumming on
+    p->ip._chksum = 0;
+    hdrpkt.flags = NETIF_TXFLAG_IPCHECKSUM;
+#endif
+
+    packet_output(&hdrpkt);
+
+    return short_size;
+}
+
+static struct packet *get_tx_packet(void)
+{
+    struct packet *p = &tx_packets[tx_idx];
+
+    // Busy-wait until packet not in flight
+    while(p->len != 0) {
+#ifdef DEBUG_LATENCIES
+        output_pipeline_stalled++;
+#endif
+        /* printf("Pipeline stalled! tx_packets_available = %zd\n", tx_packets_available); */
+        handle_free_tx_slot_fn_ptr();
+        /* if(!handle_free_tx_slot_fn_ptr()) { */
+        /*     printf("No packets could be freed!\n"); */
+        /* } */
+    }
+
+    /* tx_packets_available--; */
+
+    tx_idx = (tx_idx + 1) % MAX_PACKETS;
+    return p;
+}
+
+int lwip_shutdown(int s, int how)
+{
+    assert(arranet_tcp_accepted);
+    struct socket *sock = &sockets[s];
+    assert(sock->nonblocking);
+
+    /* printf("lwip_shutdown(%d)\n", s); */
+
+    if(how == SHUT_RD || sock->shutdown) {
+        return 0;
+    }
+
+    sock->shutdown = true;
+
+#ifdef SENDMSG_WITH_COPY
+    // Get new TX packet and send FIN-ACK
+    struct packet *newp = get_tx_packet();
+    newp->len = sizeof(struct pkt_tcp_headers);
+    newp->next = NULL;
+
+    // Slap TCP/IP/Ethernet headers in front
+    memcpy(newp->payload, &packet_tcp_header, sizeof(struct pkt_tcp_headers));
+
+    // Fine-tune headers
+    struct pkt_tcp_headers *p = (struct pkt_tcp_headers *)newp->payload;
+    p->ip.dest.addr = sock->peer_addr.sin_addr.s_addr;
+    p->tcp.dest = sock->peer_addr.sin_port;
+    struct peer *peer = peers_get_from_ip(p->ip.dest.addr);
+    p->eth.dest = peer->mac;
+    assert(sock->bound_addr.sin_port != 0);
+    p->tcp.src = sock->bound_addr.sin_port;
+    p->ip._len = htons(sizeof(struct tcp_hdr) + IP_HLEN);
+    p->tcp.seqno = htonl(sock->my_seq++);
+    p->tcp.ackno = htonl(sock->next_ack);
+    /* printf("lwip_shutdown: Sending %p, seq %x, ack %x\n", sock, sock->my_seq - 1, sock->next_ack); */
+    TCPH_FLAGS_SET(&p->tcp, TCP_FIN | TCP_ACK); // Set FIN-ACK
+    TCPH_HDRLEN_SET(&p->tcp, 5);   // 20 / 4
+    p->tcp.wnd = htons(11680);
+#ifdef CONFIG_QEMU_NETWORK
+    p->ip._chksum = inet_chksum(&p->ip, IP_HLEN);
+    p->tcp.chksum = 0;
+    newp->payload = (uint8_t *)&p->tcp;
+    newp->len -= (uint8_t *)&p->tcp - (uint8_t *)p;
+    p->tcp.chksum = inet_chksum_pseudo(newp, (ip_addr_t *)&p->ip.src, (ip_addr_t *)&p->ip.dest,
+                                       IP_PROTO_TCP, TCP_HLEN);
+    newp->payload = (uint8_t *)p;
+    newp->len = sizeof(struct pkt_tcp_headers);
+    newp->flags = 0;
+#else
+    // Hardware IP/TCP header checksumming on
+    p->ip._chksum = 0;
+    p->tcp.chksum =
+        (~inet_chksum_pseudo_partial(newp, (ip_addr_t *)&p->ip.src, (ip_addr_t *)&p->ip.dest,
+                                     IP_PROTO_TCP, TCP_HLEN, 0)) & 0xffff;
+    newp->flags = (NETIF_TXFLAG_IPCHECKSUM | NETIF_TXFLAG_TCPCHECKSUM) |
+        (TCPH_HDRLEN(&p->tcp) << NETIF_TXFLAG_TCPHDRLEN_SHIFT);
+#endif
+
+    packet_output(newp);
+
+    return 0;
+#else
+    assert(!"NYI");
+#endif
+}
+
+int lwip_close(int s)
+{
+    assert(arranet_tcp_accepted);
+    struct socket *sock = &sockets[s];
+
+    lwip_shutdown(s, SHUT_RDWR);
+
+    // Might need to return port if it was bound
+    if(sock->bound_addr.sin_port != 0 && htons(sock->bound_addr.sin_port) != 8080) {
+        tcp_free_port(sock->bound_addr.sin_port);
+    }
+
+    // Remove from active connections
+    if(sock->prev != NULL) {
+        sock->prev->next = sock->next;
+    }
+    if(sock->next != NULL) {
+        sock->next->prev = sock->prev;
+    }
+    if(connections == sock) {
+        connections = sock->next;
+    }
+    sock->next = sock->prev = NULL;
+
+    free_socket(sock);
+    return 0;
+}
+
+int lwip_send(int s, const void *data, size_t size, int flags)
+{
+    assert(arranet_tcp_accepted);
+    struct socket *sock = &sockets[s];
+    assert(sock->nonblocking);
+    assert(size + sizeof(struct pkt_tcp_headers) <= 1500);
+
+    /* printf("lwip_send(%d, , %zu)\n", s, size); */
+
+#ifdef SENDMSG_WITH_COPY
+    // Get new TX packet and copy data into it
+    struct packet *newp = get_tx_packet();
+    newp->len = sizeof(struct pkt_tcp_headers) + size;
+    newp->next = NULL;
+    uint8_t *buf = newp->payload + sizeof(struct pkt_tcp_headers);
+    memcpy(buf, data, size);
+
+    // Slap TCP/IP/Ethernet headers in front
+    memcpy(newp->payload, &packet_tcp_header, sizeof(struct pkt_tcp_headers));
+
+    // Fine-tune headers
+    struct pkt_tcp_headers *p = (struct pkt_tcp_headers *)newp->payload;
+    p->ip.dest.addr = sock->peer_addr.sin_addr.s_addr;
+    p->tcp.dest = sock->peer_addr.sin_port;
+    struct peer *peer = peers_get_from_ip(p->ip.dest.addr);
+    assert(peer != NULL);
+    p->eth.dest = peer->mac;
+    assert(sock->bound_addr.sin_port != 0);
+    p->tcp.src = sock->bound_addr.sin_port;
+    p->ip._len = htons(sizeof(struct tcp_hdr) + IP_HLEN + size);
+    p->tcp.seqno = htonl(sock->my_seq);
+    sock->my_seq += size;
+    /* printf("lwip_send: Assigning %p, seq %x\n", sock, sock->my_seq); */
+    p->tcp.ackno = htonl(sock->next_ack);
+    /* printf("lwip_send: Sending %p, %x\n", sock, sock->next_ack); */
+    TCPH_FLAGS_SET(&p->tcp, TCP_ACK | TCP_PSH);
+    TCPH_HDRLEN_SET(&p->tcp, 5);   // 20 / 4
+    p->tcp.wnd = htons(11680);
+#ifdef CONFIG_QEMU_NETWORK
+    p->ip._chksum = inet_chksum(&p->ip, IP_HLEN);
+    p->tcp.chksum = 0;
+    newp->payload = (uint8_t *)&p->tcp;
+    newp->len -= (uint8_t *)&p->tcp - (uint8_t *)p;
+    p->tcp.chksum = inet_chksum_pseudo(newp, (ip_addr_t *)&p->ip.src, (ip_addr_t *)&p->ip.dest,
+                                       IP_PROTO_TCP, TCP_HLEN + size);
+    newp->payload = (uint8_t *)p;
+    newp->len = sizeof(struct pkt_tcp_headers) + size;
+    newp->flags = 0;
+#else
+    // Hardware IP/TCP header checksumming on
+    p->ip._chksum = 0;
+    p->tcp.chksum =
+        (~inet_chksum_pseudo_partial(newp, (ip_addr_t *)&p->ip.src, (ip_addr_t *)&p->ip.dest,
+                                     IP_PROTO_TCP, TCP_HLEN + size, 0)) & 0xffff;
+    newp->flags = (NETIF_TXFLAG_IPCHECKSUM | NETIF_TXFLAG_TCPCHECKSUM) |
+        (TCPH_HDRLEN(&p->tcp) << NETIF_TXFLAG_TCPHDRLEN_SHIFT);
+#endif
+
+    packet_output(newp);
+
+    return size;
+#else
+    assert(!"NYI");
+#endif
+}
+
+int lwip_connect(int s, const struct sockaddr *name, socklen_t namelen)
+{
+    /* printf("lwip_connect(%d)\n", s); */
+    assert(arranet_tcp_accepted);
+    struct socket *sock = &sockets[s];
+    assert(sock->nonblocking);
+    assert(namelen == sizeof(struct sockaddr_in));
+    struct sockaddr_in *sa = (struct sockaddr_in *)name;
+    assert(sa->sin_family == AF_INET);
+
+    // Store peer address on socket
+    sock->peer_addr = *sa;
+
+#ifdef SENDMSG_WITH_COPY
+    // Get new TX packet and send SYN
+    struct packet *newp = get_tx_packet();
+    newp->len = sizeof(struct pkt_tcp_headers) + 6;
+    newp->next = NULL;
+
+    // Slap TCP/IP/Ethernet headers in front
+    memcpy(newp->payload, &packet_tcp_header, sizeof(struct pkt_tcp_headers));
+
+    // Fine-tune headers
+    struct pkt_tcp_headers *p = (struct pkt_tcp_headers *)newp->payload;
+    uint32_t *payload = (void *)p + sizeof(struct pkt_tcp_headers);
+    memset(payload, 0, 6);
+    p->ip.dest.addr = sa->sin_addr.s_addr;
+    p->tcp.dest = sa->sin_port;
+    struct peer *peer = peers_get_from_ip(p->ip.dest.addr);
+    assert(peer != NULL);
+    p->eth.dest = peer->mac;
+    assert(sock->bound_addr.sin_port == 0);
+    sock->bound_addr.sin_port = tcp_new_port();
+    p->tcp.src = sock->bound_addr.sin_port;
+    p->ip._len = htons(sizeof(struct tcp_hdr) + IP_HLEN + 4);
+    p->tcp.seqno = htonl(++sock->my_seq); sock->my_seq++;
+    /* printf("lwip_connect: Assigning %p seq %x\n", sock, sock->my_seq); */
+    p->tcp.ackno = 0;
+    TCPH_FLAGS_SET(&p->tcp, TCP_SYN);
+    TCPH_HDRLEN_SET(&p->tcp, 6);   // 24 / 4
+    p->tcp.wnd = htons(11680);
+    *payload = TCP_BUILD_MSS_OPTION(1460);
+#ifdef CONFIG_QEMU_NETWORK
+    p->ip._chksum = inet_chksum(&p->ip, IP_HLEN);
+    p->tcp.chksum = 0;
+    newp->payload = (uint8_t *)&p->tcp;
+    newp->len -= (uint8_t *)&p->tcp - (uint8_t *)p;
+    p->tcp.chksum = inet_chksum_pseudo(newp, (ip_addr_t *)&p->ip.src, (ip_addr_t *)&p->ip.dest,
+                                       IP_PROTO_TCP, TCP_HLEN + 4);
+    newp->payload = (uint8_t *)p;
+    newp->len = sizeof(struct pkt_tcp_headers) + 6;
+    newp->flags = 0;
+#else
+    // Hardware IP/TCP header checksumming on
+    p->ip._chksum = 0;
+    p->tcp.chksum = 0;
+    p->tcp.chksum =
+        (~inet_chksum_pseudo_partial(newp, (ip_addr_t *)&p->ip.src, (ip_addr_t *)&p->ip.dest,
+                                     IP_PROTO_TCP, TCP_HLEN + 4, 0)) & 0xffff;
+    newp->flags = (NETIF_TXFLAG_IPCHECKSUM | NETIF_TXFLAG_TCPCHECKSUM) |
+        (TCPH_HDRLEN(&p->tcp) << NETIF_TXFLAG_TCPHDRLEN_SHIFT);
+#endif
+
+    packet_output(newp);
+
+    assert(sock->prev == NULL && sock->next == NULL);
+    sock->next = connections;
+    if(connections != NULL) {
+        assert(connections->prev == NULL);
+        connections->prev = sock;
+    }
+    sock->prev = NULL;
+    connections = sock;
+
+    errno = EINPROGRESS;
+    return -1;
+#else
+    assert(!"NYI");
+#endif
+}
+
+#ifdef SENDMSG_WITH_COPY
+
+int lwip_sendmsg(int sockfd, const struct msghdr *msg, int flags)
+{
+    assert(arranet_udp_accepted);
+    struct socket *sock = &sockets[sockfd];
+
+#ifdef DEBUG_LATENCIES
+    if(posix_send_transactions < POSIX_TRANSA) {
+        if(msg->msg_iovlen > 1 && msg->msg_iov[1].iov_len == sizeof(protocol_binary_response_no_extras)) {
+            protocol_binary_response_no_extras *mypayload = msg->msg_iov[1].iov_base;
+            posix_send_time[posix_send_transactions] = get_time() - mypayload->message.header.response.opaque;
+            posix_send_transactions++;
+        } else if(msg->msg_iov[0].iov_len >= sizeof(protocol_binary_request_no_extras)) {
+            protocol_binary_request_no_extras *mypayload = msg->msg_iov[0].iov_base + UDP_HEADLEN;
+            posix_send_time[posix_send_transactions] = get_time() - mypayload->message.header.request.opaque;
+            posix_send_transactions++;
+        }
+    }
+#endif
+
+    assert(msg->msg_iovlen < MAX_SENDMSG);
+
+    // Determine length of sendmsg vector
+    ssize_t short_size = 0;
+    for(int i = 0; i < msg->msg_iovlen; i++) {
+        short_size += msg->msg_iov[i].iov_len;
+    }
+    assert(short_size <= PACKET_SIZE);
+
+/* #ifdef DEBUG_LATENCIES */
+/*     if(memcache_transactions[0] < POSIX_TRANSA) { */
+/*         if(msg->msg_iovlen > 1 && msg->msg_iov[1].iov_len == sizeof(protocol_binary_response_no_extras)) { */
+/*             protocol_binary_response_no_extras *mypayload = msg->msg_iov[1].iov_base; */
+/*             memcache_times[0][memcache_transactions[0]] = get_time() - mypayload->message.header.response.opaque; */
+/*             memcache_transactions[0]++; */
+/*         } else if(msg->msg_iov[0].iov_len >= sizeof(protocol_binary_request_no_extras)) { */
+/*             protocol_binary_request_no_extras *mypayload = msg->msg_iov[0].iov_base + UDP_HEADLEN; */
+/*             memcache_times[0][memcache_transactions[0]] = get_time() - mypayload->message.header.request.opaque; */
+/*             memcache_transactions[0]++; */
+/*         } */
+/*     } */
+/* #endif */
+
+    // Get new TX packet and copy data into it
+    struct packet *newp = get_tx_packet();
+    uint8_t *buf = newp->payload;
+    size_t pos = sizeof(struct pkt_udp_headers);
+
+/* #ifdef DEBUG_LATENCIES */
+/*     if(memcache_transactions[1] < POSIX_TRANSA) { */
+/*         if(msg->msg_iovlen > 1 && msg->msg_iov[1].iov_len == sizeof(protocol_binary_response_no_extras)) { */
+/*             protocol_binary_response_no_extras *mypayload = msg->msg_iov[1].iov_base; */
+/*             memcache_times[1][memcache_transactions[1]] = get_time() - mypayload->message.header.response.opaque; */
+/*             memcache_transactions[1]++; */
+/*         } else if(msg->msg_iov[0].iov_len >= sizeof(protocol_binary_request_no_extras)) { */
+/*             protocol_binary_request_no_extras *mypayload = msg->msg_iov[0].iov_base + UDP_HEADLEN; */
+/*             memcache_times[1][memcache_transactions[1]] = get_time() - mypayload->message.header.request.opaque; */
+/*             memcache_transactions[1]++; */
+/*         } */
+/*     } */
+
+/*     uint64_t last = rdpmc(0); */
+/* #endif */
+
+    //    assert(msg->msg_iovlen == 1);
+    for(int i = 0; i < msg->msg_iovlen; i++) {
+        /* assert((uintptr_t)(&buf[pos]) % 8 == 0); */
+        //        assert((uintptr_t)msg->msg_iov[i].iov_base % 8 == 0);
+        memcpy(&buf[pos], msg->msg_iov[i].iov_base, msg->msg_iov[i].iov_len);
+        pos += msg->msg_iov[i].iov_len;
+    }
+
+#ifdef DEBUG_LATENCIES
+    /* uint64_t now = rdpmc(0); */
+
+    /* if(memcache_transactions[19] < POSIX_TRANSA) {   // ZZZ 19 */
+    /*     memcache_times[19][memcache_transactions[19]] = now - last; */
+    /*     memcache_transactions[19]++; */
+    /* } */
+
+    if(memcache_transactions[2] < POSIX_TRANSA) {
+        if(msg->msg_iovlen > 1 && msg->msg_iov[1].iov_len == sizeof(protocol_binary_response_no_extras)) {
+            protocol_binary_response_no_extras *mypayload = msg->msg_iov[1].iov_base;
+            memcache_times[2][memcache_transactions[2]] = get_time() - mypayload->message.header.response.opaque;
+            memcache_transactions[2]++;
+        } else if(msg->msg_iov[0].iov_len >= sizeof(protocol_binary_request_no_extras)) {
+            protocol_binary_request_no_extras *mypayload = msg->msg_iov[0].iov_base + UDP_HEADLEN;
+            memcache_times[2][memcache_transactions[2]] = get_time() - mypayload->message.header.request.opaque;
+            memcache_transactions[2]++;
+        }
+    }
+#endif
+
+    newp->len = short_size + sizeof(struct pkt_udp_headers);
+    newp->next = NULL;
+
+    // Slap UDP/IP/Ethernet headers in front
+    memcpy(buf, &packet_udp_header, sizeof(struct pkt_udp_headers));
+
+/* #ifdef DEBUG_LATENCIES */
+/*     if(memcache_transactions[3] < POSIX_TRANSA) { */
+/*         if(msg->msg_iovlen > 1 && msg->msg_iov[1].iov_len == sizeof(protocol_binary_response_no_extras)) { */
+/*             protocol_binary_response_no_extras *mypayload = msg->msg_iov[1].iov_base; */
+/*             memcache_times[3][memcache_transactions[3]] = get_time() - mypayload->message.header.response.opaque; */
+/*             memcache_transactions[3]++; */
+/*         } else if(msg->msg_iov[0].iov_len >= sizeof(protocol_binary_request_no_extras)) { */
+/*             protocol_binary_request_no_extras *mypayload = msg->msg_iov[0].iov_base + UDP_HEADLEN; */
+/*             memcache_times[3][memcache_transactions[3]] = get_time() - mypayload->message.header.request.opaque; */
+/*             memcache_transactions[3]++; */
+/*         } */
+/*     } */
+/* #endif */
+
+    // Fine-tune headers
+    struct pkt_udp_headers *p = (struct pkt_udp_headers *)buf;
+    assert(msg->msg_name != NULL);
+    struct sockaddr_in *saddr = msg->msg_name;
+    assert(saddr->sin_family == AF_INET);
+    p->ip.dest.addr = saddr->sin_addr.s_addr;
+    p->udp.dest = saddr->sin_port;
+    struct peer *peer = peers_get_from_ip(p->ip.dest.addr);
+    p->eth.dest = peer->mac;
+    assert(sock->bound_addr.sin_port != 0);
+    p->udp.src = sock->bound_addr.sin_port;
+    p->udp.len = htons(short_size + sizeof(struct udp_hdr));
+    p->ip._len = htons(short_size + sizeof(struct udp_hdr) + IP_HLEN);
+#ifdef CONFIG_QEMU_NETWORK
+    p->ip._chksum = inet_chksum(&p->ip, IP_HLEN);
+    newp->flags = 0;
+#else
+    // Hardware IP header checksumming on
+    p->ip._chksum = 0;
+    newp->flags = NETIF_TXFLAG_IPCHECKSUM;
+#endif
+
+/* #ifdef DEBUG_LATENCIES */
+/*     if(memcache_transactions[4] < POSIX_TRANSA) { */
+/*         if(msg->msg_iovlen > 1 && msg->msg_iov[1].iov_len == sizeof(protocol_binary_response_no_extras)) { */
+/*             protocol_binary_response_no_extras *mypayload = msg->msg_iov[1].iov_base; */
+/*             memcache_times[4][memcache_transactions[4]] = get_time() - mypayload->message.header.response.opaque; */
+/*             memcache_transactions[4]++; */
+/*         } else if(msg->msg_iov[0].iov_len >= sizeof(protocol_binary_request_no_extras)) { */
+/*             protocol_binary_request_no_extras *mypayload = msg->msg_iov[0].iov_base + UDP_HEADLEN; */
+/*             memcache_times[4][memcache_transactions[4]] = get_time() - mypayload->message.header.request.opaque; */
+/*             memcache_transactions[4]++; */
+/*         } */
+/*     } */
+/* #endif */
+
+    packet_output(newp);
+
+/* #ifdef DEBUG_LATENCIES */
+/*     if(memcache_transactions[5] < POSIX_TRANSA) { */
+/*         if(msg->msg_iovlen > 1 && msg->msg_iov[1].iov_len == sizeof(protocol_binary_response_no_extras)) { */
+/*             protocol_binary_response_no_extras *mypayload = msg->msg_iov[1].iov_base; */
+/*             memcache_times[5][memcache_transactions[5]] = get_time() - mypayload->message.header.response.opaque; */
+/*             memcache_transactions[5]++; */
+/*         } else if(msg->msg_iov[0].iov_len >= sizeof(protocol_binary_request_no_extras)) { */
+/*             protocol_binary_request_no_extras *mypayload = msg->msg_iov[0].iov_base + UDP_HEADLEN; */
+/*             memcache_times[5][memcache_transactions[5]] = get_time() - mypayload->message.header.request.opaque; */
+/*             memcache_transactions[5]++; */
+/*         } */
+/*     } */
+/* #endif */
+
+    return short_size;
+}
+
+#else
+
+int lwip_sendmsg(int sockfd, const struct msghdr *msg, int flags)
+{
+    struct socket *sock = &sockets[sockfd];
+    ssize_t short_size = 0;
+    struct packet packets[MAX_SENDMSG];
+    struct packet *oldp = NULL;
+
+    assert(msg->msg_iovlen < MAX_SENDMSG);
+
+    for(int i = 0; i < msg->msg_iovlen; i++) {
+        struct packet *newp = &packets[i];
+
+        newp->payload = (uint8_t *)msg->msg_iov[i].iov_base;
+        newp->len = msg->msg_iov[i].iov_len;
+        newp->next = NULL;
+        newp->flags = 0;
+        newp->opaque = msg->msg_iov[i].iov_opaque;
+        if(oldp != NULL) {
+            oldp->next = newp;
+        }
+        short_size += msg->msg_iov[i].iov_len;
+        oldp = newp;
+    }
+
+    // Slap UDP/IP/Ethernet headers in front
+    struct packet *hdrpkt = get_tx_packet();
+    memcpy(hdrpkt->payload, &packet_udp_header, sizeof(struct pkt_udp_headers));
+    struct pkt_udp_headers *p = (struct pkt_udp_headers *)hdrpkt->payload;
+    hdrpkt->len = sizeof(struct pkt_udp_headers);
+    hdrpkt->next = packets;
+    hdrpkt->opaque = hdrpkt;
+
+    // Fine-tune headers
+    assert(msg->msg_name != NULL);
+    struct sockaddr_in *saddr = msg->msg_name;
+    assert(saddr->sin_family == AF_INET);
+    p->ip.dest.addr = saddr->sin_addr.s_addr;
+    p->udp.dest = saddr->sin_port;
+    struct peer *peer = peers_get_from_ip(p->ip.dest.addr);
+    p->eth.dest = peer->mac;
+    assert(sock->bound_addr.sin_port != 0);
+    p->udp.src = sock->bound_addr.sin_port;
+    p->udp.len = htons(short_size + sizeof(struct udp_hdr));
+    p->ip._len = htons(short_size + sizeof(struct udp_hdr) + IP_HLEN);
+#ifdef CONFIG_QEMU_NETWORK
+    p->ip._chksum = inet_chksum(&p->ip, IP_HLEN);
+    hdrpkt->flags = 0;
+#else
+    // Hardware IP header checksumming on
+    p->ip._chksum = 0;
+    hdrpkt->flags = NETIF_TXFLAG_IPCHECKSUM;
+#endif
+
+    packet_output(hdrpkt);
+
+    // If we sent the data directly, we need to wait here until everything is out.
+    // Else, data might be overwritten by application before card can send it.
+    /* while(!e1000n_queue_empty()) thread_yield(); */
+
+    return short_size;
+}
+
+#endif
+
+int lwip_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
+{
+    assert(arranet_tcp_accepted);
+    struct socket *sock = &sockets[s];
+    assert(sock->passive);
+    struct socket *newsock = alloc_socket();
+    newsock->nonblocking = sock->nonblocking;
+    newsock->bound_addr = sock->bound_addr;
+    socklen_t adlen = sizeof(struct sockaddr_in);
+    struct recv_tcp_args args = {
+        .buf = NULL,
+        .len = 0,
+        .src_addr = (struct sockaddr *)&newsock->peer_addr,
+        .addrlen = &adlen,
+        .syn = false,
+        .sock = newsock,
+    };
+    struct waitset ws;
+    waitset_init(&ws);
+
+    errval_t err = waitset_chan_register_polled(&ws, &recv_chanstate,
+                                                MKCLOSURE(sock_recved_tcp_packet, &args));
+    assert(err_is_ok(err));
+
+    /* if socket is ready, trigger event right away */
+    if (lwip_sock_ready_read(s)) {
+        err = waitset_chan_trigger(&recv_chanstate);
+        assert(err_is_ok(err));
+    }
+
+    if(sock->nonblocking) {
+        err = event_dispatch_non_block(&ws);
+        if(err_no(err) == LIB_ERR_NO_EVENT) {   // Deregister if it didn't fire
+            err = waitset_chan_deregister(&recv_chanstate);
+            assert(err_is_ok(err));
+        }
+
+        if(err_no(err) == LIB_ERR_NO_EVENT || !args.syn) {
+            free_socket(newsock);
+            errno = EAGAIN;
+            return -1;
+        } else {
+            assert(err_is_ok(err));
+        }
+
+        if(!args.syn) {
+            free_socket(newsock);
+            errno = EAGAIN;
+            return -1;
+        }
+    } else {
+        err = event_dispatch(&ws);
+        assert(err_is_ok(err));
+
+        if(!args.syn) {
+            assert(!"Will block forever");
+        }
+    }
+
+    assert(adlen == sizeof(struct sockaddr_in));
+    assert(*addrlen >= sizeof(struct sockaddr_in));
+    // Set caller's addr buffers
+    if(addr != NULL) {
+        memcpy(addr, &newsock->peer_addr, sizeof(struct sockaddr_in));
+        *addrlen = adlen;
+    }
+
+    /* newsock->my_seq = 0; */
+    newsock->peer_seq = htonl(args.in_seqno);
+    /* printf("lwip_accept: Assigning %p seq %x\n", newsock, newsock->my_seq); */
+
+#ifdef SENDMSG_WITH_COPY
+    // Get new TX packet and send SYN-ACK
+    struct packet *newp = get_tx_packet();
+    newp->len = sizeof(struct pkt_tcp_headers) + 4;
+    newp->next = NULL;
+
+    // Slap TCP/IP/Ethernet headers in front
+    memcpy(newp->payload, &packet_tcp_header, sizeof(struct pkt_tcp_headers));
+
+    // Fine-tune headers
+    struct pkt_tcp_headers *p = (struct pkt_tcp_headers *)newp->payload;
+    uint32_t *payload = (void *)p + sizeof(struct pkt_tcp_headers);
+    memset(payload, 0, 4);
+    p->ip.dest.addr = newsock->peer_addr.sin_addr.s_addr;
+    p->tcp.dest = newsock->peer_addr.sin_port;
+    struct peer *peer = peers_get_from_ip(p->ip.dest.addr);
+    p->eth.dest = peer->mac;
+    assert(sock->bound_addr.sin_port != 0);
+    p->tcp.src = sock->bound_addr.sin_port;
+    p->ip._len = htons(sizeof(struct tcp_hdr) + IP_HLEN + 4);
+    p->tcp.seqno = htonl(++newsock->my_seq); newsock->my_seq++;
+    /* printf("lwip_accept: Assigning %p seq %x\n", newsock, newsock->my_seq); */
+    newsock->next_ack = newsock->peer_seq + 1;
+    /* printf("lwip_accept: Assigning %p, %x\n", newsock, newsock->next_ack); */
+    p->tcp.ackno = htonl(newsock->next_ack);
+    /* printf("lwip_accept: Sending %p, %x\n", newsock, newsock->next_ack); */
+    TCPH_FLAGS_SET(&p->tcp, TCP_SYN | TCP_ACK); // Set SYN-ACK
+    TCPH_HDRLEN_SET(&p->tcp, 6);   // 24 / 4
+    p->tcp.wnd = htons(11680);
+    *payload = TCP_BUILD_MSS_OPTION(1460);
+#ifdef CONFIG_QEMU_NETWORK
+    p->ip._chksum = inet_chksum(&p->ip, IP_HLEN);
+    p->tcp.chksum = 0;
+    newp->payload = (uint8_t *)&p->tcp;
+    newp->len -= (uint8_t *)&p->tcp - (uint8_t *)p;
+    p->tcp.chksum = inet_chksum_pseudo(newp, (ip_addr_t *)&p->ip.src, (ip_addr_t *)&p->ip.dest,
+                                       IP_PROTO_TCP, TCP_HLEN + 4);
+    newp->payload = (uint8_t *)p;
+    newp->len = sizeof(struct pkt_tcp_headers) + 4;
+    newp->flags = 0;
+#else
+    // Hardware IP/TCP header checksumming on
+    p->ip._chksum = 0;
+    p->tcp.chksum =
+        (~inet_chksum_pseudo_partial(newp, (ip_addr_t *)&p->ip.src, (ip_addr_t *)&p->ip.dest,
+                                     IP_PROTO_TCP, TCP_HLEN + 4, 0)) & 0xffff;
+    newp->flags = (NETIF_TXFLAG_IPCHECKSUM | NETIF_TXFLAG_TCPCHECKSUM) |
+        (6 << NETIF_TXFLAG_TCPHDRLEN_SHIFT);
+#endif
+
+    packet_output(newp);
+#else
+    assert(!"NYI");
+#endif
+
+    /* printf("Returned %d\n", newsock->fd); */
+    newsock->connected = true;
+    assert(newsock->prev == NULL && newsock->next == NULL);
+    newsock->next = connections;
+    if(connections != NULL) {
+        assert(connections->prev == NULL);
+        connections->prev = newsock;
+    }
+    newsock->prev = NULL;
+    connections = newsock;
+
+    /* printf("lwip_accept(%d) = %d\n", s, newsock->fd); */
+    return newsock->fd;
+}
+
+void process_received_packet(struct driver_rx_buffer *buffer, size_t count,
+                             uint64_t flags)
+{
+    struct packet *p = buffer->opaque;
+    assert(p != NULL);
+    assert(count == 1);
+    p->len = buffer->len;
+
+    /* printf("Got %p from driver\n", p); */
+
+    assert(p >= rx_packets && p < &rx_packets[MAX_PACKETS]);
+
+#ifdef DEBUG_LATENCIES
+    rx_packets_available--;
+    if(rx_packets_available < 10) {
+        printf("Too many RX packets in flight!\n");
+    }
+#endif
+
+    // Drop packets with invalid checksums
+    if(flags & NETIF_RXFLAG_IPCHECKSUM) {
+        if(!(flags & NETIF_RXFLAG_IPCHECKSUM_GOOD)) {
+            goto out;
+        }
+    }
+
+    if(flags & NETIF_RXFLAG_L4CHECKSUM) {
+        if(!(flags & NETIF_RXFLAG_L4CHECKSUM_GOOD)) {
+            goto out;
+        }
+    }
+
+    struct eth_hdr *ethhdr = (struct eth_hdr *)p->payload;
+    switch (htons(ethhdr->type)) {
+    case ETHTYPE_ARP:
+        {
+            struct etharp_hdr *arphdr = (struct etharp_hdr *)(p->payload + SIZEOF_ETH_HDR);
+            uint32_t dipaddr = (arphdr->dipaddr.addrw[1] << 16) | arphdr->dipaddr.addrw[0];
+
+            /* printf("%d: ARP request, dip = %x\n", disp_get_core_id(), dipaddr); */
+
+            if(htons(arphdr->opcode) == ARP_REQUEST &&
+               dipaddr == arranet_myip) {
+                // Send reply
+                struct packet outp;
+                uint8_t payload[PACKET_SIZE];
+                struct eth_hdr *myeth = (struct eth_hdr *)payload;
+                struct etharp_hdr *myarp = (struct etharp_hdr *)(payload + SIZEOF_ETH_HDR);
+
+                /* printf("%d: ARP request for us!\n", disp_get_core_id()); */
+
+                // ETH header
+                memcpy(&myeth->dest, &arphdr->shwaddr, ETHARP_HWADDR_LEN);
+                memcpy(&myeth->src, arranet_mymac, ETHARP_HWADDR_LEN);
+                myeth->type = htons(ETHTYPE_ARP);
+
+                // ARP header
+                myarp->hwtype = htons(1);
+                myarp->proto = htons(ETHTYPE_IP);
+                myarp->hwlen = 6;
+                myarp->protolen = 4;
+                myarp->opcode = htons(ARP_REPLY);
+                memcpy(&myarp->shwaddr, arranet_mymac, ETHARP_HWADDR_LEN);
+                memcpy(&myarp->sipaddr, &arphdr->dipaddr, sizeof(myarp->sipaddr));
+                memcpy(&myarp->dhwaddr, &arphdr->shwaddr, ETHARP_HWADDR_LEN);
+                memcpy(&myarp->dipaddr, &arphdr->sipaddr, sizeof(myarp->dipaddr));
+
+                outp.payload = payload;
+                outp.len = p->len;
+                outp.next = NULL;
+                outp.flags = 0;
+                outp.opaque = NULL;
+                packet_output(&outp);
+                while(!e1000n_queue_empty()) thread_yield();
+            }
+        }
+        break;
+
+    case ETHTYPE_IP:
+        {
+            struct ip_hdr *iphdr = (struct ip_hdr *)(p->payload + SIZEOF_ETH_HDR);
+
+            /* printf("%d: Is an IP packet, type %x\n", disp_get_core_id(), IPH_PROTO(iphdr)); */
+
+#ifdef DEBUG_LATENCIES
+            if(IPH_PROTO(iphdr) == IP_PROTO_ICMP) {
+                static uint64_t cache_misses = 0;
+                uint64_t new_cache_misses = rdpmc(0);
+                printf("Cache misses = %" PRIu64 "\n", new_cache_misses - cache_misses);
+                cache_misses = new_cache_misses;
+
+                printf("hash_option1 = %zd, hash_option2 = %zd, hash_option3 = %zd\n",
+                       hash_option1, hash_option2, hash_option3);
+                printf("hash_calls = %zd, hash_length = %zd\n",
+                       hash_calls, hash_length);
+
+                printf("output pipeline stalled = %zd\n", output_pipeline_stalled);
+                output_pipeline_stalled = 0;
+
+                printf("memcache packets received = %zd\n", memcache_packets_received);
+                memcache_packets_received = 0;
+                for(int i = 0; i < 65536; i++) {
+                    if(port_cnt[i] != 0) {
+                        printf("port %d = %zu\n", i, port_cnt[i]);
+                        port_cnt[i] = 0;
+                    }
+                }
+
+                printf("recv_transa = %zu, send_transa = %zu\n",
+                       posix_recv_transactions, posix_send_transactions);
+                printf("posix_recv_transactions:\n");
+                for(int i = 0; i < posix_recv_transactions; i++) {
+                    printf("%u us\n", posix_recv_time[i]);
+                }
+                printf("posix_send_transactions:\n");
+                for(int i = 0; i < posix_send_transactions; i++) {
+                    printf("%u us\n", posix_send_time[i]);
+                }
+                posix_recv_transactions = posix_send_transactions = 0;
+
+                printf("lwip_send_transa = %zu\n", lwip_send_transactions);
+                printf("lwip_send_transactions:\n");
+                for(int i = 0; i < lwip_send_transactions; i++) {
+                    printf("%u us\n", lwip_send_time[i]);
+                }
+                lwip_send_transactions = 0;
+
+                for(int j = 0; j < 20; j++) {
+                    printf("memcache_transa[%d] = %zu:\n", j, memcache_transactions[j]);
+                    for(int i = 0; i < memcache_transactions[j]; i++) {
+                        printf("%u us\n", memcache_times[j][i]);
+                    }
+                    memcache_transactions[j] = 0;
+                }
+            }
+#endif
+
+            // Has to be UDP or TCP
+            if(IPH_PROTO(iphdr) != IP_PROTO_UDP && IPH_PROTO(iphdr) != IP_PROTO_TCP) {
+                goto out;
+            }
+
+            // XXX: Filter for our IP
+            if(iphdr->dest.addr != arranet_myip) {
+                goto out;
+            }
+
+            if(IPH_PROTO(iphdr) == IP_PROTO_UDP) {
+                struct udp_hdr *udphdr = (struct udp_hdr *)(p->payload + SIZEOF_ETH_HDR + (IPH_HL(iphdr) * 4));
+                /* uint8_t *payload = p->payload + SIZEOF_ETH_HDR + (IPH_HL(iphdr) * 4) + sizeof(struct udp_hdr); */
+
+                // Are we accepting UDP packets?
+                if(!arranet_udp_accepted) {
+                    goto out;
+                }
+
+                /* printf("Got UDP packet, dest IP %x, dest port %u\n", */
+                /*        htonl(iphdr->dest.addr), htons(udphdr->dest)); */
+
+                // XXX: Filter for UDP ports 1234, 11211, 11212
+                // TODO: Done in hardware soon
+                if(htons(udphdr->dest) != 1234 &&
+                   htons(udphdr->dest) != 11211 &&
+                   htons(udphdr->dest) != 11212) {
+                    goto out;
+                }
+
+#ifdef DEBUG_LATENCIES
+                {
+                    memcache_packets_received++;
+                    port_cnt[htons(udphdr->src)]++;
+                    protocol_binary_request_no_extras *mypayload = (void *)p->payload + SIZEOF_ETH_HDR + (IPH_HL(iphdr) * 4) + sizeof(struct udp_hdr) + UDP_HEADLEN;
+                    mypayload->message.header.request.opaque = get_time();
+                }
+#endif
+            }
+
+            if(IPH_PROTO(iphdr) == IP_PROTO_TCP) {
+                struct tcp_hdr *tcphdr = (struct tcp_hdr *)(p->payload + SIZEOF_ETH_HDR + (IPH_HL(iphdr) * 4));
+
+                // Are we accepting TCP packets?
+                if(!arranet_tcp_accepted) {
+                    goto out;
+                }
+
+                /* printf("Got TCP packet, dest IP %x, src IP %x, dest port %u, src %u\n", */
+                /*        htonl(iphdr->dest.addr), htonl(iphdr->src.addr), */
+                /*        htons(tcphdr->dest), htons(tcphdr->src)); */
+
+                // XXX: Filter for TCP port 8080 and everything that we know
+                // TODO: Done in hardware soon
+                struct socket *sock = NULL;
+                for(sock = connections; sock != NULL; sock = sock->next) {
+                    if(sock->bound_addr.sin_port == tcphdr->dest &&
+                       sock->peer_addr.sin_port == tcphdr->src &&
+                       sock->peer_addr.sin_addr.s_addr == iphdr->src.addr) {
+                        break;
+                    }
+                }
+
+                p->sock = sock;
+
+                // Handle SYN-ACKs for connections we created and FIN-ACKs
+                // Also ACK any data packet that came in
+                uint16_t pkt_len = htons(IPH_LEN(iphdr)) - (TCPH_HDRLEN(tcphdr) * 4) - (IPH_HL(iphdr) * 4);
+                if((TCPH_FLAGS(tcphdr) & TCP_ACK) &&
+                   ((TCPH_FLAGS(tcphdr) & TCP_SYN) || (TCPH_FLAGS(tcphdr) & TCP_FIN) || pkt_len > 0)) {
+                    bool is_retransmit = false;
+
+                    if(TCPH_FLAGS(tcphdr) & TCP_SYN) {
+                        assert(sock != NULL);
+                        sock->connected = true;
+                    }
+                    if((TCPH_FLAGS(tcphdr) & TCP_FIN) && sock != NULL) {
+                        // It said FIN, so we're not expecting any more from that side
+                        sock->connected = false;
+                        sock->hangup = true;
+                        // Signal application
+                        if (waitset_chan_is_registered(&recv_chanstate)) {
+                            errval_t err = waitset_chan_trigger(&recv_chanstate);
+                            assert(err_is_ok(err));
+                        }
+
+                        if(sock->prev != NULL) {
+                            sock->prev->next = sock->next;
+                        }
+                        if(sock->next != NULL) {
+                            sock->next->prev = sock->prev;
+                        }
+                        if(connections == sock) {
+                            connections = sock->next;
+                        }
+                        sock->next = sock->prev = NULL;
+                    }
+
+                    if(sock != NULL) {
+                        uint32_t new_peer_seq = htonl(tcphdr->seqno);
+                        if(new_peer_seq == sock->peer_seq &&
+                           new_peer_seq + pkt_len == sock->next_ack) {
+                            is_retransmit = true;
+                            /* printf("Is a retransmit! dst = %u, src = %u, seq = %u, ack = %u\n", */
+                            /*        htons(tcphdr->dest), htons(tcphdr->src), */
+                            /*        htonl(tcphdr->seqno), htonl(tcphdr->ackno)); */
+                        }
+                        sock->peer_seq = new_peer_seq;
+                        sock->next_ack = sock->peer_seq + pkt_len;
+                        if((TCPH_FLAGS(tcphdr) & TCP_SYN) || (TCPH_FLAGS(tcphdr) & TCP_FIN)) {
+                            sock->next_ack++;
+                        }
+                        /* printf("process_received_packet: Assigning %p, %x\n", sock, sock->next_ack); */
+                    }
+
+                    // Get new TX packet and send ACK
+                    struct packet *newp = get_tx_packet();
+                    newp->len = sizeof(struct pkt_tcp_headers);
+                    newp->next = NULL;
+
+                    // Slap TCP/IP/Ethernet headers in front
+                    memcpy(newp->payload, &packet_tcp_header, sizeof(struct pkt_tcp_headers));
+
+                    // Fine-tune headers
+                    struct pkt_tcp_headers *ph = (struct pkt_tcp_headers *)newp->payload;
+                    ph->ip.dest.addr = iphdr->src.addr;
+                    ph->tcp.dest = tcphdr->src;
+                    ph->eth.dest = ethhdr->src;
+                    ph->tcp.src = tcphdr->dest;
+                    ph->ip._len = htons(sizeof(struct tcp_hdr) + IP_HLEN);
+                    if(sock != NULL) {
+                        ph->tcp.seqno = htonl(sock->my_seq);
+                        ph->tcp.ackno = htonl(sock->next_ack);
+                        /* printf("process_received_packet: Sending %p, seq %x, ack %x\n", sock, sock->my_seq, sock->next_ack); */
+                    } else {
+                        ph->tcp.seqno = tcphdr->ackno;
+                        ph->tcp.ackno = htonl(htonl(tcphdr->seqno) + pkt_len + 1);
+                    }
+                    TCPH_FLAGS_SET(&ph->tcp, TCP_ACK);
+                    TCPH_HDRLEN_SET(&ph->tcp, 5);   // 20 / 4
+                    ph->tcp.wnd = htons(11680);
+#ifdef CONFIG_QEMU_NETWORK
+                    ph->ip._chksum = inet_chksum(&ph->ip, IP_HLEN);
+                    ph->tcp.chksum = 0;
+                    void *oldpayload = newp->payload;
+                    size_t oldlen = newp->len;
+                    newp->payload = (uint8_t *)&ph->tcp;
+                    newp->len -= (uint8_t *)&ph->tcp - (uint8_t *)oldpayload;
+                    ph->tcp.chksum = inet_chksum_pseudo(newp, (ip_addr_t *)&ph->ip.src, (ip_addr_t *)&ph->ip.dest,
+                                                       IP_PROTO_TCP, TCP_HLEN);
+                    newp->payload = oldpayload;
+                    newp->len = oldlen;
+                    newp->flags = 0;
+#else
+                    // Hardware IP/TCP header checksumming on
+                    ph->ip._chksum = 0;
+                    ph->tcp.chksum =
+                        (~inet_chksum_pseudo_partial(newp, (ip_addr_t *)&ph->ip.src, (ip_addr_t *)&ph->ip.dest,
+                                                     IP_PROTO_TCP, TCP_HLEN, 0)) & 0xffff;
+                    newp->flags = (NETIF_TXFLAG_IPCHECKSUM | NETIF_TXFLAG_TCPCHECKSUM) |
+                        (TCPH_HDRLEN(&ph->tcp) << NETIF_TXFLAG_TCPHDRLEN_SHIFT);
+#endif
+
+                    packet_output(newp);
+
+                    // Ignore retransmits -- we've already ACKed them again
+                    if(is_retransmit) {
+                        goto out;
+                    }
+                }
+
+                if(sock == NULL) {
+                    if(htons(tcphdr->dest) != 8080) {
+                        goto out;
+                    } else if(!(TCPH_FLAGS(tcphdr) & TCP_SYN)) {
+                        /* size_t psize = htons(iphdr->_len) - (TCPH_HDRLEN(tcphdr) * 4); */
+                        /* if(psize > IPH_HL(iphdr) * 4) { */
+                        /*     printf("Dropping 8080 data packet! src port = %u, payload size = %zu\n", htons(tcphdr->src), psize); */
+                        /* } */
+                        goto out;
+                    }
+                }
+
+                // Ignore stray ACKs, signaling connection establishments
+                // This will also throw away empty FIN-ACKs
+                if((TCPH_FLAGS(tcphdr) & TCP_ACK) &&
+                   htons(iphdr->_len) - (TCPH_HDRLEN(tcphdr) * 4) == IPH_HL(iphdr) * 4) {
+                    goto out;
+                }
+
+#ifdef DEBUG_LATENCIES
+                {
+                    memcache_packets_received++;
+                    port_cnt[htons(tcphdr->src)]++;
+                    /* protocol_binary_request_no_extras *mypayload = (void *)p->payload + SIZEOF_ETH_HDR + (IPH_HL(iphdr) * 4) + sizeof(struct udp_hdr) + UDP_HEADLEN; */
+                    /* mypayload->message.header.request.opaque = get_time(); */
+                }
+#endif
+            }
+
+            // ARP management
+            if(peers_get_from_ip(iphdr->src.addr) == NULL) {
+                struct peer *newpeer = peers_get_next_free();
+                assert(p != NULL);
+
+                newpeer->ip = iphdr->src.addr;
+                memcpy(&newpeer->mac.addr, &ethhdr->src.addr, ETHARP_HWADDR_LEN);
+            }
+
+            // Push packets up - signal channel
+            assert(inpkt == NULL);
+            inpkt = p;
+            if (waitset_chan_is_registered(&recv_chanstate)) {
+                errval_t err = waitset_chan_trigger(&recv_chanstate);
+                assert(err_is_ok(err));
+            }
+
+            // Return here, packet is in flight to user-space
+            return;
+        }
+        break;
+
+    default:
+        break;
+    }
+
+ out:
+    {
+        //now we have consumed the preregistered pbuf containing a received packet
+        //which was processed in this function. Therefore we have to register a new
+        //free buffer for receiving packets.
+#ifdef DEBUG_LATENCIES
+        rx_packets_available++;
+#endif
+        errval_t err = rx_register_buffer_fn_ptr(p->pa, p->payload, p);
+        assert(err_is_ok(err));
+    }
+}
+
+static arranet_tx_done_fn arranet_tx_done_callback = NULL;
+
+void arranet_register_tx_done_callback(arranet_tx_done_fn callback)
+{
+    arranet_tx_done_callback = callback;
+}
+
+bool handle_tx_done(void *opaque)
+{
+    struct packet *p = opaque;
+    if(p >= tx_packets && p < &tx_packets[MAX_PACKETS]) {
+        /* printf("Packet from TX ring, marking available\n"); */
+        // Mark packet as available, if coming from TX packet array
+        p->len = 0;
+        /* tx_packets_available++; */
+#ifndef SENDMSG_WITH_COPY
+    } else {
+        if(opaque != NULL && arranet_tx_done_callback != NULL) {
+            /* printf("Packet from app, handing up\n"); */
+            arranet_tx_done_callback(opaque);
+        /* } else { */
+        /*     if(opaque == NULL) { */
+        /*         printf("NULL packet\n"); */
+        /*     } */
+        }
+#endif
+    }
+
+    return true;
+}
+
+/* allocate a single frame, mapping it into our vspace with given attributes */
+static void *alloc_map_frame(vregion_flags_t attr, size_t size, struct capref *retcap)
+{
+    struct capref frame;
+    errval_t r;
+
+    r = frame_alloc(&frame, size, NULL);
+    assert(err_is_ok(r));
+    void *va;
+    r = vspace_map_one_frame_attr(&va, size, frame, attr,
+                                  NULL, NULL);
+    if (err_is_fail(r)) {
+        DEBUG_ERR(r, "vspace_map_one_frame failed");
+        return NULL;
+    }
+
+    if (retcap != NULL) {
+        *retcap = frame;
+    }
+
+    return va;
+}
+
+bool lwip_sock_is_open(int s)
+{
+    if(arranet_tcp_accepted) {
+        struct socket *sock = &sockets[s];
+        assert(sock != NULL);
+        return !sock->hangup;
+    } else {
+        // XXX: Not supported on UDP yet...
+        return true;
+    }
+}
+
+/**
+ * \brief Check if a read on the socket would not block.
+ *
+ * \param socket    Socket to check.
+ * \return          Whether or not the socket is ready.
+ */
+bool lwip_sock_ready_read(int s)
+{
+    if(arranet_tcp_accepted) {
+        /* printf("lwip_sock_ready_read(%d)\n", s); */
+        if(inpkt != NULL) {
+            struct socket *sock = &sockets[s];
+            assert(sock != NULL);
+            struct ip_hdr *iphdr = (struct ip_hdr *)(inpkt->payload + SIZEOF_ETH_HDR);
+            assert(IPH_PROTO(iphdr) == IP_PROTO_TCP);
+            struct tcp_hdr *tcphdr = (struct tcp_hdr *)(inpkt->payload + SIZEOF_ETH_HDR + (IPH_HL(iphdr) * 4));
+            if(sock->passive) {
+                return (TCPH_FLAGS(tcphdr) & TCP_SYN) ? true : false;
+            } else {
+                if(TCPH_FLAGS(tcphdr) & TCP_SYN) {
+                    return false;
+                }
+
+                if(tcphdr->dest == sock->bound_addr.sin_port &&
+                   tcphdr->src == sock->peer_addr.sin_port) {
+                    return true;
+                } else {
+#if 0
+                    // XXX: Remove when code works...
+                    struct fdtab_entry e;
+                    e.type = FDTAB_TYPE_LWIP_SOCKET;
+                    e.fd = inpkt->sock->fd;
+                    int rfd = fdtab_search(&e);
+                    struct fdtab_entry *ne = fdtab_get_sane(rfd);
+                    if(ne->epoll_fd == -1) {
+                        printf("Sock: %d, Last: %p %p %p\n", inpkt->sock->fd,
+                               ne->last[0], ne->last[1], ne->last[2]);
+
+                        // Drop the packet
+#ifdef DEBUG_LATENCIES
+                        rx_packets_available++;
+#endif
+                        errval_t err = rx_register_buffer_fn_ptr(inpkt->pa, inpkt->payload, inpkt);
+                        assert(err_is_ok(err));
+                        inpkt = NULL;
+                    }
+                    /* assert(ne->epoll_fd != -1); */
+#endif
+
+                    return false;
+                }
+            }
+        } else {
+            return false;
+        }
+    } else {
+        assert(arranet_udp_accepted);
+        return inpkt != NULL;
+    }
+}
+
+/**
+ * \brief Check if a write on the socket would not block.
+ *
+ * \param socket    Socket to check.
+ * \return          Whether or not the socket is ready.
+ */
+bool lwip_sock_ready_write(int s)
+{
+    if(arranet_tcp_accepted) {
+        struct socket *sock = &sockets[s];
+        assert(sock != NULL);
+        if(sock->connected) {
+            // See if there's space in the queue
+#ifdef SENDMSG_WITH_COPY
+            /* if(tx_packets[tx_idx].len != 0) { */
+            /*     return false; */
+            /* } else { */
+            // XXX: Just always return true, we will stall a little when calling get_tx_packet() if no output packet is available then.
+                return true;
+            /* } */
+#else
+            assert(!"NYI");
+#endif
+        } else {
+            return false;
+        }
+        /* printf("lwip_sock_ready_write(%d)\n", s); */
+    } else {
+        assert(arranet_udp_accepted);
+        // XXX: Can also return true when one buffer is available in queue
+        return e1000n_queue_empty();
+    }
+}
+
+static void do_nothing(void *arg)
+{
+}
+
+/**
+ * \brief Deregister previously registered waitset on which an event is delivered
+ *        when the socket is ready for reading.
+ */
+errval_t lwip_sock_waitset_deregister_read(int sock)
+{
+    return waitset_chan_deregister(&recv_chanstate);
+}
+
+/**
+ * \brief Register a waitset on which an event is delivered when the socket is
+ *        ready for reading.
+ *
+ * The event is triggered ONCE, when the socket becomes ready for reading. If
+ * the socket is already ready, the event is triggered right away.
+ *
+ * \param socket    Socket
+ * \param ws        Waitset
+ */
+errval_t lwip_sock_waitset_register_read(int sock, struct waitset *ws)
+{
+    errval_t err;
+
+    assert(ws != NULL);
+
+    if(waitset_chan_is_registered(&recv_chanstate) || recv_chanstate.state == CHAN_PENDING) {
+        assert(recv_chanstate.waitset == ws);
+        return SYS_ERR_OK;
+    }
+
+    waitset_chanstate_init(&recv_chanstate, CHANTYPE_LWIP_SOCKET);
+
+    err = waitset_chan_register_polled(ws, &recv_chanstate,
+                                       MKCLOSURE(do_nothing, NULL));
+    if (err_is_fail(err)) {
+        DEBUG_ERR(err, "Error register recv channel on waitset.");
+        return err;
+    }
+
+    /* if socket is ready, trigger event right away */
+    if (lwip_sock_ready_read(sock)) {
+        err = waitset_chan_trigger(&recv_chanstate);
+        if (err_is_fail(err)) {
+            DEBUG_ERR(err, "Error trigger event on recv channel.");
+            return err;
+        }
+    }
+
+    return SYS_ERR_OK;
+}
+
+/**
+ * \brief Deregister previously registered waitset on which an event is delivered
+ *        when the socket is ready for writing.
+ */
+errval_t lwip_sock_waitset_deregister_write(int sock)
+{
+    return waitset_chan_deregister(&send_chanstate);
+}
+
+/**
+ * \brief Register a waitset on which an event is delivered when the socket is
+ *        ready for writing.
+ *
+ * The event is triggered ONCE, when the socket becomes ready for writing. If
+ * the socket is already ready, the event is triggered right away.
+ *
+ * \param socket    Socket
+ * \param ws        Waitset
+ */
+errval_t lwip_sock_waitset_register_write(int sock, struct waitset *ws)
+{
+    errval_t err;
+
+    assert(ws != NULL);
+
+    if(waitset_chan_is_registered(&send_chanstate) || send_chanstate.state == CHAN_PENDING) {
+        assert(send_chanstate.waitset == ws);
+        return SYS_ERR_OK;
+    }
+
+    waitset_chanstate_init(&send_chanstate, CHANTYPE_LWIP_SOCKET);
+
+    err = waitset_chan_register_polled(ws, &send_chanstate,
+                                       MKCLOSURE(do_nothing, NULL));
+    if (err_is_fail(err)) {
+        DEBUG_ERR(err, "Error register send channel on waitset.");
+        return err;
+    }
+
+    /* if socket is ready, trigger event right away */
+    if (lwip_sock_ready_write(sock)) {
+        err = waitset_chan_trigger(&send_chanstate);
+        if (err_is_fail(err)) {
+            DEBUG_ERR(err, "Error trigger event on send channel.");
+            return err;
+        }
+    }
+
+    return SYS_ERR_OK;
+}
+
+void arranet_polling_loop_proxy(void);
+void arranet_polling_loop_proxy(void)
+{
+    // Push packets up - signal channel
+    if(inpkt != NULL) {
+#if 0
+        static struct packet *lastinpkt = NULL;
+        static int count = 0;
+
+        if(inpkt == lastinpkt) {
+            count++;
+            if(count > 1000) {
+                struct ip_hdr *iphdr = (struct ip_hdr *)(inpkt->payload + SIZEOF_ETH_HDR);
+                assert(IPH_PROTO(iphdr) == IP_PROTO_TCP);
+                struct tcp_hdr *tcphdr = (struct tcp_hdr *)(inpkt->payload + SIZEOF_ETH_HDR + (IPH_HL(iphdr) * 4));
+                size_t hdr_len = SIZEOF_ETH_HDR + (IPH_HL(iphdr) * 4) + (TCPH_HDRLEN(tcphdr) * 4);
+                char *payload = (char *)inpkt->payload + hdr_len;
+                uint16_t pkt_len = htons(IPH_LEN(iphdr)) - (TCPH_HDRLEN(tcphdr) * 4) - (IPH_HL(iphdr) * 4);
+
+                printf("Packet in queue too long, dst = %u, src = %u\n",
+                       htons(tcphdr->dest), htons(tcphdr->src));
+
+                if(TCPH_FLAGS(tcphdr) & TCP_SYN) {
+                    printf("SYN set\n");
+                }
+
+                if(TCPH_FLAGS(tcphdr) & TCP_ACK) {
+                    printf("ACK set\n");
+                }
+
+                if(TCPH_FLAGS(tcphdr) & TCP_FIN) {
+                    printf("FIN set\n");
+                }
+
+                if(TCPH_FLAGS(tcphdr) & TCP_RST) {
+                    printf("RST set\n");
+                }
+
+                printf("Seq = %u, Ack = %u\n", tcphdr->seqno, tcphdr->ackno);
+
+                if(pkt_len > 0) {
+                    printf("payload = '%s'\n", payload);
+                }
+
+#ifdef DEBUG_LATENCIES
+                rx_packets_available++;
+#endif
+                errval_t err = rx_register_buffer_fn_ptr(inpkt->pa, inpkt->payload, inpkt);
+                assert(err_is_ok(err));
+                inpkt = NULL;
+            }
+        } else {
+            lastinpkt = inpkt;
+            count = 0;
+        }
+#endif
+
+        if (waitset_chan_is_registered(&recv_chanstate)) {
+            errval_t err = waitset_chan_trigger(&recv_chanstate);
+            assert(err_is_ok(err));
+        }
+    } else {
+        arranet_polling_loop();
+    }
+}
+
+static const char *eat_opts[] = {
+    "function=", "interrupts=", "queue=", "msix=", "vf=", "device=", "bus=",
+    NULL
+};
+
+void lwip_arrakis_start(int *argc, char ***argv)
+{
+    uint8_t mac[6];
+
+    waitset_chanstate_init(&recv_chanstate, CHANTYPE_LWIP_SOCKET);
+    waitset_chanstate_init(&send_chanstate, CHANTYPE_LWIP_SOCKET);
+
+    e1000n_driver_init(*argc, *argv);
+
+    ether_get_mac_address_ptr(mac);
+    printf("Arranet MAC address %02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx\n",
+           mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
+
+    struct capref frame;
+    uint8_t *ram_base = alloc_map_frame(VREGION_FLAGS_READ_WRITE,
+                                        MAX_PACKETS * PACKET_SIZE + 4096, &frame);
+    assert(ram_base != NULL);
+
+    struct frame_identity id;
+    errval_t err = invoke_frame_identify(frame, &id);
+    assert(err_is_ok(err));
+
+    rx_pbase = id.base;
+    rx_vbase = (genvaddr_t)ram_base;
+
+    // Add buffers to RX ring for packet reception
+    for(int i = 0; i < MAX_PACKETS; i++) {
+        struct packet *p = &rx_packets[i];
+
+        // XXX: Use this for recvfrom_arranet to get alignment
+        p->payload = ram_base + (i * PACKET_SIZE) + 6;
+        p->pa = id.base + (i * PACKET_SIZE) + 6;
+        /* p->payload = ram_base + (i * PACKET_SIZE); */
+        /* p->pa = id.base + (i * PACKET_SIZE); */
+        p->len = PACKET_SIZE;
+        p->flags = 0;
+
+        err = rx_register_buffer_fn_ptr(p->pa, p->payload, p);
+        assert(err_is_ok(err));
+    }
+
+    // Initialize TX packet descriptors
+    for(int i = 0; i < MAX_PACKETS; i++) {
+        tx_packets[i].payload = tx_bufs[i];
+    }
+
+    // Determine my static IP address
+    for(int i = 0; i < sizeof(ip_config) / sizeof(struct mac2ip); i++) {
+        struct mac2ip *e = &ip_config[i];
+        if(!memcmp(mac, e->mac, ETHARP_HWADDR_LEN)) {
+            arranet_myip = htonl(e->ip);
+            memcpy(arranet_mymac, e->mac, ETHARP_HWADDR_LEN);
+            break;
+        }
+    }
+
+    if(arranet_myip == 0) {
+        USER_PANIC("Arranet: No static IP config for this MAC address!\n");
+    }
+
+    /***** Initialize UDP/IP/Ethernet packet header template *****/
+    {
+        struct pkt_udp_headers *p = &packet_udp_header;
+
+        // Initialize Ethernet header
+        memcpy(&p->eth.src, mac, ETHARP_HWADDR_LEN);
+        p->eth.type = htons(ETHTYPE_IP);
+
+        // Initialize IP header
+        p->ip._v_hl = 69;
+        p->ip._tos = 0;
+        p->ip._id = htons(3);
+        p->ip._offset = 0;
+        p->ip._ttl = 0xff;
+        p->ip._proto = IP_PROTO_UDP;
+        p->ip._chksum = 0;
+        p->ip.src.addr = arranet_myip;
+
+        // Initialize UDP header
+        p->udp.chksum = 0;
+    }
+
+    /***** Initialize TCP/IP/Ethernet packet header template *****/
+    {
+        struct pkt_tcp_headers *p = &packet_tcp_header;
+
+        // Initialize Ethernet header
+        memcpy(&p->eth.src, mac, ETHARP_HWADDR_LEN);
+        p->eth.type = htons(ETHTYPE_IP);
+
+        // Initialize IP header
+        p->ip._v_hl = 69;
+        p->ip._tos = 0;
+        p->ip._id = htons(3);
+        p->ip._offset = 0;
+        p->ip._ttl = 0xff;
+        p->ip._proto = IP_PROTO_TCP;
+        p->ip._chksum = 0;
+        p->ip.src.addr = arranet_myip;
+
+        // Initialize TCP header
+        p->tcp.chksum = 0;
+        p->tcp.wnd = 65535;
+    }
+
+    // Initialize queue of free TCP ports
+    for(u16_t i = 0; i <= TCP_LOCAL_PORT_RANGE_END - TCP_LOCAL_PORT_RANGE_START; i++) {
+        free_tcp_ports[i] = htons(TCP_LOCAL_PORT_RANGE_START + i);
+    }
+
+    // Initialize queue of free sockets
+    for(int i = 0; i < MAX_FD; i++) {
+        free_sockets_queue[i] = &sockets[i];
+        sockets[i].fd = i;
+    }
+
+    /***** Eat driver-specific options *****/
+    static char *new_argv[ARG_MAX];
+    int new_argc = 0;
+    for(int i = 0; i < *argc; i++) {
+        int j;
+
+        for(j = 0; eat_opts[j] != NULL; j++) {
+            if(!strncmp((*argv)[i], eat_opts[j], strlen(eat_opts[j]) - 1)) {
+                // Option matches -- delete!
+                break;
+            }
+        }
+
+        if(eat_opts[j] == NULL) {
+            // Option doesn't match -- keep!
+            new_argv[new_argc++] = (*argv)[i];
+        }
+    }
+
+    *argc = new_argc;
+    *argv = new_argv;
+}
diff --git a/lib/arranet/inet_chksum.c b/lib/arranet/inet_chksum.c
new file mode 100644
index 0000000..33bda68
--- /dev/null
+++ b/lib/arranet/inet_chksum.c
@@ -0,0 +1,452 @@
+/**
+ * @file
+ * Incluse internet checksum functions.
+ *
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+
+#include "lwip/opt.h"
+
+#include "inet_chksum.h"
+#include "lwip/def.h"
+
+#include <stddef.h>
+#include <string.h>
+
+/* These are some reference implementations of the checksum algorithm, with the
+ * aim of being simple, correct and fully portable. Checksumming is the
+ * first thing you would want to optimize for your platform. If you create
+ * your own version, link it in and in your cc.h put:
+ * 
+ * #define LWIP_CHKSUM <your_checksum_routine> 
+ *
+ * Or you can select from the implementations below by defining
+ * LWIP_CHKSUM_ALGORITHM to 1, 2 or 3.
+ */
+
+#ifndef LWIP_CHKSUM
+# define LWIP_CHKSUM lwip_standard_chksum
+# ifndef LWIP_CHKSUM_ALGORITHM
+#  define LWIP_CHKSUM_ALGORITHM 2
+# endif
+#endif
+/* If none set: */
+#ifndef LWIP_CHKSUM_ALGORITHM
+# define LWIP_CHKSUM_ALGORITHM 0
+#endif
+
+#if (LWIP_CHKSUM_ALGORITHM == 1) /* Version #1 */
+/**
+ * lwip checksum
+ *
+ * @param dataptr points to start of data to be summed at any boundary
+ * @param len length of data to be summed
+ * @return host order (!) lwip checksum (non-inverted Internet sum) 
+ *
+ * @note accumulator size limits summable length to 64k
+ * @note host endianess is irrelevant (p3 RFC1071)
+ */
+static u16_t
+lwip_standard_chksum(void *dataptr, u16_t len)
+{
+  u32_t acc;
+  u16_t src;
+  u8_t *octetptr;
+
+  acc = 0;
+  /* dataptr may be at odd or even addresses */
+  octetptr = (u8_t*)dataptr;
+  while (len > 1) {
+    /* declare first octet as most significant
+       thus assume network order, ignoring host order */
+    src = (*octetptr) << 8;
+    octetptr++;
+    /* declare second octet as least significant */
+    src |= (*octetptr);
+    octetptr++;
+    acc += src;
+    len -= 2;
+  }
+  if (len > 0) {
+    /* accumulate remaining octet */
+    src = (*octetptr) << 8;
+    acc += src;
+  }
+  /* add deferred carry bits */
+  acc = (acc >> 16) + (acc & 0x0000ffffUL);
+  if ((acc & 0xffff0000UL) != 0) {
+    acc = (acc >> 16) + (acc & 0x0000ffffUL);
+  }
+  /* This maybe a little confusing: reorder sum using htons()
+     instead of ntohs() since it has a little less call overhead.
+     The caller must invert bits for Internet sum ! */
+  return htons((u16_t)acc);
+}
+#endif
+
+#if (LWIP_CHKSUM_ALGORITHM == 2) /* Alternative version #2 */
+/*
+ * Curt McDowell
+ * Broadcom Corp.
+ * csm@broadcom.com
+ *
+ * IP checksum two bytes at a time with support for
+ * unaligned buffer.
+ * Works for len up to and including 0x20000.
+ * by Curt McDowell, Broadcom Corp. 12/08/2005
+ *
+ * @param dataptr points to start of data to be summed at any boundary
+ * @param len length of data to be summed
+ * @return host order (!) lwip checksum (non-inverted Internet sum) 
+ */
+
+static u16_t
+lwip_standard_chksum(void *dataptr, int len)
+{
+  u8_t *pb = (u8_t *)dataptr;
+  u16_t *ps, t = 0;
+  u32_t sum = 0;
+  int odd = ((mem_ptr_t)pb & 1);
+
+  /* Get aligned to u16_t */
+  if (odd && len > 0) {
+    ((u8_t *)&t)[1] = *pb++;
+    len--;
+  }
+
+  /* Add the bulk of the data */
+  ps = (u16_t *)(void *)pb;
+  while (len > 1) {
+    sum += *ps++;
+    len -= 2;
+  }
+
+  /* Consume left-over byte, if any */
+  if (len > 0) {
+    ((u8_t *)&t)[0] = *(u8_t *)ps;
+  }
+
+  /* Add end bytes */
+  sum += t;
+
+  /* Fold 32-bit sum to 16 bits
+     calling this twice is propably faster than if statements... */
+  sum = FOLD_U32T(sum);
+  sum = FOLD_U32T(sum);
+
+  /* Swap if alignment was odd */
+  if (odd) {
+    sum = SWAP_BYTES_IN_WORD(sum);
+  }
+
+  return (u16_t)sum;
+}
+#endif
+
+#if (LWIP_CHKSUM_ALGORITHM == 3) /* Alternative version #3 */
+/**
+ * An optimized checksum routine. Basically, it uses loop-unrolling on
+ * the checksum loop, treating the head and tail bytes specially, whereas
+ * the inner loop acts on 8 bytes at a time. 
+ *
+ * @arg start of buffer to be checksummed. May be an odd byte address.
+ * @len number of bytes in the buffer to be checksummed.
+ * @return host order (!) lwip checksum (non-inverted Internet sum) 
+ * 
+ * by Curt McDowell, Broadcom Corp. December 8th, 2005
+ */
+
+static u16_t
+lwip_standard_chksum(void *dataptr, int len)
+{
+  u8_t *pb = (u8_t *)dataptr;
+  u16_t *ps, t = 0;
+  u32_t *pl;
+  u32_t sum = 0, tmp;
+  /* starts at odd byte address? */
+  int odd = ((mem_ptr_t)pb & 1);
+
+  if (odd && len > 0) {
+    ((u8_t *)&t)[1] = *pb++;
+    len--;
+  }
+
+  ps = (u16_t *)pb;
+
+  if (((mem_ptr_t)ps & 3) && len > 1) {
+    sum += *ps++;
+    len -= 2;
+  }
+
+  pl = (u32_t *)ps;
+
+  while (len > 7)  {
+    tmp = sum + *pl++;          /* ping */
+    if (tmp < sum) {
+      tmp++;                    /* add back carry */
+    }
+
+    sum = tmp + *pl++;          /* pong */
+    if (sum < tmp) {
+      sum++;                    /* add back carry */
+    }
+
+    len -= 8;
+  }
+
+  /* make room in upper bits */
+  sum = FOLD_U32T(sum);
+
+  ps = (u16_t *)pl;
+
+  /* 16-bit aligned word remaining? */
+  while (len > 1) {
+    sum += *ps++;
+    len -= 2;
+  }
+
+  /* dangling tail byte remaining? */
+  if (len > 0) {                /* include odd byte */
+    ((u8_t *)&t)[0] = *(u8_t *)ps;
+  }
+
+  sum += t;                     /* add end bytes */
+
+  /* Fold 32-bit sum to 16 bits
+     calling this twice is propably faster than if statements... */
+  sum = FOLD_U32T(sum);
+  sum = FOLD_U32T(sum);
+
+  if (odd) {
+    sum = SWAP_BYTES_IN_WORD(sum);
+  }
+
+  return (u16_t)sum;
+}
+#endif
+
+/* inet_chksum_pseudo:
+ *
+ * Calculates the pseudo Internet checksum used by TCP and UDP for a pbuf chain.
+ * IP addresses are expected to be in network byte order.
+ *
+ * @param p chain of pbufs over that a checksum should be calculated (ip data part)
+ * @param src source ip address (used for checksum of pseudo header)
+ * @param dst destination ip address (used for checksum of pseudo header)
+ * @param proto ip protocol (used for checksum of pseudo header)
+ * @param proto_len length of the ip data part (used for checksum of pseudo header)
+ * @return checksum (as u16_t) to be saved directly in the protocol header
+ */
+u16_t
+inet_chksum_pseudo(struct packet *p,
+       ip_addr_t *src, ip_addr_t *dest,
+       u8_t proto, u16_t proto_len)
+{
+  u32_t acc;
+  u32_t addr;
+  struct packet *q;
+  u8_t swapped;
+
+  acc = 0;
+  swapped = 0;
+  /* iterate through all pbuf in chain */
+  for(q = p; q != NULL; q = q->next) {
+    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
+      (void *)q, (void *)q->next));
+    acc += LWIP_CHKSUM(q->payload, q->len);
+    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
+    /* just executing this next line is probably faster that the if statement needed
+       to check whether we really need to execute it, and does no harm */
+    acc = FOLD_U32T(acc);
+    if (q->len % 2 != 0) {
+      swapped = 1 - swapped;
+      acc = SWAP_BYTES_IN_WORD(acc);
+    }
+    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
+  }
+
+  if (swapped) {
+    acc = SWAP_BYTES_IN_WORD(acc);
+  }
+  addr = ip4_addr_get_u32(src);
+  acc += (addr & 0xffffUL);
+  acc += ((addr >> 16) & 0xffffUL);
+  addr = ip4_addr_get_u32(dest);
+  acc += (addr & 0xffffUL);
+  acc += ((addr >> 16) & 0xffffUL);
+  acc += (u32_t)htons((u16_t)proto);
+  acc += (u32_t)htons(proto_len);
+
+  /* Fold 32-bit sum to 16 bits
+     calling this twice is propably faster than if statements... */
+  acc = FOLD_U32T(acc);
+  acc = FOLD_U32T(acc);
+  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
+  return (u16_t)~(acc & 0xffffUL);
+}
+
+/* inet_chksum_pseudo:
+ *
+ * Calculates the pseudo Internet checksum used by TCP and UDP for a pbuf chain.
+ * IP addresses are expected to be in network byte order.
+ *
+ * @param p chain of pbufs over that a checksum should be calculated (ip data part)
+ * @param src source ip address (used for checksum of pseudo header)
+ * @param dst destination ip address (used for checksum of pseudo header)
+ * @param proto ip protocol (used for checksum of pseudo header)
+ * @param proto_len length of the ip data part (used for checksum of pseudo header)
+ * @return checksum (as u16_t) to be saved directly in the protocol header
+ */
+u16_t
+inet_chksum_pseudo_partial(struct packet *p,
+       ip_addr_t *src, ip_addr_t *dest,
+       u8_t proto, u16_t proto_len, u16_t chksum_len)
+{
+  u32_t acc;
+  u32_t addr;
+  struct packet *q;
+  u8_t swapped;
+  u16_t chklen;
+
+  acc = 0;
+  swapped = 0;
+  /* iterate through all pbuf in chain */
+  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
+    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
+      (void *)q, (void *)q->next));
+    chklen = q->len;
+    if (chklen > chksum_len) {
+      chklen = chksum_len;
+    }
+    acc += LWIP_CHKSUM(q->payload, chklen);
+    chksum_len -= chklen;
+    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
+    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
+    /* fold the upper bit down */
+    acc = FOLD_U32T(acc);
+    if (q->len % 2 != 0) {
+      swapped = 1 - swapped;
+      acc = SWAP_BYTES_IN_WORD(acc);
+    }
+    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
+  }
+
+  if (swapped) {
+    acc = SWAP_BYTES_IN_WORD(acc);
+  }
+  addr = ip4_addr_get_u32(src);
+  acc += (addr & 0xffffUL);
+  acc += ((addr >> 16) & 0xffffUL);
+  addr = ip4_addr_get_u32(dest);
+  acc += (addr & 0xffffUL);
+  acc += ((addr >> 16) & 0xffffUL);
+  acc += (u32_t)htons((u16_t)proto);
+  acc += (u32_t)htons(proto_len);
+
+  /* Fold 32-bit sum to 16 bits
+     calling this twice is propably faster than if statements... */
+  acc = FOLD_U32T(acc);
+  acc = FOLD_U32T(acc);
+  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
+  return (u16_t)~(acc & 0xffffUL);
+}
+
+/* inet_chksum:
+ *
+ * Calculates the Internet checksum over a portion of memory. Used primarily for IP
+ * and ICMP.
+ *
+ * @param dataptr start of the buffer to calculate the checksum (no alignment needed)
+ * @param len length of the buffer to calculate the checksum
+ * @return checksum (as u16_t) to be saved directly in the protocol header
+ */
+
+u16_t
+inet_chksum(void *dataptr, u16_t len)
+{
+  return ~LWIP_CHKSUM(dataptr, len);
+}
+
+#if 0
+/**
+ * Calculate a checksum over a chain of pbufs (without pseudo-header, much like
+ * inet_chksum only pbufs are used).
+ *
+ * @param p pbuf chain over that the checksum should be calculated
+ * @return checksum (as u16_t) to be saved directly in the protocol header
+ */
+u16_t
+inet_chksum_pbuf(struct pbuf *p)
+{
+  u32_t acc;
+  struct pbuf *q;
+  u8_t swapped;
+
+  acc = 0;
+  swapped = 0;
+  for(q = p; q != NULL; q = q->next) {
+    acc += LWIP_CHKSUM(q->payload, q->len);
+    acc = FOLD_U32T(acc);
+    if (q->len % 2 != 0) {
+      swapped = 1 - swapped;
+      acc = SWAP_BYTES_IN_WORD(acc);
+    }
+  }
+
+  if (swapped) {
+    acc = SWAP_BYTES_IN_WORD(acc);
+  }
+  return (u16_t)~(acc & 0xffffUL);
+}
+#endif
+
+/* These are some implementations for LWIP_CHKSUM_COPY, which copies data
+ * like MEMCPY but generates a checksum at the same time. Since this is a
+ * performance-sensitive function, you might want to create your own version
+ * in assembly targeted at your hardware by defining it in lwipopts.h:
+ *   #define LWIP_CHKSUM_COPY(dst, src, len) your_chksum_copy(dst, src, len)
+ */
+
+#if (LWIP_CHKSUM_COPY_ALGORITHM == 1) /* Version #1 */
+/** Safe but slow: first call MEMCPY, then call LWIP_CHKSUM.
+ * For architectures with big caches, data might still be in cache when
+ * generating the checksum after copying.
+ */
+u16_t
+lwip_chksum_copy(void *dst, const void *src, u16_t len)
+{
+  MEMCPY(dst, src, len);
+  return LWIP_CHKSUM(dst, len);
+}
+#endif /* (LWIP_CHKSUM_COPY_ALGORITHM == 1) */
diff --git a/lib/arranet/inet_chksum.h b/lib/arranet/inet_chksum.h
new file mode 100644
index 0000000..6f620df
--- /dev/null
+++ b/lib/arranet/inet_chksum.h
@@ -0,0 +1,93 @@
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved. 
+ * 
+ * Redistribution and use in source and binary forms, with or without modification, 
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission. 
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ * 
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef __LWIP_INET_CHKSUM_H__
+#define __LWIP_INET_CHKSUM_H__
+
+#include "lwip/opt.h"
+
+#include "lwip/pbuf.h"
+#include "lwip/ip_addr.h"
+
+#include <sys/socket.h>
+#include <arranet.h>
+
+/** Swap the bytes in an u16_t: much like htons() for little-endian */
+#ifndef SWAP_BYTES_IN_WORD
+#if LWIP_PLATFORM_BYTESWAP && (BYTE_ORDER == LITTLE_ENDIAN)
+/* little endian and PLATFORM_BYTESWAP defined */
+#define SWAP_BYTES_IN_WORD(w) LWIP_PLATFORM_HTONS(w)
+#else /* LWIP_PLATFORM_BYTESWAP && (BYTE_ORDER == LITTLE_ENDIAN) */
+/* can't use htons on big endian (or PLATFORM_BYTESWAP not defined)... */
+#define SWAP_BYTES_IN_WORD(w) (((w) & 0xff) << 8) | (((w) & 0xff00) >> 8)
+#endif /* LWIP_PLATFORM_BYTESWAP && (BYTE_ORDER == LITTLE_ENDIAN)*/
+#endif /* SWAP_BYTES_IN_WORD */
+
+/** Split an u32_t in two u16_ts and add them up */
+#ifndef FOLD_U32T
+#define FOLD_U32T(u)          (((u) >> 16) + ((u) & 0x0000ffffUL))
+#endif
+
+#if LWIP_CHECKSUM_ON_COPY
+/** Function-like macro: same as MEMCPY but returns the checksum of copied data
+    as u16_t */
+#ifndef LWIP_CHKSUM_COPY
+#define LWIP_CHKSUM_COPY(dst, src, len) lwip_chksum_copy(dst, src, len)
+#ifndef LWIP_CHKSUM_COPY_ALGORITHM
+#define LWIP_CHKSUM_COPY_ALGORITHM 1
+#endif /* LWIP_CHKSUM_COPY_ALGORITHM */
+#endif /* LWIP_CHKSUM_COPY */
+#else /* LWIP_CHECKSUM_ON_COPY */
+#define LWIP_CHKSUM_COPY_ALGORITHM 0
+#endif /* LWIP_CHECKSUM_ON_COPY */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+u16_t inet_chksum(void *dataptr, u16_t len);
+/* u16_t inet_chksum_pbuf(struct pbuf *p); */
+u16_t inet_chksum_pseudo(struct packet *p,
+       ip_addr_t *src, ip_addr_t *dest,
+       u8_t proto, u16_t proto_len);
+u16_t inet_chksum_pseudo_partial(struct packet *p,
+       ip_addr_t *src, ip_addr_t *dest,
+       u8_t proto, u16_t proto_len, u16_t chksum_len);
+#if LWIP_CHKSUM_COPY_ALGORITHM
+u16_t lwip_chksum_copy(void *dst, const void *src, u16_t len);
+#endif /* LWIP_CHKSUM_COPY_ALGORITHM */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __LWIP_INET_H__ */
+
diff --git a/lib/arranet/ip_addr.c b/lib/arranet/ip_addr.c
new file mode 100644
index 0000000..49caeff
--- /dev/null
+++ b/lib/arranet/ip_addr.c
@@ -0,0 +1,313 @@
+/**
+ * @file
+ * This is the IPv4 address tools implementation.
+ *
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved. 
+ * 
+ * Redistribution and use in source and binary forms, with or without modification, 
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission. 
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ * 
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+
+#include "lwip/opt.h"
+#include "lwip/ip_addr.h"
+#include "lwip/netif.h"
+#include <arranet_impl.h>
+
+/* used by IP_ADDR_ANY and IP_ADDR_BROADCAST in ip_addr.h */
+const ip_addr_t ip_addr_any = { IPADDR_ANY };
+const ip_addr_t ip_addr_broadcast = { IPADDR_BROADCAST };
+
+/**
+ * Determine if an address is a broadcast address on a network interface 
+ * 
+ * @param addr address to be checked
+ * @param netif the network interface against which the address is checked
+ * @return returns non-zero if the address is a broadcast address
+ */
+u8_t
+ip4_addr_isbroadcast(u32_t addr, const struct netif *netif)
+{
+  ip_addr_t ipaddr;
+  ip4_addr_set_u32(&ipaddr, addr);
+
+  /* all ones (broadcast) or all zeroes (old skool broadcast) */
+  if ((~addr == IPADDR_ANY) ||
+      (addr == IPADDR_ANY)) {
+    return 1;
+  /* no broadcast support on this network interface? */
+  } else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0) {
+    /* the given address cannot be a broadcast address
+     * nor can we check against any broadcast addresses */
+    return 0;
+  /* address matches network interface address exactly? => no broadcast */
+  } else if (addr == ip4_addr_get_u32(&netif->ip_addr)) {
+    return 0;
+  /*  on the same (sub) network... */
+  } else if (ip_addr_netcmp(&ipaddr, &(netif->ip_addr), &(netif->netmask))
+         /* ...and host identifier bits are all ones? =>... */
+          && ((addr & ~ip4_addr_get_u32(&netif->netmask)) ==
+           (IPADDR_BROADCAST & ~ip4_addr_get_u32(&netif->netmask)))) {
+    /* => network broadcast address */
+    return 1;
+  } else {
+    return 0;
+  }
+}
+
+/** Checks if a netmask is valid (starting with ones, then only zeros)
+ *
+ * @param netmask the IPv4 netmask to check (in network byte order!)
+ * @return 1 if the netmask is valid, 0 if it is not
+ */
+u8_t
+ip4_addr_netmask_valid(u32_t netmask)
+{
+  u32_t mask;
+  u32_t nm_hostorder = lwip_htonl(netmask);
+
+  /* first, check for the first zero */
+  for (mask = 1UL << 31 ; mask != 0; mask >>= 1) {
+    if ((nm_hostorder & mask) == 0) {
+      break;
+    }
+  }
+  /* then check that there is no one */
+  for (; mask != 0; mask >>= 1) {
+    if ((nm_hostorder & mask) != 0) {
+      /* there is a one after the first zero -> invalid */
+      return 0;
+    }
+  }
+  /* no one after the first zero -> valid */
+  return 1;
+}
+
+/* Here for now until needed in other places in lwIP */
+#ifndef isprint
+#define in_range(c, lo, up)  ((u8_t)c >= lo && (u8_t)c <= up)
+#define isprint(c)           in_range(c, 0x20, 0x7f)
+#define isdigit(c)           in_range(c, '0', '9')
+#define isxdigit(c)          (isdigit(c) || in_range(c, 'a', 'f') || in_range(c, 'A', 'F'))
+#define islower(c)           in_range(c, 'a', 'z')
+#define isspace(c)           (c == ' ' || c == '\f' || c == '\n' || c == '\r' || c == '\t' || c == '\v')
+#endif
+
+/**
+ * Ascii internet address interpretation routine.
+ * The value returned is in network order.
+ *
+ * @param cp IP address in ascii represenation (e.g. "127.0.0.1")
+ * @return ip address in network order
+ */
+u32_t
+ipaddr_addr(const char *cp)
+{
+  ip_addr_t val;
+
+  if (ipaddr_aton(cp, &val)) {
+    return ip4_addr_get_u32(&val);
+  }
+  return (IPADDR_NONE);
+}
+
+/**
+ * Check whether "cp" is a valid ascii representation
+ * of an Internet address and convert to a binary address.
+ * Returns 1 if the address is valid, 0 if not.
+ * This replaces inet_addr, the return value from which
+ * cannot distinguish between failure and a local broadcast address.
+ *
+ * @param cp IP address in ascii represenation (e.g. "127.0.0.1")
+ * @param addr pointer to which to save the ip address in network order
+ * @return 1 if cp could be converted to addr, 0 on failure
+ */
+int
+ipaddr_aton(const char *cp, ip_addr_t *addr)
+{
+  u32_t val;
+  u8_t base;
+  char c;
+  u32_t parts[4];
+  u32_t *pp = parts;
+
+  c = *cp;
+  for (;;) {
+    /*
+     * Collect number up to ``.''.
+     * Values are specified as for C:
+     * 0x=hex, 0=octal, 1-9=decimal.
+     */
+    if (!isdigit(c))
+      return (0);
+    val = 0;
+    base = 10;
+    if (c == '0') {
+      c = *++cp;
+      if (c == 'x' || c == 'X') {
+        base = 16;
+        c = *++cp;
+      } else
+        base = 8;
+    }
+    for (;;) {
+      if (isdigit(c)) {
+        val = (val * base) + (int)(c - '0');
+        c = *++cp;
+      } else if (base == 16 && isxdigit(c)) {
+        val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
+        c = *++cp;
+      } else
+        break;
+    }
+    if (c == '.') {
+      /*
+       * Internet format:
+       *  a.b.c.d
+       *  a.b.c   (with c treated as 16 bits)
+       *  a.b (with b treated as 24 bits)
+       */
+      if (pp >= parts + 3) {
+        return (0);
+      }
+      *pp++ = val;
+      c = *++cp;
+    } else
+      break;
+  }
+  /*
+   * Check for trailing characters.
+   */
+  if (c != '\0' && !isspace(c)) {
+    return (0);
+  }
+  /*
+   * Concoct the address according to
+   * the number of parts specified.
+   */
+  switch (pp - parts + 1) {
+
+  case 0:
+    return (0);       /* initial nondigit */
+
+  case 1:             /* a -- 32 bits */
+    break;
+
+  case 2:             /* a.b -- 8.24 bits */
+    if (val > 0xffffffUL) {
+      return (0);
+    }
+    val |= parts[0] << 24;
+    break;
+
+  case 3:             /* a.b.c -- 8.8.16 bits */
+    if (val > 0xffff) {
+      return (0);
+    }
+    val |= (parts[0] << 24) | (parts[1] << 16);
+    break;
+
+  case 4:             /* a.b.c.d -- 8.8.8.8 bits */
+    if (val > 0xff) {
+      return (0);
+    }
+    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
+    break;
+  default:
+    LWIP_ASSERT("unhandled", 0);
+    break;
+  }
+  if (addr) {
+    ip4_addr_set_u32(addr, htonl(val));
+  }
+  return (1);
+}
+
+/**
+ * Convert numeric IP address into decimal dotted ASCII representation.
+ * returns ptr to static buffer; not reentrant!
+ *
+ * @param addr ip address in network order to convert
+ * @return pointer to a global static (!) buffer that holds the ASCII
+ *         represenation of addr
+ */
+char *
+ipaddr_ntoa(const ip_addr_t *addr)
+{
+  static char str[16];
+  return ipaddr_ntoa_r(addr, str, 16);
+}
+
+/**
+ * Same as ipaddr_ntoa, but reentrant since a user-supplied buffer is used.
+ *
+ * @param addr ip address in network order to convert
+ * @param buf target buffer where the string is stored
+ * @param buflen length of buf
+ * @return either pointer to buf which now holds the ASCII
+ *         representation of addr or NULL if buf was too small
+ */
+char *ipaddr_ntoa_r(const ip_addr_t *addr, char *buf, int buflen)
+{
+  u32_t s_addr;
+  char inv[3];
+  char *rp;
+  u8_t *ap;
+  u8_t rem;
+  u8_t n;
+  u8_t i;
+  int len = 0;
+
+  s_addr = ip4_addr_get_u32(addr);
+
+  rp = buf;
+  ap = (u8_t *)&s_addr;
+  for(n = 0; n < 4; n++) {
+    i = 0;
+    do {
+      rem = *ap % (u8_t)10;
+      *ap /= (u8_t)10;
+      inv[i++] = '0' + rem;
+    } while(*ap);
+    while(i--) {
+      if (len++ >= buflen) {
+        return NULL;
+      }
+      *rp++ = inv[i];
+    }
+    if (len++ >= buflen) {
+      return NULL;
+    }
+    *rp++ = '.';
+    ap++;
+  }
+  *--rp = 0;
+  return buf;
+}
diff --git a/lib/barrelfish/Hakefile b/lib/barrelfish/Hakefile
index 930a833..cb3f010 100644
--- a/lib/barrelfish/Hakefile
+++ b/lib/barrelfish/Hakefile
@@ -76,7 +76,86 @@
                     cFiles = arch_srcs arch ++ archfam_srcs (archFamily arch)
                              ++ common_srcs ++ idc_srcs,
                     assemblyFiles = arch_assembly (archFamily arch),
-                    flounderBindings = [ "mem", "octopus", "interdisp", "spawn",
+                    flounderBindings = [ "mem", "octopus", "interdisp", "spawn", 
+                                         "terminal", "arrakis" ],
+                    -- only makes sense to compile monitor binding for lmp
+                    flounderTHCStubs = [ "octopus" ],
+                    flounderExtraBindings = [ ("monitor", ["lmp"]),
+		    			      ("monitor_blocking", ["lmp", "rpcclient"]),
+                                              ("mem", ["rpcclient"]),
+                                              ("octopus", ["rpcclient"]),
+                                              ("spawn", ["rpcclient"]),
+                                              ("arrakis", ["rpcclient"])],
+                    addIncludes = [ "include", "include" ./. arch_dir ],
+                    addGeneratedDependencies = [ "/include/asmoffsets.h" ]
+                  }
+ ) | arch <- allArchitectures ] ++
+[(let arch_dir = "arch" ./. archFamily arch
+      common_srcs = [ "capabilities.c", "init.c", "dispatch.c", "threads.c",
+                      "thread_sync.c", "slab.c", "domain.c", "idc.c",
+                      "waitset.c", "event_queue.c", "event_mutex.c",
+                      "idc_export.c", "nameservice_client.c", "msgbuf.c",
+                      "monitor_client.c", "flounder_support.c", "flounder_glue_binding.c",
+                      "morecore.c", "debug.c", "heap.c", "ram_alloc.c",
+                      "terminal.c", "spawn_client.c", "vspace/vspace.c", 
+                      "vspace/vregion.c", "vspace/memobj_one_frame.c",
+                      "vspace/memobj_one_frame_lazy.c",
+                      "vspace/utils.c",
+                      "vspace/memobj_one_frame_one_map.c", "vspace/mmu_aware.c",
+                      "slot_alloc/single_slot_alloc.c", "slot_alloc/multi_slot_alloc.c",
+                      "slot_alloc/slot_alloc.c", "slot_alloc/range_slot_alloc.c",
+                      "bulk_transfer.c", "trace.c", "resource_ctrl.c", "coreset.c",
+                      "inthandler.c", "deferred.c"
+                    ]
+
+      idc_srcs = concat $ map getsrcs $ optInterconnectDrivers $ options arch
+          where
+            getsrcs "lmp" = [ "lmp_chan.c", "lmp_endpoints.c" ]
+            getsrcs "ump" = [ "ump_chan.c", "ump_endpoint.c" ]
+            getsrcs "multihop" = [ "multihop_chan.c" ]
+            getsrcs _ = []
+
+      -- sources specific to the architecture family
+      archfam_srcs "x86_32"  = [ "arch/x86_32/debug.c" ,
+                              "arch/x86_32/dispatch.c" , "arch/x86_32/syscalls.c" ,
+                              "arch/x86_32/sys_debug.c", "target/x86_32/pmap_target.c",
+                              "target/x86/pmap_x86.c",
+                              "vspace/arch/x86_32/layout.c" , "vspace/memobj_pinned.c" ,
+                              "vspace/pinned.c", "vspace/memobj_anon.c",
+                              "arch/x86/perfmon.c", "arch/x86/tls.c"]
+      archfam_srcs "x86_64"  = [ "arch/x86_64/debug.c", "arch/x86_64/dispatch.c" ,
+                                 "arch/x86_64/syscalls.c", "arch/x86_64/sys_debug.c",
+                                 "arch/x86_64/ldt.c",
+                                 "target/x86_64/pmap_target.c", "target/x86/pmap_x86.c",
+                                 "vspace/arch/x86_64/layout.c",
+                                 "vspace/memobj_pinned.c", "vspace/pinned.c", "vspace/memobj_anon.c",
+                                 "arch/x86/perfmon.c", "arch/x86/tls.c"]
+      archfam_srcs "arm"     = [ "arch/arm/debug.c", "arch/arm/dispatch.c", 
+                                 "arch/arm/pmap_arch.c", "arch/arm/sys_debug.c",
+                                 "arch/arm/syscalls.c", "vspace/memobj_pinned.c" ,
+                                 "vspace/pinned.c", "vspace/memobj_anon.c",
+                                 "vspace/arch/arm/layout.c" ]
+      archfam_srcs _         = []
+
+      -- sources specific to the architecture
+      arch_srcs "scc" = [ "arch/x86/ipi_notify.c" ]
+      arch_srcs "x86_32" = [ "arch/x86/ipi_notify.c" ]
+      arch_srcs "x86_64" = [ "arch/x86/ipi_notify.c" ]
+      arch_srcs _     = []
+
+      arch_assembly "x86_32"  = [ "arch/x86_32/entry.S" ]
+      arch_assembly "x86_64"  = [ "arch/x86_64/entry.S" ]
+      arch_assembly "arm"     = [ "arch/arm/entry.S", "arch/arm/syscall.S" ]
+      arch_assembly _         = []
+
+  in
+    build library { target = "arrakis",
+                    architectures = [arch],
+                    cFiles = arch_srcs arch ++ archfam_srcs (archFamily arch)
+                             ++ common_srcs ++ idc_srcs,
+                    assemblyFiles = arch_assembly (archFamily arch),
+                    addCFlags = [ "-DARRAKIS" ],
+                    flounderBindings = [ "mem", "octopus", "interdisp", "spawn", "arrakis", 
                                          "terminal" ],
                     -- only makes sense to compile monitor binding for lmp
                     flounderTHCStubs = [ "octopus" ],
@@ -84,7 +163,8 @@
 		    			      ("monitor_blocking", ["lmp", "rpcclient"]),
                                               ("mem", ["rpcclient"]),
                                               ("octopus", ["rpcclient"]),
-                                              ("spawn", ["rpcclient"])],
+                                              ("spawn", ["rpcclient"]),
+                                              ("arrakis", ["rpcclient"])],
                     addIncludes = [ "include", "include" ./. arch_dir ],
                     addGeneratedDependencies = [ "/include/asmoffsets.h" ]
                   }
diff --git a/lib/barrelfish/arch/x86_64/dispatch.c b/lib/barrelfish/arch/x86_64/dispatch.c
index 0522ff6..afc9c12 100644
--- a/lib/barrelfish/arch/x86_64/dispatch.c
+++ b/lib/barrelfish/arch/x86_64/dispatch.c
@@ -185,7 +185,7 @@ disp_switch(dispatcher_handle_t handle, arch_registers_state_t *from_state,
                       [disp] "D" (disp),
                       [to_regs] "S" (to_regs)
                     : "rbx", "rcx", "rsp",
-                      "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15"
+                      "r8", "r9", "r10", "r12", "r13", "r14", "r15"
                     );
 
     __asm volatile ("switch_resume:");
@@ -244,7 +244,7 @@ disp_save(dispatcher_handle_t handle, arch_registers_state_t *state,
                       [fs] "m" (regs->fs),
                       [gs] "m" (regs->gs)
                     : "rbx", "rcx", "rdx", "rsi", "rdi",
-                      "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15"
+                      "r8", "r9", "r10", "r12", "r13", "r14", "r15"
                     );
 
     if (yield) {
diff --git a/lib/barrelfish/arch/x86_64/ldt.c b/lib/barrelfish/arch/x86_64/ldt.c
index 14adba1..b575d88 100644
--- a/lib/barrelfish/arch/x86_64/ldt.c
+++ b/lib/barrelfish/arch/x86_64/ldt.c
@@ -4,7 +4,7 @@
  */
 
 /*
- * Copyright (c) 2011, ETH Zurich.
+ * Copyright (c) 2011, 2013, ETH Zurich.
  * All rights reserved.
  *
  * This file is distributed under the terms in the attached LICENSE file.
@@ -20,7 +20,9 @@
 #include <barrelfish/ldt.h>
 #include <arch/ldt.h>
 #include <target/x86_64/barrelfish_kpi/cpu_target.h> // segment_descriptor
+#include <barrelfish_kpi/cpu_arch.h> // segment_descriptor
 #include <stdio.h>
+#include <string.h>
 
 #define LDT_NENTRIES    512     ///< Number of entries in the statically-sized LDT
 
@@ -32,6 +34,538 @@ static union segment_descriptor ldt[LDT_NENTRIES];
 // (XXX: coherence assumption)
 static spinlock_t ldt_spinlock;
 
+#ifdef ARRAKIS
+
+/*
+ * AMD64 Segmentation Data Structures and definitions
+ */
+
+/*
+ * Selectors
+ */
+
+#define SEL_RPL_MASK    3       /* requester priv level */
+#define ISPL(s) ((s)&3)         /* what is the priority level of a selector */
+#define SEL_KPL 0               /* kernel priority level */
+#define SEL_UPL 3               /* user priority level */
+#define ISLDT(s)        ((s)&SEL_LDT)   /* is it local or global */
+#define SEL_LDT 4               /* local descriptor table */
+#define IDXSEL(s)       (((s)>>3) & 0x1fff)             /* index of selector */
+#define LSEL(s,r)       (((s)<<3) | SEL_LDT | r)        /* a local selector */
+#define GSEL(s,r)       (((s)<<3) | r)                  /* a global selector */
+
+/**
+ * Gate descriptors (e.g. indirect descriptors, trap, interrupt etc. 128 bit)
+ * Only interrupt and trap gates have gd_ist.
+ */
+struct  gate_descriptor {
+    uint64_t gd_looffset:16;       /* gate offset (lsb) */
+    uint64_t gd_selector:16;       /* gate segment selector */
+    uint64_t gd_ist:3;             /* IST table index */
+    uint64_t gd_xx:5;              /* unused */
+    uint64_t gd_type:5;            /* segment type */
+    uint64_t gd_dpl:2;             /* segment descriptor priority level */
+    uint64_t gd_p:1;               /* segment descriptor present */
+    uint64_t gd_hioffset:48;       /* gate offset (msb) */
+    uint64_t sd_xx1:32;
+} __attribute__((packed));
+
+/* system segments and gate types */
+#define SDT_SYSNULL      0      /* system null */
+#define SDT_SYSLDT       2      /* system 64 bit local descriptor table */
+#define SDT_SYSTSS       9      /* system available 64 bit TSS */
+#define SDT_SYSBSY      11      /* system busy 64 bit TSS */
+#define SDT_SYSCGT      12      /* system 64 bit call gate */
+#define SDT_SYSIGT      14      /* system 64 bit interrupt gate */
+#define SDT_SYSTGT      15      /* system 64 bit trap gate */
+
+/* memory segment types */
+#define SDT_MEMRO       16      /* memory read only */
+#define SDT_MEMROA      17      /* memory read only accessed */
+#define SDT_MEMRW       18      /* memory read write */
+#define SDT_MEMRWA      19      /* memory read write accessed */
+#define SDT_MEMROD      20      /* memory read only expand dwn limit */
+#define SDT_MEMRODA     21      /* memory read only expand dwn limit accessed */
+#define SDT_MEMRWD      22      /* memory read write expand dwn limit */
+#define SDT_MEMRWDA     23      /* memory read write expand dwn limit accessed */
+#define SDT_MEME        24      /* memory execute only */
+#define SDT_MEMEA       25      /* memory execute only accessed */
+#define SDT_MEMER       26      /* memory execute read */
+#define SDT_MEMERA      27      /* memory execute read accessed */
+#define SDT_MEMEC       28      /* memory execute only conforming */
+#define SDT_MEMEAC      29      /* memory execute only accessed conforming */
+#define SDT_MEMERC      30      /* memory execute read conforming */
+#define SDT_MEMERAC     31      /* memory execute read accessed conforming */
+
+/*
+ * Size of IDT table
+ */
+#define NIDT    256             /* 32 reserved, 16 h/w, 0 s/w, linux's 0x80 */
+
+/*
+ * Entries in the Global Descriptor Table (GDT)
+ */
+#define NULL_SEL        0       /**< Null descriptor */
+#define KCODE_SEL       1       /**< Kernel code descriptor */
+#define KSTACK_SEL      2       /**< Shared user/kernel stack descriptor */
+#define USTACK_SEL      3       /**< User stack descriptor */
+#define UCODE_SEL       4       /**< User code descriptor */
+#define TSS_LO_SEL      5       /**< Task State Segment (TSS) -- low 64bit */
+#define TSS_HI_SEL      6       /**< Task State Segment (TSS) -- high 64bit */
+#define LDT_LO_SEL      7       /**< Local descriptor table (LDT) -- low */
+#define LDT_HI_SEL      8       /**< Local descriptor table (LDT) -- high */
+#define NGDT_MEM        9       /**< Number of descriptors */
+
+/**
+ * region descriptors, used to load gdt/idt tables before segments yet exist.
+ */
+struct region_descriptor {
+    uint16_t rd_limit;          /**< segment extent */
+    uint64_t rd_base;           /**< base address  */
+} __attribute__((packed));
+
+struct task_state_segment {
+    uint32_t    reserved;
+    uint64_t    rsp[3];
+    uint64_t    reserved2;
+    uint64_t    ist[7];
+    uint64_t    reserved3;
+    uint16_t    reserved4;
+    uint16_t    iomap_base;
+} __attribute__ ((packed));
+
+/**
+ * \brief Global Task State Segment (TSS).
+ *
+ * This is the global, static and only Task State Segment (TSS). It is used
+ * for interrupt and exception handling (stack setup) while in user-space.
+ */
+static struct task_state_segment tss __attribute__ ((aligned (4)));
+
+union segment_descriptor gdt[] __attribute__ ((aligned (4))) = {
+    [NULL_SEL] = {   // Null segment
+        .raw = 0
+    },
+    [KCODE_SEL] = {   // Kernel code segment
+        .d = {
+            .lo_limit = 0xffff,
+            .lo_base = 0,
+            .type = 0xa,
+            .system_desc = 1,
+            .privilege_level = SEL_KPL,
+            .present = 1,
+            .hi_limit = 0xf,
+            .available = 0,
+            .long_mode = 1,
+            .operation_size = 0,
+            .granularity = 1,
+            .hi_base = 0
+        }
+    },
+    [KSTACK_SEL] = {   // Kernel stack segment
+        .d = {
+            .lo_limit = 0xffff,
+            .lo_base = 0,
+            .type = 2,
+            .system_desc = 1,
+            .privilege_level = SEL_KPL,
+            .present = 1,
+            .hi_limit = 0xf,
+            .available = 0,
+            .long_mode = 1,
+            .operation_size = 0,
+            .granularity = 1,
+            .hi_base = 0
+        }
+    },
+    [USTACK_SEL] = {   // User stack segment
+        .d = {
+            .lo_limit = 0xffff,
+            .lo_base = 0,
+            .type = 2,
+            .system_desc = 1,
+            .privilege_level = SEL_UPL,
+            .present = 1,
+            .hi_limit = 0xf,
+            .available = 0,
+            .long_mode = 1,
+            .operation_size = 0,
+            .granularity = 1,
+            .hi_base = 0
+        }
+    },
+    [UCODE_SEL] = {   // User code segment
+        .d = {
+            .lo_limit = 0xffff,
+            .lo_base = 0,
+            .type = 0xa,
+            .system_desc = 1,
+            .privilege_level = SEL_UPL,
+            .present = 1,
+            .hi_limit = 0xf,
+            .available = 0,
+            .long_mode = 1,
+            .operation_size = 0,
+            .granularity = 1,
+            .hi_base = 0
+        }
+    },
+    [TSS_LO_SEL] = {   // Global Task State Segment (TSS), lower 8 bytes
+        .sys_lo = {
+            .lo_limit = sizeof(tss) & 0xffff,
+            .type = SDT_SYSTSS,
+            .privilege_level = SEL_KPL,
+            .present = 1,
+            .hi_limit = (sizeof(tss) >> 16) & 0xf,
+            .available = 0,
+            .granularity = 0,
+        }
+    },
+    [TSS_HI_SEL] = {   // Global Task State Segment (TSS), upper 8 bytes
+        .sys_hi = {
+            .base = 0
+        }
+    },
+    [LDT_LO_SEL] = {    // Local descriptor table (LDT), lower 8 bytes
+        .sys_lo = {
+            .lo_limit = 0, // # 4k pages (since granularity = 1)
+            .lo_base = 0, // changed by context switch path when doing lldt
+            .type = 2, // LDT
+            .privilege_level = SEL_UPL,
+            .present = 1,
+            .hi_limit = 0,
+            .available = 0,
+            .granularity = 1,
+            .hi_base = 0
+        }
+    },
+    [LDT_HI_SEL] = {    // Local descriptor table (LDT), upper 8 bytes
+        .sys_hi = {
+            .base = 0 // changed by context switch path when doing lldt
+        }
+    },
+};
+
+static union segment_descriptor *ldt_descriptor = &gdt[LDT_LO_SEL];
+
+/// Remember current LDT pointer, so we can avoid reloading it
+static lvaddr_t current_ldt_base = -1;
+static size_t current_ldt_npages;
+
+static void maybe_reload_ldt(struct dispatcher_shared_x86_64 *disp, bool force_reload)
+{
+    /* Read fields from user dispatcher once for consistency */
+    lvaddr_t ldt_base = disp->ldt_base;
+    size_t ldt_npages = disp->ldt_npages;
+
+    /* optimize out if this is the same as the previous LDT */
+    if (!force_reload && ldt_base == current_ldt_base
+        && ldt_npages == current_ldt_npages) {
+        return;
+    }
+
+    uint16_t selector = 0;
+
+    if (ldt_base != 0 && ldt_npages != 0) {
+        ldt_descriptor[0].sys_lo.lo_base = ldt_base & ((1ul << 24) - 1);
+        ldt_descriptor[0].sys_lo.hi_base = (ldt_base >> 24) & 0xff;
+        ldt_descriptor[1].sys_hi.base = ldt_base >> 32;
+        assert(ldt_descriptor[0].sys_lo.granularity != 0);
+        ldt_descriptor[0].sys_lo.lo_limit = ldt_npages;
+
+        selector = GSEL(LDT_LO_SEL, SEL_UPL);
+    }
+
+    __asm volatile("lldt %%ax"
+                   : /* No output */
+                   : "a" (selector));
+
+    current_ldt_base = ldt_base;
+    current_ldt_npages = ldt_npages;
+}
+
+/**
+ * \brief Setup default GDT.
+ *
+ * Loads the GDT register with the default GDT and reloads CS and SS
+ * to point to the new entries. Resets all other segment registers to null.
+ * Finally, completes setup of GDT to include TSS base address mapping and
+ * loads TSS into task register.
+ */
+static void gdt_reset(struct dispatcher_generic *disp)
+{
+    lvaddr_t                     ptss = (lvaddr_t)&tss;
+    struct region_descriptor    region = {
+        .rd_limit = sizeof(gdt),
+        .rd_base = (uint64_t)&gdt
+    };
+
+    // Load default GDT
+    __asm volatile("lgdt %[region]" :: [region] "m" (region));
+
+    // Reload segments
+    __asm volatile("mov %[null], %%ds      \n\t"
+                   "mov %[null], %%es      \n\t"
+                   "mov %[ss], %%ss        \n\t"
+                   "mov %[null], %%gs      \n\t"
+                   "mov %[null], %%fs      \n\t"
+                   "pushq %[cs]            \n\t"          // new CS
+                   "lea 1f(%%rip), %%rax   \n\t"          // jumps to after lret
+                   "pushq %%rax            \n\t"          // new IP
+                   "lretq                  \n\t"          // fake return
+                   "1:                     \n\t"          // we'll continue here
+                   : /* No Output */
+                   :
+                   [null] "r" (0),
+                   [ss] "r" (GSEL(KSTACK_SEL, SEL_KPL)),
+                   [cs] "i" (GSEL(KCODE_SEL, SEL_KPL))
+                   : "rax"
+                   );
+
+    // Complete setup of TSS descriptor (by inserting base address of TSS)
+    gdt[TSS_LO_SEL].sys_lo.lo_base = ptss & 0xffffff;
+    gdt[TSS_LO_SEL].sys_lo.hi_base = (ptss >> 24) & 0xff;
+    gdt[TSS_HI_SEL].sys_hi.base = ptss >> 32;
+
+    // Complete setup of TSS
+    tss.rsp[0] = (lvaddr_t)&disp->stack[DISPATCHER_STACK_WORDS];
+
+    // Load task state register
+    __asm volatile("ltr %%ax" :: "a" (GSEL(TSS_LO_SEL, SEL_KPL)));
+}
+
+/* Utility function for code below; initialises a gate_descriptor */
+static void setgd(struct gate_descriptor *gd, void (* handler)(void),
+                  int ist, int type, int dpl, int selector)
+{
+    memset(gd, 0, sizeof(struct gate_descriptor));
+    gd->gd_looffset = (uintptr_t)handler & ((1UL << 16) - 1);
+    gd->gd_hioffset = (uintptr_t)handler >> 16;
+    gd->gd_selector = selector;
+    gd->gd_ist = ist;
+    gd->gd_type = type;
+    gd->gd_dpl = dpl;
+    gd->gd_p = 1;
+}
+
+/**
+ * \brief Define IRQ handler number 'num'.
+ *
+ * This defines an interrupt handler for vector #num. The way this is done is
+ * quite tricky: A block of assembly is emitted, with a label pointing to
+ * the beginning of that block. The label is made known as a symbol by
+ * having a C function _declaration_ directly in front of the block. The
+ * symbol has to be defined extern, so it is global, but its ELF visibility
+ * is set "hidden", so that the symbol does not end up in the GOT. This is
+ * very important for keeping the code position-independent.
+ *
+ * The NOERR/ERR variants depend on whether the hardware delivers an error code.
+ */
+#define HW_EXCEPTION_NOERR(num)                                         \
+    void __attribute__ ((visibility ("hidden"))) hwexc_##num(void);     \
+    __asm (                                                             \
+           "\t.text                                        \n\t"        \
+           "\t.type hwexc_"#num",@function                 \n\t"        \
+           "hwexc_"#num":                                  \n\t"        \
+           "pushq $0                /* dummy error code */ \n\t"        \
+           "pushq $"#num"           /* vector number */    \n\t"        \
+           "jmp    hwexc_common     /* common stuff */     \n\t"        \
+                                                                        )
+
+#define HW_EXCEPTION_ERR(num)                                           \
+    void __attribute__ ((visibility ("hidden"))) hwexc_##num(void);     \
+    __asm (                                                             \
+           "\t.text                                        \n\t"        \
+           "\t.type hwexc_"#num",@function                 \n\t"        \
+           "hwexc_"#num":                                  \n\t"        \
+           "pushq $"#num"           /* vector number */    \n\t"        \
+           "jmp    hwexc_common     /* common stuff */     \n\t"        \
+                                                                        )
+
+__asm (
+    ".text                                              \n\t"
+    "   .type hwexc_common ,@function                   \n\t"
+    /* a kernel fault means something bad happened, so we stack
+     * everything for the debugger to use, in the GDB frame format */
+    "hwexc_common:                                      \n\t"
+    "pushq 6*8(%rsp) /* SS */                           \n\t"
+    "pushq 4*8(%rsp) /* CS */                           \n\t"
+    "pushq 7*8(%rsp) /* EFLAGS */                       \n\t"
+    "pushq 5*8(%rsp) /* RIP */                          \n\t"
+    /* TODO: extend frame size and save FS/GS so we can resume afterwards */
+    "pushq %r15                                         \n\t"
+    "pushq %r14                                         \n\t"
+    "pushq %r13                                         \n\t"
+    "pushq %r12                                         \n\t"
+    "pushq %r11                                         \n\t"
+    "pushq %r10                                         \n\t"
+    "pushq %r9                                          \n\t"
+    "pushq %r8                                          \n\t"
+    "pushq 17*8(%rsp) /* RSP */                         \n\t"
+    "pushq %rbp                                         \n\t"
+    "pushq %rdi                                         \n\t"
+    "pushq %rsi                                         \n\t"
+    "pushq %rdx                                         \n\t"
+    "pushq %rcx                                         \n\t"
+    "pushq %rbx                                         \n\t"
+    "pushq %rax                                         \n\t"
+    "movq 20*8(%rsp), %rdi  /* vector number */         \n\t"
+    "movq 21*8(%rsp), %rsi  /* error code   */          \n\t"
+    "movq %rsp, %rdx       /* save area ptr*/           \n\t"
+    "jmp generic_handle_exception                       \n\t"
+);
+
+// CPU exceptions
+HW_EXCEPTION_NOERR(0);
+HW_EXCEPTION_NOERR(1);
+HW_EXCEPTION_NOERR(2);
+HW_EXCEPTION_NOERR(3);
+HW_EXCEPTION_NOERR(4);
+HW_EXCEPTION_NOERR(5);
+HW_EXCEPTION_NOERR(6);
+HW_EXCEPTION_NOERR(7);
+HW_EXCEPTION_ERR(8);
+HW_EXCEPTION_NOERR(9);
+HW_EXCEPTION_ERR(10);
+HW_EXCEPTION_ERR(11);
+HW_EXCEPTION_ERR(12);
+HW_EXCEPTION_ERR(13);
+HW_EXCEPTION_ERR(14);
+HW_EXCEPTION_NOERR(16);
+HW_EXCEPTION_ERR(17);
+HW_EXCEPTION_NOERR(18);
+HW_EXCEPTION_NOERR(19);
+
+// Reserved as "unhandled exception" handler
+HW_EXCEPTION_NOERR(666);
+
+/**
+ * \brief X86_64 register set
+ *
+ * As defined by GDB.
+ */
+enum gdb_x86_64_register_nums {
+    GDB_X86_64_RAX_REG, GDB_X86_64_RBX_REG, GDB_X86_64_RCX_REG, GDB_X86_64_RDX_REG,
+    GDB_X86_64_RSI_REG, GDB_X86_64_RDI_REG, GDB_X86_64_RBP_REG, GDB_X86_64_RSP_REG,
+    GDB_X86_64_R8_REG, GDB_X86_64_R9_REG, GDB_X86_64_R10_REG, GDB_X86_64_R11_REG,
+    GDB_X86_64_R12_REG, GDB_X86_64_R13_REG, GDB_X86_64_R14_REG, GDB_X86_64_R15_REG,
+    GDB_X86_64_RIP_REG, GDB_X86_64_EFLAGS_REG, GDB_X86_64_CS_REG, GDB_X86_64_SS_REG,
+
+/* these are not saved/used in 64-bit mode, and currently avoided
+    DS_REG, ES_REG, FS_REG, GS_REG,
+*/
+
+/* these are not used yet:
+    ST0_REG, ST1_REG, ST2_REG, ST3_REG, ST4_REG, ST5_REG, ST6_REG, ST7_REG,
+
+    FCTRL_REG, FSTAT_REG, FTAG_REG, FISEG_REG,
+    FIOFF_REG, FOSEG_REG, FOOFF_REG, FOP_REG,
+
+    XMM0_REG, XMM1_REG, XMM2_REG, XMM3_REG, XMM4_REG, XMM5_REG,
+    XMM6_REG, XMM7_REG, XMM8_REG, XMM9_REG, XMM10_REG, XMM11_REG,
+    XMM12_REG, XMM13_REG, XMM14_REG, XMM15_REG,
+    MXCSR_REG
+*/
+
+    GDB_X86_64_NUM_REGS /* not a real register; must be last! */
+};
+
+void disp_pagefault(dispatcher_handle_t handle, lvaddr_t fault_address,
+                    uintptr_t error, lvaddr_t ip);
+
+/**
+ * \brief Handles kernel exceptions
+ *
+ * \param vec   Vector number of exception
+ * \param error Error code from CPU, or 0 for an exception without an error code
+ * \param gdb_save_frame Pointer to save area for registers stacked by trap handler
+ */
+static __attribute__ ((used))
+void generic_handle_exception(uint64_t vec, uint64_t error,
+                              uintptr_t *gdb_save_frame)
+{
+    // XXX: This assumes we're enabled. That's not always the case...
+
+    switch(vec) {
+    case IDT_PF:
+        {
+            // For now, disable the dispatcher and call classic exception handler code
+            dispatcher_handle_t handle = disp_disable();
+            lvaddr_t fault_address;
+            arch_registers_state_t *regs = dispatcher_get_enabled_save_area(handle);
+            __asm volatile("mov %%cr2, %[fault_address]"
+                           : [fault_address] "=r" (fault_address));
+
+            // Write registers to dispatcher save area
+            regs->rsp = gdb_save_frame[GDB_X86_64_RSP_REG];
+            regs->eflags = gdb_save_frame[GDB_X86_64_EFLAGS_REG];
+            regs->rip = gdb_save_frame[GDB_X86_64_RIP_REG];
+
+            disp_pagefault(handle, fault_address, error, regs->rip);
+        }
+        break;
+
+    default:
+        debug_printf("Unhandled exception %d at 0x%" PRIxPTR " (error code 0x%lx)\n",
+                     (int)vec, gdb_save_frame[GDB_X86_64_RIP_REG], error);
+        abort();
+        break;
+    }
+}
+
+/**
+ * \brief Interrupt Descriptor Table (IDT) for processor this kernel is running
+ * on.
+ */
+static struct gate_descriptor idt[NIDT] __attribute__ ((aligned (16)));
+
+/**
+ * \brief Sets up the default IDT for current CPU.
+ */
+static void setup_default_idt(void)
+{
+    struct region_descriptor region = {         // set default IDT
+        .rd_limit = NIDT * sizeof(idt[0]) - 1,
+        .rd_base = (uint64_t)&idt
+    };
+    int i;
+
+    // reset IDT
+    memset((void *)&idt, 0, NIDT * sizeof(idt[0]));
+
+    // initialize IDT with default generic handlers
+    for (i = 0; i < NIDT; i++)
+        setgd(&idt[i], hwexc_666, 0, SDT_SYSIGT, SEL_KPL,
+              GSEL(KCODE_SEL, SEL_KPL));
+
+    /* Setup exception handlers */
+    setgd(&idt[0], hwexc_0, 0, SDT_SYSTGT, SEL_KPL, GSEL(KCODE_SEL, SEL_KPL));
+    setgd(&idt[1], hwexc_1, 0, SDT_SYSTGT, SEL_KPL, GSEL(KCODE_SEL, SEL_KPL));
+    setgd(&idt[2], hwexc_2, 0, SDT_SYSTGT, SEL_KPL, GSEL(KCODE_SEL, SEL_KPL));
+    setgd(&idt[3], hwexc_3, 0, SDT_SYSTGT, SEL_UPL, GSEL(KCODE_SEL, SEL_KPL));
+    setgd(&idt[4], hwexc_4, 0, SDT_SYSTGT, SEL_KPL, GSEL(KCODE_SEL, SEL_KPL));
+    setgd(&idt[5], hwexc_5, 0, SDT_SYSTGT, SEL_KPL, GSEL(KCODE_SEL, SEL_KPL));
+    setgd(&idt[6], hwexc_6, 0, SDT_SYSTGT, SEL_KPL, GSEL(KCODE_SEL, SEL_KPL));
+    setgd(&idt[7], hwexc_7, 0, SDT_SYSTGT, SEL_KPL, GSEL(KCODE_SEL, SEL_KPL));
+    setgd(&idt[8], hwexc_8, 0, SDT_SYSTGT, SEL_KPL, GSEL(KCODE_SEL, SEL_KPL));
+    setgd(&idt[9], hwexc_9, 0, SDT_SYSTGT, SEL_KPL, GSEL(KCODE_SEL, SEL_KPL));
+    setgd(&idt[10], hwexc_10, 0, SDT_SYSTGT, SEL_KPL, GSEL(KCODE_SEL, SEL_KPL));
+    setgd(&idt[11], hwexc_11, 0, SDT_SYSTGT, SEL_KPL, GSEL(KCODE_SEL, SEL_KPL));
+    setgd(&idt[12], hwexc_12, 0, SDT_SYSTGT, SEL_KPL, GSEL(KCODE_SEL, SEL_KPL));
+    setgd(&idt[13], hwexc_13, 0, SDT_SYSTGT, SEL_KPL, GSEL(KCODE_SEL, SEL_KPL));
+    setgd(&idt[14], hwexc_14, 0, SDT_SYSTGT, SEL_KPL, GSEL(KCODE_SEL, SEL_KPL));
+    // Interrupt 15 is undefined
+    setgd(&idt[16], hwexc_16, 0, SDT_SYSTGT, SEL_KPL, GSEL(KCODE_SEL, SEL_KPL));
+    setgd(&idt[17], hwexc_17, 0, SDT_SYSTGT, SEL_KPL, GSEL(KCODE_SEL, SEL_KPL));
+    setgd(&idt[18], hwexc_18, 0, SDT_SYSTGT, SEL_KPL, GSEL(KCODE_SEL, SEL_KPL));
+    setgd(&idt[19], hwexc_19, 0, SDT_SYSTGT, SEL_KPL, GSEL(KCODE_SEL, SEL_KPL));
+    // Interrupts 20 - 31 are reserved
+
+    /* Load IDT register */
+    __asm volatile("lidt %0" :: "m" (region));
+}
+#endif
+
 /** \brief Initialise private (per-dispatcher) LDT */
 void ldt_init_disabled(dispatcher_handle_t handle)
 {
@@ -45,7 +579,13 @@ void ldt_init_disabled(dispatcher_handle_t handle)
     disp->ldt_base = (lvaddr_t) ldt;
     // XXX: size may not be multiple of page size, but does it really matter?
     disp->ldt_npages = DIVIDE_ROUND_UP(sizeof(ldt), BASE_PAGE_SIZE);
+#ifdef ARRAKIS
+    gdt_reset(get_dispatcher_generic(handle));
+    maybe_reload_ldt(disp, true);
+    setup_default_idt();
+#else
     sys_x86_reload_ldt();
+#endif
 
     /* XXX: kludge to maintain backwards compatibility.
      * Setup a single segment descriptor that we can use to locate the
@@ -142,15 +682,15 @@ errval_t ldt_free_segment_ondisp(dispatcher_handle_t handle, uint16_t selector)
         return LIB_ERR_LDT_SELECTOR_INVALID;
     }
 
-    int index = X86_64_SELECTOR_IDX(selector);
+    int idx = X86_64_SELECTOR_IDX(selector);
 
     // check that this entry is occupied
-    if (index >= LDT_NENTRIES || !ldt[index].d.present) {
+    if (idx >= LDT_NENTRIES || !ldt[idx].d.present) {
         return LIB_ERR_LDT_SELECTOR_INVALID;
     }
 
     // mark entry as free
-    ldt[index].raw = 0;
+    ldt[idx].raw = 0;
     return SYS_ERR_OK;
 }
 
@@ -180,10 +720,10 @@ errval_t ldt_update_segment(uint16_t selector, void *segbase)
         return LIB_ERR_LDT_SELECTOR_INVALID;
     }
 
-    int index = X86_64_SELECTOR_IDX(selector);
+    int idx = X86_64_SELECTOR_IDX(selector);
 
     // check that this entry is occupied
-    if (index >= LDT_NENTRIES || !ldt[index].d.present) {
+    if (idx >= LDT_NENTRIES || !ldt[idx].d.present) {
         return LIB_ERR_LDT_SELECTOR_INVALID;
     }
 
@@ -193,8 +733,8 @@ errval_t ldt_update_segment(uint16_t selector, void *segbase)
     }
 
     // update base address
-    ldt[index].d.lo_base = ((lvaddr_t) segbase) & 0xffffff;
-    ldt[index].d.hi_base = (((lvaddr_t) segbase) >> 24) & 0xff;
+    ldt[idx].d.lo_base = ((lvaddr_t) segbase) & 0xffffff;
+    ldt[idx].d.hi_base = (((lvaddr_t) segbase) >> 24) & 0xff;
 
     return SYS_ERR_OK;
 }
diff --git a/lib/barrelfish/arch/x86_64/sys_debug.c b/lib/barrelfish/arch/x86_64/sys_debug.c
index 52b7b08..bca0103 100644
--- a/lib/barrelfish/arch/x86_64/sys_debug.c
+++ b/lib/barrelfish/arch/x86_64/sys_debug.c
@@ -66,6 +66,13 @@ errval_t sys_debug_get_tsc_per_ms(uint64_t *ret)
     return sr.error;
 }
 
+errval_t sys_debug_get_apic_id(uint8_t *ret)
+{
+    struct sysret sr = syscall2(SYSCALL_DEBUG, DEBUG_GET_APIC_ID);
+    *ret = sr.value;
+    return sr.error;
+}
+
 errval_t sys_debug_get_apic_timer(uint32_t *ret)
 {
     struct sysret sr = syscall2(SYSCALL_DEBUG, DEBUG_GET_APIC_TIMER);
diff --git a/lib/barrelfish/debug.c b/lib/barrelfish/debug.c
index c3b0f6b..da95267 100644
--- a/lib/barrelfish/debug.c
+++ b/lib/barrelfish/debug.c
@@ -326,10 +326,10 @@ int debug_print_capref(char *buf, size_t len, struct capref cap)
                     get_cap_valid_bits(cap));
 }
 
-void debug_dump_mem(lvaddr_t start_addr, lvaddr_t end_addr)
+void debug_dump_mem(lvaddr_t start_addr, lvaddr_t end_addr, lvaddr_t point)
 {
-    debug_printf("Dumping memory in range 0x%" PRIuLVADDR
-                 " to 0x%" PRIuLVADDR ":\n",
+    debug_printf("Dumping memory in range 0x%" PRIxLVADDR
+                 " to 0x%" PRIxLVADDR ":\n",
                  start_addr, end_addr);
 
     for (uintptr_t *p = (void *)start_addr; (uintptr_t)p < end_addr; p++) {
@@ -340,25 +340,26 @@ void debug_dump_mem(lvaddr_t start_addr, lvaddr_t end_addr)
             bufpos += snprintf(&buf[bufpos], sizeof(buf) - bufpos, "%02x ", bytes[i]);
             assert(bufpos < sizeof(buf));
         }
-        debug_printf("%p: %.*s %*" PRIxPTR "\n", p, (int)sizeof(buf), buf,
-                     (int)sizeof(uintptr_t) * 2, *p);
+        debug_printf("%p: %.*s %*" PRIxPTR "%s\n", p, (int)sizeof(buf), buf,
+                     (int)sizeof(uintptr_t) * 2, *p,
+                     p == (uintptr_t *)point ? " <== We are here" : "");
     }
 }
 
 void debug_dump_mem_around_addr(lvaddr_t addr)
 {
-    lvaddr_t page_aligned_addr = ROUND_DOWN(addr, BASE_PAGE_SIZE);
+    /* lvaddr_t page_aligned_addr = ROUND_DOWN(addr, BASE_PAGE_SIZE); */
     lvaddr_t start_addr = ROUND_DOWN(addr - DISP_MEMORY_SIZE/2, sizeof(uintptr_t));
     lvaddr_t end_addr = ROUND_UP(addr + DISP_MEMORY_SIZE/2, sizeof(uintptr_t));
 
-    if (start_addr < page_aligned_addr) {
-        start_addr = page_aligned_addr;
-    }
-    if (end_addr > page_aligned_addr + BASE_PAGE_SIZE) {
-        end_addr = page_aligned_addr + BASE_PAGE_SIZE;
-    }
+    /* if (start_addr < page_aligned_addr) { */
+    /*     start_addr = page_aligned_addr; */
+    /* } */
+    /* if (end_addr > page_aligned_addr + BASE_PAGE_SIZE) { */
+    /*     end_addr = page_aligned_addr + BASE_PAGE_SIZE; */
+    /* } */
 
-    debug_dump_mem(start_addr, end_addr);
+    debug_dump_mem(start_addr, end_addr, addr);
 }
 
 void debug_err(const char *file, const char *func, int line, errval_t err,
diff --git a/lib/barrelfish/deferred.c b/lib/barrelfish/deferred.c
index 88a2710..3a536b2 100644
--- a/lib/barrelfish/deferred.c
+++ b/lib/barrelfish/deferred.c
@@ -4,7 +4,7 @@
  */
 
 /*
- * Copyright (c) 2009, 2011, 2012, ETH Zurich.
+ * Copyright (c) 2009, 2011, 2012, 2013, ETH Zurich.
  * All rights reserved.
  *
  * This file is distributed under the terms in the attached LICENSE file.
@@ -112,18 +112,49 @@ errval_t deferred_event_register(struct deferred_event *event,
     return err;
 }
 
+static void usleep_callback(void *val)
+{
+    bool *wakeup = val;
+    *wakeup = true;
+}
+
+errval_t barrelfish_usleep(delayus_t delay)
+{
+    struct deferred_event dev;
+    struct waitset ws;
+    errval_t err;
+    bool wakeup = false;
+
+    deferred_event_init(&dev);
+    waitset_init(&ws);
+    err = deferred_event_register(&dev, &ws, delay,
+                                  MKCLOSURE(usleep_callback, &wakeup));
+    if(err_is_fail(err)) {
+        return err;
+    }
+
+    while(!wakeup) {
+        err = event_dispatch(&ws);
+        if(err_is_fail(err)) {
+            return err;
+        }
+    }
+
+    return waitset_destroy(&ws);
+}
+
 /**
  * \brief Cancel a deferred event that has not yet fired
  */
 errval_t deferred_event_cancel(struct deferred_event *event)
 {
+    enum ws_chanstate chanstate = event->waitset_state.state;
     dispatcher_handle_t dh = disp_disable();
     errval_t err = waitset_chan_deregister_disabled(&event->waitset_state);
-    if (err_is_ok(err)) {
+    if (err_is_ok(err) && chanstate != CHAN_PENDING) {
         // remove from dispatcher queue
         struct dispatcher_generic *disp = get_dispatcher_generic(dh);
         if (event->prev == NULL) {
-            assert(disp->deferred_events == event);
             disp->deferred_events = event->next;
         } else {
             event->prev->next = event->next;
@@ -194,7 +225,7 @@ void trigger_deferred_events_disabled(dispatcher_handle_t dh, systime_t now)
 
     for (e = dg->deferred_events; e != NULL && e->time <= now; e = e->next) {
         err = waitset_chan_trigger_disabled(&e->waitset_state, dh);
-        assert(err_is_ok(err));
+        assert_disabled(err_is_ok(err));
     }
     dg->deferred_events = e;
     if (e != NULL) {
diff --git a/lib/barrelfish/dispatch.c b/lib/barrelfish/dispatch.c
index 92c0859..b1724d4 100644
--- a/lib/barrelfish/dispatch.c
+++ b/lib/barrelfish/dispatch.c
@@ -75,6 +75,13 @@ uint64_t disp_run_counter(void)
  */
 void disp_run(dispatcher_handle_t handle)
 {
+#ifdef __x86_64__
+    struct dispatcher_x86_64 *disp_priv = get_dispatcher_x86_64(handle);
+    /* load compatibility dispatcher segment to FS */
+    __asm volatile("mov %%ax, %%fs"
+                   : /* No outputs */
+                   : "a" (disp_priv->disp_seg_selector));
+#endif
     // We can't call printf(), so do this silly thing...
 //    assert_print("FIXME: infinite while loop\n");
 //    while(1);
diff --git a/lib/barrelfish/domain.c b/lib/barrelfish/domain.c
index 6b3016b..bd0bcad 100644
--- a/lib/barrelfish/domain.c
+++ b/lib/barrelfish/domain.c
@@ -1123,6 +1123,25 @@ void set_spawn_rpc_client(coreid_t core, struct spawn_rpc_client *c)
     disp->core_state.c.spawn_rpc_clients[core] = c;
 }
 
+struct arrakis_rpc_client *get_arrakis_rpc_client(coreid_t core)
+{
+    dispatcher_handle_t handle = curdispatcher();
+    struct dispatcher_generic* disp = get_dispatcher_generic(handle);
+    assert(core < MAX_CPUS);
+    return disp->core_state.c.arrakis_rpc_clients[core];
+}
+
+/**
+ * \brief set the chips_context state on the dispatcher priv
+ */
+void set_arrakis_rpc_client(coreid_t core, struct arrakis_rpc_client *c)
+{
+    dispatcher_handle_t handle = curdispatcher();
+    struct dispatcher_generic* disp = get_dispatcher_generic(handle);
+    assert(core < MAX_CPUS);
+    disp->core_state.c.arrakis_rpc_clients[core] = c;
+}
+
 /**
  * \brief Returns a pointer to the terminal state on the dispatcher priv
  */
diff --git a/lib/barrelfish/include/threads_priv.h b/lib/barrelfish/include/threads_priv.h
index a26e3f2..760450b 100644
--- a/lib/barrelfish/include/threads_priv.h
+++ b/lib/barrelfish/include/threads_priv.h
@@ -13,6 +13,9 @@
 #include <barrelfish/dispatcher_arch.h>
 #include <barrelfish/except.h>
 
+/// Maximum number of thread-local storage keys
+#define MAX_TLS         16
+
 /** \brief TLS dynamic thread vector data structure
  *
  * See: ELF handling for thread-local storage. Ulrich Drepper, Dec 2005.
@@ -51,6 +54,7 @@ struct thread {
     void                *exception_stack_top; ///< Bounds of exception stack
     exception_handler_fn exception_handler; ///< Exception handler, or NULL
     void                *userptr;           ///< User's thread local pointer
+    void                *userptrs[MAX_TLS]; ///< User's thread local pointers
     uintptr_t           yield_epoch;        ///< Yield epoch
     void                *wakeup_reason;     ///< Value returned from block()
     coreid_t            coreid;             ///< XXX: Core ID affinity
@@ -68,6 +72,7 @@ struct thread {
 #endif
     arch_registers_fpu_state_t fpu_state;   ///< FPU state
     void                *slab;              ///< Base of slab block containing this TCB
+    uintptr_t           id;                 ///< User-defined thread identifier
 };
 
 void thread_enqueue(struct thread *thread, struct thread **queue);
diff --git a/lib/barrelfish/include/waitset_chan_priv.h b/lib/barrelfish/include/waitset_chan_priv.h
index 9c29a1f..37408ee 100644
--- a/lib/barrelfish/include/waitset_chan_priv.h
+++ b/lib/barrelfish/include/waitset_chan_priv.h
@@ -27,9 +27,6 @@ errval_t waitset_chan_deregister_disabled(struct waitset_chanstate *chan);
 errval_t waitset_chan_register_disabled(struct waitset *ws,
                                         struct waitset_chanstate *chan,
                                         struct event_closure closure);
-errval_t waitset_chan_register_polled(struct waitset *ws,
-                                      struct waitset_chanstate *chan,
-                                      struct event_closure closure);
 errval_t waitset_chan_register_polled_disabled(struct waitset *ws,
                                                struct waitset_chanstate *chan,
                                                struct event_closure closure,
diff --git a/lib/barrelfish/init.c b/lib/barrelfish/init.c
index a803a54..5d50b7d 100644
--- a/lib/barrelfish/init.c
+++ b/lib/barrelfish/init.c
@@ -276,6 +276,19 @@ errval_t barrelfish_init_onthread(struct spawn_domain_params *params)
         return err_push(err, LIB_ERR_DOMAIN_INIT);
     }
 
+    // XXX: Record text/data mappings from environment
+    char *p = getenv("ARRAKIS_PMAP");
+    if(p != NULL) {
+        struct morecore_state *mcstate = get_morecore_state();
+        for(mcstate->v2p_entries = 0; *p != '\0'; mcstate->v2p_entries++) {
+            assert(mcstate->v2p_entries < MAX_V2P_MAPPINGS);
+            struct v2pmap *e = &mcstate->v2p_mappings[mcstate->v2p_entries];
+            int r = sscanf(p, "%" PRIxGENVADDR ":%" PRIxGENPADDR ":%zx ", &e->va, &e->pa, &e->size);
+            assert(r == 3);
+            p = strchr(p, ' ') + 1;
+        }
+    }
+
     return err;
 }
 
diff --git a/lib/barrelfish/inthandler.c b/lib/barrelfish/inthandler.c
index 918e0ae..469d01b 100644
--- a/lib/barrelfish/inthandler.c
+++ b/lib/barrelfish/inthandler.c
@@ -16,6 +16,8 @@
 #include <barrelfish/inthandler.h>
 #include <if/monitor_blocking_rpcclient_defs.h>
 
+struct waitset *barrelfish_interrupt_waitset = NULL;
+
 /* allocate inrq */
 static errval_t arm_allocirq(struct capref ep, uint32_t irq)
 {
@@ -75,7 +77,7 @@ static void generic_interrupt_handler(void *arg)
         .handler = generic_interrupt_handler,
         .arg = arg,
     };
-    err = lmp_endpoint_register(state->idcep, get_default_waitset(), cl);
+    err = lmp_endpoint_register(state->idcep, barrelfish_interrupt_waitset, cl);
     assert(err_is_ok(err));
 }
 
@@ -146,6 +148,10 @@ errval_t inthandler_setup(interrupt_handler_fn handler, void *handler_arg,
 {
     errval_t err;
 
+    if(barrelfish_interrupt_waitset == NULL) {
+        barrelfish_interrupt_waitset = get_default_waitset();
+    }
+
     /* alloc state */
     struct interrupt_handler_state *state;
     state = malloc(sizeof(struct interrupt_handler_state));
@@ -175,7 +181,7 @@ errval_t inthandler_setup(interrupt_handler_fn handler, void *handler_arg,
         .handler = generic_interrupt_handler,
         .arg = state,
     };
-    err = lmp_endpoint_register(state->idcep, get_default_waitset(), cl);
+    err = lmp_endpoint_register(state->idcep, barrelfish_interrupt_waitset, cl);
     if (err_is_fail(err)) {
         lmp_endpoint_free(state->idcep);
         // TODO: release vector
diff --git a/lib/barrelfish/spawn_client.c b/lib/barrelfish/spawn_client.c
index 46bf705..4b68065 100644
--- a/lib/barrelfish/spawn_client.c
+++ b/lib/barrelfish/spawn_client.c
@@ -21,6 +21,7 @@
 #include <barrelfish/spawn_client.h>
 #include <barrelfish/cpu_arch.h>
 #include <if/spawn_rpcclient_defs.h>
+#include <if/arrakis_rpcclient_defs.h>
 #include <vfs/vfs_path.h>
 
 extern char **environ;
@@ -31,6 +32,12 @@ struct spawn_bind_retst {
     bool present;
 };
 
+struct arrakis_bind_retst {
+    errval_t err;
+    struct arrakis_binding *b;
+    bool present;
+};
+
 static void spawn_bind_cont(void *st, errval_t err, struct spawn_binding *b)
 {
     struct spawn_bind_retst *retst = st;
@@ -41,6 +48,16 @@ static void spawn_bind_cont(void *st, errval_t err, struct spawn_binding *b)
     retst->present = true;
 }
 
+static void arrakis_bind_cont(void *st, errval_t err, struct arrakis_binding *b)
+{
+    struct arrakis_bind_retst *retst = st;
+    assert(retst != NULL);
+    assert(!retst->present);
+    retst->err = err;
+    retst->b = b;
+    retst->present = true;
+}
+
 static struct spawn_binding *spawn_b = NULL;
 
 static errval_t bind_client(coreid_t coreid)
@@ -248,6 +265,129 @@ errval_t spawn_program_with_caps(coreid_t coreid, const char *path,
     return msgerr;
 }
 
+errval_t spawn_arrakis_program(coreid_t coreid, const char *path,
+                               char *const argv[], char *const envp[],
+                               struct capref inheritcn_cap,
+                               struct capref argcn_cap, spawn_flags_t flags,
+                               domainid_t *ret_domainid)
+{
+    struct arrakis_rpc_client *cl;
+    errval_t err, msgerr;
+
+    // default to copying our environment
+    if (envp == NULL) {
+        envp = environ;
+    }
+
+    // do we have a arrakis client connection for this core?
+    assert(coreid < MAX_CPUS);
+    cl = get_arrakis_rpc_client(coreid);
+    if (cl == NULL) {
+        char namebuf[16];
+        snprintf(namebuf, sizeof(namebuf), "arrakis.%u", coreid);
+        namebuf[sizeof(namebuf) - 1] = '\0';
+
+        iref_t iref;
+        err = nameservice_blocking_lookup(namebuf, &iref);
+        if (err_is_fail(err)) {
+            //DEBUG_ERR(err, "arrakis daemon on core %u not found\n", coreid);
+            return err;
+        }
+
+        // initiate bind
+        struct arrakis_bind_retst bindst = { .present = false };
+        err = arrakis_bind(iref, arrakis_bind_cont, &bindst, get_default_waitset(),
+                           IDC_BIND_FLAGS_DEFAULT);
+        if (err_is_fail(err)) {
+            USER_PANIC_ERR(err, "arrakis_bind failed");
+        }
+
+        // XXX: block for bind completion
+        while (!bindst.present) {
+            messages_wait_and_handle_next();
+        }
+
+        if(err_is_fail(bindst.err)) {
+            USER_PANIC_ERR(bindst.err, "asynchronous error during arrakis_bind");
+        }
+        assert(bindst.b != NULL);
+
+        cl = malloc(sizeof(struct arrakis_rpc_client));
+        assert(cl != NULL);
+
+        err = arrakis_rpc_client_init(cl, bindst.b);
+        if (err_is_fail(err)) {
+            USER_PANIC_ERR(err, "arrakis_rpc_client_init failed");
+        }
+
+        set_arrakis_rpc_client(coreid, cl);
+    }
+
+    // construct argument "string"
+    // \0-separated strings in contiguous character buffer
+    // this is needed, as flounder can't send variable-length arrays of strings
+    size_t argstrlen = 0;
+    for (int i = 0; argv[i] != NULL; i++) {
+        argstrlen += strlen(argv[i]) + 1;
+    }
+
+    char argstr[argstrlen];
+    size_t argstrpos = 0;
+    for (int i = 0; argv[i] != NULL; i++) {
+        strcpy(&argstr[argstrpos], argv[i]);
+        argstrpos += strlen(argv[i]);
+        argstr[argstrpos++] = '\0';
+    }
+    assert(argstrpos == argstrlen);
+
+    // repeat for environment
+    size_t envstrlen = 0;
+    for (int i = 0; envp[i] != NULL; i++) {
+        envstrlen += strlen(envp[i]) + 1;
+    }
+
+    char envstr[envstrlen];
+    size_t envstrpos = 0;
+    for (int i = 0; envp[i] != NULL; i++) {
+        strcpy(&envstr[envstrpos], envp[i]);
+        envstrpos += strlen(envp[i]);
+        envstr[envstrpos++] = '\0';
+    }
+    assert(envstrpos == envstrlen);
+
+
+    domainid_t domain_id;
+
+    // make an unqualified path absolute using the $PATH variable
+    // TODO: implement search (currently assumes PATH is a single directory)
+    char *searchpath = getenv("PATH");
+    if (searchpath == NULL) {
+        searchpath = VFS_PATH_SEP_STR; // XXX: just put it in the root
+    }
+    size_t buflen = strlen(path) + strlen(searchpath) + 2;
+    char pathbuf[buflen];
+    if (path[0] != VFS_PATH_SEP) {
+        snprintf(pathbuf, buflen, "%s%c%s", searchpath, VFS_PATH_SEP, path);
+        pathbuf[buflen - 1] = '\0';
+        //vfs_path_normalise(pathbuf);
+        path = pathbuf;
+    }
+
+    err = cl->vtbl.spawn_arrakis_domain(cl, path, argstr, argstrlen,
+                                        envstr, envstrlen, &msgerr, &domain_id);
+    if (err_is_fail(err)) {
+        USER_PANIC_ERR(err, "error sending arrakis request");
+    } else if (err_is_fail(msgerr)) {
+        return msgerr;
+    }
+
+    if (ret_domainid != NULL) {
+        *ret_domainid = domain_id;
+    }
+
+    return msgerr;
+}
+
 
 /**
  * \brief Request the spawn daemon on a specific core to spawn a program
diff --git a/lib/barrelfish/threads.c b/lib/barrelfish/threads.c
index 594012e..d08d27c 100644
--- a/lib/barrelfish/threads.c
+++ b/lib/barrelfish/threads.c
@@ -241,6 +241,7 @@ static void thread_init(dispatcher_handle_t disp, struct thread *newthread)
     newthread->disp = disp;
     newthread->coreid = get_dispatcher_generic(disp)->core_id;
     newthread->userptr = NULL;
+    memset(newthread->userptrs, 0, sizeof(newthread->userptrs));
     newthread->yield_epoch = 0;
     newthread->wakeup_reason = NULL;
     newthread->return_value = 0;
@@ -583,6 +584,17 @@ struct thread *thread_self(void)
     return me;
 }
 
+uintptr_t thread_id(void)
+{
+    return thread_self()->id;
+}
+
+void thread_set_id(uintptr_t id)
+{
+    struct thread *me = thread_self();
+    me->id = id;
+}
+
 /**
  * \brief Yield the calling thread
  *
@@ -1248,6 +1260,12 @@ void thread_set_tls(void *p)
     me->userptr = p;
 }
 
+void thread_set_tls_key(int key, void *p)
+{
+    struct thread *me = thread_self();
+    me->userptrs[key] = p;
+}
+
 /**
  * \brief Return old-style thread-local storage pointer.
  * \return User's pointer, previously passed to thread_set_tls()
@@ -1258,6 +1276,12 @@ void *thread_get_tls(void)
     return me->userptr;
 }
 
+void *thread_get_tls_key(int key)
+{
+    struct thread *me = thread_self();
+    return me->userptrs[key];
+}
+
 /**
  * \brief Set the exception handler function for the current thread.
  *        Optionally also change its stack, and return the old values.
diff --git a/lib/barrelfish/vspace/memobj_anon.c b/lib/barrelfish/vspace/memobj_anon.c
index 0c5c03a..ad14cc3 100644
--- a/lib/barrelfish/vspace/memobj_anon.c
+++ b/lib/barrelfish/vspace/memobj_anon.c
@@ -224,6 +224,13 @@ static errval_t fill(struct memobj *memobj, genvaddr_t offset, struct capref fra
     new->frame  = frame;
     new->size   = size;
 
+    {
+        struct frame_identity id;
+        err = invoke_frame_identify(frame, &id);
+        assert(err_is_ok(err));
+        new->pa = id.base;
+    }
+
     // Insert in order
     struct memobj_frame_list *walk = anon->frame_list;
     struct memobj_frame_list *prev = NULL;
diff --git a/lib/barrelfish/waitset.c b/lib/barrelfish/waitset.c
index 1aacbfc..cb2c2b6 100644
--- a/lib/barrelfish/waitset.c
+++ b/lib/barrelfish/waitset.c
@@ -129,7 +129,7 @@ static struct waitset_chanstate *get_pending_event_disabled(struct waitset *ws)
     // dequeue next pending event
     struct waitset_chanstate *chan = ws->pending;
     if (chan->next == chan) {
-        assert(chan->prev == chan);
+        assert_disabled(chan->prev == chan);
         ws->pending = NULL;
     } else {
         ws->pending = chan->next;
@@ -141,7 +141,7 @@ static struct waitset_chanstate *get_pending_event_disabled(struct waitset *ws)
 #endif
 
     // mark not pending
-    assert(chan->state == CHAN_PENDING);
+    assert_disabled(chan->state == CHAN_PENDING);
     chan->state = CHAN_UNREGISTERED;
     chan->waitset = NULL;
 
@@ -167,6 +167,12 @@ static inline void ump_endpoint_poll(struct waitset_chanstate *chan)
 }
 #endif // CONFIG_INTERCONNECT_DRIVER_UMP
 
+void arranet_polling_loop_proxy(void) __attribute__((weak));
+void arranet_polling_loop_proxy(void)
+{
+    USER_PANIC("Network polling not available without Arranet!\n");
+}
+
 /// Helper function that knows how to poll the given channel, based on its type
 static void poll_channel(struct waitset_chanstate *chan)
 {
@@ -177,6 +183,10 @@ static void poll_channel(struct waitset_chanstate *chan)
         break;
 #endif // CONFIG_INTERCONNECT_DRIVER_UMP
 
+    case CHANTYPE_LWIP_SOCKET:
+        arranet_polling_loop_proxy();
+        break;
+
     default:
         assert(!"invalid channel type to poll!");
     }
@@ -324,10 +334,10 @@ check_for_events: ;
             // start a blocked thread polling
             struct thread *t;
             t = thread_unblock_one_disabled(handle, &ws->waiting_threads, NULL);
-            assert(t == NULL); // shouldn't see a remote thread
+            assert_disabled(t == NULL); // shouldn't see a remote thread
         } else if (was_polling) {
             // I'm stopping polling, and there is nobody else
-            assert(ws->polling);
+            assert_disabled(ws->polling);
             ws->polling = false;
         }
         disp_enable(handle);
@@ -548,11 +558,11 @@ errval_t waitset_chan_register_disabled(struct waitset *ws,
     chan->waitset = ws;
 
     // channel must not already be registered!
-    assert(chan->next == NULL && chan->prev == NULL);
-    assert(chan->state == CHAN_UNREGISTERED);
+    assert_disabled(chan->next == NULL && chan->prev == NULL);
+    assert_disabled(chan->state == CHAN_UNREGISTERED);
 
     // this is probably insane! :)
-    assert(closure.handler != NULL);
+    assert_disabled(closure.handler != NULL);
 
     // store closure
     chan->closure = closure;
@@ -597,8 +607,8 @@ errval_t waitset_chan_register_polled_disabled(struct waitset *ws,
     chan->waitset = ws;
 
     // channel must not already be registered!
-    assert(chan->next == NULL && chan->prev == NULL);
-    assert(chan->state == CHAN_UNREGISTERED);
+    assert_disabled(chan->next == NULL && chan->prev == NULL);
+    assert_disabled(chan->state == CHAN_UNREGISTERED);
 
     // store closure
     chan->closure = closure;
@@ -612,7 +622,7 @@ errval_t waitset_chan_register_polled_disabled(struct waitset *ws,
             ws->polling = true;
             struct thread *t;
             t = thread_unblock_one_disabled(handle, &ws->waiting_threads, NULL);
-            assert(t == NULL); // shouldn't see a remote thread: waitsets are per-dispatcher
+            assert_disabled(t == NULL); // shouldn't see a remote thread: waitsets are per-dispatcher
         }
     } else {
         chan->next = ws->polled;
@@ -793,7 +803,7 @@ out:
  */
 errval_t waitset_chan_deregister_disabled(struct waitset_chanstate *chan)
 {
-    assert(chan != NULL);
+    assert_disabled(chan != NULL);
     struct waitset *ws = chan->waitset;
     if (ws == NULL) {
         return LIB_ERR_CHAN_NOT_REGISTERED;
@@ -801,32 +811,32 @@ errval_t waitset_chan_deregister_disabled(struct waitset_chanstate *chan)
 
     // remove this channel from the queue in which it is waiting
     chan->waitset = NULL;
-    assert(chan->next != NULL && chan->prev != NULL);
+    assert_disabled(chan->next != NULL && chan->prev != NULL);
 
     if (chan->next == chan) {
         // only thing in the list: must be the head
-        assert(chan->prev == chan);
+        assert_disabled(chan->prev == chan);
         switch (chan->state) {
         case CHAN_IDLE:
-            assert(chan == ws->idle);
+            assert_disabled(chan == ws->idle);
             ws->idle = NULL;
             break;
 
         case CHAN_POLLED:
-            assert(chan == ws->polled);
+            assert_disabled(chan == ws->polled);
             ws->polled = NULL;
             break;
 
         case CHAN_PENDING:
-            assert(chan == ws->pending);
+            assert_disabled(chan == ws->pending);
             ws->pending = NULL;
             break;
 
         default:
-            assert(!"invalid channel state in deregister");
+            assert_disabled(!"invalid channel state in deregister");
         }
     } else {
-        assert(chan->prev != chan);
+        assert_disabled(chan->prev != chan);
         chan->prev->next = chan->next;
         chan->next->prev = chan->prev;
         switch (chan->state) {
@@ -849,7 +859,7 @@ errval_t waitset_chan_deregister_disabled(struct waitset_chanstate *chan)
             break;
 
         default:
-            assert(!"invalid channel state in deregister");
+            assert_disabled(!"invalid channel state in deregister");
         }
     }
     chan->state = CHAN_UNREGISTERED;
@@ -988,10 +998,10 @@ void waitset_chan_migrate(struct waitset_chanstate *chan,
 errval_t waitset_chan_trigger_disabled(struct waitset_chanstate *chan,
                                        dispatcher_handle_t handle)
 {
-    assert(chan != NULL);
+    assert_disabled(chan != NULL);
     struct waitset *ws = chan->waitset;
-    assert(ws != NULL);
-    assert(chan->prev != NULL && chan->next != NULL);
+    assert_disabled(ws != NULL);
+    assert_disabled(chan->prev != NULL && chan->next != NULL);
 
     // no-op if already pending
     if (chan->state == CHAN_PENDING) {
@@ -1000,13 +1010,13 @@ errval_t waitset_chan_trigger_disabled(struct waitset_chanstate *chan,
 
     // remove from previous queue (either idle or polled)
     if (chan->next == chan) {
-        assert(chan->prev == chan);
+        assert_disabled(chan->prev == chan);
         if (chan->state == CHAN_IDLE) {
-            assert(ws->idle == chan);
+            assert_disabled(ws->idle == chan);
             ws->idle = NULL;
         } else {
-            assert(chan->state == CHAN_POLLED);
-            assert(ws->polled == chan);
+            assert_disabled(chan->state == CHAN_POLLED);
+            assert_disabled(ws->polled == chan);
             ws->polled = NULL;
         }
     } else {
@@ -1017,7 +1027,7 @@ errval_t waitset_chan_trigger_disabled(struct waitset_chanstate *chan,
                 ws->idle = chan->next;
             }
         } else {
-            assert(chan->state == CHAN_POLLED);
+            assert_disabled(chan->state == CHAN_POLLED);
             if (ws->polled == chan) {
                 ws->polled = chan->next;
             }
@@ -1033,7 +1043,7 @@ errval_t waitset_chan_trigger_disabled(struct waitset_chanstate *chan,
         chan->state = CHAN_UNREGISTERED;
         struct thread *t;
         t = thread_unblock_one_disabled(handle, &ws->waiting_threads, chan);
-        assert(t == NULL);
+        assert_disabled(t == NULL);
         return SYS_ERR_OK;
     }
 
@@ -1045,6 +1055,9 @@ errval_t waitset_chan_trigger_disabled(struct waitset_chanstate *chan,
     } else {
         chan->next = ws->pending;
         chan->prev = ws->pending->prev;
+        assert_disabled(ws->pending->next != NULL);
+        assert_disabled(ws->pending->prev != NULL);
+        assert_disabled(chan->prev != NULL);
         chan->next->prev = chan;
         chan->prev->next = chan;
     }
@@ -1087,15 +1100,15 @@ errval_t waitset_chan_trigger_closure_disabled(struct waitset *ws,
                                                struct event_closure closure,
                                                dispatcher_handle_t handle)
 {
-    assert(chan != NULL);
-    assert(ws != NULL);
+    assert_disabled(chan != NULL);
+    assert_disabled(ws != NULL);
 
     // check if already registered
     if (chan->waitset != NULL || chan->state != CHAN_UNREGISTERED) {
         return LIB_ERR_CHAN_ALREADY_REGISTERED;
     }
 
-    assert(chan->prev == NULL && chan->next == NULL);
+    assert_disabled(chan->prev == NULL && chan->next == NULL);
 
     // set closure
     chan->closure = closure;
@@ -1104,7 +1117,7 @@ errval_t waitset_chan_trigger_closure_disabled(struct waitset *ws,
     if (ws->waiting_threads != NULL) {
         struct thread *t;
         t = thread_unblock_one_disabled(handle, &ws->waiting_threads, chan);
-        assert(t == NULL);
+        assert_disabled(t == NULL);
         return SYS_ERR_OK;
     }
 
@@ -1121,6 +1134,8 @@ errval_t waitset_chan_trigger_closure_disabled(struct waitset *ws,
         chan->prev->next = chan;
     }
 
+    assert(ws->pending->prev != NULL && ws->pending->next != NULL);
+
     return SYS_ERR_OK;
 }
 
diff --git a/lib/lwip/Hakefile b/lib/lwip/Hakefile
index 47f1451..c5ca2ec 100644
--- a/lib/lwip/Hakefile
+++ b/lib/lwip/Hakefile
@@ -1,5 +1,5 @@
 --------------------------------------------------------------------------
--- Copyright (c) 2007-2009, 2011, 2012, ETH Zurich.
+-- Copyright (c) 2007-2009, 2011, 2013, ETH Zurich.
 -- All rights reserved.
 --
 -- This file is distributed under the terms in the attached LICENSE file.
diff --git a/lib/lwip/src/api/sockets.c b/lib/lwip/src/api/sockets.c
index a67ac4a..cfac7b0 100644
--- a/lib/lwip/src/api/sockets.c
+++ b/lib/lwip/src/api/sockets.c
@@ -713,6 +713,13 @@ int lwip_send(int s, const void *data, size_t size, int flags)
     return (err == ERR_OK ? (int) size : -1);
 }
 
+// XXX: Here for upwards-compatibility with lwIP 1.4.1
+int
+lwip_fcntl(int fd, int cmd, int val)
+{
+    assert(!"NYI");
+}
+
 int
 lwip_sendto(int s, const void *data, size_t size, int flags,
             const struct sockaddr *to, socklen_t tolen)
@@ -824,6 +831,11 @@ lwip_sendto(int s, const void *data, size_t size, int flags,
     return (err == ERR_OK ? short_size : -1);
 }
 
+int lwip_sendmsg(int sockfd, const struct msghdr *msg, int flags)
+{
+    assert(!"NYI");
+}
+
 int lwip_socket(int domain, int type, int protocol)
 {
     struct netconn *conn;
@@ -2281,6 +2293,11 @@ bool lwip_sock_ready_write(int socket)
     return is_ready;
 }
 
+bool lwip_sock_is_open(int s)
+{
+    assert(!"NYI");
+}
+
 static void do_nothing(void *arg)
 {
     return;
diff --git a/lib/lwip/src/include/arch/sys_arch.h b/lib/lwip/src/include/arch/sys_arch.h
new file mode 100644
index 0000000..6497993
--- /dev/null
+++ b/lib/lwip/src/include/arch/sys_arch.h
@@ -0,0 +1,36 @@
+/*
+ * Copyright (c) 2007, 2008, 2009, 2011, 2012, ETH Zurich.
+ * All rights reserved.
+ *
+ * This file is distributed under the terms in the attached LICENSE file.
+ * If you do not find this file, copies can be found by writing to:
+ * ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich. Attn: Systems Group.
+ */
+
+#ifndef SYS_ARCH_H
+#define SYS_ARCH_H
+
+#include <stdbool.h>
+#include <assert.h>
+#include <barrelfish/thread_sync.h>
+
+/// Protection level
+typedef u8_t    sys_prot_t;
+
+typedef struct thread_wrapper *sys_thread_t;
+
+typedef struct thread_sem *sys_sem_t;
+
+struct bf_sys_mbox {
+    void *msg;
+    bool empty;
+    struct thread_mutex mutex;
+    struct thread_cond changed_cond;
+};
+typedef struct bf_sys_mbox * sys_mbox_t;
+
+
+#define SYS_MBOX_NULL   0
+#define SYS_SEM_NULL    0
+
+#endif
diff --git a/lib/lwip/src/include/ipv4/lwip/autoip.h b/lib/lwip/src/include/ipv4/lwip/autoip.h
new file mode 100644
index 0000000..83c0da5
--- /dev/null
+++ b/lib/lwip/src/include/ipv4/lwip/autoip.h
@@ -0,0 +1,104 @@
+/**
+ * @file
+ *
+ * AutoIP Automatic LinkLocal IP Configuration
+ */
+
+/*
+ *
+ * Copyright (c) 2007 Dominik Spies <kontakt@dspies.de>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * Author: Dominik Spies <kontakt@dspies.de>
+ *
+ * This is a AutoIP implementation for the lwIP TCP/IP stack. It aims to conform
+ * with RFC 3927.
+ *
+ *
+ * Please coordinate changes and requests with Dominik Spies
+ * <kontakt@dspies.de>
+ */
+
+#ifndef __LWIP_AUTOIP_H__
+#define __LWIP_AUTOIP_H__
+
+#include "lwip/opt.h"
+
+#if LWIP_AUTOIP                 /* don't build if not configured for use in lwipopts.h */
+
+#include "lwip/netif.h"
+#include "lwip/udp.h"
+#include "netif/etharp.h"
+
+/* AutoIP Timing */
+#define AUTOIP_TMR_INTERVAL      100
+#define AUTOIP_TICKS_PER_SECOND (1000 / AUTOIP_TMR_INTERVAL)
+
+/* RFC 3927 Constants */
+#define PROBE_WAIT               1      /* second   (initial random delay)                 */
+#define PROBE_MIN                1      /* second   (minimum delay till repeated probe)    */
+#define PROBE_MAX                2      /* seconds  (maximum delay till repeated probe)    */
+#define PROBE_NUM                3      /*          (number of probe packets)              */
+#define ANNOUNCE_NUM             2      /*          (number of announcement packets)       */
+#define ANNOUNCE_INTERVAL        2      /* seconds  (time between announcement packets)    */
+#define ANNOUNCE_WAIT            2      /* seconds  (delay before announcing)              */
+#define MAX_CONFLICTS            10     /*          (max conflicts before rate limiting)   */
+#define RATE_LIMIT_INTERVAL      60     /* seconds  (delay between successive attempts)    */
+#define DEFEND_INTERVAL          10     /* seconds  (min. wait between defensive ARPs)     */
+
+/* AutoIP client states */
+#define AUTOIP_STATE_OFF         0
+#define AUTOIP_STATE_PROBING     1
+#define AUTOIP_STATE_ANNOUNCING  2
+#define AUTOIP_STATE_BOUND       3
+
+struct autoip {
+    struct ip_addr llipaddr;    /* the currently selected, probed, announced or used LL IP-Address */
+    u8_t state;                 /* current AutoIP state machine state */
+    u8_t sent_num;              /* sent number of probes or announces, dependent on state */
+    u16_t ttw;                  /* ticks to wait, tick is AUTOIP_TMR_INTERVAL long */
+    u8_t lastconflict;          /* ticks until a conflict can be solved by defending */
+    u8_t tried_llipaddr;        /* total number of probed/used Link Local IP-Addresses */
+};
+
+
+/** Init srand, has to be called before entering mainloop */
+void autoip_init(void);
+
+/** Start AutoIP client */
+err_t autoip_start(struct netif *netif);
+
+/** Stop AutoIP client */
+err_t autoip_stop(struct netif *netif);
+
+/** Handles every incoming ARP Packet, called by etharp_arp_input */
+void autoip_arp_reply(struct netif *netif, struct etharp_hdr *hdr);
+
+/** Has to be called in loop every AUTOIP_TMR_INTERVAL milliseconds */
+void autoip_tmr(void);
+
+#endif                          /* LWIP_AUTOIP */
+
+#endif                          /* __LWIP_AUTOIP_H__ */
diff --git a/lib/lwip/src/include/ipv4/lwip/icmp.h b/lib/lwip/src/include/ipv4/lwip/icmp.h
new file mode 100644
index 0000000..fa36e1b
--- /dev/null
+++ b/lib/lwip/src/include/ipv4/lwip/icmp.h
@@ -0,0 +1,110 @@
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved. 
+ * 
+ * Redistribution and use in source and binary forms, with or without modification, 
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission. 
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ * 
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef __LWIP_ICMP_H__
+#define __LWIP_ICMP_H__
+
+#include "lwip/opt.h"
+
+#if LWIP_ICMP                   /* don't build if not configured for use in lwipopts.h */
+
+#include "lwip/pbuf.h"
+#include "lwip/ip_addr.h"
+#include "lwip/netif.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define ICMP_ER 0               /* echo reply */
+#define ICMP_DUR 3              /* destination unreachable */
+#define ICMP_SQ 4               /* source quench */
+#define ICMP_RD 5               /* redirect */
+#define ICMP_ECHO 8             /* echo */
+#define ICMP_TE 11              /* time exceeded */
+#define ICMP_PP 12              /* parameter problem */
+#define ICMP_TS 13              /* timestamp */
+#define ICMP_TSR 14             /* timestamp reply */
+#define ICMP_IRQ 15             /* information request */
+#define ICMP_IR 16              /* information reply */
+
+    enum icmp_dur_type {
+        ICMP_DUR_NET = 0,       /* net unreachable */
+        ICMP_DUR_HOST = 1,      /* host unreachable */
+        ICMP_DUR_PROTO = 2,     /* protocol unreachable */
+        ICMP_DUR_PORT = 3,      /* port unreachable */
+        ICMP_DUR_FRAG = 4,      /* fragmentation needed and DF set */
+        ICMP_DUR_SR = 5         /* source route failed */
+    };
+
+    enum icmp_te_type {
+        ICMP_TE_TTL = 0,        /* time to live exceeded in transit */
+        ICMP_TE_FRAG = 1        /* fragment reassembly time exceeded */
+    };
+
+/* for ICMP notifications needed for ICMP benchmark. */
+    typedef void (*icmp_notification_fn) (struct pbuf * p);
+    void record_icmp_upcall(icmp_notification_fn notification_function_name);
+
+    void icmp_input(struct pbuf *p, struct netif *inp);
+
+    void icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t);
+    void icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t);
+
+#ifdef PACK_STRUCT_USE_INCLUDES
+#include "arch/bpstruct.h"
+#endif
+/** This is the standard ICMP header only that the u32_t data
+ *  is splitted to two u16_t like ICMP echo needs it.
+ *  This header is also used for other ICMP types that do not
+ *  use the data part.
+ */
+     PACK_STRUCT_BEGIN struct icmp_echo_hdr {
+        PACK_STRUCT_FIELD(u8_t type);
+        PACK_STRUCT_FIELD(u8_t code);
+        PACK_STRUCT_FIELD(u16_t chksum);
+        PACK_STRUCT_FIELD(u16_t id);
+        PACK_STRUCT_FIELD(u16_t seqno);
+    } PACK_STRUCT_STRUCT;
+     PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#include "arch/epstruct.h"
+#endif
+#define ICMPH_TYPE(hdr) ((hdr)->type)
+#define ICMPH_CODE(hdr) ((hdr)->code)
+/** Combines type and code to an u16_t */
+#define ICMPH_TYPE_SET(hdr, t) ((hdr)->type = (t))
+#define ICMPH_CODE_SET(hdr, c) ((hdr)->code = (c))
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* LWIP_ICMP */
+#endif                          /* __LWIP_ICMP_H__ */
diff --git a/lib/lwip/src/include/ipv4/lwip/igmp.h b/lib/lwip/src/include/ipv4/lwip/igmp.h
new file mode 100644
index 0000000..43189c8
--- /dev/null
+++ b/lib/lwip/src/include/ipv4/lwip/igmp.h
@@ -0,0 +1,161 @@
+/*
+ * Copyright (c) 2002 CITEL Technologies Ltd.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions 
+ * are met: 
+ * 1. Redistributions of source code must retain the above copyright 
+ *    notice, this list of conditions and the following disclaimer. 
+ * 2. Redistributions in binary form must reproduce the above copyright 
+ *    notice, this list of conditions and the following disclaimer in the 
+ *    documentation and/or other materials provided with the distribution. 
+ * 3. Neither the name of CITEL Technologies Ltd nor the names of its contributors 
+ *    may be used to endorse or promote products derived from this software 
+ *    without specific prior written permission. 
+ *
+ * THIS SOFTWARE IS PROVIDED BY CITEL TECHNOLOGIES AND CONTRIBUTORS ``AS IS''
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
+ * ARE DISCLAIMED.  IN NO EVENT SHALL CITEL TECHNOLOGIES OR CONTRIBUTORS BE LIABLE 
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS 
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY 
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
+ * SUCH DAMAGE. 
+ *
+ * This file is a contribution to the lwIP TCP/IP stack.
+ * The Swedish Institute of Computer Science and Adam Dunkels
+ * are specifically granted permission to redistribute this
+ * source code.
+*/
+
+#ifndef __LWIP_IGMP_H__
+#define __LWIP_IGMP_H__
+
+#include "lwip/opt.h"
+#include "lwip/ip_addr.h"
+#include "lwip/netif.h"
+#include "lwip/pbuf.h"
+
+#if LWIP_IGMP                   /* don't build if not configured for use in lwipopts.h */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* 
+ * IGMP constants
+ */
+#define IP_PROTO_IGMP                  2
+#define IGMP_TTL                       1
+#define IGMP_MINLEN                    8
+#define ROUTER_ALERT                   0x9404
+#define ROUTER_ALERTLEN                4
+
+/*
+ * IGMP message types, including version number.
+ */
+#define IGMP_MEMB_QUERY                0x11     /* Membership query         */
+#define IGMP_V1_MEMB_REPORT            0x12     /* Ver. 1 membership report */
+#define IGMP_V2_MEMB_REPORT            0x16     /* Ver. 2 membership report */
+#define IGMP_LEAVE_GROUP               0x17     /* Leave-group message      */
+
+/* IGMP timer */
+#define IGMP_TMR_INTERVAL              100      /* Milliseconds */
+#define IGMP_V1_DELAYING_MEMBER_TMR   (1000/IGMP_TMR_INTERVAL)
+#define IGMP_JOIN_DELAYING_MEMBER_TMR (500 /IGMP_TMR_INTERVAL)
+
+/* MAC Filter Actions */
+#define IGMP_DEL_MAC_FILTER            0
+#define IGMP_ADD_MAC_FILTER            1
+
+/* Group  membership states */
+#define IGMP_GROUP_NON_MEMBER          0
+#define IGMP_GROUP_DELAYING_MEMBER     1
+#define IGMP_GROUP_IDLE_MEMBER         2
+
+/*
+ * IGMP packet format.
+ */
+#ifdef PACK_STRUCT_USE_INCLUDES
+#include "arch/bpstruct.h"
+#endif
+    PACK_STRUCT_BEGIN struct igmp_msg {
+        PACK_STRUCT_FIELD(u8_t igmp_msgtype);
+        PACK_STRUCT_FIELD(u8_t igmp_maxresp);
+        PACK_STRUCT_FIELD(u16_t igmp_checksum);
+        PACK_STRUCT_FIELD(struct ip_addr igmp_group_address);
+    } PACK_STRUCT_STRUCT;
+     PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#include "arch/epstruct.h"
+#endif
+/* 
+ * now a group structure - there is
+ * a list of groups for each interface
+ * these should really be linked from the interface, but
+ * if we keep them separate we will not affect the lwip original code
+ * too much
+ * 
+ * There will be a group for the all systems group address but this 
+ * will not run the state machine as it is used to kick off reports
+ * from all the other groups
+ */
+      struct igmp_group {
+        struct igmp_group *next;
+        struct netif *interface;
+        struct ip_addr group_address;
+        u8_t last_reporter_flag;        /* signifies we were the last person to report */
+        u8_t group_state;
+        u16_t timer;
+        u8_t use;               /* counter of simultaneous uses */
+    };
+
+
+/*  Prototypes */
+    void igmp_init(void);
+
+    err_t igmp_start(struct netif *netif);
+
+    err_t igmp_stop(struct netif *netif);
+
+    void igmp_report_groups(struct netif *netif);
+
+    struct igmp_group *igmp_lookfor_group(struct netif *ifp,
+                                          struct ip_addr *addr);
+
+    struct igmp_group *igmp_lookup_group(struct netif *ifp,
+                                         struct ip_addr *addr);
+
+    err_t igmp_remove_group(struct igmp_group *group);
+
+    void igmp_input(struct pbuf *p, struct netif *inp, struct ip_addr *dest);
+
+    err_t igmp_joingroup(struct ip_addr *ifaddr, struct ip_addr *groupaddr);
+
+    err_t igmp_leavegroup(struct ip_addr *ifaddr, struct ip_addr *groupaddr);
+
+    void igmp_tmr(void);
+
+    void igmp_timeout(struct igmp_group *group);
+
+    void igmp_start_timer(struct igmp_group *group, u8_t max_time);
+
+    void igmp_stop_timer(struct igmp_group *group);
+
+    void igmp_delaying_member(struct igmp_group *group, u8_t maxresp);
+
+    err_t igmp_ip_output_if(struct pbuf *p, struct ip_addr *src,
+                            struct ip_addr *dest, u8_t ttl, u8_t proto,
+                            struct netif *netif);
+
+    void igmp_send(struct igmp_group *group, u8_t type);
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* LWIP_IGMP */
+#endif                          /* __LWIP_IGMP_H__ */
diff --git a/lib/lwip/src/include/ipv4/lwip/inet.h b/lib/lwip/src/include/ipv4/lwip/inet.h
new file mode 100644
index 0000000..b52698b
--- /dev/null
+++ b/lib/lwip/src/include/ipv4/lwip/inet.h
@@ -0,0 +1,102 @@
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved. 
+ * 
+ * Redistribution and use in source and binary forms, with or without modification, 
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission. 
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ * 
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef __LWIP_INET_H__
+#define __LWIP_INET_H__
+
+#include "lwip/opt.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* For compatibility with BSD code */
+    struct in_addr {
+        u32_t s_addr;
+    };
+
+#define INADDR_NONE         ((u32_t)0xffffffffUL)       /* 255.255.255.255 */
+#define INADDR_LOOPBACK     ((u32_t)0x7f000001UL)       /* 127.0.0.1 */
+#define INADDR_ANY          ((u32_t)0x00000000UL)       /* 0.0.0.0 */
+#define INADDR_BROADCAST    ((u32_t)0xffffffffUL)       /* 255.255.255.255 */
+
+    u32_t inet_addr(const char *cp);
+    int inet_aton(const char *cp, struct in_addr *addr);
+    char *inet_ntoa(struct in_addr addr);       /* returns ptr to static buffer; not reentrant! */
+
+#ifdef htons
+#undef htons
+#endif                          /* htons */
+#ifdef htonl
+#undef htonl
+#endif                          /* htonl */
+#ifdef ntohs
+#undef ntohs
+#endif                          /* ntohs */
+#ifdef ntohl
+#undef ntohl
+#endif                          /* ntohl */
+
+#ifndef LWIP_PLATFORM_BYTESWAP
+#define LWIP_PLATFORM_BYTESWAP 0
+#endif
+
+#if BYTE_ORDER == BIG_ENDIAN
+#define htons(x) (x)
+#define ntohs(x) (x)
+#define htonl(x) (x)
+#define ntohl(x) (x)
+#else                           /* BYTE_ORDER != BIG_ENDIAN */
+#ifdef LWIP_PREFIX_BYTEORDER_FUNCS
+/* workaround for naming collisions on some platforms */
+#define htons lwip_htons
+#define ntohs lwip_ntohs
+#define htonl lwip_htonl
+#define ntohl lwip_ntohl
+#endif                          /* LWIP_PREFIX_BYTEORDER_FUNCS */
+#if LWIP_PLATFORM_BYTESWAP
+#define htons(x) LWIP_PLATFORM_HTONS(x)
+#define ntohs(x) LWIP_PLATFORM_HTONS(x)
+#define htonl(x) LWIP_PLATFORM_HTONL(x)
+#define ntohl(x) LWIP_PLATFORM_HTONL(x)
+#else                           /* LWIP_PLATFORM_BYTESWAP */
+    u16_t htons(u16_t x);
+    u16_t ntohs(u16_t x);
+    u32_t htonl(u32_t x);
+    u32_t ntohl(u32_t x);
+#endif                          /* LWIP_PLATFORM_BYTESWAP */
+
+#endif                          /* BYTE_ORDER == BIG_ENDIAN */
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* __LWIP_INET_H__ */
diff --git a/lib/lwip/src/include/ipv4/lwip/inet_chksum.h b/lib/lwip/src/include/ipv4/lwip/inet_chksum.h
new file mode 100644
index 0000000..98bd72f
--- /dev/null
+++ b/lib/lwip/src/include/ipv4/lwip/inet_chksum.h
@@ -0,0 +1,57 @@
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved. 
+ * 
+ * Redistribution and use in source and binary forms, with or without modification, 
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission. 
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ * 
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef __LWIP_INET_CHKSUM_H__
+#define __LWIP_INET_CHKSUM_H__
+
+#include "lwip/opt.h"
+
+#include "lwip/pbuf.h"
+#include "lwip/ip_addr.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+    u16_t inet_chksum(void *dataptr, u16_t len);
+    u16_t inet_chksum_pbuf(struct pbuf *p);
+    u16_t inet_chksum_pseudo(struct pbuf *p,
+                             struct ip_addr *src, struct ip_addr *dest,
+                             u8_t proto, u16_t proto_len);
+    u16_t inet_chksum_pseudo_partial(struct pbuf *p,
+                                     struct ip_addr *src, struct ip_addr *dest,
+                                     u8_t proto, u16_t proto_len,
+                                     u16_t chksum_len);
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* __LWIP_INET_H__ */
diff --git a/lib/lwip/src/include/ipv4/lwip/ip.h b/lib/lwip/src/include/ipv4/lwip/ip.h
new file mode 100644
index 0000000..f5ad351
--- /dev/null
+++ b/lib/lwip/src/include/ipv4/lwip/ip.h
@@ -0,0 +1,181 @@
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved. 
+ * 
+ * Redistribution and use in source and binary forms, with or without modification, 
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission. 
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ * 
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef __LWIP_IP_H__
+#define __LWIP_IP_H__
+
+#include "lwip/opt.h"
+
+#include "lwip/def.h"
+#include "lwip/pbuf.h"
+#include "lwip/ip_addr.h"
+#include "lwip/err.h"
+#include "lwip/netif.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** Currently, the function ip_output_if_opt() is only used with IGMP */
+#define IP_OPTIONS_SEND   LWIP_IGMP
+
+#define IP_HLEN 20
+
+#define IP_PROTO_ICMP    1
+#define IP_PROTO_UDP     17
+#define IP_PROTO_UDPLITE 136
+#define IP_PROTO_TCP     6
+
+/* This is passed as the destination address to ip_output_if (not
+   to ip_output), meaning that an IP header already is constructed
+   in the pbuf. This is used when TCP retransmits. */
+#ifdef IP_HDRINCL
+#undef IP_HDRINCL
+#endif                          /* IP_HDRINCL */
+#define IP_HDRINCL  NULL
+
+#if LWIP_NETIF_HWADDRHINT
+#define IP_PCB_ADDRHINT ;u8_t addr_hint
+#else
+#define IP_PCB_ADDRHINT
+#endif                          /* LWIP_NETIF_HWADDRHINT */
+
+/* This is the common part of all PCB types. It needs to be at the
+   beginning of a PCB type definition. It is located here so that
+   changes to this common part are made in one location instead of
+   having to change all PCB structs. */
+#define IP_PCB \
+  /* ip addresses in network byte order */ \
+  struct ip_addr local_ip; \
+  struct ip_addr remote_ip; \
+   /* Socket options */  \
+  u16_t so_options;      \
+   /* Type Of Service */ \
+  u8_t tos;              \
+  /* Time To Live */     \
+  u8_t ttl               \
+  /* link layer address resolution hint */ \
+  IP_PCB_ADDRHINT
+
+    struct ip_pcb {
+/* Common members of all PCB types */
+        IP_PCB;
+    };
+
+/*
+ * Option flags per-socket. These are the same like SO_XXX.
+ */
+#define SOF_DEBUG       (u16_t)0x0001U  /* turn on debugging info recording */
+#define SOF_ACCEPTCONN  (u16_t)0x0002U  /* socket has had listen() */
+#define SOF_REUSEADDR   (u16_t)0x0004U  /* allow local address reuse */
+#define SOF_KEEPALIVE   (u16_t)0x0008U  /* keep connections alive */
+#define SOF_DONTROUTE   (u16_t)0x0010U  /* just use interface addresses */
+#define SOF_BROADCAST   (u16_t)0x0020U  /* permit to send and to receive broadcast messages (see IP_SOF_BROADCAST option) */
+#define SOF_USELOOPBACK (u16_t)0x0040U  /* bypass hardware when possible */
+#define SOF_LINGER      (u16_t)0x0080U  /* linger on close if data present */
+#define SOF_OOBINLINE   (u16_t)0x0100U  /* leave received OOB data in line */
+#define SOF_REUSEPORT   (u16_t)0x0200U  /* allow local address & port reuse */
+
+
+#ifdef PACK_STRUCT_USE_INCLUDES
+#include "arch/bpstruct.h"
+#endif
+     PACK_STRUCT_BEGIN struct ip_hdr {
+        /* version / header length / type of service */
+        PACK_STRUCT_FIELD(u16_t _v_hl_tos);
+        /* total length */
+        PACK_STRUCT_FIELD(u16_t _len);
+        /* identification */
+        PACK_STRUCT_FIELD(u16_t _id);
+        /* fragment offset field */
+        PACK_STRUCT_FIELD(u16_t _offset);
+#define IP_RF 0x8000            /* reserved fragment flag */
+#define IP_DF 0x4000            /* dont fragment flag */
+#define IP_MF 0x2000            /* more fragments flag */
+#define IP_OFFMASK 0x1fff       /* mask for fragmenting bits */
+        /* time to live / protocol */
+        PACK_STRUCT_FIELD(u16_t _ttl_proto);
+        /* checksum */
+        PACK_STRUCT_FIELD(u16_t _chksum);
+        /* source and destination IP addresses */
+        PACK_STRUCT_FIELD(struct ip_addr src);
+         PACK_STRUCT_FIELD(struct ip_addr dest);
+    } PACK_STRUCT_STRUCT;
+     PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#include "arch/epstruct.h"
+#endif
+#define IPH_V(hdr)  (ntohs((hdr)->_v_hl_tos) >> 12)
+#define IPH_HL(hdr) ((ntohs((hdr)->_v_hl_tos) >> 8) & 0x0f)
+#define IPH_TOS(hdr) (ntohs((hdr)->_v_hl_tos) & 0xff)
+#define IPH_LEN(hdr) ((hdr)->_len)
+#define IPH_ID(hdr) ((hdr)->_id)
+#define IPH_OFFSET(hdr) ((hdr)->_offset)
+#define IPH_TTL(hdr) (ntohs((hdr)->_ttl_proto) >> 8)
+#define IPH_PROTO(hdr) (ntohs((hdr)->_ttl_proto) & 0xff)
+#define IPH_CHKSUM(hdr) ((hdr)->_chksum)
+#define IPH_VHLTOS_SET(hdr, v, hl, tos) (hdr)->_v_hl_tos = (htons(((v) << 12) | ((hl) << 8) | (tos)))
+#define IPH_LEN_SET(hdr, len) (hdr)->_len = (len)
+#define IPH_ID_SET(hdr, id) (hdr)->_id = (id)
+#define IPH_OFFSET_SET(hdr, off) (hdr)->_offset = (off)
+#define IPH_TTL_SET(hdr, ttl) (hdr)->_ttl_proto = (htons(IPH_PROTO(hdr) | ((u16_t)(ttl) << 8)))
+#define IPH_PROTO_SET(hdr, proto) (hdr)->_ttl_proto = (htons((proto) | (IPH_TTL(hdr) << 8)))
+#define IPH_CHKSUM_SET(hdr, chksum) (hdr)->_chksum = (chksum)
+#define ip_init()               /* Compatibility define, not init needed. */
+    struct netif *ip_route(struct ip_addr *dest);
+    err_t ip_input(struct pbuf *p, struct netif *inp);
+    err_t ip_output(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
+                    u8_t ttl, u8_t tos, u8_t proto);
+    err_t ip_output_if(struct pbuf *p, struct ip_addr *src,
+                       struct ip_addr *dest, u8_t ttl, u8_t tos, u8_t proto,
+                       struct netif *netif);
+#if LWIP_NETIF_HWADDRHINT
+    err_t ip_output_hinted(struct pbuf *p, struct ip_addr *src,
+                           struct ip_addr *dest, u8_t ttl, u8_t tos, u8_t proto,
+                           u8_t * addr_hint);
+#endif                          /* LWIP_NETIF_HWADDRHINT */
+#if IP_OPTIONS_SEND
+    err_t ip_output_if_opt(struct pbuf *p, struct ip_addr *src,
+                           struct ip_addr *dest, u8_t ttl, u8_t tos, u8_t proto,
+                           struct netif *netif, void *ip_options, u16_t optlen);
+#endif                          /* IP_OPTIONS_SEND */
+    struct netif *ip_current_netif(void);
+    const struct ip_hdr *ip_current_header(void);
+#if IP_DEBUG
+    void ip_debug_print(struct pbuf *p);
+#else
+#define ip_debug_print(p)
+#endif                          /* IP_DEBUG */
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* __LWIP_IP_H__ */
diff --git a/lib/lwip/src/include/ipv4/lwip/ip_addr.h b/lib/lwip/src/include/ipv4/lwip/ip_addr.h
new file mode 100644
index 0000000..8880936
--- /dev/null
+++ b/lib/lwip/src/include/ipv4/lwip/ip_addr.h
@@ -0,0 +1,183 @@
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef __LWIP_IP_ADDR_H__
+#define __LWIP_IP_ADDR_H__
+
+#include "lwip/opt.h"
+
+#include "lwip/inet.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifdef PACK_STRUCT_USE_INCLUDES
+#include "arch/bpstruct.h"
+#endif
+    PACK_STRUCT_BEGIN struct ip_addr {
+        PACK_STRUCT_FIELD(u32_t addr);
+    } PACK_STRUCT_STRUCT;
+     PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#include "arch/epstruct.h"
+#endif
+
+// XXX: In lwIP 1.3.1 this is all the same.
+typedef struct ip_addr ip_addr_t;
+typedef struct ip_addr ip_addr_p_t;
+
+/*
+ * struct ipaddr2 is used in the definition of the ARP packet format in
+ * order to support compilers that don't have structure packing.
+ */
+#ifdef PACK_STRUCT_USE_INCLUDES
+#include "arch/bpstruct.h"
+#endif
+     PACK_STRUCT_BEGIN struct ip_addr2 {
+        PACK_STRUCT_FIELD(u16_t addrw[2]);
+    } PACK_STRUCT_STRUCT;
+     PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#include "arch/epstruct.h"
+#endif
+      struct netif;
+
+    extern const struct ip_addr ip_addr_any;
+    extern const struct ip_addr ip_addr_broadcast;
+
+/** IP_ADDR_ can be used as a fixed IP address
+ *  for the wildcard and the broadcast address
+ */
+#define IP_ADDR_ANY         ((struct ip_addr *)&ip_addr_any)
+#define IP_ADDR_BROADCAST   ((struct ip_addr *)&ip_addr_broadcast)
+
+/** 255.255.255.255 */
+#define IPADDR_NONE         ((u32_t)0xffffffffUL)
+/** 127.0.0.1 */
+#define IPADDR_LOOPBACK     ((u32_t)0x7f000001UL)
+/** 0.0.0.0 */
+#define IPADDR_ANY          ((u32_t)0x00000000UL)
+/** 255.255.255.255 */
+#define IPADDR_BROADCAST    ((u32_t)0xffffffffUL)
+
+/* Definitions of the bits in an Internet address integer.
+
+   On subnets, host and network parts are found according to
+   the subnet mask, not these masks.  */
+
+#define IN_CLASSA(a)        ((((u32_t)(a)) & 0x80000000UL) == 0)
+#define IN_CLASSA_NET       0xff000000
+#define IN_CLASSA_NSHIFT    24
+#define IN_CLASSA_HOST      (0xffffffff & ~IN_CLASSA_NET)
+#define IN_CLASSA_MAX       128
+
+#define IN_CLASSB(a)        ((((u32_t)(a)) & 0xc0000000UL) == 0x80000000UL)
+#define IN_CLASSB_NET       0xffff0000
+#define IN_CLASSB_NSHIFT    16
+#define IN_CLASSB_HOST      (0xffffffff & ~IN_CLASSB_NET)
+#define IN_CLASSB_MAX       65536
+
+#define IN_CLASSC(a)        ((((u32_t)(a)) & 0xe0000000UL) == 0xc0000000UL)
+#define IN_CLASSC_NET       0xffffff00
+#define IN_CLASSC_NSHIFT    8
+#define IN_CLASSC_HOST      (0xffffffff & ~IN_CLASSC_NET)
+
+#define IN_CLASSD(a)        (((u32_t)(a) & 0xf0000000UL) == 0xe0000000UL)
+#define IN_CLASSD_NET       0xf0000000  /* These ones aren't really */
+#define IN_CLASSD_NSHIFT    28  /*   net and host fields, but */
+#define IN_CLASSD_HOST      0x0fffffff  /*   routing needn't know. */
+#define IN_MULTICAST(a)     IN_CLASSD(a)
+
+#define IN_EXPERIMENTAL(a)  (((u32_t)(a) & 0xf0000000UL) == 0xf0000000UL)
+#define IN_BADCLASS(a)      (((u32_t)(a) & 0xf0000000UL) == 0xf0000000UL)
+
+#define IN_LOOPBACKNET      127 /* official! */
+
+#define IP4_ADDR(ipaddr, a,b,c,d) \
+        (ipaddr)->addr = htonl(((u32_t)((a) & 0xff) << 24) | \
+                               ((u32_t)((b) & 0xff) << 16) | \
+                               ((u32_t)((c) & 0xff) << 8) | \
+                                (u32_t)((d) & 0xff))
+
+#define ip_addr_set(dest, src) (dest)->addr = \
+                               ((src) == NULL? 0:\
+                               (src)->addr)
+
+/** IPv4 only: set the IP address given as an u32_t */
+#define ip4_addr_set_u32(dest_ipaddr, src_u32) ((dest_ipaddr)->addr = (src_u32))
+/** IPv4 only: get the IP address as an u32_t */
+#define ip4_addr_get_u32(src_ipaddr) ((src_ipaddr)->addr)
+
+/**
+ * Determine if two address are on the same network.
+ *
+ * @arg addr1 IP address 1
+ * @arg addr2 IP address 2
+ * @arg mask network identifier mask
+ * @return !0 if the network identifiers of both address match
+ */
+#define ip_addr_netcmp(addr1, addr2, mask) (((addr1)->addr & \
+                                              (mask)->addr) == \
+                                             ((addr2)->addr & \
+                                              (mask)->addr))
+#define ip_addr_cmp(addr1, addr2) ((addr1)->addr == (addr2)->addr)
+
+#define ip_addr_isany(addr1) ((addr1) == NULL || (addr1)->addr == 0)
+
+    u8_t ip_addr_isbroadcast(struct ip_addr *, struct netif *);
+
+#define ip_addr_ismulticast(addr1) (((addr1)->addr & ntohl(0xf0000000UL)) == ntohl(0xe0000000UL))
+
+#define ip_addr_islinklocal(addr1) (((addr1)->addr & ntohl(0xffff0000UL)) == ntohl(0xa9fe0000UL))
+
+#define ip_addr_debug_print(debug, ipaddr) \
+  LWIP_DEBUGF(debug, ("%"U16_F".%"U16_F".%"U16_F".%"U16_F,              \
+                      ipaddr != NULL ?                                  \
+                      (u16_t)(ntohl((ipaddr)->addr) >> 24) & 0xff : 0,  \
+                      ipaddr != NULL ?                                  \
+                      (u16_t)(ntohl((ipaddr)->addr) >> 16) & 0xff : 0,  \
+                      ipaddr != NULL ?                                  \
+                      (u16_t)(ntohl((ipaddr)->addr) >> 8) & 0xff : 0,   \
+                      ipaddr != NULL ?                                  \
+                      (u16_t)ntohl((ipaddr)->addr) & 0xff : 0))
+
+/* These are cast to u16_t, with the intent that they are often arguments
+ * to printf using the U16_F format from cc.h. */
+#define ip4_addr1(ipaddr) ((u16_t)(ntohl((ipaddr)->addr) >> 24) & 0xff)
+#define ip4_addr2(ipaddr) ((u16_t)(ntohl((ipaddr)->addr) >> 16) & 0xff)
+#define ip4_addr3(ipaddr) ((u16_t)(ntohl((ipaddr)->addr) >> 8) & 0xff)
+#define ip4_addr4(ipaddr) ((u16_t)(ntohl((ipaddr)->addr)) & 0xff)
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* __LWIP_IP_ADDR_H__ */
diff --git a/lib/lwip/src/include/ipv4/lwip/ip_frag.h b/lib/lwip/src/include/ipv4/lwip/ip_frag.h
new file mode 100644
index 0000000..e99f942
--- /dev/null
+++ b/lib/lwip/src/include/ipv4/lwip/ip_frag.h
@@ -0,0 +1,75 @@
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved. 
+ * 
+ * Redistribution and use in source and binary forms, with or without modification, 
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission. 
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ * 
+ * Author: Jani Monoses <jani@iv.ro>
+ *
+ */
+
+#ifndef __LWIP_IP_FRAG_H__
+#define __LWIP_IP_FRAG_H__
+
+#include "lwip/opt.h"
+#include "lwip/err.h"
+#include "lwip/pbuf.h"
+#include "lwip/netif.h"
+#include "lwip/ip_addr.h"
+#include "lwip/ip.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if IP_REASSEMBLY
+/* The IP reassembly timer interval in milliseconds. */
+#define IP_TMR_INTERVAL 1000
+
+/* IP reassembly helper struct.
+ * This is exported because memp needs to know the size.
+ */
+    struct ip_reassdata {
+        struct ip_reassdata *next;
+        struct pbuf *p;
+        struct ip_hdr iphdr;
+        u16_t datagram_len;
+        u8_t flags;
+        u8_t timer;
+    };
+
+    void ip_reass_init(void);
+    void ip_reass_tmr(void);
+    struct pbuf *ip_reass(struct pbuf *p);
+#endif                          /* IP_REASSEMBLY */
+
+#if IP_FRAG
+    err_t ip_frag(struct pbuf *p, struct netif *netif, struct ip_addr *dest);
+#endif                          /* IP_FRAG */
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* __LWIP_IP_FRAG_H__ */
diff --git a/lib/lwip/src/include/ipv6/lwip/icmp.h b/lib/lwip/src/include/ipv6/lwip/icmp.h
new file mode 100644
index 0000000..9028978
--- /dev/null
+++ b/lib/lwip/src/include/ipv6/lwip/icmp.h
@@ -0,0 +1,97 @@
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved. 
+ * 
+ * Redistribution and use in source and binary forms, with or without modification, 
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission. 
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ * 
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef __LWIP_ICMP_H__
+#define __LWIP_ICMP_H__
+
+#include "lwip/opt.h"
+
+#if LWIP_ICMP                   /* don't build if not configured for use in lwipopts.h */
+
+#include "lwip/pbuf.h"
+#include "lwip/netif.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define ICMP6_DUR  1
+#define ICMP6_TE   3
+#define ICMP6_ECHO 128          /* echo */
+#define ICMP6_ER   129          /* echo reply */
+
+
+    enum icmp_dur_type {
+        ICMP_DUR_NET = 0,       /* net unreachable */
+        ICMP_DUR_HOST = 1,      /* host unreachable */
+        ICMP_DUR_PROTO = 2,     /* protocol unreachable */
+        ICMP_DUR_PORT = 3,      /* port unreachable */
+        ICMP_DUR_FRAG = 4,      /* fragmentation needed and DF set */
+        ICMP_DUR_SR = 5         /* source route failed */
+    };
+
+    enum icmp_te_type {
+        ICMP_TE_TTL = 0,        /* time to live exceeded in transit */
+        ICMP_TE_FRAG = 1        /* fragment reassembly time exceeded */
+    };
+
+    void icmp_input(struct pbuf *p, struct netif *inp);
+
+    void icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t);
+    void icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t);
+
+    struct icmp_echo_hdr {
+        u8_t type;
+        u8_t icode;
+        u16_t chksum;
+        u16_t id;
+        u16_t seqno;
+    };
+
+    struct icmp_dur_hdr {
+        u8_t type;
+        u8_t icode;
+        u16_t chksum;
+        u32_t unused;
+    };
+
+    struct icmp_te_hdr {
+        u8_t type;
+        u8_t icode;
+        u16_t chksum;
+        u32_t unused;
+    };
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* LWIP_ICMP */
+#endif                          /* __LWIP_ICMP_H__ */
diff --git a/lib/lwip/src/include/ipv6/lwip/inet.h b/lib/lwip/src/include/ipv6/lwip/inet.h
new file mode 100644
index 0000000..680be42
--- /dev/null
+++ b/lib/lwip/src/include/ipv6/lwip/inet.h
@@ -0,0 +1,66 @@
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved. 
+ * 
+ * Redistribution and use in source and binary forms, with or without modification, 
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission. 
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ * 
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef __LWIP_INET_H__
+#define __LWIP_INET_H__
+
+#include "lwip/opt.h"
+#include "lwip/pbuf.h"
+#include "lwip/ip_addr.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+    u16_t inet_chksum(void *data, u16_t len);
+    u16_t inet_chksum_pbuf(struct pbuf *p);
+    u16_t inet_chksum_pseudo(struct pbuf *p,
+                             struct ip_addr *src, struct ip_addr *dest,
+                             u8_t proto, u32_t proto_len);
+
+    u32_t inet_addr(const char *cp);
+    s8_t inet_aton(const char *cp, struct in_addr *addr);
+
+#ifndef _MACHINE_ENDIAN_H_
+#ifndef _NETINET_IN_H
+#ifndef _LINUX_BYTEORDER_GENERIC_H
+    u16_t htons(u16_t n);
+    u16_t ntohs(u16_t n);
+    u32_t htonl(u32_t n);
+    u32_t ntohl(u32_t n);
+#endif                          /* _LINUX_BYTEORDER_GENERIC_H */
+#endif                          /* _NETINET_IN_H */
+#endif                          /* _MACHINE_ENDIAN_H_ */
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* __LWIP_INET_H__ */
diff --git a/lib/lwip/src/include/ipv6/lwip/ip.h b/lib/lwip/src/include/ipv6/lwip/ip.h
new file mode 100644
index 0000000..a345408
--- /dev/null
+++ b/lib/lwip/src/include/ipv6/lwip/ip.h
@@ -0,0 +1,127 @@
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved. 
+ * 
+ * Redistribution and use in source and binary forms, with or without modification, 
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission. 
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ * 
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef __LWIP_IP_H__
+#define __LWIP_IP_H__
+
+#include "lwip/opt.h"
+#include "lwip/def.h"
+#include "lwip/pbuf.h"
+#include "lwip/ip_addr.h"
+
+#include "lwip/err.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define IP_HLEN 40
+
+#define IP_PROTO_ICMP    58
+#define IP_PROTO_UDP     17
+#define IP_PROTO_UDPLITE 136
+#define IP_PROTO_TCP     6
+
+/* This is passed as the destination address to ip_output_if (not
+   to ip_output), meaning that an IP header already is constructed
+   in the pbuf. This is used when TCP retransmits. */
+#ifdef IP_HDRINCL
+#undef IP_HDRINCL
+#endif                          /* IP_HDRINCL */
+#define IP_HDRINCL  NULL
+
+#if LWIP_NETIF_HWADDRHINT
+#define IP_PCB_ADDRHINT ;u8_t addr_hint
+#else
+#define IP_PCB_ADDRHINT
+#endif                          /* LWIP_NETIF_HWADDRHINT */
+
+/* This is the common part of all PCB types. It needs to be at the
+   beginning of a PCB type definition. It is located here so that
+   changes to this common part are made in one location instead of
+   having to change all PCB structs. */
+#define IP_PCB struct ip_addr local_ip; \
+  struct ip_addr remote_ip; \
+   /* Socket options */  \
+  u16_t so_options;      \
+   /* Type Of Service */ \
+  u8_t tos;              \
+  /* Time To Live */     \
+  u8_t ttl;              \
+  /* link layer address resolution hint */ \
+  IP_PCB_ADDRHINT
+
+
+/* The IPv6 header. */
+    struct ip_hdr {
+#if BYTE_ORDER == LITTLE_ENDIAN
+        u8_t tclass1:4, v:4;
+        u8_t flow1:4, tclass2:4;
+#else
+        u8_t v:4, tclass1:4;
+        u8_t tclass2:8, flow1:4;
+#endif
+        u16_t flow2;
+        u16_t len;              /* payload length */
+        u8_t nexthdr;           /* next header */
+        u8_t hoplim;            /* hop limit (TTL) */
+        struct ip_addr src, dest;       /* source and destination IP addresses */
+    };
+
+#define IPH_PROTO(hdr) (iphdr->nexthdr)
+
+    void ip_init(void);
+
+#include "lwip/netif.h"
+
+    struct netif *ip_route(struct ip_addr *dest);
+
+    void ip_input(struct pbuf *p, struct netif *inp);
+
+/* source and destination addresses in network byte order, please */
+    err_t ip_output(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
+                    u8_t ttl, u8_t proto);
+
+    err_t ip_output_if(struct pbuf *p, struct ip_addr *src,
+                       struct ip_addr *dest, u8_t ttl, u8_t proto,
+                       struct netif *netif);
+
+#define ip_current_netif() NULL
+#define ip_current_header() NULL
+
+#if IP_DEBUG
+    void ip_debug_print(struct pbuf *p);
+#endif                          /* IP_DEBUG */
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* __LWIP_IP_H__ */
diff --git a/lib/lwip/src/include/ipv6/lwip/ip_addr.h b/lib/lwip/src/include/ipv6/lwip/ip_addr.h
new file mode 100644
index 0000000..ecdbdd4
--- /dev/null
+++ b/lib/lwip/src/include/ipv6/lwip/ip_addr.h
@@ -0,0 +1,91 @@
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved. 
+ * 
+ * Redistribution and use in source and binary forms, with or without modification, 
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission. 
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ * 
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef __LWIP_IP_ADDR_H__
+#define __LWIP_IP_ADDR_H__
+
+#include "lwip/opt.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define IP_ADDR_ANY 0
+
+#ifdef PACK_STRUCT_USE_INCLUDES
+#include "arch/bpstruct.h"
+#endif
+    PACK_STRUCT_BEGIN struct ip_addr {
+        PACK_STRUCT_FIELD(u32_t addr[4]);
+    } PACK_STRUCT_STRUCT;
+     PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#include "arch/epstruct.h"
+#endif
+/*
+ * struct ipaddr2 is used in the definition of the ARP packet format in
+ * order to support compilers that don't have structure packing.
+ */
+#ifdef PACK_STRUCT_USE_INCLUDES
+#include "arch/bpstruct.h"
+#endif
+     PACK_STRUCT_BEGIN struct ip_addr2 {
+        PACK_STRUCT_FIELD(u16_t addrw[2]);
+    } PACK_STRUCT_STRUCT;
+     PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#include "arch/epstruct.h"
+#endif
+#define IP6_ADDR(ipaddr, a,b,c,d,e,f,g,h) do { (ipaddr)->addr[0] = htonl((u32_t)((a & 0xffff) << 16) | (b & 0xffff)); \
+                                               (ipaddr)->addr[1] = htonl(((c & 0xffff) << 16) | (d & 0xffff)); \
+                                               (ipaddr)->addr[2] = htonl(((e & 0xffff) << 16) | (f & 0xffff)); \
+                                               (ipaddr)->addr[3] = htonl(((g & 0xffff) << 16) | (h & 0xffff)); } while(0)
+     u8_t ip_addr_netcmp(struct ip_addr *addr1, struct ip_addr *addr2,
+                         struct ip_addr *mask);
+    u8_t ip_addr_cmp(struct ip_addr *addr1, struct ip_addr *addr2);
+    void ip_addr_set(struct ip_addr *dest, struct ip_addr *src);
+    u8_t ip_addr_isany(struct ip_addr *addr);
+
+#define ip_addr_debug_print(debug, ipaddr) \
+        LWIP_DEBUGF(debug, ("%"X32_F":%"X32_F":%"X32_F":%"X32_F":%"X32_F":%"X32_F":%"X32_F":%"X32_F"\n", \
+         (ntohl(ipaddr->addr[0]) >> 16) & 0xffff, \
+         ntohl(ipaddr->addr[0]) & 0xffff, \
+         (ntohl(ipaddr->addr[1]) >> 16) & 0xffff, \
+         ntohl(ipaddr->addr[1]) & 0xffff, \
+         (ntohl(ipaddr->addr[2]) >> 16) & 0xffff, \
+         ntohl(ipaddr->addr[2]) & 0xffff, \
+         (ntohl(ipaddr->addr[3]) >> 16) & 0xffff, \
+         ntohl(ipaddr->addr[3]) & 0xffff));
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* __LWIP_IP_ADDR_H__ */
diff --git a/lib/lwip/src/include/lwip/api.h b/lib/lwip/src/include/lwip/api.h
new file mode 100644
index 0000000..3f9cac5
--- /dev/null
+++ b/lib/lwip/src/include/lwip/api.h
@@ -0,0 +1,225 @@
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved. 
+ * 
+ * Redistribution and use in source and binary forms, with or without modification, 
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission. 
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ * 
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef __LWIP_API_H__
+#define __LWIP_API_H__
+
+#include "lwip/opt.h"
+
+#if LWIP_NETCONN                /* don't build if not configured for use in lwipopts.h */
+
+#include <stddef.h>             /* for size_t */
+
+#include "lwip/netbuf.h"
+#include "lwip/sys.h"
+#include "lwip/ip_addr.h"
+#include "lwip/err.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Throughout this file, IP addresses and port numbers are expected to be in
+ * the same byte order as in the corresponding pcb.
+ */
+
+/* Flags for netconn_write */
+#define NETCONN_NOFLAG 0x00
+#define NETCONN_NOCOPY 0x00     /* Only for source code compatibility */
+#define NETCONN_COPY   0x01
+#define NETCONN_MORE   0x02
+
+/* Helpers to process several netconn_types by the same code */
+#define NETCONNTYPE_GROUP(t)    (t&0xF0)
+#define NETCONNTYPE_DATAGRAM(t) (t&0xE0)
+
+    enum netconn_type {
+        NETCONN_INVALID = 0,
+        /* NETCONN_TCP Group */
+        NETCONN_TCP = 0x10,
+        /* NETCONN_UDP Group */
+        NETCONN_UDP = 0x20,
+        NETCONN_UDPLITE = 0x21,
+        NETCONN_UDPNOCHKSUM = 0x22,
+        /* NETCONN_RAW Group */
+        NETCONN_RAW = 0x40
+    };
+
+    enum netconn_state {
+        NETCONN_NONE,
+        NETCONN_WRITE,
+        NETCONN_LISTEN,
+        NETCONN_CONNECT,
+        NETCONN_CLOSE
+    };
+
+    enum netconn_evt {
+        NETCONN_EVT_RCVPLUS,
+        NETCONN_EVT_RCVMINUS,
+        NETCONN_EVT_SENDPLUS,
+        NETCONN_EVT_SENDMINUS
+    };
+
+#if LWIP_IGMP
+    enum netconn_igmp {
+        NETCONN_JOIN,
+        NETCONN_LEAVE
+    };
+#endif                          /* LWIP_IGMP */
+
+/* forward-declare some structs to avoid to include their headers */
+    struct ip_pcb;
+    struct tcp_pcb;
+    struct udp_pcb;
+    struct raw_pcb;
+    struct netconn;
+
+/** A callback prototype to inform about events for a netconn */
+    typedef void (*netconn_callback) (struct netconn *, enum netconn_evt,
+                                      u16_t len);
+
+/** A netconn descriptor */
+    struct netconn {
+  /** type of the netconn (TCP, UDP or RAW) */
+        enum netconn_type type;
+  /** current state of the netconn */
+        enum netconn_state state;
+  /** the lwIP internal protocol control block */
+        union {
+            struct ip_pcb *ip;
+            struct tcp_pcb *tcp;
+            struct udp_pcb *udp;
+            struct raw_pcb *raw;
+        } pcb;
+  /** the last error this netconn had */
+        err_t err;
+  /** sem that is used to synchroneously execute functions in the core context */
+        sys_sem_t op_completed;
+  /** mbox where received packets are stored until they are fetched
+      by the netconn application thread (can grow quite big) */
+        sys_mbox_t recvmbox;
+  /** mbox where new connections are stored until processed
+      by the application thread */
+        sys_mbox_t acceptmbox;
+  /** only used for socket layer */
+        int socket;
+#if LWIP_SO_RCVTIMEO
+  /** timeout to wait for new data to be received
+      (or connections to arrive for listening netconns) */
+        int recv_timeout;
+#endif                          /* LWIP_SO_RCVTIMEO */
+#if LWIP_SO_RCVBUF
+  /** maximum amount of bytes queued in recvmbox */
+        int recv_bufsize;
+#endif                          /* LWIP_SO_RCVBUF */
+        s16_t recv_avail;
+#if LWIP_TCP
+  /** TCP: when data passed to netconn_write doesn't fit into the send buffer,
+      this temporarily stores the message. */
+        struct api_msg_msg *write_msg;
+  /** TCP: when data passed to netconn_write doesn't fit into the send buffer,
+      this temporarily stores how much is already sent. */
+        size_t write_offset;
+#if LWIP_TCPIP_CORE_LOCKING
+  /** TCP: when data passed to netconn_write doesn't fit into the send buffer,
+      this temporarily stores whether to wake up the original application task
+      if data couldn't be sent in the first try. */
+        u8_t write_delayed;
+#endif                          /* LWIP_TCPIP_CORE_LOCKING */
+#endif                          /* LWIP_TCP */
+  /** A callback function that is informed about events for this netconn */
+        netconn_callback callback;
+    };
+
+/* Register an Network connection event */
+#define API_EVENT(c,e,l) if (c->callback) {         \
+                           (*c->callback)(c, e, l); \
+                         }
+
+/* Network connection functions: */
+#define netconn_new(t)                  netconn_new_with_proto_and_callback(t, 0, NULL)
+#define netconn_new_with_callback(t, c) netconn_new_with_proto_and_callback(t, 0, c)
+    struct
+    netconn *netconn_new_with_proto_and_callback(enum netconn_type t,
+                                                 u8_t proto,
+                                                 netconn_callback callback);
+    err_t netconn_delete(struct netconn *conn);
+/** Get the type of a netconn (as enum netconn_type). */
+#define netconn_type(conn) (conn->type)
+
+    err_t netconn_getaddr(struct netconn *conn,
+                          struct ip_addr *addr, u16_t * port, u8_t local);
+#define netconn_peer(c,i,p) netconn_getaddr(c,i,p,0)
+#define netconn_addr(c,i,p) netconn_getaddr(c,i,p,1)
+
+    err_t netconn_bind(struct netconn *conn, struct ip_addr *addr, u16_t port);
+
+    err_t netconn_redirect(struct netconn *conn,
+                           struct ip_addr *local_ip,
+                           u16_t local_port,
+                           struct ip_addr *remote_ip, u16_t remote_port);
+     err_t
+      netconn_pause(struct netconn *conn, struct ip_addr *local_ip,
+                    u16_t local_port,
+                    struct ip_addr *remote_ip, u16_t remote_port);
+
+    err_t netconn_connect(struct netconn *conn,
+                          struct ip_addr *addr, u16_t port);
+    err_t netconn_disconnect(struct netconn *conn);
+    err_t netconn_listen_with_backlog(struct netconn *conn, u8_t backlog);
+#define netconn_listen(conn) netconn_listen_with_backlog(conn, TCP_DEFAULT_LISTEN_BACKLOG)
+    struct netconn *netconn_accept(struct netconn *conn);
+    struct netbuf *netconn_recv(struct netconn *conn);
+    err_t netconn_sendto(struct netconn *conn,
+                         struct netbuf *buf, struct ip_addr *addr, u16_t port);
+    err_t netconn_send(struct netconn *conn, struct netbuf *buf);
+    err_t netconn_write(struct netconn *conn,
+                        const void *dataptr, size_t size, u8_t apiflags);
+    err_t netconn_close(struct netconn *conn);
+
+#if LWIP_IGMP
+    err_t netconn_join_leave_group(struct netconn *conn,
+                                   struct ip_addr *multiaddr,
+                                   struct ip_addr *interface,
+                                   enum netconn_igmp join_or_leave);
+#endif                          /* LWIP_IGMP */
+#if LWIP_DNS
+    err_t netconn_gethostbyname(const char *name, struct ip_addr *addr);
+#endif                          /* LWIP_DNS */
+
+#define netconn_err(conn)          ((conn)->err)
+#define netconn_recv_bufsize(conn) ((conn)->recv_bufsize)
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* LWIP_NETCONN */
+#endif                          /* __LWIP_API_H__ */
diff --git a/lib/lwip/src/include/lwip/api_msg.h b/lib/lwip/src/include/lwip/api_msg.h
new file mode 100644
index 0000000..0089177
--- /dev/null
+++ b/lib/lwip/src/include/lwip/api_msg.h
@@ -0,0 +1,171 @@
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved. 
+ * 
+ * Redistribution and use in source and binary forms, with or without modification, 
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission. 
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ * 
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef __LWIP_API_MSG_H__
+#define __LWIP_API_MSG_H__
+
+#include "lwip/opt.h"
+
+#if LWIP_NETCONN                /* don't build if not configured for use in lwipopts.h */
+
+#include <stddef.h>             /* for size_t */
+
+#include "lwip/ip_addr.h"
+#include "lwip/err.h"
+#include "lwip/sys.h"
+#include "lwip/igmp.h"
+#include "lwip/api.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* IP addresses and port numbers are expected to be in
+ * the same byte order as in the corresponding pcb.
+ */
+/** This struct includes everything that is necessary to execute a function
+    for a netconn in another thread context (mainly used to process netconns
+    in the tcpip_thread context to be thread safe). */
+    struct api_msg_msg {
+  /** The netconn which to process - always needed: it includes the semaphore
+      which is used to block the application thread until the function finished. */
+        struct netconn *conn;
+  /** Depending on the executed function, one of these union members is used */
+        union {
+    /** used for do_send */
+            struct netbuf *b;
+    /** used for do_newconn */
+            struct {
+                u8_t proto;
+            } n;
+    /** used for do_bind and do_connect */
+            struct {
+                struct ip_addr *ipaddr;
+                u16_t port;
+            } bc;
+    /** used for do_getaddr */
+            struct {
+                struct ip_addr *ipaddr;
+                u16_t *port;
+                u8_t local;
+            } ad;
+    /** used for do_write */
+            struct {
+                const void *dataptr;
+                size_t len;
+                u8_t apiflags;
+            } w;
+    /** used ofr do_recv */
+            struct {
+                u16_t len;
+            } r;
+#if LWIP_IGMP
+    /** used for do_join_leave_group */
+            struct {
+                struct ip_addr *multiaddr;
+                struct ip_addr *interface;
+                enum netconn_igmp join_or_leave;
+            } jl;
+#endif                          /* LWIP_IGMP */
+#if TCP_LISTEN_BACKLOG
+            struct {
+                u8_t backlog;
+            } lb;
+#endif                          /* TCP_LISTEN_BACKLOG */
+            // IK
+            struct {
+                struct ip_addr *local_ip;
+                u16_t local_port;
+                struct ip_addr *remote_ip;
+                u16_t remote_port;
+            } red;
+
+        } msg;
+    };
+
+/** This struct contains a function to execute in another thread context and
+    a struct api_msg_msg that serves as an argument for this function.
+    This is passed to tcpip_apimsg to execute functions in tcpip_thread context. */
+    struct api_msg {
+  /** function to execute in tcpip_thread context */
+        void (*function) (struct api_msg_msg * msg);
+  /** arguments for this function */
+        struct api_msg_msg msg;
+    };
+
+#if LWIP_DNS
+/** As do_gethostbyname requires more arguments but doesn't require a netconn,
+    it has its own struct (to avoid struct api_msg getting bigger than necessary).
+    do_gethostbyname must be called using tcpip_callback instead of tcpip_apimsg
+    (see netconn_gethostbyname). */
+    struct dns_api_msg {
+  /** Hostname to query or dotted IP address string */
+        const char *name;
+  /** Rhe resolved address is stored here */
+        struct ip_addr *addr;
+  /** This semaphore is posted when the name is resolved, the application thread
+      should wait on it. */
+        sys_sem_t sem;
+  /** Errors are given back here */
+        err_t *err;
+    };
+#endif                          /* LWIP_DNS */
+
+    void do_newconn(struct api_msg_msg *msg);
+    void do_delconn(struct api_msg_msg *msg);
+    void do_bind(struct api_msg_msg *msg);
+    void do_redirect(struct api_msg_msg *msg);
+    void do_pause(struct api_msg_msg *msg);
+    void do_connect(struct api_msg_msg *msg);
+    void do_disconnect(struct api_msg_msg *msg);
+    void do_listen(struct api_msg_msg *msg);
+    void do_send(struct api_msg_msg *msg);
+    void do_recv(struct api_msg_msg *msg);
+    void do_write(struct api_msg_msg *msg);
+    void do_getaddr(struct api_msg_msg *msg);
+    void do_close(struct api_msg_msg *msg);
+#if LWIP_IGMP
+    void do_join_leave_group(struct api_msg_msg *msg);
+#endif                          /* LWIP_IGMP */
+
+#if LWIP_DNS
+    void do_gethostbyname(void *arg);
+#endif                          /* LWIP_DNS */
+
+    struct netconn *netconn_alloc(enum netconn_type t,
+                                  netconn_callback callback);
+    void netconn_free(struct netconn *conn);
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* LWIP_NETCONN */
+#endif                          /* __LWIP_API_MSG_H__ */
diff --git a/lib/lwip/src/include/lwip/arch.h b/lib/lwip/src/include/lwip/arch.h
new file mode 100644
index 0000000..9e9d10d
--- /dev/null
+++ b/lib/lwip/src/include/lwip/arch.h
@@ -0,0 +1,226 @@
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved. 
+ * 
+ * Redistribution and use in source and binary forms, with or without modification, 
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission. 
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ * 
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef __LWIP_ARCH_H__
+#define __LWIP_ARCH_H__
+
+#include "arch/cc.h"
+
+/** Temporary: define format string for size_t if not defined in cc.h */
+#ifndef SZT_F
+#define SZT_F U32_F
+#endif                          /* SZT_F */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef PACK_STRUCT_BEGIN
+#define PACK_STRUCT_BEGIN
+#endif                          /* PACK_STRUCT_BEGIN */
+
+#ifndef PACK_STRUCT_END
+#define PACK_STRUCT_END
+#endif                          /* PACK_STRUCT_END */
+
+#ifndef PACK_STRUCT_FIELD
+#define PACK_STRUCT_FIELD(x) x
+#endif                          /* PACK_STRUCT_FIELD */
+
+
+#ifndef LWIP_UNUSED_ARG
+#define LWIP_UNUSED_ARG(x) (void)x
+#endif                          /* LWIP_UNUSED_ARG */
+
+
+#ifdef LWIP_PROVIDE_ERRNO
+
+#define  EPERM     1            /* Operation not permitted */
+#define  ENOENT     2           /* No such file or directory */
+#define  ESRCH     3            /* No such process */
+#define  EINTR     4            /* Interrupted system call */
+#define  EIO     5              /* I/O error */
+#define  ENXIO     6            /* No such device or address */
+#define  E2BIG     7            /* Arg list too long */
+#define  ENOEXEC     8          /* Exec format error */
+#define  EBADF     9            /* Bad file number */
+#define  ECHILD    10           /* No child processes */
+#define  EAGAIN    11           /* Try again */
+#define  ENOMEM    12           /* Out of memory */
+#define  EACCES    13           /* Permission denied */
+#define  EFAULT    14           /* Bad address */
+#define  ENOTBLK    15          /* Block device required */
+#define  EBUSY    16            /* Device or resource busy */
+#define  EEXIST    17           /* File exists */
+#define  EXDEV    18            /* Cross-device link */
+#define  ENODEV    19           /* No such device */
+#define  ENOTDIR    20          /* Not a directory */
+#define  EISDIR    21           /* Is a directory */
+#define  EINVAL    22           /* Invalid argument */
+#define  ENFILE    23           /* File table overflow */
+#define  EMFILE    24           /* Too many open files */
+#define  ENOTTY    25           /* Not a typewriter */
+#define  ETXTBSY    26          /* Text file busy */
+#define  EFBIG    27            /* File too large */
+#define  ENOSPC    28           /* No space left on device */
+#define  ESPIPE    29           /* Illegal seek */
+#define  EROFS    30            /* Read-only file system */
+#define  EMLINK    31           /* Too many links */
+#define  EPIPE    32            /* Broken pipe */
+#define  EDOM    33             /* Math argument out of domain of func */
+#define  ERANGE    34           /* Math result not representable */
+#define  EDEADLK    35          /* Resource deadlock would occur */
+#define  ENAMETOOLONG  36       /* File name too long */
+#define  ENOLCK    37           /* No record locks available */
+#define  ENOSYS    38           /* Function not implemented */
+#define  ENOTEMPTY  39          /* Directory not empty */
+#define  ELOOP    40            /* Too many symbolic links encountered */
+#define  EWOULDBLOCK  EAGAIN    /* Operation would block */
+#define  ENOMSG    42           /* No message of desired type */
+#define  EIDRM    43            /* Identifier removed */
+#define  ECHRNG    44           /* Channel number out of range */
+#define  EL2NSYNC  45           /* Level 2 not synchronized */
+#define  EL3HLT    46           /* Level 3 halted */
+#define  EL3RST    47           /* Level 3 reset */
+#define  ELNRNG    48           /* Link number out of range */
+#define  EUNATCH    49          /* Protocol driver not attached */
+#define  ENOCSI    50           /* No CSI structure available */
+#define  EL2HLT    51           /* Level 2 halted */
+#define  EBADE    52            /* Invalid exchange */
+#define  EBADR    53            /* Invalid request descriptor */
+#define  EXFULL    54           /* Exchange full */
+#define  ENOANO    55           /* No anode */
+#define  EBADRQC    56          /* Invalid request code */
+#define  EBADSLT    57          /* Invalid slot */
+
+#define  EDEADLOCK  EDEADLK
+
+#define  EBFONT    59           /* Bad font file format */
+#define  ENOSTR    60           /* Device not a stream */
+#define  ENODATA    61          /* No data available */
+#define  ETIME    62            /* Timer expired */
+#define  ENOSR    63            /* Out of streams resources */
+#define  ENONET    64           /* Machine is not on the network */
+#define  ENOPKG    65           /* Package not installed */
+#define  EREMOTE    66          /* Object is remote */
+#define  ENOLINK    67          /* Link has been severed */
+#define  EADV    68             /* Advertise error */
+#define  ESRMNT    69           /* Srmount error */
+#define  ECOMM    70            /* Communication error on send */
+#define  EPROTO    71           /* Protocol error */
+#define  EMULTIHOP  72          /* Multihop attempted */
+#define  EDOTDOT    73          /* RFS specific error */
+#define  EBADMSG    74          /* Not a data message */
+#define  EOVERFLOW  75          /* Value too large for defined data type */
+#define  ENOTUNIQ  76           /* Name not unique on network */
+#define  EBADFD    77           /* File descriptor in bad state */
+#define  EREMCHG    78          /* Remote address changed */
+#define  ELIBACC    79          /* Can not access a needed shared library */
+#define  ELIBBAD    80          /* Accessing a corrupted shared library */
+#define  ELIBSCN    81          /* .lib section in a.out corrupted */
+#define  ELIBMAX    82          /* Attempting to link in too many shared libraries */
+#define  ELIBEXEC  83           /* Cannot exec a shared library directly */
+#define  EILSEQ    84           /* Illegal byte sequence */
+#define  ERESTART  85           /* Interrupted system call should be restarted */
+#define  ESTRPIPE  86           /* Streams pipe error */
+#define  EUSERS    87           /* Too many users */
+#define  ENOTSOCK  88           /* Socket operation on non-socket */
+#define  EDESTADDRREQ  89       /* Destination address required */
+#define  EMSGSIZE  90           /* Message too long */
+#define  EPROTOTYPE  91         /* Protocol wrong type for socket */
+#define  ENOPROTOOPT  92        /* Protocol not available */
+#define  EPROTONOSUPPORT  93    /* Protocol not supported */
+#define  ESOCKTNOSUPPORT  94    /* Socket type not supported */
+#define  EOPNOTSUPP  95         /* Operation not supported on transport endpoint */
+#define  EPFNOSUPPORT  96       /* Protocol family not supported */
+#define  EAFNOSUPPORT  97       /* Address family not supported by protocol */
+#define  EADDRINUSE  98         /* Address already in use */
+#define  EADDRNOTAVAIL  99      /* Cannot assign requested address */
+#define  ENETDOWN  100          /* Network is down */
+#define  ENETUNREACH  101       /* Network is unreachable */
+#define  ENETRESET  102         /* Network dropped connection because of reset */
+#define  ECONNABORTED  103      /* Software caused connection abort */
+#define  ECONNRESET  104        /* Connection reset by peer */
+#define  ENOBUFS    105         /* No buffer space available */
+#define  EISCONN    106         /* Transport endpoint is already connected */
+#define  ENOTCONN  107          /* Transport endpoint is not connected */
+/* XXX: ESHUTDOWN (108) has been moved down, for newlib compatiblity -AKK */
+#define  ETOOMANYREFS  109      /* Too many references: cannot splice */
+#define  ETIMEDOUT  110         /* Connection timed out */
+#define  ECONNREFUSED  111      /* Connection refused */
+#define  EHOSTDOWN  112         /* Host is down */
+#define  EHOSTUNREACH  113      /* No route to host */
+#define  EALREADY  114          /* Operation already in progress */
+#define  EINPROGRESS  115       /* Operation now in progress */
+#define  ESTALE    116          /* Stale NFS file handle */
+#define  EUCLEAN    117         /* Structure needs cleaning */
+#define  ENOTNAM    118         /* Not a XENIX named type file */
+#define  ENAVAIL    119         /* No XENIX semaphores available */
+#define  EISNAM    120          /* Is a named type file */
+#define  EREMOTEIO  121         /* Remote I/O error */
+#define  EDQUOT    122          /* Quota exceeded */
+
+#define  ENOMEDIUM  123         /* No medium found */
+#define  EMEDIUMTYPE  124       /* Wrong medium type */
+
+#ifndef errno
+extern int errno;
+#endif
+
+#endif /* LWIP_PROVIDE_ERRNO */
+
+/* These are not protected by LWIP_PROVIDE_ERRNO for newlib compatiblity -AKK */
+
+#define ENSROK    0             /* DNS server returned answer with no data */
+#define ESHUTDOWN  108         /* Cannot send after transport endpoint shutdown */
+#define ENSRNODATA  160         /* DNS server returned answer with no data */
+#define ENSRFORMERR 161         /* DNS server claims query was misformatted */
+#define ENSRSERVFAIL 162        /* DNS server returned general failure */
+#define ENSRNOTFOUND 163        /* Domain name not found */
+#define ENSRNOTIMP  164         /* DNS server does not implement requested operation */
+#define ENSRREFUSED 165         /* DNS server refused query */
+#define ENSRBADQUERY 166        /* Misformatted DNS query */
+#define ENSRBADNAME 167         /* Misformatted domain name */
+#define ENSRBADFAMILY 168       /* Unsupported address family */
+#define ENSRBADRESP 169         /* Misformatted DNS reply */
+#define ENSRCONNREFUSED 170     /* Could not contact DNS servers */
+#define ENSRTIMEOUT 171         /* Timeout while contacting DNS servers */
+#define ENSROF    172           /* End of file */
+#define ENSRFILE  173           /* Error reading file */
+#define ENSRNOMEM 174           /* Out of memory */
+#define ENSRDESTRUCTION 175     /* Application terminated lookup */
+#define ENSRQUERYDOMAINTOOLONG  176     /* Domain name is too long */
+#define ENSRCNAMELOOP 177       /* Domain name is too long */
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* __LWIP_ARCH_H__ */
diff --git a/lib/lwip/src/include/lwip/barrelfish.h b/lib/lwip/src/include/lwip/barrelfish.h
new file mode 100644
index 0000000..4bd0c7a
--- /dev/null
+++ b/lib/lwip/src/include/lwip/barrelfish.h
@@ -0,0 +1,18 @@
+/*
+ * Copyright (c) 2012, ETH Zurich.
+ * All rights reserved.
+ *
+ * This file is distributed under the terms in the attached LICENSE file.
+ * If you do not find this file, copies can be found by writing to:
+ * ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich. Attn: Systems Group.
+ */
+
+#ifndef BARRELFISH_LWIP_H
+#define BARRELFISH_LWIP_H
+
+#include <errors/errno.h>
+#include <lwip/err.h>
+
+errval_t lwip_err_to_errval(err_t e);
+
+#endif
diff --git a/lib/lwip/src/include/lwip/debug.h b/lib/lwip/src/include/lwip/debug.h
new file mode 100644
index 0000000..ee633a4
--- /dev/null
+++ b/lib/lwip/src/include/lwip/debug.h
@@ -0,0 +1,108 @@
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef __LWIP_DEBUG_H__
+#define __LWIP_DEBUG_H__
+
+#include "lwip/arch.h"
+
+/** lower two bits indicate debug level
+ * - 0 off
+ * - 1 warning
+ * - 2 serious
+ * - 3 severe
+ */
+#define LWIP_DBG_LEVEL_OFF     0x00
+#define LWIP_DBG_LEVEL_WARNING 0x01     /* bad checksums, dropped packets, ... */
+#define LWIP_DBG_LEVEL_SERIOUS 0x02     /* memory allocation failures, ... */
+#define LWIP_DBG_LEVEL_SEVERE  0x03
+#define LWIP_DBG_MASK_LEVEL    0x03
+
+/** flag for LWIP_DEBUGF to enable that debug message */
+#define LWIP_DBG_ON            0x80U
+/** flag for LWIP_DEBUGF to disable that debug message */
+#define LWIP_DBG_OFF           0x00U
+
+/** flag for LWIP_DEBUGF indicating a tracing message (to follow program flow) */
+#define LWIP_DBG_TRACE         0x40U
+/** flag for LWIP_DEBUGF indicating a state debug message (to follow module states) */
+#define LWIP_DBG_STATE         0x20U
+/** flag for LWIP_DEBUGF indicating newly added code, not thoroughly tested yet */
+#define LWIP_DBG_FRESH         0x10U
+/** flag for LWIP_DEBUGF to halt after printing this debug message */
+#define LWIP_DBG_HALT          0x08U
+
+#ifndef LWIP_NOASSERT
+#define LWIP_ASSERT(message, assertion) do { if(!(assertion)) \
+  LWIP_PLATFORM_ASSERT(message); } while(0)
+#else                           /* LWIP_NOASSERT */
+#define LWIP_ASSERT(message, assertion)
+#endif                          /* LWIP_NOASSERT */
+
+/** if "expression" isn't true, then print "message" and execute "handler" expression */
+#ifndef LWIP_ERROR
+#define LWIP_ERROR(message, expression, handler) do { if (!(expression)) { \
+  LWIP_PLATFORM_ASSERT(message); handler;}} while(0)
+#endif                          /* LWIP_ERROR */
+
+//#define LWIP_DEBUG 1
+#ifdef LWIP_DEBUG
+/** print debug message only if debug message type is enabled...
+ *  AND is of correct type AND is at least LWIP_DBG_LEVEL
+ */
+
+/*
+#define LWIP_DEBUGF(debug, message) do { \
+                                 LWIP_PLATFORM_DIAG(message); \
+                                } while(0)
+
+#else                          // LWIP_DEBUG
+#define LWIP_DEBUGF(debug, message)
+#endif                          // LWIP_DEBUG
+*/
+
+#define LWIP_DEBUGF(debug, message) do { \
+                               if ( \
+                                   ((debug) & LWIP_DBG_ON) && \
+                                   ((debug) & LWIP_DBG_TYPES_ON) && \
+                                   ((s16_t)((debug) & LWIP_DBG_MASK_LEVEL) >= LWIP_DBG_MIN_LEVEL)) { \
+                                 LWIP_PLATFORM_DIAG(message); \
+                                 if ((debug) & LWIP_DBG_HALT) { \
+                                   while(1); \
+                                 } \
+                               } \
+                             } while(0)
+
+#else                          // LWIP_DEBUG
+#define LWIP_DEBUGF(debug, message)
+#endif                          // LWIP_DEBUG
+
+#endif                          /* __LWIP_DEBUG_H__ */
diff --git a/lib/lwip/src/include/lwip/def.h b/lib/lwip/src/include/lwip/def.h
new file mode 100644
index 0000000..31980ef
--- /dev/null
+++ b/lib/lwip/src/include/lwip/def.h
@@ -0,0 +1,53 @@
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef __LWIP_DEF_H__
+#define __LWIP_DEF_H__
+
+/* this might define NULL already */
+#include "lwip/arch.h"
+
+/* This enum is used to give buffer_id */
+/*enum buffer_memory_types {
+    RX_BUFFER_ID = 0,
+    TX_BUFFER_ID = 1,
+};
+*/
+
+#define LWIP_MAX(x , y)  (((x) > (y)) ? (x) : (y))
+#define LWIP_MIN(x , y)  (((x) < (y)) ? (x) : (y))
+
+#ifndef NULL
+#define NULL ((void *)0)
+#endif
+
+
+#endif                          /* __LWIP_DEF_H__ */
diff --git a/lib/lwip/src/include/lwip/dhcp.h b/lib/lwip/src/include/lwip/dhcp.h
new file mode 100644
index 0000000..13a2166
--- /dev/null
+++ b/lib/lwip/src/include/lwip/dhcp.h
@@ -0,0 +1,241 @@
+/** @file
+ */
+
+#ifndef __LWIP_DHCP_H__
+#define __LWIP_DHCP_H__
+
+#include "lwip/opt.h"
+
+#if LWIP_DHCP                   /* don't build if not configured for use in lwipopts.h */
+
+#include "lwip/netif.h"
+#include "lwip/udp.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** period (in seconds) of the application calling dhcp_coarse_tmr() */
+#define DHCP_COARSE_TIMER_SECS 60
+/** period (in milliseconds) of the application calling dhcp_coarse_tmr() */
+#define DHCP_COARSE_TIMER_MSECS (DHCP_COARSE_TIMER_SECS * 1000UL)
+/** period (in milliseconds) of the application calling dhcp_fine_tmr() */
+#define DHCP_FINE_TIMER_MSECS 500
+
+    struct dhcp {
+  /** current DHCP state machine state */
+        u8_t state;
+  /** retries of current request */
+        u8_t tries;
+  /** transaction identifier of last sent request */
+        u32_t xid;
+  /** our connection to the DHCP server */
+        struct udp_pcb *pcb;
+  /** (first) pbuf of incoming msg */
+        struct pbuf *p;
+  /** incoming msg */
+        struct dhcp_msg *msg_in;
+  /** incoming msg options */
+        struct dhcp_msg *options_in;
+  /** ingoing msg options length */
+        u16_t options_in_len;
+
+        struct pbuf *p_out;     /* pbuf of outcoming msg */
+        struct dhcp_msg *msg_out;       /* outgoing msg */
+        u16_t options_out_len;  /* outgoing msg options length */
+        u16_t request_timeout;  /* #ticks with period DHCP_FINE_TIMER_SECS for request timeout */
+        u16_t t1_timeout;       /* #ticks with period DHCP_COARSE_TIMER_SECS for renewal time */
+        u16_t t2_timeout;       /* #ticks with period DHCP_COARSE_TIMER_SECS for rebind time */
+        struct ip_addr server_ip_addr;  /* dhcp server address that offered this lease */
+        struct ip_addr offered_ip_addr;
+        struct ip_addr offered_sn_mask;
+        struct ip_addr offered_gw_addr;
+        struct ip_addr offered_bc_addr;
+#define DHCP_MAX_DNS 2
+        u32_t dns_count;        /* actual number of DNS servers obtained */
+        struct ip_addr offered_dns_addr[DHCP_MAX_DNS];  /* DNS server addresses */
+
+        u32_t offered_t0_lease; /* lease period (in seconds) */
+        u32_t offered_t1_renew; /* recommended renew time (usually 50% of lease period) */
+        u32_t offered_t2_rebind;        /* recommended rebind time (usually 66% of lease period)  */
+#if LWIP_DHCP_AUTOIP_COOP
+        u8_t autoip_coop_state;
+#endif
+/** Patch #1308
+ *  TODO: See dhcp.c "TODO"s
+ */
+#if 0
+        struct ip_addr offered_si_addr;
+        u8_t *boot_file_name;
+#endif
+    };
+
+/* MUST be compiled with "pack structs" or equivalent! */
+#ifdef PACK_STRUCT_USE_INCLUDES
+#include "arch/bpstruct.h"
+#endif
+     PACK_STRUCT_BEGIN
+/** minimum set of fields of any DHCP message */
+      struct dhcp_msg {
+        PACK_STRUCT_FIELD(u8_t op);
+        PACK_STRUCT_FIELD(u8_t htype);
+        PACK_STRUCT_FIELD(u8_t hlen);
+        PACK_STRUCT_FIELD(u8_t hops);
+        PACK_STRUCT_FIELD(u32_t xid);
+        PACK_STRUCT_FIELD(u16_t secs);
+        PACK_STRUCT_FIELD(u16_t flags);
+        PACK_STRUCT_FIELD(struct ip_addr ciaddr);
+         PACK_STRUCT_FIELD(struct ip_addr yiaddr);
+         PACK_STRUCT_FIELD(struct ip_addr siaddr);
+         PACK_STRUCT_FIELD(struct ip_addr giaddr);
+#define DHCP_CHADDR_LEN 16U
+         PACK_STRUCT_FIELD(u8_t chaddr[DHCP_CHADDR_LEN]);
+#define DHCP_SNAME_LEN 64U
+         PACK_STRUCT_FIELD(u8_t sname[DHCP_SNAME_LEN]);
+#define DHCP_FILE_LEN 128U
+         PACK_STRUCT_FIELD(u8_t file[DHCP_FILE_LEN]);
+         PACK_STRUCT_FIELD(u32_t cookie);
+#define DHCP_MIN_OPTIONS_LEN 68U
+/** make sure user does not configure this too small */
+#if ((defined(DHCP_OPTIONS_LEN)) && (DHCP_OPTIONS_LEN < DHCP_MIN_OPTIONS_LEN))
+#undef DHCP_OPTIONS_LEN
+#endif
+/** allow this to be configured in lwipopts.h, but not too small */
+#if (!defined(DHCP_OPTIONS_LEN))
+/** set this to be sufficient for your options in outgoing DHCP msgs */
+#define DHCP_OPTIONS_LEN DHCP_MIN_OPTIONS_LEN
+#endif
+         PACK_STRUCT_FIELD(u8_t options[DHCP_OPTIONS_LEN]);
+    } PACK_STRUCT_STRUCT;
+     PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#include "arch/epstruct.h"
+#endif
+/** start DHCP configuration */
+     err_t dhcp_start(struct netif *netif);
+/** enforce early lease renewal (not needed normally)*/
+    err_t dhcp_renew(struct netif *netif);
+/** release the DHCP lease, usually called before dhcp_stop()*/
+    err_t dhcp_release(struct netif *netif);
+/** stop DHCP configuration */
+    void dhcp_stop(struct netif *netif);
+/** inform server of our manual IP address */
+    void dhcp_inform(struct netif *netif);
+
+/** if enabled, check whether the offered IP address is not in use, using ARP */
+#if DHCP_DOES_ARP_CHECK
+    void dhcp_arp_reply(struct netif *netif, struct ip_addr *addr);
+#endif
+
+/** to be called every minute */
+    void dhcp_coarse_tmr(void);
+/** to be called every half second */
+    void dhcp_fine_tmr(void);
+
+/** DHCP message item offsets and length */
+#define DHCP_MSG_OFS (UDP_DATA_OFS)
+#define DHCP_OP_OFS (DHCP_MSG_OFS + 0)
+#define DHCP_HTYPE_OFS (DHCP_MSG_OFS + 1)
+#define DHCP_HLEN_OFS (DHCP_MSG_OFS + 2)
+#define DHCP_HOPS_OFS (DHCP_MSG_OFS + 3)
+#define DHCP_XID_OFS (DHCP_MSG_OFS + 4)
+#define DHCP_SECS_OFS (DHCP_MSG_OFS + 8)
+#define DHCP_FLAGS_OFS (DHCP_MSG_OFS + 10)
+#define DHCP_CIADDR_OFS (DHCP_MSG_OFS + 12)
+#define DHCP_YIADDR_OFS (DHCP_MSG_OFS + 16)
+#define DHCP_SIADDR_OFS (DHCP_MSG_OFS + 20)
+#define DHCP_GIADDR_OFS (DHCP_MSG_OFS + 24)
+#define DHCP_CHADDR_OFS (DHCP_MSG_OFS + 28)
+#define DHCP_SNAME_OFS (DHCP_MSG_OFS + 44)
+#define DHCP_FILE_OFS (DHCP_MSG_OFS + 108)
+#define DHCP_MSG_LEN 236
+
+#define DHCP_COOKIE_OFS (DHCP_MSG_OFS + DHCP_MSG_LEN)
+#define DHCP_OPTIONS_OFS (DHCP_MSG_OFS + DHCP_MSG_LEN + 4)
+
+#define DHCP_CLIENT_PORT 68
+#define DHCP_SERVER_PORT 67
+
+/** DHCP client states */
+#define DHCP_REQUESTING 1
+#define DHCP_INIT 2
+#define DHCP_REBOOTING 3
+#define DHCP_REBINDING 4
+#define DHCP_RENEWING 5
+#define DHCP_SELECTING 6
+#define DHCP_INFORMING 7
+#define DHCP_CHECKING 8
+#define DHCP_PERMANENT 9
+#define DHCP_BOUND 10
+/** not yet implemented #define DHCP_RELEASING 11 */
+#define DHCP_BACKING_OFF 12
+#define DHCP_OFF 13
+
+/** AUTOIP cooperatation flags */
+#define DHCP_AUTOIP_COOP_STATE_OFF 0
+#define DHCP_AUTOIP_COOP_STATE_ON 1
+
+#define DHCP_BOOTREQUEST 1
+#define DHCP_BOOTREPLY 2
+
+#define DHCP_DISCOVER 1
+#define DHCP_OFFER 2
+#define DHCP_REQUEST 3
+#define DHCP_DECLINE 4
+#define DHCP_ACK 5
+#define DHCP_NAK 6
+#define DHCP_RELEASE 7
+#define DHCP_INFORM 8
+
+#define DHCP_HTYPE_ETH 1
+
+#define DHCP_HLEN_ETH 6
+
+#define DHCP_BROADCAST_FLAG 15
+#define DHCP_BROADCAST_MASK (1 << DHCP_FLAG_BROADCAST)
+
+/** BootP options */
+#define DHCP_OPTION_PAD 0
+#define DHCP_OPTION_SUBNET_MASK 1       /* RFC 2132 3.3 */
+#define DHCP_OPTION_ROUTER 3
+#define DHCP_OPTION_DNS_SERVER 6
+#define DHCP_OPTION_HOSTNAME 12
+#define DHCP_OPTION_IP_TTL 23
+#define DHCP_OPTION_MTU 26
+#define DHCP_OPTION_BROADCAST 28
+#define DHCP_OPTION_TCP_TTL 37
+#define DHCP_OPTION_END 255
+
+/** DHCP options */
+#define DHCP_OPTION_REQUESTED_IP 50     /* RFC 2132 9.1, requested IP address */
+#define DHCP_OPTION_LEASE_TIME 51       /* RFC 2132 9.2, time in seconds, in 4 bytes */
+#define DHCP_OPTION_OVERLOAD 52 /* RFC2132 9.3, use file and/or sname field for options */
+
+#define DHCP_OPTION_MESSAGE_TYPE 53     /* RFC 2132 9.6, important for DHCP */
+#define DHCP_OPTION_MESSAGE_TYPE_LEN 1
+
+
+#define DHCP_OPTION_SERVER_ID 54        /* RFC 2132 9.7, server IP address */
+#define DHCP_OPTION_PARAMETER_REQUEST_LIST 55   /* RFC 2132 9.8, requested option types */
+
+#define DHCP_OPTION_MAX_MSG_SIZE 57     /* RFC 2132 9.10, message size accepted >= 576 */
+#define DHCP_OPTION_MAX_MSG_SIZE_LEN 2
+
+#define DHCP_OPTION_T1 58       /* T1 renewal time */
+#define DHCP_OPTION_T2 59       /* T2 rebinding time */
+#define DHCP_OPTION_US 60
+#define DHCP_OPTION_CLIENT_ID 61
+#define DHCP_OPTION_TFTP_SERVERNAME 66
+#define DHCP_OPTION_BOOTFILE 67
+
+/** possible combinations of overloading the file and sname fields with options */
+#define DHCP_OVERLOAD_NONE 0
+#define DHCP_OVERLOAD_FILE 1
+#define DHCP_OVERLOAD_SNAME  2
+#define DHCP_OVERLOAD_SNAME_FILE 3
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* LWIP_DHCP */
+#endif /*__LWIP_DHCP_H__*/
diff --git a/lib/lwip/src/include/lwip/dns.h b/lib/lwip/src/include/lwip/dns.h
new file mode 100644
index 0000000..7f463bf
--- /dev/null
+++ b/lib/lwip/src/include/lwip/dns.h
@@ -0,0 +1,98 @@
+/**
+ * lwip DNS resolver header file.
+
+ * Author: Jim Pettinato 
+ *   April 2007
+
+ * ported from uIP resolv.c Copyright (c) 2002-2003, Adam Dunkels.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote
+ *    products derived from this software without specific prior
+ *    written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __LWIP_DNS_H__
+#define __LWIP_DNS_H__
+
+#include "lwip/opt.h"
+
+#if LWIP_DNS                    /* don't build if not configured for use in lwipopts.h */
+
+/** DNS timer period */
+#define DNS_TMR_INTERVAL          1000
+
+/** DNS field TYPE used for "Resource Records" */
+#define DNS_RRTYPE_A              1     /* a host address */
+#define DNS_RRTYPE_NS             2     /* an authoritative name server */
+#define DNS_RRTYPE_MD             3     /* a mail destination (Obsolete - use MX) */
+#define DNS_RRTYPE_MF             4     /* a mail forwarder (Obsolete - use MX) */
+#define DNS_RRTYPE_CNAME          5     /* the canonical name for an alias */
+#define DNS_RRTYPE_SOA            6     /* marks the start of a zone of authority */
+#define DNS_RRTYPE_MB             7     /* a mailbox domain name (EXPERIMENTAL) */
+#define DNS_RRTYPE_MG             8     /* a mail group member (EXPERIMENTAL) */
+#define DNS_RRTYPE_MR             9     /* a mail rename domain name (EXPERIMENTAL) */
+#define DNS_RRTYPE_NULL           10    /* a null RR (EXPERIMENTAL) */
+#define DNS_RRTYPE_WKS            11    /* a well known service description */
+#define DNS_RRTYPE_PTR            12    /* a domain name pointer */
+#define DNS_RRTYPE_HINFO          13    /* host information */
+#define DNS_RRTYPE_MINFO          14    /* mailbox or mail list information */
+#define DNS_RRTYPE_MX             15    /* mail exchange */
+#define DNS_RRTYPE_TXT            16    /* text strings */
+
+/** DNS field CLASS used for "Resource Records" */
+#define DNS_RRCLASS_IN            1     /* the Internet */
+#define DNS_RRCLASS_CS            2     /* the CSNET class (Obsolete - used only for examples in some obsolete RFCs) */
+#define DNS_RRCLASS_CH            3     /* the CHAOS class */
+#define DNS_RRCLASS_HS            4     /* Hesiod [Dyer 87] */
+#define DNS_RRCLASS_FLUSH         0x800 /* Flush bit */
+
+/** Callback which is invoked when a hostname is found.
+ * A function of this type must be implemented by the application using the DNS resolver.
+ * @param name pointer to the name that was looked up.
+ * @param ipaddr pointer to a struct ip_addr containing the IP address of the hostname,
+ *        or NULL if the name could not be found (or on any other error).
+ * @param callback_arg a user-specified callback argument passed to dns_gethostbyname
+*/
+typedef void (*dns_found_callback) (const char *name, struct ip_addr * ipaddr,
+                                    void *callback_arg);
+
+
+void dns_init(void);
+
+void dns_tmr(void);
+
+void dns_setserver(u8_t numdns, struct ip_addr *dnsserver);
+
+struct ip_addr dns_getserver(u8_t numdns);
+
+err_t dns_gethostbyname(const char *hostname, struct ip_addr *addr,
+                        dns_found_callback found, void *callback_arg);
+
+#if DNS_LOCAL_HOSTLIST && DNS_LOCAL_HOSTLIST_IS_DYNAMIC
+int dns_local_removehost(const char *hostname, const struct ip_addr *addr);
+err_t dns_local_addhost(const char *hostname, const struct ip_addr *addr);
+#endif                          /* DNS_LOCAL_HOSTLIST && DNS_LOCAL_HOSTLIST_IS_DYNAMIC */
+
+#endif                          /* LWIP_DNS */
+
+#endif                          /* __LWIP_DNS_H__ */
diff --git a/lib/lwip/src/include/lwip/err.h b/lib/lwip/src/include/lwip/err.h
new file mode 100644
index 0000000..3cae392
--- /dev/null
+++ b/lib/lwip/src/include/lwip/err.h
@@ -0,0 +1,89 @@
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved. 
+ * 
+ * Redistribution and use in source and binary forms, with or without modification, 
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission. 
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ * 
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef __LWIP_ERR_H__
+#define __LWIP_ERR_H__
+
+#include "lwip/opt.h"
+#include "lwip/arch.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** Define LWIP_ERR_T in cc.h if you want to use
+ *  a different type for your platform (must be signed). */
+#ifdef LWIP_ERR_T
+    typedef LWIP_ERR_T err_t;
+#else                           /* LWIP_ERR_T */
+    typedef s8_t err_t;
+#endif                          /* LWIP_ERR_T */
+
+/* Definitions for error constants. */
+
+#define ERR_OK          0       /* No error, everything OK. */
+#define ERR_MEM        -1       /* Out of memory error.     */
+#define ERR_BUF        -2       /* Buffer error.            */
+#define ERR_TIMEOUT    -3       /* Timeout.                 */
+#define ERR_RTE        -4       /* Routing problem.         */
+
+#define ERR_IS_FATAL(e) ((e) < ERR_RTE)
+
+#define ERR_ABRT       -5       /* Connection aborted.      */
+#define ERR_RST        -6       /* Connection reset.        */
+#define ERR_CLSD       -7       /* Connection closed.       */
+#define ERR_CONN       -8       /* Not connected.           */
+
+#define ERR_VAL        -9       /* Illegal value.           */
+
+#define ERR_ARG        -10      /* Illegal argument.        */
+
+#define ERR_USE        -11      /* Address in use.          */
+
+#define ERR_IF         -12      /* Low-level netif error    */
+#define ERR_ISCONN     -13      /* Already connected.       */
+
+#define ERR_INPROGRESS -14      /* Operation in progress    */
+
+
+#ifdef LWIP_DEBUG
+    extern const char *lwip_strerr(err_t err);
+#else
+#define lwip_strerr(x) ""
+#endif                          /* LWIP_DEBUG */
+
+#ifdef __cplusplus
+}
+#endif
+
+#include <errno.h>
+
+#endif                          /* __LWIP_ERR_H__ */
diff --git a/lib/lwip/src/include/lwip/init.h b/lib/lwip/src/include/lwip/init.h
new file mode 100644
index 0000000..92b6510
--- /dev/null
+++ b/lib/lwip/src/include/lwip/init.h
@@ -0,0 +1,165 @@
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef __LWIP_INIT_H__
+#define __LWIP_INIT_H__
+
+//#include <barrelfish/barrelfish.h>
+#include "lwip/opt.h"
+#include "lwip/err.h"
+#include <stdbool.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** X.x.x: Major version of the stack */
+#define LWIP_VERSION_MAJOR      1U
+/** x.X.x: Minor version of the stack */
+#define LWIP_VERSION_MINOR      3U
+/** x.x.X: Revision of the stack */
+#define LWIP_VERSION_REVISION   1U
+/** For release candidates, this is set to 1..254
+  * For official releases, this is set to 255 (LWIP_RC_RELEASE)
+  * For development versions (CVS), this is set to 0 (LWIP_RC_DEVELOPMENT) */
+#define LWIP_VERSION_RC         255U
+
+/** LWIP_VERSION_RC is set to LWIP_RC_RELEASE for official releases */
+#define LWIP_RC_RELEASE         255U
+/** LWIP_VERSION_RC is set to LWIP_RC_DEVELOPMENT for CVS versions */
+#define LWIP_RC_DEVELOPMENT     0U
+
+#define LWIP_VERSION_IS_RELEASE     (LWIP_VERSION_RC == LWIP_RC_RELEASE)
+#define LWIP_VERSION_IS_DEVELOPMENT (LWIP_VERSION_RC == LWIP_RC_DEVELOPMENT)
+#define LWIP_VERSION_IS_RC          ((LWIP_VERSION_RC != LWIP_RC_RELEASE) && (LWIP_VERSION_RC != LWIP_RC_DEVELOPMENT))
+
+/** Provides the version of the stack */
+#define LWIP_VERSION   (LWIP_VERSION_MAJOR << 24   | LWIP_VERSION_MINOR << 16 | \
+                        LWIP_VERSION_REVISION << 8 | LWIP_VERSION_RC)
+
+enum net_ports_port_type_t;
+
+// FIXME: remove this
+void perform_ownership_housekeeping(uint16_t(*alloc_tcp_ptr) (void),
+                                        uint16_t(*alloc_udp_ptr) (void),
+                                        uint16_t(*bind_port_ptr) (uint16_t,
+                                                enum net_ports_port_type_t),
+                                        void (*close_port_ptr) (uint16_t,
+                                                enum net_ports_port_type_t));
+
+// global variables
+struct waitset;
+struct thread_mutex;
+
+// *********************************************************************
+// function prototypes
+// *********************************************************************
+
+// Tells if this app is special or not
+bool is_this_special_app(void);
+
+// To be called from "netd" which is responsible for ARP table
+struct netif *owner_lwip_init(char *card_name, uint64_t queueid);
+
+// initialize networkign with specific card and queue
+bool lwip_init(const char *card_name, uint64_t queueid);
+
+// initialize networking when cardname and queue is not known
+bool lwip_init_auto(void);
+
+// FIXME: remove these functions as they are not used anymore
+int is_lwip_loaded(void);
+uint64_t lwip_packet_drop_count(void);
+
+
+uint64_t wrapper_perform_lwip_work(void);
+
+void lwip_benchmark_control(int connection, uint8_t state, uint64_t trigger,
+        uint64_t cl);
+uint8_t lwip_driver_benchmark_state(int direction, uint64_t *delta,
+        uint64_t *cl);
+void lwip_debug_show_spp_status(int connection);
+
+enum Recorded_Events {
+    RE_ALL,
+    RX_ALL_PROCESS,
+    RE_REG_PBUF,
+    RE_PBUF_REPLACE,
+    RE_PBUF_REPLACE_1,
+    RE_PBUF_REPLACE_2,
+    RE_PBUF_QUEUE,
+    RE_PKT_RCV_CS,
+    RE_PBUF_REPLACE_3,
+    TX_SP,
+    TX_SP1,
+    TX_SPP_FULL,
+    TX_SN_WAIT,
+    TX_SN_SEND,
+    TX_A_SP_RN_CS,
+    TX_A_SP_RN_T,
+    TX_SND_PKT_C,
+    TX_SND_PKT_S,
+/*
+    RPC_RECV_T,
+    RPC_CALLBACK_T,
+    RPC_RECV_OUT_T,
+*/
+    RPC_CALL_T,
+    NFS_READCB_T,
+    NFS_READ_T,
+    NFS_READ_1_T,
+    NFS_READ_w_T,
+    RECORDED_EVENTS_COUNT  // MUST BE THE LAST ELEMENT!!
+};
+
+extern struct netbench_details *nb;
+void lwip_print_interesting_stats(void);
+void lwip_record_event_simple(uint8_t event_type, uint64_t ts);
+
+bool lwip_init_auto_ex(struct waitset *opt_waitset,
+                       struct thread_mutex *opt_mutex);
+bool lwip_init_ex(const char *card_name, uint64_t queueid,
+                  struct waitset *opt_waitset, struct thread_mutex *opt_mutex);
+
+// For supporting hardware features
+enum enabled_hardware_features {
+    IPv4_CHECKSUM_HW = 1,
+    IPv6_CHECKSUM_HW,
+    UDP_IPV4_CHECKSUM_HW,
+    TCP_IPV4_CHECKSUM_HW,
+};
+bool is_hw_feature_enabled(int hw_feature);
+#ifdef __cplusplus
+}
+#endif
+
+#endif // __LWIP_INIT_H__
+
diff --git a/lib/lwip/src/include/lwip/mem.h b/lib/lwip/src/include/lwip/mem.h
new file mode 100644
index 0000000..d0a3fe7
--- /dev/null
+++ b/lib/lwip/src/include/lwip/mem.h
@@ -0,0 +1,105 @@
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved. 
+ * 
+ * Redistribution and use in source and binary forms, with or without modification, 
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission. 
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ * 
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef __LWIP_MEM_H__
+#define __LWIP_MEM_H__
+
+#include "lwip/opt.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if MEM_LIBC_MALLOC
+
+#include <stddef.h>             /* for size_t */
+
+    typedef size_t mem_size_t;
+
+/* aliases for C library malloc() */
+#define mem_init()
+/* in case C library malloc() needs extra protection,
+ * allow these defines to be overridden.
+ */
+#ifndef mem_free
+#define mem_free free
+#endif
+#ifndef mem_malloc
+#define mem_malloc malloc
+#endif
+#ifndef mem_calloc
+#define mem_calloc calloc
+#endif
+#ifndef mem_realloc
+    static void *mem_realloc(void *mem, mem_size_t size) {
+        LWIP_UNUSED_ARG(size);
+        return mem;
+    }
+#endif
+#else                           /* MEM_LIBC_MALLOC */
+
+/* MEM_SIZE would have to be aligned, but using 64000 here instead of
+ * 65535 leaves some room for alignment...
+ */
+#if MEM_SIZE > 64000l
+    typedef u32_t mem_size_t;
+#else
+    typedef u16_t mem_size_t;
+#endif                          /* MEM_SIZE > 64000 */
+
+#if MEM_USE_POOLS
+/** mem_init is not used when using pools instead of a heap */
+#define mem_init()
+/** mem_realloc is not used when using pools instead of a heap:
+    we can't free part of a pool element and don't want to copy the rest */
+#define mem_realloc(mem, size) (mem)
+#else                           /* MEM_USE_POOLS */
+/* lwIP alternative malloc */
+    void mem_init(void);
+    void *mem_realloc(void *mem, mem_size_t size);
+#endif                          /* MEM_USE_POOLS */
+    void *mem_malloc(mem_size_t size);
+    void *mem_calloc(mem_size_t count, mem_size_t size);
+    void mem_free(void *mem);
+#endif                          /* MEM_LIBC_MALLOC */
+
+#ifndef LWIP_MEM_ALIGN_SIZE
+#define LWIP_MEM_ALIGN_SIZE(size) (((size) + MEM_ALIGNMENT - 1) & ~(MEM_ALIGNMENT-1))
+#endif
+
+#ifndef LWIP_MEM_ALIGN
+#define LWIP_MEM_ALIGN(addr) ((void *)(((mem_ptr_t)(addr) + MEM_ALIGNMENT - 1) & ~(mem_ptr_t)(MEM_ALIGNMENT-1)))
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* __LWIP_MEM_H__ */
diff --git a/lib/lwip/src/include/lwip/memp.h b/lib/lwip/src/include/lwip/memp.h
new file mode 100644
index 0000000..9d54481
--- /dev/null
+++ b/lib/lwip/src/include/lwip/memp.h
@@ -0,0 +1,117 @@
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+
+#ifndef __LWIP_MEMP_H__
+#define __LWIP_MEMP_H__
+
+#include "lwip/opt.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Create the list of all memory pools managed by memp. MEMP_MAX represents a NULL pool at the end */
+    typedef enum {
+#define LWIP_MEMPOOL(name,num,size,desc)  MEMP_##name,
+#include "lwip/memp_std.h"
+        MEMP_MAX
+    } memp_t;
+
+#if MEM_USE_POOLS
+/* Use a helper type to get the start and end of the user "memory pools" for mem_malloc */
+    typedef enum {
+        /* Get the first (via:
+           MEMP_POOL_HELPER_START = ((u8_t) 1*MEMP_POOL_A + 0*MEMP_POOL_B + 0*MEMP_POOL_C + 0) */
+        MEMP_POOL_HELPER_FIRST = ((u8_t)
+#define LWIP_MEMPOOL(name,num,size,desc)
+#define LWIP_MALLOC_MEMPOOL_START 1
+#define LWIP_MALLOC_MEMPOOL(num, size) * MEMP_POOL_##size + 0
+#define LWIP_MALLOC_MEMPOOL_END
+#include "lwip/memp_std.h"
+          ),
+        /* Get the last (via:
+           MEMP_POOL_HELPER_END = ((u8_t) 0 + MEMP_POOL_A*0 + MEMP_POOL_B*0 + MEMP_POOL_C*1) */
+        MEMP_POOL_HELPER_LAST = ((u8_t)
+#define LWIP_MEMPOOL(name,num,size,desc)
+#define LWIP_MALLOC_MEMPOOL_START
+#define LWIP_MALLOC_MEMPOOL(num, size) 0 + MEMP_POOL_##size *
+#define LWIP_MALLOC_MEMPOOL_END 1
+#include "lwip/memp_std.h"
+          )
+    } memp_pool_helper_t;
+
+/* The actual start and stop values are here (cast them over)
+   We use this helper type and these defines so we can avoid using const memp_t values */
+#define MEMP_POOL_FIRST ((memp_t) MEMP_POOL_HELPER_FIRST)
+#define MEMP_POOL_LAST   ((memp_t) MEMP_POOL_HELPER_LAST)
+#endif                          /* MEM_USE_POOLS */
+
+#if MEMP_MEM_MALLOC || MEM_USE_POOLS
+    extern const u16_t memp_sizes[MEMP_MAX];
+#endif                          /* MEMP_MEM_MALLOC || MEM_USE_POOLS */
+
+#if MEMP_MEM_MALLOC
+
+#include "mem.h"
+
+#define memp_init()
+#define memp_initialize_pbuf_list()
+#define memp_malloc(type)     mem_malloc(memp_sizes[type])
+#define memp_free(type, mem)  mem_free(mem)
+
+#else                           /* MEMP_MEM_MALLOC */
+
+#if MEM_USE_POOLS
+/** This structure is used to save the pool one element came from. */
+    struct memp_malloc_helper {
+        memp_t poolnr;
+    };
+#endif                          /* MEM_USE_POOLS */
+
+    void memp_init(void);
+    u16_t memp_pbuf_peek(void);
+    void memp_initialize_pbuf_list(void);
+
+#if MEMP_OVERFLOW_CHECK
+    void *memp_malloc_fn(memp_t type, const char *file, const int line);
+#define memp_malloc(t) memp_malloc_fn((t), __FILE__, __LINE__)
+#else
+    void *memp_malloc(memp_t type);
+#endif
+    void memp_free(memp_t type, void *mem);
+
+#endif                          /* MEMP_MEM_MALLOC */
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* __LWIP_MEMP_H__ */
diff --git a/lib/lwip/src/include/lwip/memp_std.h b/lib/lwip/src/include/lwip/memp_std.h
new file mode 100644
index 0000000..4bde61b
--- /dev/null
+++ b/lib/lwip/src/include/lwip/memp_std.h
@@ -0,0 +1,98 @@
+/*
+ * SETUP: Make sure we define everything we will need.
+ *
+ * We have create three types of pools:
+ *   1) MEMPOOL - standard pools
+ *   2) MALLOC_MEMPOOL - to be used by mem_malloc in mem.c
+ *   3) PBUF_MEMPOOL - a mempool of pbuf's, so include space for the pbuf struct
+ *
+ * If the include'r doesn't require any special treatment of each of the types
+ * above, then will declare #2 & #3 to be just standard mempools.
+ */
+#ifndef LWIP_MALLOC_MEMPOOL
+/* This treats "malloc pools" just like any other pool.
+   The pools are a little bigger to provide 'size' as the amount of user data. */
+#define LWIP_MALLOC_MEMPOOL(num, size) LWIP_MEMPOOL(POOL_##size, num, (size + sizeof(struct memp_malloc_helper)), "MALLOC_"#size)
+#define LWIP_MALLOC_MEMPOOL_START
+#define LWIP_MALLOC_MEMPOOL_END
+#endif                          /* LWIP_MALLOC_MEMPOOL */
+
+#ifndef LWIP_PBUF_MEMPOOL
+/* This treats "pbuf pools" just like any other pool.
+ * Allocates buffers for a pbuf struct AND a payload size */
+#define LWIP_PBUF_MEMPOOL(name, num, payload, desc) LWIP_MEMPOOL(name, num, (MEMP_ALIGN_SIZE(sizeof(struct pbuf)) + MEMP_ALIGN_SIZE(payload)), desc)
+#endif                          /* LWIP_PBUF_MEMPOOL */
+
+
+/*
+ * A list of internal pools used by LWIP.
+ *
+ * LWIP_MEMPOOL(pool_name, number_elements, element_size, pool_description)
+ *     creates a pool name MEMP_pool_name. description is used in stats.c
+ */
+#if LWIP_RAW
+LWIP_MEMPOOL(RAW_PCB, MEMP_NUM_RAW_PCB, sizeof(struct raw_pcb), "RAW_PCB")
+#endif                          /* LWIP_RAW */
+#if LWIP_UDP
+  LWIP_MEMPOOL(UDP_PCB, MEMP_NUM_UDP_PCB, sizeof(struct udp_pcb), "UDP_PCB")
+#endif                          /* LWIP_UDP */
+#if LWIP_TCP
+  LWIP_MEMPOOL(TCP_PCB, MEMP_NUM_TCP_PCB, sizeof(struct tcp_pcb), "TCP_PCB")
+  LWIP_MEMPOOL(TCP_PCB_LISTEN, MEMP_NUM_TCP_PCB_LISTEN,
+             sizeof(struct tcp_pcb_listen), "TCP_PCB_LISTEN")
+  LWIP_MEMPOOL(TCP_SEG, MEMP_NUM_TCP_SEG, sizeof(struct tcp_seg), "TCP_SEG")
+#endif                          /* LWIP_TCP */
+#if IP_REASSEMBLY
+  LWIP_MEMPOOL(REASSDATA, MEMP_NUM_REASSDATA, sizeof(struct ip_reassdata),
+             "REASSDATA")
+#endif                          /* IP_REASSEMBLY */
+#if LWIP_NETCONN
+  LWIP_MEMPOOL(NETBUF, MEMP_NUM_NETBUF, sizeof(struct netbuf), "NETBUF")
+  LWIP_MEMPOOL(NETCONN, MEMP_NUM_NETCONN, sizeof(struct netconn), "NETCONN")
+#endif                          /* LWIP_NETCONN */
+#if NO_SYS==0
+  LWIP_MEMPOOL(TCPIP_MSG_API, MEMP_NUM_TCPIP_MSG_API, sizeof(struct tcpip_msg),
+             "TCPIP_MSG_API")
+  LWIP_MEMPOOL(TCPIP_MSG_INPKT, MEMP_NUM_TCPIP_MSG_INPKT,
+             sizeof(struct tcpip_msg), "TCPIP_MSG_INPKT")
+#endif                          /* NO_SYS==0 */
+#if ARP_QUEUEING
+  LWIP_MEMPOOL(ARP_QUEUE, MEMP_NUM_ARP_QUEUE, sizeof(struct etharp_q_entry),
+             "ARP_QUEUE")
+#endif                          /* ARP_QUEUEING */
+#if LWIP_IGMP
+  LWIP_MEMPOOL(IGMP_GROUP, MEMP_NUM_IGMP_GROUP, sizeof(struct igmp_group),
+             "IGMP_GROUP")
+#endif                          /* LWIP_IGMP */
+#if NO_SYS==0
+  LWIP_MEMPOOL(SYS_TIMEOUT, MEMP_NUM_SYS_TIMEOUT, sizeof(struct sys_timeo),
+             "SYS_TIMEOUT")
+#endif                          /* NO_SYS==0 */
+/*
+ * A list of pools of pbuf's used by LWIP.
+ *
+ * LWIP_PBUF_MEMPOOL(pool_name, number_elements, pbuf_payload_size, pool_description)
+ *     creates a pool name MEMP_pool_name. description is used in stats.c
+ *     This allocates enough space for the pbuf struct and a payload.
+ *     (Example: pbuf_payload_size=0 allocates only size for the struct)
+ */
+  LWIP_PBUF_MEMPOOL(PBUF, MEMP_NUM_PBUF + PBUF_POOL_SIZE, 0, "PBUF_REF/ROM")
+  LWIP_MEMPOOL(PBUF_POOL, PBUF_POOL_SIZE, PBUF_POOL_BUFSIZE, "PBUF_POOL")
+
+
+/*
+ * Allow for user-defined pools; this must be explicitly set in lwipopts.h
+ * since the default is to NOT look for lwippools.h
+ */
+#if MEMP_USE_CUSTOM_POOLS
+#include "lwippools.h"
+#endif                          /* MEMP_USE_CUSTOM_POOLS */
+/*
+ * REQUIRED CLEANUP: Clear up so we don't get "multiply defined" error later
+ * (#undef is ignored for something that is not defined)
+ */
+#undef LWIP_MEMPOOL
+#undef LWIP_MALLOC_MEMPOOL
+#undef LWIP_MALLOC_MEMPOOL_START
+#undef LWIP_MALLOC_MEMPOOL_END
+#undef LWIP_PBUF_MEMPOOL
diff --git a/lib/lwip/src/include/lwip/netbuf.h b/lib/lwip/src/include/lwip/netbuf.h
new file mode 100644
index 0000000..59a14f6
--- /dev/null
+++ b/lib/lwip/src/include/lwip/netbuf.h
@@ -0,0 +1,73 @@
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved. 
+ * 
+ * Redistribution and use in source and binary forms, with or without modification, 
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission. 
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ * 
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef __LWIP_NETBUF_H__
+#define __LWIP_NETBUF_H__
+
+#include "lwip/opt.h"
+#include "lwip/pbuf.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+    struct netbuf {
+        struct pbuf *p, *ptr;
+        struct ip_addr *addr;
+        u16_t port;
+    };
+
+/* Network buffer functions: */
+    struct netbuf *netbuf_new(void);
+    void netbuf_delete(struct netbuf *buf);
+    void *netbuf_alloc(struct netbuf *buf, u16_t size);
+    void netbuf_free(struct netbuf *buf);
+    err_t netbuf_ref(struct netbuf *buf, const void *dataptr, u16_t size);
+    void netbuf_chain(struct netbuf *head, struct netbuf *tail);
+
+    u16_t netbuf_len(struct netbuf *buf);
+    err_t netbuf_data(struct netbuf *buf, void **dataptr, u16_t * len);
+    s8_t netbuf_next(struct netbuf *buf);
+    void netbuf_first(struct netbuf *buf);
+
+
+#define netbuf_copy_partial(buf, dataptr, len, offset) \
+  pbuf_copy_partial((buf)->p, (dataptr), (len), (offset))
+#define netbuf_copy(buf,dataptr,len) netbuf_copy_partial(buf, dataptr, len, 0)
+#define netbuf_take(buf, dataptr, len) pbuf_take((buf)->p, dataptr, len)
+#define netbuf_len(buf)              ((buf)->p->tot_len)
+#define netbuf_fromaddr(buf)         ((buf)->addr)
+#define netbuf_fromport(buf)         ((buf)->port)
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* __LWIP_NETBUF_H__ */
diff --git a/lib/lwip/src/include/lwip/netdb.h b/lib/lwip/src/include/lwip/netdb.h
new file mode 100644
index 0000000..1df6865
--- /dev/null
+++ b/lib/lwip/src/include/lwip/netdb.h
@@ -0,0 +1,112 @@
+/*
+ * Redistribution and use in source and binary forms, with or without modification, 
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission. 
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ * 
+ * Author: Simon Goldschmidt
+ *
+ */
+
+#include "lwip/opt.h"
+
+#if LWIP_DNS && LWIP_SOCKET
+
+#include <stddef.h>             /* for size_t */
+
+#include "lwip/sockets.h"
+
+/* some rarely used options */
+#ifndef LWIP_DNS_API_DECLARE_H_ERRNO
+#define LWIP_DNS_API_DECLARE_H_ERRNO 1
+#endif
+
+#ifndef LWIP_DNS_API_DEFINE_ERRORS
+#define LWIP_DNS_API_DEFINE_ERRORS 1
+#endif
+
+#ifndef LWIP_DNS_API_DECLARE_STRUCTS
+#define LWIP_DNS_API_DECLARE_STRUCTS 1
+#endif
+
+#if LWIP_DNS_API_DEFINE_ERRORS
+/** Errors used by the DNS API functions, h_errno can be one of them */
+#define EAI_NONAME      200
+#define EAI_SERVICE     201
+#define EAI_FAIL        202
+#define EAI_MEMORY      203
+#define EAI_FAMILY      204
+
+#define HOST_NOT_FOUND  210
+#define NO_DATA         211
+#define NO_RECOVERY     212
+#define TRY_AGAIN       213
+#define EAI_AGAIN	TRY_AGAIN
+#endif                          /* LWIP_DNS_API_DEFINE_ERRORS */
+
+#if LWIP_DNS_API_DECLARE_STRUCTS
+struct hostent {
+    char *h_name;               /* Official name of the host. */
+    char **h_aliases;           /* A pointer to an array of pointers to alternative host names,
+                                   terminated by a null pointer. */
+    int h_addrtype;             /* Address type. */
+    int h_length;               /* The length, in bytes, of the address. */
+    char **h_addr_list;         /* A pointer to an array of pointers to network addresses (in
+                                   network byte order) for the host, terminated by a null pointer. */
+#define h_addr h_addr_list[0]   /* for backward compatibility */
+};
+
+struct addrinfo {
+    int ai_flags;               /* Input flags. */
+    int ai_family;              /* Address family of socket. */
+    int ai_socktype;            /* Socket type. */
+    int ai_protocol;            /* Protocol of socket. */
+    socklen_t ai_addrlen;       /* Length of socket address. */
+    struct sockaddr *ai_addr;   /* Socket address of socket. */
+    char *ai_canonname;         /* Canonical name of service location. */
+    struct addrinfo *ai_next;   /* Pointer to next in list. */
+};
+#endif                          /* LWIP_DNS_API_DECLARE_STRUCTS */
+
+#if LWIP_DNS_API_DECLARE_H_ERRNO
+/* application accessable error code set by the DNS API functions */
+extern int h_errno;
+#endif                          /* LWIP_DNS_API_DECLARE_H_ERRNO */
+
+struct hostent *lwip_gethostbyname(const char *name);
+int lwip_gethostbyname_r(const char *name, struct hostent *ret, char *buf,
+                         size_t buflen, struct hostent **result, int *h_errnop);
+void lwip_freeaddrinfo(struct addrinfo *ai);
+int lwip_getaddrinfo(const char *nodename,
+                     const char *servname,
+                     const struct addrinfo *hints, struct addrinfo **res);
+
+#if LWIP_COMPAT_SOCKETS
+#define gethostbyname(name) lwip_gethostbyname(name)
+#define gethostbyname_r(name, ret, buf, buflen, result, h_errnop) \
+       lwip_gethostbyname_r(name, ret, buf, buflen, result, h_errnop)
+#define freeaddrinfo(addrinfo) lwip_freeaddrinfo(a)
+#define getaddrinfo(nodname, servname, hints, res) \
+       lwip_getaddrinfo(nodname, servname, hints, res)
+#endif                          /* LWIP_COMPAT_SOCKETS */
+
+#endif                          /* LWIP_DNS && LWIP_SOCKET */
diff --git a/lib/lwip/src/include/lwip/netif.h b/lib/lwip/src/include/lwip/netif.h
new file mode 100644
index 0000000..c0ca6b1
--- /dev/null
+++ b/lib/lwip/src/include/lwip/netif.h
@@ -0,0 +1,268 @@
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved. 
+ * 
+ * Redistribution and use in source and binary forms, with or without modification, 
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission. 
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ * 
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef __LWIP_NETIF_H__
+#define __LWIP_NETIF_H__
+
+#include "lwip/opt.h"
+
+#define ENABLE_LOOPBACK (LWIP_NETIF_LOOPBACK || LWIP_HAVE_LOOPIF)
+
+#include "lwip/err.h"
+
+#include "lwip/ip_addr.h"
+
+#include "lwip/inet.h"
+#include "lwip/pbuf.h"
+#if LWIP_DHCP
+struct dhcp;
+#endif
+#if LWIP_AUTOIP
+struct autoip;
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Throughout this file, IP addresses are expected to be in
+ * the same byte order as in IP_PCB. */
+
+/** must be the maximum of all used hardware address lengths
+    across all types of interfaces in use */
+#define NETIF_MAX_HWADDR_LEN 6U
+
+/** TODO: define the use (where, when, whom) of netif flags */
+
+/** whether the network interface is 'up'. this is
+ * a software flag used to control whether this network
+ * interface is enabled and processes traffic.
+ */
+#define NETIF_FLAG_UP           0x01U
+/** if set, the netif has broadcast capability */
+#define NETIF_FLAG_BROADCAST    0x02U
+/** if set, the netif is one end of a point-to-point connection */
+#define NETIF_FLAG_POINTTOPOINT 0x04U
+/** if set, the interface is configured using DHCP */
+#define NETIF_FLAG_DHCP         0x08U
+/** if set, the interface has an active link
+ *  (set by the network interface driver) */
+#define NETIF_FLAG_LINK_UP      0x10U
+/** if set, the netif is an device using ARP */
+#define NETIF_FLAG_ETHARP       0x20U
+/** if set, the netif has IGMP capability */
+#define NETIF_FLAG_IGMP         0x40U
+
+/** Generic data structure used for all lwIP network interfaces.
+ *  The following fields should be filled in by the initialization
+ *  function for the device driver: hwaddr_len, hwaddr[], mtu, flags */
+
+    struct netif {
+  /** pointer to next in linked list */
+        struct netif *next;
+
+  /** IP address configuration in network byte order */
+        struct ip_addr ip_addr;
+        struct ip_addr netmask;
+        struct ip_addr gw;
+
+  /** This function is called by the network device driver
+   *  to pass a packet up the TCP/IP stack. */
+         err_t(*input) (struct pbuf * p, struct netif * inp);
+  /** This function is called by the IP module when it wants
+   *  to send a packet on the interface. This function typically
+   *  first resolves the hardware address, then sends the packet. */
+         err_t(*output) (struct netif * netif, struct pbuf * p,
+                         struct ip_addr * ipaddr);
+  /** This function is called by the ARP module when it wants
+   *  to send a packet on the interface. This function outputs
+   *  the pbuf as-is on the link medium. */
+         err_t(*linkoutput) (struct netif * netif, struct pbuf * p);
+#if LWIP_NETIF_STATUS_CALLBACK
+  /** This function is called when the netif state is set to up or down
+   */
+        void (*status_callback) (struct netif * netif);
+#endif                          /* LWIP_NETIF_STATUS_CALLBACK */
+#if LWIP_NETIF_LINK_CALLBACK
+  /** This function is called when the netif link is set to up or down
+   */
+        void (*link_callback) (struct netif * netif);
+#endif                          /* LWIP_NETIF_LINK_CALLBACK */
+  /** This field can be set by the device driver and could point
+   *  to state information for the device. */
+        void *state;
+#if LWIP_DHCP
+  /** the DHCP client state information for this netif */
+        struct dhcp *dhcp;
+#endif                          /* LWIP_DHCP */
+#if LWIP_AUTOIP
+  /** the AutoIP client state information for this netif */
+        struct autoip *autoip;
+#endif
+#if LWIP_NETIF_HOSTNAME
+        /* the hostname for this netif, NULL is a valid value */
+        char *hostname;
+#endif                          /* LWIP_NETIF_HOSTNAME */
+  /** number of bytes used in hwaddr */
+        u8_t hwaddr_len;
+  /** link level hardware address of this interface */
+        u8_t hwaddr[NETIF_MAX_HWADDR_LEN];
+  /** maximum transfer unit (in bytes) */
+        u16_t mtu;
+  /** flags (see NETIF_FLAG_ above) */
+        u8_t flags;
+  /** descriptive abbreviation */
+        char name[2];
+  /** number of this interface */
+        u8_t num;
+#if LWIP_SNMP
+  /** link type (from "snmp_ifType" enum from snmp.h) */
+        u8_t link_type;
+  /** (estimate) link speed */
+        u32_t link_speed;
+  /** timestamp at last change made (up/down) */
+        u32_t ts;
+  /** counters */
+        u32_t ifinoctets;
+        u32_t ifinucastpkts;
+        u32_t ifinnucastpkts;
+        u32_t ifindiscards;
+        u32_t ifoutoctets;
+        u32_t ifoutucastpkts;
+        u32_t ifoutnucastpkts;
+        u32_t ifoutdiscards;
+#endif                          /* LWIP_SNMP */
+#if LWIP_IGMP
+        /* This function could be called to add or delete a entry in the multicast filter table of the ethernet MAC. */
+         err_t(*igmp_mac_filter) (struct netif * netif, struct ip_addr * group,
+                                  u8_t action);
+#endif                          /* LWIP_IGMP */
+#if LWIP_NETIF_HWADDRHINT
+        u8_t *addr_hint;
+#endif                          /* LWIP_NETIF_HWADDRHINT */
+#if ENABLE_LOOPBACK
+        /* List of packets to be queued for ourselves. */
+        struct pbuf *loop_first;
+        struct pbuf *loop_last;
+#if LWIP_LOOPBACK_MAX_PBUFS
+        u16_t loop_cnt_current;
+#endif                          /* LWIP_LOOPBACK_MAX_PBUFS */
+#endif                          /* ENABLE_LOOPBACK */
+    };
+
+#if LWIP_SNMP
+#define NETIF_INIT_SNMP(netif, type, speed) \
+  /* use "snmp_ifType" enum from snmp.h for "type", snmp_ifType_ethernet_csmacd by example */ \
+  netif->link_type = type;    \
+  /* your link speed here (units: bits per second) */  \
+  netif->link_speed = speed;  \
+  netif->ts = 0;              \
+  netif->ifinoctets = 0;      \
+  netif->ifinucastpkts = 0;   \
+  netif->ifinnucastpkts = 0;  \
+  netif->ifindiscards = 0;    \
+  netif->ifoutoctets = 0;     \
+  netif->ifoutucastpkts = 0;  \
+  netif->ifoutnucastpkts = 0; \
+  netif->ifoutdiscards = 0
+#else                           /* LWIP_SNMP */
+#define NETIF_INIT_SNMP(netif, type, speed)
+#endif                          /* LWIP_SNMP */
+
+
+/** The list of network interfaces. */
+    extern struct netif *netif_list;
+/** The default network interface. */
+    extern struct netif *netif_default;
+
+#define netif_init()            /* Compatibility define, not init needed. */
+
+    struct netif *netif_add(struct netif *netif, struct ip_addr *ipaddr,
+                            struct ip_addr *netmask, struct ip_addr *gw,
+                            void *state, err_t(*init) (struct netif * netif),
+                            err_t(*input) (struct pbuf * p,
+                                           struct netif * netif));
+
+    void
+     netif_set_addr(struct netif *netif, struct ip_addr *ipaddr,
+                    struct ip_addr *netmask, struct ip_addr *gw);
+    void netif_remove(struct netif *netif);
+
+/* Returns a network interface given its name. The name is of the form
+   "et0", where the first two letters are the "name" field in the
+   netif structure, and the digit is in the num field in the same
+   structure. */
+    struct netif *netif_find(char *name);
+
+    void netif_set_default(struct netif *netif);
+
+    void netif_set_ipaddr(struct netif *netif, struct ip_addr *ipaddr);
+    void netif_set_netmask(struct netif *netif, struct ip_addr *netmask);
+    void netif_set_gw(struct netif *netif, struct ip_addr *gw);
+
+    void netif_set_up(struct netif *netif);
+    void netif_set_down(struct netif *netif);
+    u8_t netif_is_up(struct netif *netif);
+
+#if LWIP_NETIF_STATUS_CALLBACK
+/*
+ * Set callback to be called when interface is brought up/down
+ */
+    void netif_set_status_callback(struct netif *netif,
+                                   void (*status_callback) (struct netif *
+                                                            netif));
+#endif                          /* LWIP_NETIF_STATUS_CALLBACK */
+
+#if LWIP_NETIF_LINK_CALLBACK
+    void netif_set_link_up(struct netif *netif);
+    void netif_set_link_down(struct netif *netif);
+    u8_t netif_is_link_up(struct netif *netif);
+/*
+ * Set callback to be called when link is brought up/down
+ */
+    void netif_set_link_callback(struct netif *netif,
+                                 void (*link_callback) (struct netif * netif));
+#endif                          /* LWIP_NETIF_LINK_CALLBACK */
+
+#ifdef __cplusplus
+}
+#endif
+#if ENABLE_LOOPBACK
+err_t netif_loop_output(struct netif *netif, struct pbuf *p,
+                        struct ip_addr *dest_ip);
+void netif_poll(struct netif *netif);
+
+#if !LWIP_NETIF_LOOPBACK_MULTITHREADING
+void netif_poll_all(void);
+#endif                          /* !LWIP_NETIF_LOOPBACK_MULTITHREADING */
+#endif                          /* ENABLE_LOOPBACK */
+
+#endif                          /* __LWIP_NETIF_H__ */
diff --git a/lib/lwip/src/include/lwip/netifapi.h b/lib/lwip/src/include/lwip/netifapi.h
new file mode 100644
index 0000000..4b8186b
--- /dev/null
+++ b/lib/lwip/src/include/lwip/netifapi.h
@@ -0,0 +1,99 @@
+/*
+ * Redistribution and use in source and binary forms, with or without modification, 
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission. 
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ * 
+ */
+
+#ifndef __LWIP_NETIFAPI_H__
+#define __LWIP_NETIFAPI_H__
+
+#include "lwip/opt.h"
+
+#if LWIP_NETIF_API              /* don't build if not configured for use in lwipopts.h */
+
+#include "lwip/sys.h"
+#include "lwip/netif.h"
+#include "lwip/dhcp.h"
+#include "lwip/autoip.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+    struct netifapi_msg_msg {
+#if !LWIP_TCPIP_CORE_LOCKING
+        sys_sem_t sem;
+#endif                          /* !LWIP_TCPIP_CORE_LOCKING */
+        err_t err;
+        struct netif *netif;
+        union {
+            struct {
+                struct ip_addr *ipaddr;
+                struct ip_addr *netmask;
+                struct ip_addr *gw;
+                void *state;
+                 err_t(*init) (struct netif * netif);
+                 err_t(*input) (struct pbuf * p, struct netif * netif);
+            } add;
+            struct {
+                void (*voidfunc) (struct netif * netif);
+                 err_t(*errtfunc) (struct netif * netif);
+            } common;
+        } msg;
+    };
+
+    struct netifapi_msg {
+        void (*function) (struct netifapi_msg_msg * msg);
+        struct netifapi_msg_msg msg;
+    };
+
+
+/* API for application */
+    err_t netifapi_netif_add(struct netif *netif,
+                             struct ip_addr *ipaddr,
+                             struct ip_addr *netmask,
+                             struct ip_addr *gw,
+                             void *state,
+                             err_t(*init) (struct netif * netif),
+                             err_t(*input) (struct pbuf * p,
+                                            struct netif * netif));
+
+    err_t netifapi_netif_common(struct netif *netif,
+                                void (*voidfunc) (struct netif * netif),
+                                err_t(*errtfunc) (struct netif * netif));
+
+#define netifapi_netif_remove(n)      netifapi_netif_common(n, netif_remove, NULL)
+#define netifapi_netif_set_up(n)      netifapi_netif_common(n, netif_set_up, NULL)
+#define netifapi_netif_set_down(n)    netifapi_netif_common(n, netif_set_down, NULL)
+#define netifapi_netif_set_default(n) netifapi_netif_common(n, netif_set_default, NULL)
+#define netifapi_dhcp_start(n)        netifapi_netif_common(n, NULL, dhcp_start)
+#define netifapi_dhcp_stop(n)         netifapi_netif_common(n, dhcp_stop, NULL)
+#define netifapi_autoip_start(n)      netifapi_netif_common(n, NULL, autoip_start)
+#define netifapi_autoip_stop(n)       netifapi_netif_common(n, NULL, autoip_stop)
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* LWIP_NETIF_API */
+#endif                          /* __LWIP_NETIFAPI_H__ */
diff --git a/lib/lwip/src/include/lwip/opt.h b/lib/lwip/src/include/lwip/opt.h
new file mode 100644
index 0000000..7a46d78
--- /dev/null
+++ b/lib/lwip/src/include/lwip/opt.h
@@ -0,0 +1,1822 @@
+/**
+ * @file
+ *
+ * lwIP Options Configuration
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef __LWIP_OPT_H__
+#define __LWIP_OPT_H__
+
+/*
+ * Include user defined options first. Anything not defined in these files
+ * will be set to standard values. Override anything you dont like!
+ */
+#include "lwipopts.h"
+#include "lwip/debug.h"
+
+/*
+   -----------------------------------------------
+   ---------- Platform specific locking ----------
+   -----------------------------------------------
+*/
+
+/**
+ * SYS_LIGHTWEIGHT_PROT==1: if you want inter-task protection for certain
+ * critical regions during buffer allocation, deallocation and memory
+ * allocation and deallocation.
+ */
+#ifndef SYS_LIGHTWEIGHT_PROT
+#define SYS_LIGHTWEIGHT_PROT            0
+#endif
+
+/**
+ * NO_SYS==1: Provides VERY minimal functionality. Otherwise,
+ * use lwIP facilities.
+ */
+#ifndef NO_SYS
+#define NO_SYS                          0
+#endif
+
+/**
+ * MEMCPY: override this if you have a faster implementation at hand than the
+ * one included in your C library
+ */
+#ifndef MEMCPY
+#define MEMCPY(dst,src,len)             memcpy(dst,src,len)
+#endif
+
+/**
+ * SMEMCPY: override this with care! Some compilers (e.g. gcc) can inline a
+ * call to memcpy() if the length is known at compile time and is small.
+ */
+#ifndef SMEMCPY
+#define SMEMCPY(dst,src,len)            memcpy(dst,src,len)
+#endif
+
+/*
+   ------------------------------------
+   ---------- Memory options ----------
+   ------------------------------------
+*/
+/**
+ * MEM_LIBC_MALLOC==1: Use malloc/free/realloc provided by your C-library
+ * instead of the lwip internal allocator. Can save code size if you
+ * already use it.
+ */
+#ifndef MEM_LIBC_MALLOC
+#define MEM_LIBC_MALLOC                 0
+#endif
+
+/**
+* MEMP_MEM_MALLOC==1: Use mem_malloc/mem_free instead of the lwip pool allocator.
+* Especially useful with MEM_LIBC_MALLOC but handle with care regarding execution
+* speed and usage from interrupts!
+*/
+#ifndef MEMP_MEM_MALLOC
+#define MEMP_MEM_MALLOC                 0
+#endif
+
+/**
+ * MEM_ALIGNMENT: should be set to the alignment of the CPU
+ *    4 byte alignment -> #define MEM_ALIGNMENT 4
+ *    2 byte alignment -> #define MEM_ALIGNMENT 2
+ */
+#ifndef MEM_ALIGNMENT
+#define MEM_ALIGNMENT                   4
+#endif
+
+/**
+ * MEM_SIZE: the size of the heap memory. If the application will send
+ * a lot of data that needs to be copied, this should be set high.
+ */
+#ifndef MEM_SIZE
+#define MEM_SIZE                        (20*1024*1024)
+#endif
+
+/**
+ * MEMP_OVERFLOW_CHECK: memp overflow protection reserves a configurable
+ * amount of bytes before and after each memp element in every pool and fills
+ * it with a prominent default value.
+ *    MEMP_OVERFLOW_CHECK == 0 no checking
+ *    MEMP_OVERFLOW_CHECK == 1 checks each element when it is freed
+ *    MEMP_OVERFLOW_CHECK >= 2 checks each element in every pool every time
+ *      memp_malloc() or memp_free() is called (useful but slow!)
+ */
+#ifndef MEMP_OVERFLOW_CHECK
+#define MEMP_OVERFLOW_CHECK             0
+#endif
+
+/**
+ * MEMP_SANITY_CHECK==1: run a sanity check after each memp_free() to make
+ * sure that there are no cycles in the linked lists.
+ */
+#ifndef MEMP_SANITY_CHECK
+#define MEMP_SANITY_CHECK               0
+#endif
+
+/**
+ * MEM_USE_POOLS==1: Use an alternative to malloc() by allocating from a set
+ * of memory pools of various sizes. When mem_malloc is called, an element of
+ * the smallest pool that can provide the length needed is returned.
+ * To use this, MEMP_USE_CUSTOM_POOLS also has to be enabled.
+ */
+#ifndef MEM_USE_POOLS
+#define MEM_USE_POOLS                   0
+#endif
+
+/**
+ * MEM_USE_POOLS_TRY_BIGGER_POOL==1: if one malloc-pool is empty, try the next
+ * bigger pool - WARNING: THIS MIGHT WASTE MEMORY but it can make a system more
+ * reliable. */
+#ifndef MEM_USE_POOLS_TRY_BIGGER_POOL
+#define MEM_USE_POOLS_TRY_BIGGER_POOL   0
+#endif
+
+/**
+ * MEMP_USE_CUSTOM_POOLS==1: whether to include a user file lwippools.h
+ * that defines additional pools beyond the "standard" ones required
+ * by lwIP. If you set this to 1, you must have lwippools.h in your
+ * inlude path somewhere.
+ */
+#ifndef MEMP_USE_CUSTOM_POOLS
+#define MEMP_USE_CUSTOM_POOLS           0
+#endif
+
+/**
+ * Set this to 1 if you want to free PBUF_RAM pbufs (or call mem_free()) from
+ * interrupt context (or another context that doesn't allow waiting for a
+ * semaphore).
+ * If set to 1, mem_malloc will be protected by a semaphore and SYS_ARCH_PROTECT,
+ * while mem_free will only use SYS_ARCH_PROTECT. mem_malloc SYS_ARCH_UNPROTECTs
+ * with each loop so that mem_free can run.
+ *
+ * ATTENTION: As you can see from the above description, this leads to dis-/
+ * enabling interrupts often, which can be slow! Also, on low memory, mem_malloc
+ * can need longer.
+ *
+ * If you don't want that, at least for NO_SYS=0, you can still use the following
+ * functions to enqueue a deallocation call which then runs in the tcpip_thread
+ * context:
+ * - pbuf_free_callback(p);
+ * - mem_free_callback(m);
+ */
+#ifndef LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
+#define LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT 0
+#endif
+
+/*
+   ------------------------------------------------
+   ---------- Internal Memory Pool Sizes ----------
+   ------------------------------------------------
+*/
+/**
+ * MEMP_NUM_PBUF: the number of memp struct pbufs (used for PBUF_ROM and PBUF_REF).
+ * If the application sends a lot of data out of ROM (or other static memory),
+ * this should be set high.
+ */
+#ifndef MEMP_NUM_PBUF
+#define MEMP_NUM_PBUF                   8192
+#endif
+
+/**
+ * MEMP_NUM_RAW_PCB: Number of raw connection PCBs
+ * (requires the LWIP_RAW option)
+ */
+#ifndef MEMP_NUM_RAW_PCB
+#define MEMP_NUM_RAW_PCB                4
+#endif
+
+/**
+ * MEMP_NUM_UDP_PCB: the number of UDP protocol control blocks. One
+ * per active UDP "connection".
+ * (requires the LWIP_UDP option)
+ */
+#ifndef MEMP_NUM_UDP_PCB
+#define MEMP_NUM_UDP_PCB                4
+#endif
+
+/**
+ * MEMP_NUM_TCP_PCB: the number of simulatenously active TCP connections.
+ * (requires the LWIP_TCP option)
+ */
+#ifndef MEMP_NUM_TCP_PCB
+#define MEMP_NUM_TCP_PCB                5
+#endif
+
+/**
+ * MEMP_NUM_TCP_PCB_LISTEN: the number of listening TCP connections.
+ * (requires the LWIP_TCP option)
+ */
+#ifndef MEMP_NUM_TCP_PCB_LISTEN
+#define MEMP_NUM_TCP_PCB_LISTEN         18
+#endif
+
+/**
+ * MEMP_NUM_TCP_SEG: the number of simultaneously queued TCP segments.
+ * (requires the LWIP_TCP option)
+ */
+#ifndef MEMP_NUM_TCP_SEG
+#define MEMP_NUM_TCP_SEG                16
+#endif
+
+/**
+ * MEMP_NUM_REASSDATA: the number of simultaneously IP packets queued for
+ * reassembly (whole packets, not fragments!)
+ */
+#ifndef MEMP_NUM_REASSDATA
+#define MEMP_NUM_REASSDATA              5
+#endif
+
+/**
+ * MEMP_NUM_ARP_QUEUE: the number of simulateously queued outgoing
+ * packets (pbufs) that are waiting for an ARP request (to resolve
+ * their destination address) to finish.
+ * (requires the ARP_QUEUEING option)
+ */
+#ifndef MEMP_NUM_ARP_QUEUE
+#define MEMP_NUM_ARP_QUEUE              30
+#endif
+
+/**
+ * MEMP_NUM_IGMP_GROUP: The number of multicast groups whose network interfaces
+ * can be members et the same time (one per netif - allsystems group -, plus one
+ * per netif membership).
+ * (requires the LWIP_IGMP option)
+ */
+#ifndef MEMP_NUM_IGMP_GROUP
+#define MEMP_NUM_IGMP_GROUP             8
+#endif
+
+/**
+ * MEMP_NUM_SYS_TIMEOUT: the number of simulateously active timeouts.
+ * (requires NO_SYS==0)
+ */
+#ifndef MEMP_NUM_SYS_TIMEOUT
+#define MEMP_NUM_SYS_TIMEOUT            8
+#endif
+
+/**
+ * MEMP_NUM_NETBUF: the number of struct netbufs.
+ * (only needed if you use the sequential API, like api_lib.c)
+ */
+#ifndef MEMP_NUM_NETBUF
+#define MEMP_NUM_NETBUF                 12
+#endif
+
+/**
+ * MEMP_NUM_NETCONN: the number of struct netconns.
+ * (only needed if you use the sequential API, like api_lib.c)
+ */
+#ifndef MEMP_NUM_NETCONN
+#define MEMP_NUM_NETCONN                24
+#endif
+
+/**
+ * MEMP_NUM_TCPIP_MSG_API: the number of struct tcpip_msg, which are used
+ * for callback/timeout API communication.
+ * (only needed if you use tcpip.c)
+ */
+#ifndef MEMP_NUM_TCPIP_MSG_API
+#define MEMP_NUM_TCPIP_MSG_API          38
+#endif
+
+/**
+ * MEMP_NUM_TCPIP_MSG_INPKT: the number of struct tcpip_msg, which are used
+ * for incoming packets.
+ * (only needed if you use tcpip.c)
+ */
+#ifndef MEMP_NUM_TCPIP_MSG_INPKT
+#define MEMP_NUM_TCPIP_MSG_INPKT        38
+#endif
+
+/**
+ * PBUF_POOL_SIZE: the number of buffers in the pbuf pool.
+ */
+#ifndef PBUF_POOL_SIZE
+#define PBUF_POOL_SIZE                  65535
+#endif
+
+/*
+   ---------------------------------
+   ---------- ARP options ----------
+   ---------------------------------
+*/
+/**
+ * LWIP_ARP==1: Enable ARP functionality.
+ */
+#ifndef LWIP_ARP
+#define LWIP_ARP                        1
+#endif
+
+/**
+ * ARP_TABLE_SIZE: Number of active MAC-IP address pairs cached.
+ */
+#ifndef ARP_TABLE_SIZE
+#define ARP_TABLE_SIZE                  10
+#endif
+
+/**
+ * ARP_QUEUEING==1: Outgoing packets are queued during hardware address
+ * resolution.
+ */
+#ifndef ARP_QUEUEING
+#define ARP_QUEUEING                    1
+#endif
+
+/**
+ * ETHARP_TRUST_IP_MAC==1: Incoming IP packets cause the ARP table to be
+ * updated with the source MAC and IP addresses supplied in the packet.
+ * You may want to disable this if you do not trust LAN peers to have the
+ * correct addresses, or as a limited approach to attempt to handle
+ * spoofing. If disabled, lwIP will need to make a new ARP request if
+ * the peer is not already in the ARP table, adding a little latency.
+ */
+#ifndef ETHARP_TRUST_IP_MAC
+#define ETHARP_TRUST_IP_MAC             1
+#endif
+
+/*
+   --------------------------------
+   ---------- IP options ----------
+   --------------------------------
+*/
+/**
+ * IP_FORWARD==1: Enables the ability to forward IP packets across network
+ * interfaces. If you are going to run lwIP on a device with only one network
+ * interface, define this to 0.
+ */
+#ifndef IP_FORWARD
+#define IP_FORWARD                      0
+#endif
+
+/**
+ * IP_OPTIONS_ALLOWED: Defines the behavior for IP options.
+ *      IP_OPTIONS_ALLOWED==0: All packets with IP options are dropped.
+ *      IP_OPTIONS_ALLOWED==1: IP options are allowed (but not parsed).
+ */
+#ifndef IP_OPTIONS_ALLOWED
+#define IP_OPTIONS_ALLOWED              1
+#endif
+
+/**
+ * IP_REASSEMBLY==1: Reassemble incoming fragmented IP packets. Note that
+ * this option does not affect outgoing packet sizes, which can be controlled
+ * via IP_FRAG.
+ */
+#ifndef IP_REASSEMBLY
+#define IP_REASSEMBLY                   1
+#endif
+
+/**
+ * IP_FRAG==1: Fragment outgoing IP packets if their size exceeds MTU. Note
+ * that this option does not affect incoming packet sizes, which can be
+ * controlled via IP_REASSEMBLY.
+ */
+#ifndef IP_FRAG
+#define IP_FRAG                         1
+#endif
+
+/**
+ * IP_REASS_MAXAGE: Maximum time (in multiples of IP_TMR_INTERVAL - so seconds, normally)
+ * a fragmented IP packet waits for all fragments to arrive. If not all fragments arrived
+ * in this time, the whole packet is discarded.
+ */
+#ifndef IP_REASS_MAXAGE
+#define IP_REASS_MAXAGE                 3
+#endif
+
+/**
+ * IP_REASS_MAX_PBUFS: Total maximum amount of pbufs waiting to be reassembled.
+ * Since the received pbufs are enqueued, be sure to configure
+ * PBUF_POOL_SIZE > IP_REASS_MAX_PBUFS so that the stack is still able to receive
+ * packets even if the maximum amount of fragments is enqueued for reassembly!
+ */
+#ifndef IP_REASS_MAX_PBUFS
+#define IP_REASS_MAX_PBUFS              10
+#endif
+
+/**
+ * IP_FRAG_USES_STATIC_BUF==1: Use a static MTU-sized buffer for IP
+ * fragmentation. Otherwise pbufs are allocated and reference the original
+ * packet data to be fragmented.
+ */
+// FIXME: commented out so that code will not use PBUF_REF
+//#ifndef IP_FRAG_USES_STATIC_BUF
+//#define IP_FRAG_USES_STATIC_BUF         1
+//#endif
+
+/**
+ * IP_FRAG_MAX_MTU: Assumed max MTU on any interface for IP frag buffer
+ * (requires IP_FRAG_USES_STATIC_BUF==1)
+ */
+#if IP_FRAG_USES_STATIC_BUF && !defined(IP_FRAG_MAX_MTU)
+#define IP_FRAG_MAX_MTU                 1500
+#endif
+
+/**
+ * IP_DEFAULT_TTL: Default value for Time-To-Live used by transport layers.
+ */
+#ifndef IP_DEFAULT_TTL
+#define IP_DEFAULT_TTL                  255
+#endif
+
+/**
+ * IP_SOF_BROADCAST=1: Use the SOF_BROADCAST field to enable broadcast
+ * filter per pcb on udp and raw send operations. To enable broadcast filter
+ * on recv operations, you also have to set IP_SOF_BROADCAST_RECV=1.
+ */
+#ifndef IP_SOF_BROADCAST
+#define IP_SOF_BROADCAST                0
+#endif
+
+/**
+ * IP_SOF_BROADCAST_RECV (requires IP_SOF_BROADCAST=1) enable the broadcast
+ * filter on recv operations.
+ */
+#ifndef IP_SOF_BROADCAST_RECV
+#define IP_SOF_BROADCAST_RECV           0
+#endif
+
+/*
+   ----------------------------------
+   ---------- ICMP options ----------
+   ----------------------------------
+*/
+/**
+ * LWIP_ICMP==1: Enable ICMP module inside the IP stack.
+ * Be careful, disable that make your product non-compliant to RFC1122
+ */
+#ifndef LWIP_ICMP
+#define LWIP_ICMP                       1
+#endif
+
+/**
+ * ICMP_TTL: Default value for Time-To-Live used by ICMP packets.
+ */
+#ifndef ICMP_TTL
+#define ICMP_TTL                       (IP_DEFAULT_TTL)
+#endif
+
+/**
+ * LWIP_BROADCAST_PING==1: respond to broadcast pings (default is unicast only)
+ */
+#ifndef LWIP_BROADCAST_PING
+#define LWIP_BROADCAST_PING             0
+#endif
+
+/**
+ * LWIP_MULTICAST_PING==1: respond to multicast pings (default is unicast only)
+ */
+#ifndef LWIP_MULTICAST_PING
+#define LWIP_MULTICAST_PING             0
+#endif
+
+/*
+   ---------------------------------
+   ---------- RAW options ----------
+   ---------------------------------
+*/
+/**
+ * LWIP_RAW==1: Enable application layer to hook into the IP layer itself.
+ */
+#ifndef LWIP_RAW
+#define LWIP_RAW                        1
+#endif
+
+/**
+ * LWIP_RAW==1: Enable application layer to hook into the IP layer itself.
+ */
+#ifndef RAW_TTL
+#define RAW_TTL                        (IP_DEFAULT_TTL)
+#endif
+
+/*
+   ----------------------------------
+   ---------- DHCP options ----------
+   ----------------------------------
+*/
+/**
+ * LWIP_DHCP==1: Enable DHCP module.
+ */
+#ifndef LWIP_DHCP
+#define LWIP_DHCP                       0
+#endif
+
+/**
+ * DHCP_DOES_ARP_CHECK==1: Do an ARP check on the offered address.
+ */
+#ifndef DHCP_DOES_ARP_CHECK
+#define DHCP_DOES_ARP_CHECK             ((LWIP_DHCP) && (LWIP_ARP))
+#endif
+
+/*
+   ------------------------------------
+   ---------- AUTOIP options ----------
+   ------------------------------------
+*/
+/**
+ * LWIP_AUTOIP==1: Enable AUTOIP module.
+ */
+#ifndef LWIP_AUTOIP
+#define LWIP_AUTOIP                     0
+#endif
+
+/**
+ * LWIP_DHCP_AUTOIP_COOP==1: Allow DHCP and AUTOIP to be both enabled on
+ * the same interface at the same time.
+ */
+#ifndef LWIP_DHCP_AUTOIP_COOP
+#define LWIP_DHCP_AUTOIP_COOP           0
+#endif
+
+/**
+ * LWIP_DHCP_AUTOIP_COOP_TRIES: Set to the number of DHCP DISCOVER probes
+ * that should be sent before falling back on AUTOIP. This can be set
+ * as low as 1 to get an AutoIP address very quickly, but you should
+ * be prepared to handle a changing IP address when DHCP overrides
+ * AutoIP.
+ */
+#ifndef LWIP_DHCP_AUTOIP_COOP_TRIES
+#define LWIP_DHCP_AUTOIP_COOP_TRIES     9
+#endif
+
+/*
+   ----------------------------------
+   ---------- SNMP options ----------
+   ----------------------------------
+*/
+/**
+ * LWIP_SNMP==1: Turn on SNMP module. UDP must be available for SNMP
+ * transport.
+ */
+#ifndef LWIP_SNMP
+#define LWIP_SNMP                       0
+#endif
+
+/**
+ * SNMP_CONCURRENT_REQUESTS: Number of concurrent requests the module will
+ * allow. At least one request buffer is required.
+ */
+#ifndef SNMP_CONCURRENT_REQUESTS
+#define SNMP_CONCURRENT_REQUESTS        1
+#endif
+
+/**
+ * SNMP_TRAP_DESTINATIONS: Number of trap destinations. At least one trap
+ * destination is required
+ */
+#ifndef SNMP_TRAP_DESTINATIONS
+#define SNMP_TRAP_DESTINATIONS          1
+#endif
+
+/**
+ * SNMP_PRIVATE_MIB:
+ */
+#ifndef SNMP_PRIVATE_MIB
+#define SNMP_PRIVATE_MIB                0
+#endif
+
+/**
+ * Only allow SNMP write actions that are 'safe' (e.g. disabeling netifs is not
+ * a safe action and disabled when SNMP_SAFE_REQUESTS = 1).
+ * Unsafe requests are disabled by default!
+ */
+#ifndef SNMP_SAFE_REQUESTS
+#define SNMP_SAFE_REQUESTS              1
+#endif
+
+/*
+   ----------------------------------
+   ---------- IGMP options ----------
+   ----------------------------------
+*/
+/**
+ * LWIP_IGMP==1: Turn on IGMP module.
+ */
+#ifndef LWIP_IGMP
+#define LWIP_IGMP                       0
+#endif
+
+/*
+   ----------------------------------
+   ---------- DNS options -----------
+   ----------------------------------
+*/
+/**
+ * LWIP_DNS==1: Turn on DNS module. UDP must be available for DNS
+ * transport.
+ */
+#ifndef LWIP_DNS
+#define LWIP_DNS                        0
+#endif
+
+/** DNS maximum number of entries to maintain locally. */
+#ifndef DNS_TABLE_SIZE
+#define DNS_TABLE_SIZE                  4
+#endif
+
+/** DNS maximum host name length supported in the name table. */
+#ifndef DNS_MAX_NAME_LENGTH
+#define DNS_MAX_NAME_LENGTH             256
+#endif
+
+/** The maximum of DNS servers */
+#ifndef DNS_MAX_SERVERS
+#define DNS_MAX_SERVERS                 2
+#endif
+
+/** DNS do a name checking between the query and the response. */
+#ifndef DNS_DOES_NAME_CHECK
+#define DNS_DOES_NAME_CHECK             1
+#endif
+
+/** DNS use a local buffer if DNS_USES_STATIC_BUF=0, a static one if
+    DNS_USES_STATIC_BUF=1, or a dynamic one if DNS_USES_STATIC_BUF=2.
+    The buffer will be of size DNS_MSG_SIZE */
+#ifndef DNS_USES_STATIC_BUF
+#define DNS_USES_STATIC_BUF             1
+#endif
+
+/** DNS message max. size. Default value is RFC compliant. */
+#ifndef DNS_MSG_SIZE
+#define DNS_MSG_SIZE                    512
+#endif
+
+/** DNS_LOCAL_HOSTLIST: Implements a local host-to-address list. If enabled,
+ *  you have to define
+ *    #define DNS_LOCAL_HOSTLIST_INIT {{"host1", 0x123}, {"host2", 0x234}}
+ *  (an array of structs name/address, where address is an u32_t in network
+ *  byte order).
+ *
+ *  Instead, you can also use an external function:
+ *  #define DNS_LOOKUP_LOCAL_EXTERN(x) extern u32_t my_lookup_function(const char *name)
+ *  that returns the IP address or INADDR_NONE if not found.
+ */
+#ifndef DNS_LOCAL_HOSTLIST
+#define DNS_LOCAL_HOSTLIST              0
+#endif                          /* DNS_LOCAL_HOSTLIST */
+
+/** If this is turned on, the local host-list can be dynamically changed
+ *  at runtime. */
+#ifndef DNS_LOCAL_HOSTLIST_IS_DYNAMIC
+#define DNS_LOCAL_HOSTLIST_IS_DYNAMIC   0
+#endif                          /* DNS_LOCAL_HOSTLIST_IS_DYNAMIC */
+
+/*
+   ---------------------------------
+   ---------- UDP options ----------
+   ---------------------------------
+*/
+/**
+ * LWIP_UDP==1: Turn on UDP.
+ */
+#ifndef LWIP_UDP
+#define LWIP_UDP                        1
+#endif
+
+/**
+ * LWIP_UDPLITE==1: Turn on UDP-Lite. (Requires LWIP_UDP)
+ */
+#ifndef LWIP_UDPLITE
+#define LWIP_UDPLITE                    0
+#endif
+
+/**
+ * UDP_TTL: Default Time-To-Live value.
+ */
+#ifndef UDP_TTL
+#define UDP_TTL                         (IP_DEFAULT_TTL)
+#endif
+
+/*
+   ---------------------------------
+   ---------- TCP options ----------
+   ---------------------------------
+*/
+/**
+ * LWIP_TCP==1: Turn on TCP.
+ */
+#ifndef LWIP_TCP
+#define LWIP_TCP                        1
+#endif
+
+/**
+ * TCP_TTL: Default Time-To-Live value.
+ */
+#ifndef TCP_TTL
+#define TCP_TTL                         (IP_DEFAULT_TTL)
+#endif
+
+/**
+ * TCP_WND: The size of a TCP window.  This must be at least
+ * (2 * TCP_MSS) for things to work well
+ */
+#ifndef TCP_WND
+#define TCP_WND                         2048
+#endif
+
+/**
+ * TCP_MAXRTX: Maximum number of retransmissions of data segments.
+ */
+#ifndef TCP_MAXRTX
+#define TCP_MAXRTX                      12
+#endif
+
+/**
+ * TCP_SYNMAXRTX: Maximum number of retransmissions of SYN segments.
+ */
+#ifndef TCP_SYNMAXRTX
+#define TCP_SYNMAXRTX                   6
+#endif
+
+/**
+ * TCP_QUEUE_OOSEQ==1: TCP will queue segments that arrive out of order.
+ * Define to 0 if your device is low on memory.
+ */
+#ifndef TCP_QUEUE_OOSEQ
+#define TCP_QUEUE_OOSEQ                 (LWIP_TCP)
+#endif
+
+/**
+ * TCP_MSS: TCP Maximum segment size. (default is 128, a *very*
+ * conservative default.)
+ * For the receive side, this MSS is advertised to the remote side
+ * when opening a connection. For the transmit size, this MSS sets
+ * an upper limit on the MSS advertised by the remote host.
+ */
+#ifndef TCP_MSS
+#define TCP_MSS                         128
+#endif
+
+/**
+ * TCP_CALCULATE_EFF_SEND_MSS: "The maximum size of a segment that TCP really
+ * sends, the 'effective send MSS,' MUST be the smaller of the send MSS (which
+ * reflects the available reassembly buffer size at the remote host) and the
+ * largest size permitted by the IP layer" (RFC 1122)
+ * Setting this to 1 enables code that checks TCP_MSS against the MTU of the
+ * netif used for a connection and limits the MSS if it would be too big otherwise.
+ */
+#ifndef TCP_CALCULATE_EFF_SEND_MSS
+#define TCP_CALCULATE_EFF_SEND_MSS      1
+#endif
+
+
+/**
+ * TCP_SND_BUF: TCP sender buffer space (bytes).
+ */
+#ifndef TCP_SND_BUF
+#define TCP_SND_BUF                     256
+#endif
+
+/**
+ * TCP_SND_QUEUELEN: TCP sender buffer space (pbufs). This must be at least
+ * as much as (2 * TCP_SND_BUF/TCP_MSS) for things to work.
+ */
+#ifndef TCP_SND_QUEUELEN
+#define TCP_SND_QUEUELEN                (4 * (TCP_SND_BUF/TCP_MSS))
+#endif
+
+/**
+ * TCP_SNDLOWAT: TCP writable space (bytes). This must be less than or equal
+ * to TCP_SND_BUF. It is the amount of space which must be available in the
+ * TCP snd_buf for select to return writable.
+ */
+#ifndef TCP_SNDLOWAT
+#define TCP_SNDLOWAT                    (TCP_SND_BUF/2)
+#endif
+
+/**
+ * TCP_LISTEN_BACKLOG: Enable the backlog option for tcp listen pcb.
+ */
+#ifndef TCP_LISTEN_BACKLOG
+#define TCP_LISTEN_BACKLOG              0
+#endif
+
+/**
+ * The maximum allowed backlog for TCP listen netconns.
+ * This backlog is used unless another is explicitly specified.
+ * 0xff is the maximum (u8_t).
+ */
+#ifndef TCP_DEFAULT_LISTEN_BACKLOG
+#define TCP_DEFAULT_LISTEN_BACKLOG      0xff
+#endif
+
+/**
+ * LWIP_TCP_TIMESTAMPS==1: support the TCP timestamp option.
+ */
+#ifndef LWIP_TCP_TIMESTAMPS
+#define LWIP_TCP_TIMESTAMPS             0
+#endif
+
+/**
+ * TCP_WND_UPDATE_THRESHOLD: difference in window to trigger an
+ * explicit window update
+ */
+#ifndef TCP_WND_UPDATE_THRESHOLD
+#define TCP_WND_UPDATE_THRESHOLD   (TCP_WND / 4)
+#endif
+
+/**
+ * LWIP_EVENT_API and LWIP_CALLBACK_API: Only one of these should be set to 1.
+ *     LWIP_EVENT_API==1: The user defines lwip_tcp_event() to receive all
+ *         events (accept, sent, etc) that happen in the system.
+ *     LWIP_CALLBACK_API==1: The PCB callback function is called directly
+ *         for the event.
+ */
+#ifndef LWIP_EVENT_API
+#define LWIP_EVENT_API                  0
+#define LWIP_CALLBACK_API               1
+#else
+#define LWIP_EVENT_API                  1
+#define LWIP_CALLBACK_API               0
+#endif
+
+
+/*
+   ----------------------------------
+   ---------- Pbuf options ----------
+   ----------------------------------
+*/
+/**
+ * PBUF_LINK_HLEN: the number of bytes that should be allocated for a
+ * link level header. The default is 14, the standard value for
+ * Ethernet.
+ */
+#ifndef PBUF_LINK_HLEN
+#define PBUF_LINK_HLEN                  14
+#endif
+
+/**
+ * PBUF_POOL_BUFSIZE: the size of each pbuf in the pbuf pool. The default is
+ * designed to accomodate single full size TCP frame in one pbuf, including
+ * TCP_MSS, IP header, and link header.
+ */
+#ifndef PBUF_POOL_BUFSIZE
+#define PBUF_POOL_BUFSIZE               LWIP_MEM_ALIGN_SIZE(TCP_MSS+40+PBUF_LINK_HLEN)
+#endif
+
+/*
+   ------------------------------------------------
+   ---------- Network Interfaces options ----------
+   ------------------------------------------------
+*/
+/**
+ * LWIP_NETIF_HOSTNAME==1: use DHCP_OPTION_HOSTNAME with netif's hostname
+ * field.
+ */
+#ifndef LWIP_NETIF_HOSTNAME
+#define LWIP_NETIF_HOSTNAME             0
+#endif
+
+/**
+ * LWIP_NETIF_API==1: Support netif api (in netifapi.c)
+ */
+#ifndef LWIP_NETIF_API
+#define LWIP_NETIF_API                  0
+#endif
+
+/**
+ * LWIP_NETIF_STATUS_CALLBACK==1: Support a callback function whenever an interface
+ * changes its up/down status (i.e., due to DHCP IP acquistion)
+ */
+#ifndef LWIP_NETIF_STATUS_CALLBACK
+#define LWIP_NETIF_STATUS_CALLBACK      0
+#endif
+
+/**
+ * LWIP_NETIF_LINK_CALLBACK==1: Support a callback function from an interface
+ * whenever the link changes (i.e., link down)
+ */
+#ifndef LWIP_NETIF_LINK_CALLBACK
+#define LWIP_NETIF_LINK_CALLBACK        0
+#endif
+
+/**
+ * LWIP_NETIF_HWADDRHINT==1: Cache link-layer-address hints (e.g. table
+ * indices) in struct netif. TCP and UDP can make use of this to prevent
+ * scanning the ARP table for every sent packet. While this is faster for big
+ * ARP tables or many concurrent connections, it might be counterproductive
+ * if you have a tiny ARP table or if there never are concurrent connections.
+ */
+#ifndef LWIP_NETIF_HWADDRHINT
+#define LWIP_NETIF_HWADDRHINT           0
+#endif
+
+/**
+ * LWIP_NETIF_LOOPBACK==1: Support sending packets with a destination IP
+ * address equal to the netif IP address, looping them back up the stack.
+ */
+#ifndef LWIP_NETIF_LOOPBACK
+#define LWIP_NETIF_LOOPBACK             0
+#endif
+
+/**
+ * LWIP_LOOPBACK_MAX_PBUFS: Maximum number of pbufs on queue for loopback
+ * sending for each netif (0 = disabled)
+ */
+#ifndef LWIP_LOOPBACK_MAX_PBUFS
+#define LWIP_LOOPBACK_MAX_PBUFS         0
+#endif
+
+/**
+ * LWIP_NETIF_LOOPBACK_MULTITHREADING: Indicates whether threading is enabled in
+ * the system, as netifs must change how they behave depending on this setting
+ * for the LWIP_NETIF_LOOPBACK option to work.
+ * Setting this is needed to avoid reentering non-reentrant functions like
+ * tcp_input().
+ *    LWIP_NETIF_LOOPBACK_MULTITHREADING==1: Indicates that the user is using a
+ *       multithreaded environment like tcpip.c. In this case, netif->input()
+ *       is called directly.
+ *    LWIP_NETIF_LOOPBACK_MULTITHREADING==0: Indicates a polling (or NO_SYS) setup.
+ *       The packets are put on a list and netif_poll() must be called in
+ *       the main application loop.
+ */
+#ifndef LWIP_NETIF_LOOPBACK_MULTITHREADING
+#define LWIP_NETIF_LOOPBACK_MULTITHREADING    (!NO_SYS)
+#endif
+
+/**
+ * LWIP_NETIF_TX_SINGLE_PBUF: if this is set to 1, lwIP tries to put all data
+ * to be sent into one single pbuf. This is for compatibility with DMA-enabled
+ * MACs that do not support scatter-gather.
+ * Beware that this might involve CPU-memcpy before transmitting that would not
+ * be needed without this flag! Use this only if you need to!
+ *
+ * @todo: TCP and IP-frag do not work with this, yet:
+ */
+#ifndef LWIP_NETIF_TX_SINGLE_PBUF
+#define LWIP_NETIF_TX_SINGLE_PBUF             0
+#endif                          /* LWIP_NETIF_TX_SINGLE_PBUF */
+
+/*
+   ------------------------------------
+   ---------- LOOPIF options ----------
+   ------------------------------------
+*/
+/**
+ * LWIP_HAVE_LOOPIF==1: Support loop interface (127.0.0.1) and loopif.c
+ */
+#ifndef LWIP_HAVE_LOOPIF
+#define LWIP_HAVE_LOOPIF                0
+#endif
+
+/*
+   ------------------------------------
+   ---------- SLIPIF options ----------
+   ------------------------------------
+*/
+/**
+ * LWIP_HAVE_SLIPIF==1: Support slip interface and slipif.c
+ */
+#ifndef LWIP_HAVE_SLIPIF
+#define LWIP_HAVE_SLIPIF                0
+#endif
+
+/*
+   ------------------------------------
+   ---------- Thread options ----------
+   ------------------------------------
+*/
+/**
+ * TCPIP_THREAD_NAME: The name assigned to the main tcpip thread.
+ */
+#ifndef TCPIP_THREAD_NAME
+#define TCPIP_THREAD_NAME              "tcpip_thread"
+#endif
+
+/**
+ * TCPIP_THREAD_STACKSIZE: The stack size used by the main tcpip thread.
+ * The stack size value itself is platform-dependent, but is passed to
+ * sys_thread_new() when the thread is created.
+ */
+#ifndef TCPIP_THREAD_STACKSIZE
+#define TCPIP_THREAD_STACKSIZE          0
+#endif
+
+/**
+ * TCPIP_THREAD_PRIO: The priority assigned to the main tcpip thread.
+ * The priority value itself is platform-dependent, but is passed to
+ * sys_thread_new() when the thread is created.
+ */
+#ifndef TCPIP_THREAD_PRIO
+#define TCPIP_THREAD_PRIO               1
+#endif
+
+/**
+ * TCPIP_MBOX_SIZE: The mailbox size for the tcpip thread messages
+ * The queue size value itself is platform-dependent, but is passed to
+ * sys_mbox_new() when tcpip_init is called.
+ */
+#ifndef TCPIP_MBOX_SIZE
+#define TCPIP_MBOX_SIZE                 0
+#endif
+
+/**
+ * SLIPIF_THREAD_NAME: The name assigned to the slipif_loop thread.
+ */
+#ifndef SLIPIF_THREAD_NAME
+#define SLIPIF_THREAD_NAME             "slipif_loop"
+#endif
+
+/**
+ * SLIP_THREAD_STACKSIZE: The stack size used by the slipif_loop thread.
+ * The stack size value itself is platform-dependent, but is passed to
+ * sys_thread_new() when the thread is created.
+ */
+#ifndef SLIPIF_THREAD_STACKSIZE
+#define SLIPIF_THREAD_STACKSIZE         0
+#endif
+
+/**
+ * SLIPIF_THREAD_PRIO: The priority assigned to the slipif_loop thread.
+ * The priority value itself is platform-dependent, but is passed to
+ * sys_thread_new() when the thread is created.
+ */
+#ifndef SLIPIF_THREAD_PRIO
+#define SLIPIF_THREAD_PRIO              1
+#endif
+
+/**
+ * PPP_THREAD_NAME: The name assigned to the pppMain thread.
+ */
+#ifndef PPP_THREAD_NAME
+#define PPP_THREAD_NAME                "pppMain"
+#endif
+
+/**
+ * PPP_THREAD_STACKSIZE: The stack size used by the pppMain thread.
+ * The stack size value itself is platform-dependent, but is passed to
+ * sys_thread_new() when the thread is created.
+ */
+#ifndef PPP_THREAD_STACKSIZE
+#define PPP_THREAD_STACKSIZE            0
+#endif
+
+/**
+ * PPP_THREAD_PRIO: The priority assigned to the pppMain thread.
+ * The priority value itself is platform-dependent, but is passed to
+ * sys_thread_new() when the thread is created.
+ */
+#ifndef PPP_THREAD_PRIO
+#define PPP_THREAD_PRIO                 1
+#endif
+
+/**
+ * DEFAULT_THREAD_NAME: The name assigned to any other lwIP thread.
+ */
+#ifndef DEFAULT_THREAD_NAME
+#define DEFAULT_THREAD_NAME            "lwIP"
+#endif
+
+/**
+ * DEFAULT_THREAD_STACKSIZE: The stack size used by any other lwIP thread.
+ * The stack size value itself is platform-dependent, but is passed to
+ * sys_thread_new() when the thread is created.
+ */
+#ifndef DEFAULT_THREAD_STACKSIZE
+#define DEFAULT_THREAD_STACKSIZE        0
+#endif
+
+/**
+ * DEFAULT_THREAD_PRIO: The priority assigned to any other lwIP thread.
+ * The priority value itself is platform-dependent, but is passed to
+ * sys_thread_new() when the thread is created.
+ */
+#ifndef DEFAULT_THREAD_PRIO
+#define DEFAULT_THREAD_PRIO             1
+#endif
+
+/**
+ * DEFAULT_RAW_RECVMBOX_SIZE: The mailbox size for the incoming packets on a
+ * NETCONN_RAW. The queue size value itself is platform-dependent, but is passed
+ * to sys_mbox_new() when the recvmbox is created.
+ */
+#ifndef DEFAULT_RAW_RECVMBOX_SIZE
+#define DEFAULT_RAW_RECVMBOX_SIZE       0
+#endif
+
+/**
+ * DEFAULT_UDP_RECVMBOX_SIZE: The mailbox size for the incoming packets on a
+ * NETCONN_UDP. The queue size value itself is platform-dependent, but is passed
+ * to sys_mbox_new() when the recvmbox is created.
+ */
+#ifndef DEFAULT_UDP_RECVMBOX_SIZE
+#define DEFAULT_UDP_RECVMBOX_SIZE       0
+#endif
+
+/**
+ * DEFAULT_TCP_RECVMBOX_SIZE: The mailbox size for the incoming packets on a
+ * NETCONN_TCP. The queue size value itself is platform-dependent, but is passed
+ * to sys_mbox_new() when the recvmbox is created.
+ */
+#ifndef DEFAULT_TCP_RECVMBOX_SIZE
+#define DEFAULT_TCP_RECVMBOX_SIZE       0
+#endif
+
+/**
+ * DEFAULT_ACCEPTMBOX_SIZE: The mailbox size for the incoming connections.
+ * The queue size value itself is platform-dependent, but is passed to
+ * sys_mbox_new() when the acceptmbox is created.
+ */
+#ifndef DEFAULT_ACCEPTMBOX_SIZE
+#define DEFAULT_ACCEPTMBOX_SIZE         0
+#endif
+
+/*
+   ----------------------------------------------
+   ---------- Sequential layer options ----------
+   ----------------------------------------------
+*/
+/**
+ * LWIP_TCPIP_CORE_LOCKING: (EXPERIMENTAL!)
+ * Don't use it if you're not an active lwIP project member
+ */
+#ifndef LWIP_TCPIP_CORE_LOCKING
+#define LWIP_TCPIP_CORE_LOCKING         0
+#endif
+
+/**
+ * LWIP_NETCONN==1: Enable Netconn API (require to use api_lib.c)
+ */
+#ifndef LWIP_NETCONN
+#define LWIP_NETCONN                    1
+#endif
+
+/*
+   ------------------------------------
+   ---------- Socket options ----------
+   ------------------------------------
+*/
+/**
+ * LWIP_SOCKET==1: Enable Socket API (require to use sockets.c)
+ */
+#ifndef LWIP_SOCKET
+#define LWIP_SOCKET                     1
+#endif
+
+/**
+ * LWIP_COMPAT_SOCKETS==1: Enable BSD-style sockets functions names.
+ * (only used if you use sockets.c)
+ */
+#ifndef LWIP_COMPAT_SOCKETS
+#define LWIP_COMPAT_SOCKETS             1
+#endif
+
+/**
+ * LWIP_POSIX_SOCKETS_IO_NAMES==1: Enable POSIX-style sockets functions names.
+ * Disable this option if you use a POSIX operating system that uses the same
+ * names (read, write & close). (only used if you use sockets.c)
+ */
+#ifndef LWIP_POSIX_SOCKETS_IO_NAMES
+#define LWIP_POSIX_SOCKETS_IO_NAMES     1
+#endif
+
+/**
+ * LWIP_TCP_KEEPALIVE==1: Enable TCP_KEEPIDLE, TCP_KEEPINTVL and TCP_KEEPCNT
+ * options processing. Note that TCP_KEEPIDLE and TCP_KEEPINTVL have to be set
+ * in seconds. (does not require sockets.c, and will affect tcp.c)
+ */
+#ifndef LWIP_TCP_KEEPALIVE
+#define LWIP_TCP_KEEPALIVE              0
+#endif
+
+/**
+ * LWIP_SO_RCVTIMEO==1: Enable SO_RCVTIMEO processing.
+ */
+#ifndef LWIP_SO_RCVTIMEO
+#define LWIP_SO_RCVTIMEO                0
+#endif
+
+/**
+ * LWIP_SO_RCVBUF==1: Enable SO_RCVBUF processing.
+ */
+#ifndef LWIP_SO_RCVBUF
+#define LWIP_SO_RCVBUF                  0
+#endif
+
+/**
+ * If LWIP_SO_RCVBUF is used, this is the default value for recv_bufsize.
+ */
+#ifndef RECV_BUFSIZE_DEFAULT
+#define RECV_BUFSIZE_DEFAULT            INT_MAX
+#endif
+
+/**
+ * SO_REUSE==1: Enable SO_REUSEADDR and SO_REUSEPORT options. DO NOT USE!
+ */
+#ifndef SO_REUSE
+#define SO_REUSE                        0
+#endif
+
+/*
+   ----------------------------------------
+   ---------- Statistics options ----------
+   ----------------------------------------
+*/
+/**
+ * LWIP_STATS==1: Enable statistics collection in lwip_stats.
+ */
+#ifndef LWIP_STATS
+#define LWIP_STATS                      1
+#endif
+
+#if LWIP_STATS
+
+/**
+ * LWIP_STATS_DISPLAY==1: Compile in the statistics output functions.
+ */
+#ifndef LWIP_STATS_DISPLAY
+#define LWIP_STATS_DISPLAY              0
+#endif
+
+/**
+ * LINK_STATS==1: Enable link stats.
+ */
+#ifndef LINK_STATS
+#define LINK_STATS                      1
+#endif
+
+/**
+ * ETHARP_STATS==1: Enable etharp stats.
+ */
+#ifndef ETHARP_STATS
+#define ETHARP_STATS                    (LWIP_ARP)
+#endif
+
+/**
+ * IP_STATS==1: Enable IP stats.
+ */
+#ifndef IP_STATS
+#define IP_STATS                        1
+#endif
+
+/**
+ * IPFRAG_STATS==1: Enable IP fragmentation stats. Default is
+ * on if using either frag or reass.
+ */
+#ifndef IPFRAG_STATS
+#define IPFRAG_STATS                    (IP_REASSEMBLY || IP_FRAG)
+#endif
+
+/**
+ * ICMP_STATS==1: Enable ICMP stats.
+ */
+#ifndef ICMP_STATS
+#define ICMP_STATS                      1
+#endif
+
+/**
+ * IGMP_STATS==1: Enable IGMP stats.
+ */
+#ifndef IGMP_STATS
+#define IGMP_STATS                      (LWIP_IGMP)
+#endif
+
+/**
+ * UDP_STATS==1: Enable UDP stats. Default is on if
+ * UDP enabled, otherwise off.
+ */
+#ifndef UDP_STATS
+#define UDP_STATS                       (LWIP_UDP)
+#endif
+
+/**
+ * TCP_STATS==1: Enable TCP stats. Default is on if TCP
+ * enabled, otherwise off.
+ */
+#ifndef TCP_STATS
+#define TCP_STATS                       (LWIP_TCP)
+#endif
+
+/**
+ * MEM_STATS==1: Enable mem.c stats.
+ */
+#ifndef MEM_STATS
+#define MEM_STATS                       1
+#endif
+
+/**
+ * MEMP_STATS==1: Enable memp.c pool stats.
+ */
+#ifndef MEMP_STATS
+#define MEMP_STATS                      1
+#endif
+
+/**
+ * SYS_STATS==1: Enable system stats (sem and mbox counts, etc).
+ */
+#ifndef SYS_STATS
+#define SYS_STATS                       1
+#endif
+
+#else
+
+#define LINK_STATS                      0
+#define IP_STATS                        0
+#define IPFRAG_STATS                    0
+#define ICMP_STATS                      0
+#define IGMP_STATS                      0
+#define UDP_STATS                       0
+#define TCP_STATS                       0
+#define MEM_STATS                       0
+#define MEMP_STATS                      0
+#define SYS_STATS                       0
+#define LWIP_STATS_DISPLAY              0
+
+#endif                          /* LWIP_STATS */
+
+/*
+   ---------------------------------
+   ---------- PPP options ----------
+   ---------------------------------
+*/
+/**
+ * PPP_SUPPORT==1: Enable PPP.
+ */
+#ifndef PPP_SUPPORT
+#define PPP_SUPPORT                     0
+#endif
+
+/**
+ * PPPOE_SUPPORT==1: Enable PPP Over Ethernet
+ */
+#ifndef PPPOE_SUPPORT
+#define PPPOE_SUPPORT                   0
+#endif
+
+/**
+ * PPPOS_SUPPORT==1: Enable PPP Over Serial
+ */
+#ifndef PPPOS_SUPPORT
+#define PPPOS_SUPPORT                   PPP_SUPPORT
+#endif
+
+#if PPP_SUPPORT
+
+/**
+ * NUM_PPP: Max PPP sessions.
+ */
+#ifndef NUM_PPP
+#define NUM_PPP                         1
+#endif
+
+/**
+ * PAP_SUPPORT==1: Support PAP.
+ */
+#ifndef PAP_SUPPORT
+#define PAP_SUPPORT                     0
+#endif
+
+/**
+ * CHAP_SUPPORT==1: Support CHAP.
+ */
+#ifndef CHAP_SUPPORT
+#define CHAP_SUPPORT                    0
+#endif
+
+/**
+ * MSCHAP_SUPPORT==1: Support MSCHAP. CURRENTLY NOT SUPPORTED! DO NOT SET!
+ */
+#ifndef MSCHAP_SUPPORT
+#define MSCHAP_SUPPORT                  0
+#endif
+
+/**
+ * CBCP_SUPPORT==1: Support CBCP. CURRENTLY NOT SUPPORTED! DO NOT SET!
+ */
+#ifndef CBCP_SUPPORT
+#define CBCP_SUPPORT                    0
+#endif
+
+/**
+ * CCP_SUPPORT==1: Support CCP. CURRENTLY NOT SUPPORTED! DO NOT SET!
+ */
+#ifndef CCP_SUPPORT
+#define CCP_SUPPORT                     0
+#endif
+
+/**
+ * VJ_SUPPORT==1: Support VJ header compression.
+ */
+#ifndef VJ_SUPPORT
+#define VJ_SUPPORT                      0
+#endif
+
+/**
+ * MD5_SUPPORT==1: Support MD5 (see also CHAP).
+ */
+#ifndef MD5_SUPPORT
+#define MD5_SUPPORT                     0
+#endif
+
+/*
+ * Timeouts
+ */
+#ifndef FSM_DEFTIMEOUT
+#define FSM_DEFTIMEOUT                  6       /* Timeout time in seconds */
+#endif
+
+#ifndef FSM_DEFMAXTERMREQS
+#define FSM_DEFMAXTERMREQS              2       /* Maximum Terminate-Request transmissions */
+#endif
+
+#ifndef FSM_DEFMAXCONFREQS
+#define FSM_DEFMAXCONFREQS              10      /* Maximum Configure-Request transmissions */
+#endif
+
+#ifndef FSM_DEFMAXNAKLOOPS
+#define FSM_DEFMAXNAKLOOPS              5       /* Maximum number of nak loops */
+#endif
+
+#ifndef UPAP_DEFTIMEOUT
+#define UPAP_DEFTIMEOUT                 6       /* Timeout (seconds) for retransmitting req */
+#endif
+
+#ifndef UPAP_DEFREQTIME
+#define UPAP_DEFREQTIME                 30      /* Time to wait for auth-req from peer */
+#endif
+
+#ifndef CHAP_DEFTIMEOUT
+#define CHAP_DEFTIMEOUT                 6       /* Timeout time in seconds */
+#endif
+
+#ifndef CHAP_DEFTRANSMITS
+#define CHAP_DEFTRANSMITS               10      /* max # times to send challenge */
+#endif
+
+/* Interval in seconds between keepalive echo requests, 0 to disable. */
+#ifndef LCP_ECHOINTERVAL
+#define LCP_ECHOINTERVAL                0
+#endif
+
+/* Number of unanswered echo requests before failure. */
+#ifndef LCP_MAXECHOFAILS
+#define LCP_MAXECHOFAILS                3
+#endif
+
+/* Max Xmit idle time (in jiffies) before resend flag char. */
+#ifndef PPP_MAXIDLEFLAG
+#define PPP_MAXIDLEFLAG                 100
+#endif
+
+/*
+ * Packet sizes
+ *
+ * Note - lcp shouldn't be allowed to negotiate stuff outside these
+ *    limits.  See lcp.h in the pppd directory.
+ * (XXX - these constants should simply be shared by lcp.c instead
+ *    of living in lcp.h)
+ */
+#define PPP_MTU                         1500    /* Default MTU (size of Info field) */
+#ifndef PPP_MAXMTU
+/* #define PPP_MAXMTU  65535 - (PPP_HDRLEN + PPP_FCSLEN) */
+#define PPP_MAXMTU                      1500    /* Largest MTU we allow */
+#endif
+#define PPP_MINMTU                      64
+#define PPP_MRU                         1500    /* default MRU = max length of info field */
+#define PPP_MAXMRU                      1500    /* Largest MRU we allow */
+#ifndef PPP_DEFMRU
+#define PPP_DEFMRU                      296     /* Try for this */
+#endif
+#define PPP_MINMRU                      128     /* No MRUs below this */
+
+
+#define MAXNAMELEN                      256     /* max length of hostname or name for auth */
+#define MAXSECRETLEN                    256     /* max length of password or secret */
+
+#endif                          /* PPP_SUPPORT */
+
+/*
+   --------------------------------------
+   ---------- Checksum options ----------
+   --------------------------------------
+*/
+/**
+ * CHECKSUM_GEN_IP==1: Generate checksums in software for outgoing IP packets.
+ */
+#ifndef CHECKSUM_GEN_IP
+#define CHECKSUM_GEN_IP                 1
+#endif
+
+/**
+ * CHECKSUM_GEN_UDP==1: Generate checksums in software for outgoing UDP packets.
+ */
+#ifndef CHECKSUM_GEN_UDP
+#define CHECKSUM_GEN_UDP                1
+#endif
+
+/**
+ * CHECKSUM_GEN_TCP==1: Generate checksums in software for outgoing TCP packets.
+ */
+#ifndef CHECKSUM_GEN_TCP
+#define CHECKSUM_GEN_TCP                1
+#endif
+
+/**
+ * CHECKSUM_CHECK_IP==1: Check checksums in software for incoming IP packets.
+ */
+#ifndef CHECKSUM_CHECK_IP
+#define CHECKSUM_CHECK_IP               1
+#endif
+
+/**
+ * CHECKSUM_CHECK_UDP==1: Check checksums in software for incoming UDP packets.
+ */
+#ifndef CHECKSUM_CHECK_UDP
+#define CHECKSUM_CHECK_UDP              1
+#endif
+
+/**
+ * CHECKSUM_CHECK_TCP==1: Check checksums in software for incoming TCP packets.
+ */
+#ifndef CHECKSUM_CHECK_TCP
+#define CHECKSUM_CHECK_TCP              1
+#endif
+
+/*
+   ---------------------------------------
+   ---------- Debugging options ----------
+   ---------------------------------------
+*/
+/**
+ * LWIP_DBG_MIN_LEVEL: After masking, the value of the debug is
+ * compared against this value. If it is smaller, then debugging
+ * messages are written.
+ */
+#ifndef LWIP_DBG_MIN_LEVEL
+#define LWIP_DBG_MIN_LEVEL              LWIP_DBG_LEVEL_OFF
+#endif
+
+/**
+ * LWIP_DBG_TYPES_ON: A mask that can be used to globally enable/disable
+ * debug messages of certain types.
+ */
+#ifndef LWIP_DBG_TYPES_ON
+#define LWIP_DBG_TYPES_ON               LWIP_DBG_ON
+#endif
+
+/**
+ * ETHARP_DEBUG: Enable debugging in etharp.c.
+ */
+#ifndef ETHARP_DEBUG
+#define ETHARP_DEBUG                    LWIP_DBG_OFF
+#endif
+
+/**
+ * NETIF_DEBUG: Enable debugging in netif.c.
+ */
+#ifndef NETIF_DEBUG
+#define NETIF_DEBUG                     LWIP_DBG_OFF
+#endif
+
+/**
+ * PBUF_DEBUG: Enable debugging in pbuf.c.
+ */
+#ifndef PBUF_DEBUG
+#define PBUF_DEBUG                      LWIP_DBG_OFF
+#endif
+
+/**
+ * API_LIB_DEBUG: Enable debugging in api_lib.c.
+ */
+#ifndef API_LIB_DEBUG
+#define API_LIB_DEBUG                   LWIP_DBG_OFF
+#endif
+
+/**
+ * API_MSG_DEBUG: Enable debugging in api_msg.c.
+ */
+#ifndef API_MSG_DEBUG
+#define API_MSG_DEBUG                   LWIP_DBG_OFF
+#endif
+
+/**
+ * SOCKETS_DEBUG: Enable debugging in sockets.c.
+ */
+#ifndef SOCKETS_DEBUG
+#define SOCKETS_DEBUG                   LWIP_DBG_OFF
+#endif
+
+/**
+ * ICMP_DEBUG: Enable debugging in icmp.c.
+ */
+#ifndef ICMP_DEBUG
+#define ICMP_DEBUG                      LWIP_DBG_OFF
+#endif
+
+/**
+ * IGMP_DEBUG: Enable debugging in igmp.c.
+ */
+#ifndef IGMP_DEBUG
+#define IGMP_DEBUG                      LWIP_DBG_OFF
+#endif
+
+/**
+ * INET_DEBUG: Enable debugging in inet.c.
+ */
+#ifndef INET_DEBUG
+#define INET_DEBUG                      LWIP_DBG_OFF
+#endif
+
+/**
+ * IP_DEBUG: Enable debugging for IP.
+ */
+#ifndef IP_DEBUG
+#define IP_DEBUG                        LWIP_DBG_OFF
+#endif
+
+/**
+ * IP_REASS_DEBUG: Enable debugging in ip_frag.c for both frag & reass.
+ */
+#ifndef IP_REASS_DEBUG
+#define IP_REASS_DEBUG                  LWIP_DBG_OFF
+#endif
+
+/**
+ * RAW_DEBUG: Enable debugging in raw.c.
+ */
+#ifndef RAW_DEBUG
+#define RAW_DEBUG                       LWIP_DBG_OFF
+#endif
+
+/**
+ * MEM_DEBUG: Enable debugging in mem.c.
+ */
+#ifndef MEM_DEBUG
+#define MEM_DEBUG                       LWIP_DBG_OFF
+#endif
+
+/**
+ * MEMP_DEBUG: Enable debugging in memp.c.
+ */
+#ifndef MEMP_DEBUG
+#define MEMP_DEBUG                      LWIP_DBG_OFF
+#endif
+
+/**
+ * SYS_DEBUG: Enable debugging in sys.c.
+ */
+#ifndef SYS_DEBUG
+#define SYS_DEBUG                       LWIP_DBG_OFF
+#endif
+
+/**
+ * TCP_DEBUG: Enable debugging for TCP.
+ */
+#ifndef TCP_DEBUG
+#define TCP_DEBUG                       LWIP_DBG_OFF
+#endif
+
+/**
+ * TCP_INPUT_DEBUG: Enable debugging in tcp_in.c for incoming debug.
+ */
+#ifndef TCP_INPUT_DEBUG
+#define TCP_INPUT_DEBUG                 LWIP_DBG_OFF
+#endif
+
+/**
+ * TCP_FR_DEBUG: Enable debugging in tcp_in.c for fast retransmit.
+ */
+#ifndef TCP_FR_DEBUG
+#define TCP_FR_DEBUG                    LWIP_DBG_OFF
+#endif
+
+/**
+ * TCP_RTO_DEBUG: Enable debugging in TCP for retransmit
+ * timeout.
+ */
+#ifndef TCP_RTO_DEBUG
+#define TCP_RTO_DEBUG                   LWIP_DBG_OFF
+#endif
+
+/**
+ * TCP_CWND_DEBUG: Enable debugging for TCP congestion window.
+ */
+#ifndef TCP_CWND_DEBUG
+#define TCP_CWND_DEBUG                  LWIP_DBG_OFF
+#endif
+
+/**
+ * TCP_WND_DEBUG: Enable debugging in tcp_in.c for window updating.
+ */
+#ifndef TCP_WND_DEBUG
+#define TCP_WND_DEBUG                   LWIP_DBG_OFF
+#endif
+
+/**
+ * TCP_OUTPUT_DEBUG: Enable debugging in tcp_out.c output functions.
+ */
+#ifndef TCP_OUTPUT_DEBUG
+#define TCP_OUTPUT_DEBUG                LWIP_DBG_OFF
+#endif
+
+/**
+ * TCP_RST_DEBUG: Enable debugging for TCP with the RST message.
+ */
+#ifndef TCP_RST_DEBUG
+#define TCP_RST_DEBUG                   LWIP_DBG_OFF
+#endif
+
+/**
+ * TCP_QLEN_DEBUG: Enable debugging for TCP queue lengths.
+ */
+#ifndef TCP_QLEN_DEBUG
+#define TCP_QLEN_DEBUG                  LWIP_DBG_OFF
+#endif
+
+/**
+ * UDP_DEBUG: Enable debugging in UDP.
+ */
+#ifndef UDP_DEBUG
+//#define UDP_DEBUG                       LWIP_DBG_ON
+#define UDP_DEBUG                       LWIP_DBG_OFF
+#endif
+
+/**
+ * TCPIP_DEBUG: Enable debugging in tcpip.c.
+ */
+#ifndef TCPIP_DEBUG
+#define TCPIP_DEBUG                     LWIP_DBG_OFF
+#endif
+
+/**
+ * PPP_DEBUG: Enable debugging for PPP.
+ */
+#ifndef PPP_DEBUG
+#define PPP_DEBUG                       LWIP_DBG_OFF
+#endif
+
+/**
+ * SLIP_DEBUG: Enable debugging in slipif.c.
+ */
+#ifndef SLIP_DEBUG
+#define SLIP_DEBUG                      LWIP_DBG_OFF
+#endif
+
+/**
+ * DHCP_DEBUG: Enable debugging in dhcp.c.
+ */
+#ifndef DHCP_DEBUG
+#define DHCP_DEBUG                      LWIP_DBG_OFF
+#endif
+
+/**
+ * AUTOIP_DEBUG: Enable debugging in autoip.c.
+ */
+#ifndef AUTOIP_DEBUG
+#define AUTOIP_DEBUG                    LWIP_DBG_OFF
+#endif
+
+/**
+ * SNMP_MSG_DEBUG: Enable debugging for SNMP messages.
+ */
+#ifndef SNMP_MSG_DEBUG
+#define SNMP_MSG_DEBUG                  LWIP_DBG_OFF
+#endif
+
+/**
+ * SNMP_MIB_DEBUG: Enable debugging for SNMP MIBs.
+ */
+#ifndef SNMP_MIB_DEBUG
+#define SNMP_MIB_DEBUG                  LWIP_DBG_OFF
+#endif
+
+/**
+ * DNS_DEBUG: Enable debugging for DNS.
+ */
+#ifndef DNS_DEBUG
+#define DNS_DEBUG                       LWIP_DBG_OFF
+#endif
+
+#endif                          /* __LWIP_OPT_H__ */
diff --git a/lib/lwip/src/include/lwip/pbuf.h b/lib/lwip/src/include/lwip/pbuf.h
new file mode 100644
index 0000000..779d364
--- /dev/null
+++ b/lib/lwip/src/include/lwip/pbuf.h
@@ -0,0 +1,140 @@
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+
+#ifndef __LWIP_PBUF_H__
+#define __LWIP_PBUF_H__
+
+#include "lwip/opt.h"
+#include "lwip/err.h"
+
+#include <net_interfaces/flags.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* FIXME: this might be the bad place for this #define */
+#define PBUF_PKT_SIZE 2048      // NOTE: size of each pbuf struct.
+
+#define PBUF_TRANSPORT_HLEN 20
+#define PBUF_IP_HLEN        20
+
+    typedef enum {
+        PBUF_TRANSPORT,
+        PBUF_IP,
+        PBUF_LINK,
+        PBUF_RAW
+    } pbuf_layer;
+
+    typedef enum {
+        PBUF_RAM,               /* pbuf data is stored in RAM */
+        PBUF_ROM,               /* pbuf data is stored in ROM */
+        PBUF_REF,               /* pbuf comes from the pbuf pool */
+        PBUF_POOL               /* pbuf payload refers to RAM */
+    } pbuf_type;
+
+
+/** indicates this packet's data should be immediately passed to the application */
+#define PBUF_FLAG_PUSH 0x01U
+
+    struct pbuf {
+  /** next pbuf in singly linked pbuf chain */
+        struct pbuf *next;
+
+  /** pointer to the actual data in the buffer */
+        void *payload;
+
+  /**
+   * total length of this buffer and all next buffers in chain
+   * belonging to the same packet.
+   *
+   * For non-queue packet chains this is the invariant:
+   * p->tot_len == p->len + (p->next? p->next->tot_len: 0)
+   */
+        u16_t tot_len;
+
+  /** length of this buffer */
+        u16_t len;
+
+  /** pbuf_type as u8_t instead of enum to save space */
+         u8_t /*pbuf_type */ type;
+
+  /** misc flags */
+        u8_t flags;
+
+  /**
+   * the reference count always equals the number of pointers
+   * that refer to this pbuf. This can be pointers from an application,
+   * the stack itself, or pbuf->next pointers from a chain.
+   */
+        u16_t ref;
+
+        /* buff len is the size of buffer allocated to this pbuf */
+        u16_t buff_len;
+
+        uint64_t nicflags;
+    };
+
+/* Initializes the pbuf module. This call is empty for now, but may not be in future. */
+#define pbuf_init()
+
+//#define pbuf_free(a)    do{ pbuf_free_tagged((a));  } while(0)
+#define pbuf_free(a)    pbuf_free_tagged((a), (__func__), (__LINE__))
+#define pbuf_ref(a)    pbuf_ref_tagged((a), (__func__), (__LINE__))
+#define pbuf_alloc(l, len, t)    pbuf_alloc_tagged((l), (len), (t), (__func__), (__LINE__))
+
+    void pbuf_ref_tagged(struct pbuf *p, const char *func_name, int line_no);
+    struct pbuf *pbuf_alloc_tagged(pbuf_layer layer, u16_t length, pbuf_type type,
+       const char *func_name, int line_no);
+//    u8_t pbuf_free(struct pbuf *p);
+    u8_t pbuf_free_tagged(struct pbuf * p, const char *func_name, int line_no);
+
+    uint16_t free_pbuf_pool_count(void);
+    void pbuf_realloc(struct pbuf *p, u16_t size);
+    u8_t pbuf_header(struct pbuf *p, s16_t header_size);
+//    void pbuf_ref(struct pbuf *p);
+    void pbuf_ref_chain(struct pbuf *p);
+//    u8_t pbuf_free(struct pbuf *p);
+    u8_t pbuf_clen(struct pbuf *p);
+    void pbuf_cat(struct pbuf *head, struct pbuf *tail);
+    void pbuf_chain(struct pbuf *head, struct pbuf *tail);
+    struct pbuf *pbuf_dechain(struct pbuf *p);
+    err_t pbuf_copy(struct pbuf *p_to, struct pbuf *p_from);
+    u16_t pbuf_copy_partial(struct pbuf *p, void *dataptr, u16_t len,
+                            u16_t offset);
+    err_t pbuf_take(struct pbuf *buf, const void *dataptr, u16_t len);
+    struct pbuf *pbuf_coalesce(struct pbuf *p, pbuf_layer layer);
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* __LWIP_PBUF_H__ */
diff --git a/lib/lwip/src/include/lwip/raw.h b/lib/lwip/src/include/lwip/raw.h
new file mode 100644
index 0000000..785a41e
--- /dev/null
+++ b/lib/lwip/src/include/lwip/raw.h
@@ -0,0 +1,95 @@
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef __LWIP_RAW_H__
+#define __LWIP_RAW_H__
+
+#include "lwip/opt.h"
+
+#if LWIP_RAW                    /* don't build if not configured for use in lwipopts.h */
+
+#include "lwip/pbuf.h"
+#include "lwip/inet.h"
+#include "lwip/ip.h"
+#include "lwip/ip_addr.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+    struct raw_pcb {
+/* Common members of all PCB types */
+        IP_PCB;
+
+        struct raw_pcb *next;
+
+        u8_t protocol;
+
+        /* receive callback function
+         * @param arg user supplied argument (raw_pcb.recv_arg)
+         * @param pcb the raw_pcb which received data
+         * @param p the packet buffer that was received
+         * @param addr the remote IP address from which the packet was received
+         * @return 1 if the packet was 'eaten' (aka. deleted),
+         *         0 if the packet lives on
+         * If returning 1, the callback is responsible for freeing the pbuf
+         * if it's not used any more.
+         */
+         u8_t(*recv) (void *arg, struct raw_pcb * pcb, struct pbuf * p,
+                      struct ip_addr * addr);
+        /* user-supplied argument for the recv callback */
+        void *recv_arg;
+    };
+
+/* The following functions is the application layer interface to the
+   RAW code. */
+    struct raw_pcb *raw_new(u8_t proto);
+    void raw_remove(struct raw_pcb *pcb);
+    err_t raw_bind(struct raw_pcb *pcb, struct ip_addr *ipaddr);
+    err_t raw_connect(struct raw_pcb *pcb, struct ip_addr *ipaddr);
+
+    void raw_recv(struct raw_pcb *pcb,
+                  u8_t(*recv) (void *arg, struct raw_pcb * pcb,
+                               struct pbuf * p,
+                               struct ip_addr * addr), void *recv_arg);
+    err_t raw_sendto(struct raw_pcb *pcb, struct pbuf *p,
+                     struct ip_addr *ipaddr);
+    err_t raw_send(struct raw_pcb *pcb, struct pbuf *p);
+
+/* The following functions are the lower layer interface to RAW. */
+    u8_t raw_input(struct pbuf *p, struct netif *inp);
+#define raw_init()              /* Compatibility define, not init needed. */
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* LWIP_RAW */
+#endif                          /* __LWIP_RAW_H__ */
diff --git a/lib/lwip/src/include/lwip/sio.h b/lib/lwip/src/include/lwip/sio.h
new file mode 100644
index 0000000..8088dce
--- /dev/null
+++ b/lib/lwip/src/include/lwip/sio.h
@@ -0,0 +1,80 @@
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved. 
+ * 
+ * Redistribution and use in source and binary forms, with or without modification, 
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission. 
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ */
+
+/*
+ * This is the interface to the platform specific serial IO module
+ * It needs to be implemented by those platforms which need SLIP or PPP
+ */
+
+#ifndef __SIO_H__
+#define __SIO_H__
+
+#include "lwip/arch.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* If you want to define sio_fd_t elsewhere or differently,
+   define this in your cc.h file. */
+#ifndef __sio_fd_t_defined
+    typedef void *sio_fd_t;
+#endif
+
+/* The following functions can be defined to something else in your cc.h file
+   or be implemented in your custom sio.c file. */
+
+#ifndef sio_open
+    sio_fd_t sio_open(u8_t);
+#endif
+
+#ifndef sio_send
+    void sio_send(u8_t, sio_fd_t);
+#endif
+
+#ifndef sio_recv
+    u8_t sio_recv(sio_fd_t);
+#endif
+
+#ifndef sio_read
+    u32_t sio_read(sio_fd_t, u8_t *, u32_t);
+#endif
+
+#ifndef sio_write
+    u32_t sio_write(sio_fd_t, u8_t *, u32_t);
+#endif
+
+#ifndef sio_read_abort
+    void sio_read_abort(sio_fd_t);
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* __SIO_H__ */
diff --git a/lib/lwip/src/include/lwip/snmp.h b/lib/lwip/src/include/lwip/snmp.h
new file mode 100644
index 0000000..15f9140
--- /dev/null
+++ b/lib/lwip/src/include/lwip/snmp.h
@@ -0,0 +1,362 @@
+/*
+ * Copyright (c) 2001, 2002 Leon Woestenberg <leon.woestenberg@axon.tv>
+ * Copyright (c) 2001, 2002 Axon Digital Design B.V., The Netherlands.
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without modification, 
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission. 
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ * 
+ * Author: Leon Woestenberg <leon.woestenberg@axon.tv>
+ *
+ */
+#ifndef __LWIP_SNMP_H__
+#define __LWIP_SNMP_H__
+
+#include "lwip/opt.h"
+#include "lwip/netif.h"
+#include "lwip/udp.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @see RFC1213, "MIB-II, 6. Definitions"
+ */
+    enum snmp_ifType {
+        snmp_ifType_other = 1,  /* none of the following */
+        snmp_ifType_regular1822,
+        snmp_ifType_hdh1822,
+        snmp_ifType_ddn_x25,
+        snmp_ifType_rfc877_x25,
+        snmp_ifType_ethernet_csmacd,
+        snmp_ifType_iso88023_csmacd,
+        snmp_ifType_iso88024_tokenBus,
+        snmp_ifType_iso88025_tokenRing,
+        snmp_ifType_iso88026_man,
+        snmp_ifType_starLan,
+        snmp_ifType_proteon_10Mbit,
+        snmp_ifType_proteon_80Mbit,
+        snmp_ifType_hyperchannel,
+        snmp_ifType_fddi,
+        snmp_ifType_lapb,
+        snmp_ifType_sdlc,
+        snmp_ifType_ds1,        /* T-1 */
+        snmp_ifType_e1,         /* european equiv. of T-1 */
+        snmp_ifType_basicISDN,
+        snmp_ifType_primaryISDN,        /* proprietary serial */
+        snmp_ifType_propPointToPointSerial,
+        snmp_ifType_ppp,
+        snmp_ifType_softwareLoopback,
+        snmp_ifType_eon,        /* CLNP over IP [11] */
+        snmp_ifType_ethernet_3Mbit,
+        snmp_ifType_nsip,       /* XNS over IP */
+        snmp_ifType_slip,       /* generic SLIP */
+        snmp_ifType_ultra,      /* ULTRA technologies */
+        snmp_ifType_ds3,        /* T-3 */
+        snmp_ifType_sip,        /* SMDS */
+        snmp_ifType_frame_relay
+    };
+
+#if LWIP_SNMP                   /* don't build if not configured for use in lwipopts.h */
+
+/** SNMP "sysuptime" Interval */
+#define SNMP_SYSUPTIME_INTERVAL 10
+
+/** fixed maximum length for object identifier type */
+#define LWIP_SNMP_OBJ_ID_LEN 32
+
+/** internal object identifier representation */
+    struct snmp_obj_id {
+        u8_t len;
+        s32_t id[LWIP_SNMP_OBJ_ID_LEN];
+    };
+
+/* system */
+    void snmp_set_sysdesr(u8_t * str, u8_t * len);
+    void snmp_set_sysobjid(struct snmp_obj_id *oid);
+    void snmp_get_sysobjid_ptr(struct snmp_obj_id **oid);
+    void snmp_inc_sysuptime(void);
+    void snmp_add_sysuptime(u32_t value);
+    void snmp_get_sysuptime(u32_t * value);
+    void snmp_set_syscontact(u8_t * ocstr, u8_t * ocstrlen);
+    void snmp_set_sysname(u8_t * ocstr, u8_t * ocstrlen);
+    void snmp_set_syslocation(u8_t * ocstr, u8_t * ocstrlen);
+
+/* network interface */
+    void snmp_add_ifinoctets(struct netif *ni, u32_t value);
+    void snmp_inc_ifinucastpkts(struct netif *ni);
+    void snmp_inc_ifinnucastpkts(struct netif *ni);
+    void snmp_inc_ifindiscards(struct netif *ni);
+    void snmp_add_ifoutoctets(struct netif *ni, u32_t value);
+    void snmp_inc_ifoutucastpkts(struct netif *ni);
+    void snmp_inc_ifoutnucastpkts(struct netif *ni);
+    void snmp_inc_ifoutdiscards(struct netif *ni);
+    void snmp_inc_iflist(void);
+    void snmp_dec_iflist(void);
+
+/* ARP (for atTable and ipNetToMediaTable) */
+    void snmp_insert_arpidx_tree(struct netif *ni, struct ip_addr *ip);
+    void snmp_delete_arpidx_tree(struct netif *ni, struct ip_addr *ip);
+
+/* IP */
+    void snmp_inc_ipinreceives(void);
+    void snmp_inc_ipinhdrerrors(void);
+    void snmp_inc_ipinaddrerrors(void);
+    void snmp_inc_ipforwdatagrams(void);
+    void snmp_inc_ipinunknownprotos(void);
+    void snmp_inc_ipindiscards(void);
+    void snmp_inc_ipindelivers(void);
+    void snmp_inc_ipoutrequests(void);
+    void snmp_inc_ipoutdiscards(void);
+    void snmp_inc_ipoutnoroutes(void);
+    void snmp_inc_ipreasmreqds(void);
+    void snmp_inc_ipreasmoks(void);
+    void snmp_inc_ipreasmfails(void);
+    void snmp_inc_ipfragoks(void);
+    void snmp_inc_ipfragfails(void);
+    void snmp_inc_ipfragcreates(void);
+    void snmp_inc_iproutingdiscards(void);
+    void snmp_insert_ipaddridx_tree(struct netif *ni);
+    void snmp_delete_ipaddridx_tree(struct netif *ni);
+    void snmp_insert_iprteidx_tree(u8_t dflt, struct netif *ni);
+    void snmp_delete_iprteidx_tree(u8_t dflt, struct netif *ni);
+
+/* ICMP */
+    void snmp_inc_icmpinmsgs(void);
+    void snmp_inc_icmpinerrors(void);
+    void snmp_inc_icmpindestunreachs(void);
+    void snmp_inc_icmpintimeexcds(void);
+    void snmp_inc_icmpinparmprobs(void);
+    void snmp_inc_icmpinsrcquenchs(void);
+    void snmp_inc_icmpinredirects(void);
+    void snmp_inc_icmpinechos(void);
+    void snmp_inc_icmpinechoreps(void);
+    void snmp_inc_icmpintimestamps(void);
+    void snmp_inc_icmpintimestampreps(void);
+    void snmp_inc_icmpinaddrmasks(void);
+    void snmp_inc_icmpinaddrmaskreps(void);
+    void snmp_inc_icmpoutmsgs(void);
+    void snmp_inc_icmpouterrors(void);
+    void snmp_inc_icmpoutdestunreachs(void);
+    void snmp_inc_icmpouttimeexcds(void);
+    void snmp_inc_icmpoutparmprobs(void);
+    void snmp_inc_icmpoutsrcquenchs(void);
+    void snmp_inc_icmpoutredirects(void);
+    void snmp_inc_icmpoutechos(void);
+    void snmp_inc_icmpoutechoreps(void);
+    void snmp_inc_icmpouttimestamps(void);
+    void snmp_inc_icmpouttimestampreps(void);
+    void snmp_inc_icmpoutaddrmasks(void);
+    void snmp_inc_icmpoutaddrmaskreps(void);
+
+/* TCP */
+    void snmp_inc_tcpactiveopens(void);
+    void snmp_inc_tcppassiveopens(void);
+    void snmp_inc_tcpattemptfails(void);
+    void snmp_inc_tcpestabresets(void);
+    void snmp_inc_tcpinsegs(void);
+    void snmp_inc_tcpoutsegs(void);
+    void snmp_inc_tcpretranssegs(void);
+    void snmp_inc_tcpinerrs(void);
+    void snmp_inc_tcpoutrsts(void);
+
+/* UDP */
+    void snmp_inc_udpindatagrams(void);
+    void snmp_inc_udpnoports(void);
+    void snmp_inc_udpinerrors(void);
+    void snmp_inc_udpoutdatagrams(void);
+    void snmp_insert_udpidx_tree(struct udp_pcb *pcb);
+    void snmp_delete_udpidx_tree(struct udp_pcb *pcb);
+
+/* SNMP */
+    void snmp_inc_snmpinpkts(void);
+    void snmp_inc_snmpoutpkts(void);
+    void snmp_inc_snmpinbadversions(void);
+    void snmp_inc_snmpinbadcommunitynames(void);
+    void snmp_inc_snmpinbadcommunityuses(void);
+    void snmp_inc_snmpinasnparseerrs(void);
+    void snmp_inc_snmpintoobigs(void);
+    void snmp_inc_snmpinnosuchnames(void);
+    void snmp_inc_snmpinbadvalues(void);
+    void snmp_inc_snmpinreadonlys(void);
+    void snmp_inc_snmpingenerrs(void);
+    void snmp_add_snmpintotalreqvars(u8_t value);
+    void snmp_add_snmpintotalsetvars(u8_t value);
+    void snmp_inc_snmpingetrequests(void);
+    void snmp_inc_snmpingetnexts(void);
+    void snmp_inc_snmpinsetrequests(void);
+    void snmp_inc_snmpingetresponses(void);
+    void snmp_inc_snmpintraps(void);
+    void snmp_inc_snmpouttoobigs(void);
+    void snmp_inc_snmpoutnosuchnames(void);
+    void snmp_inc_snmpoutbadvalues(void);
+    void snmp_inc_snmpoutgenerrs(void);
+    void snmp_inc_snmpoutgetrequests(void);
+    void snmp_inc_snmpoutgetnexts(void);
+    void snmp_inc_snmpoutsetrequests(void);
+    void snmp_inc_snmpoutgetresponses(void);
+    void snmp_inc_snmpouttraps(void);
+    void snmp_get_snmpgrpid_ptr(struct snmp_obj_id **oid);
+    void snmp_set_snmpenableauthentraps(u8_t * value);
+    void snmp_get_snmpenableauthentraps(u8_t * value);
+
+/* LWIP_SNMP support not available */
+/* define everything to be empty */
+#else
+
+/* system */
+#define snmp_set_sysdesr(str, len)
+#define snmp_set_sysobjid(oid);
+#define snmp_get_sysobjid_ptr(oid)
+#define snmp_inc_sysuptime()
+#define snmp_add_sysuptime(value)
+#define snmp_get_sysuptime(value)
+#define snmp_set_syscontact(ocstr, ocstrlen);
+#define snmp_set_sysname(ocstr, ocstrlen);
+#define snmp_set_syslocation(ocstr, ocstrlen);
+
+/* network interface */
+#define snmp_add_ifinoctets(ni,value)
+#define snmp_inc_ifinucastpkts(ni)
+#define snmp_inc_ifinnucastpkts(ni)
+#define snmp_inc_ifindiscards(ni)
+#define snmp_add_ifoutoctets(ni,value)
+#define snmp_inc_ifoutucastpkts(ni)
+#define snmp_inc_ifoutnucastpkts(ni)
+#define snmp_inc_ifoutdiscards(ni)
+#define snmp_inc_iflist()
+#define snmp_dec_iflist()
+
+/* ARP */
+#define snmp_insert_arpidx_tree(ni,ip)
+#define snmp_delete_arpidx_tree(ni,ip)
+
+/* IP */
+#define snmp_inc_ipinreceives()
+#define snmp_inc_ipinhdrerrors()
+#define snmp_inc_ipinaddrerrors()
+#define snmp_inc_ipforwdatagrams()
+#define snmp_inc_ipinunknownprotos()
+#define snmp_inc_ipindiscards()
+#define snmp_inc_ipindelivers()
+#define snmp_inc_ipoutrequests()
+#define snmp_inc_ipoutdiscards()
+#define snmp_inc_ipoutnoroutes()
+#define snmp_inc_ipreasmreqds()
+#define snmp_inc_ipreasmoks()
+#define snmp_inc_ipreasmfails()
+#define snmp_inc_ipfragoks()
+#define snmp_inc_ipfragfails()
+#define snmp_inc_ipfragcreates()
+#define snmp_inc_iproutingdiscards()
+#define snmp_insert_ipaddridx_tree(ni)
+#define snmp_delete_ipaddridx_tree(ni)
+#define snmp_insert_iprteidx_tree(dflt, ni)
+#define snmp_delete_iprteidx_tree(dflt, ni)
+
+/* ICMP */
+#define snmp_inc_icmpinmsgs()
+#define snmp_inc_icmpinerrors()
+#define snmp_inc_icmpindestunreachs()
+#define snmp_inc_icmpintimeexcds()
+#define snmp_inc_icmpinparmprobs()
+#define snmp_inc_icmpinsrcquenchs()
+#define snmp_inc_icmpinredirects()
+#define snmp_inc_icmpinechos()
+#define snmp_inc_icmpinechoreps()
+#define snmp_inc_icmpintimestamps()
+#define snmp_inc_icmpintimestampreps()
+#define snmp_inc_icmpinaddrmasks()
+#define snmp_inc_icmpinaddrmaskreps()
+#define snmp_inc_icmpoutmsgs()
+#define snmp_inc_icmpouterrors()
+#define snmp_inc_icmpoutdestunreachs()
+#define snmp_inc_icmpouttimeexcds()
+#define snmp_inc_icmpoutparmprobs()
+#define snmp_inc_icmpoutsrcquenchs()
+#define snmp_inc_icmpoutredirects()
+#define snmp_inc_icmpoutechos()
+#define snmp_inc_icmpoutechoreps()
+#define snmp_inc_icmpouttimestamps()
+#define snmp_inc_icmpouttimestampreps()
+#define snmp_inc_icmpoutaddrmasks()
+#define snmp_inc_icmpoutaddrmaskreps()
+/* TCP */
+#define snmp_inc_tcpactiveopens()
+#define snmp_inc_tcppassiveopens()
+#define snmp_inc_tcpattemptfails()
+#define snmp_inc_tcpestabresets()
+#define snmp_inc_tcpinsegs()
+#define snmp_inc_tcpoutsegs()
+#define snmp_inc_tcpretranssegs()
+#define snmp_inc_tcpinerrs()
+#define snmp_inc_tcpoutrsts()
+
+/* UDP */
+#define snmp_inc_udpindatagrams()
+#define snmp_inc_udpnoports()
+#define snmp_inc_udpinerrors()
+#define snmp_inc_udpoutdatagrams()
+#define snmp_insert_udpidx_tree(pcb)
+#define snmp_delete_udpidx_tree(pcb)
+
+/* SNMP */
+#define snmp_inc_snmpinpkts()
+#define snmp_inc_snmpoutpkts()
+#define snmp_inc_snmpinbadversions()
+#define snmp_inc_snmpinbadcommunitynames()
+#define snmp_inc_snmpinbadcommunityuses()
+#define snmp_inc_snmpinasnparseerrs()
+#define snmp_inc_snmpintoobigs()
+#define snmp_inc_snmpinnosuchnames()
+#define snmp_inc_snmpinbadvalues()
+#define snmp_inc_snmpinreadonlys()
+#define snmp_inc_snmpingenerrs()
+#define snmp_add_snmpintotalreqvars(value)
+#define snmp_add_snmpintotalsetvars(value)
+#define snmp_inc_snmpingetrequests()
+#define snmp_inc_snmpingetnexts()
+#define snmp_inc_snmpinsetrequests()
+#define snmp_inc_snmpingetresponses()
+#define snmp_inc_snmpintraps()
+#define snmp_inc_snmpouttoobigs()
+#define snmp_inc_snmpoutnosuchnames()
+#define snmp_inc_snmpoutbadvalues()
+#define snmp_inc_snmpoutgenerrs()
+#define snmp_inc_snmpoutgetrequests()
+#define snmp_inc_snmpoutgetnexts()
+#define snmp_inc_snmpoutsetrequests()
+#define snmp_inc_snmpoutgetresponses()
+#define snmp_inc_snmpouttraps()
+#define snmp_get_snmpgrpid_ptr(oid)
+#define snmp_set_snmpenableauthentraps(value)
+#define snmp_get_snmpenableauthentraps(value)
+
+#endif                          /* LWIP_SNMP */
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* __LWIP_SNMP_H__ */
diff --git a/lib/lwip/src/include/lwip/snmp_asn1.h b/lib/lwip/src/include/lwip/snmp_asn1.h
new file mode 100644
index 0000000..4773b46
--- /dev/null
+++ b/lib/lwip/src/include/lwip/snmp_asn1.h
@@ -0,0 +1,109 @@
+/**
+ * @file
+ * Abstract Syntax Notation One (ISO 8824, 8825) codec.
+ */
+
+/*
+ * Copyright (c) 2006 Axon Digital Design B.V., The Netherlands.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * Author: Christiaan Simons <christiaan.simons@axon.tv>
+ */
+
+#ifndef __LWIP_SNMP_ASN1_H__
+#define __LWIP_SNMP_ASN1_H__
+
+#include "lwip/opt.h"
+#include "lwip/err.h"
+#include "lwip/pbuf.h"
+#include "lwip/snmp.h"
+
+#if LWIP_SNMP
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define SNMP_ASN1_UNIV   (!0x80 | !0x40)
+#define SNMP_ASN1_APPLIC (!0x80 |  0x40)
+#define SNMP_ASN1_CONTXT ( 0x80 | !0x40)
+
+#define SNMP_ASN1_CONSTR (0x20)
+#define SNMP_ASN1_PRIMIT (!0x20)
+
+/* universal tags */
+#define SNMP_ASN1_INTEG  2
+#define SNMP_ASN1_OC_STR 4
+#define SNMP_ASN1_NUL    5
+#define SNMP_ASN1_OBJ_ID 6
+#define SNMP_ASN1_SEQ    16
+
+/* application specific (SNMP) tags */
+#define SNMP_ASN1_IPADDR 0      /* octet string size(4) */
+#define SNMP_ASN1_COUNTER 1     /* u32_t */
+#define SNMP_ASN1_GAUGE 2       /* u32_t */
+#define SNMP_ASN1_TIMETICKS 3   /* u32_t */
+#define SNMP_ASN1_OPAQUE 4      /* octet string */
+
+/* context specific (SNMP) tags */
+#define SNMP_ASN1_PDU_GET_REQ 0
+#define SNMP_ASN1_PDU_GET_NEXT_REQ 1
+#define SNMP_ASN1_PDU_GET_RESP 2
+#define SNMP_ASN1_PDU_SET_REQ 3
+#define SNMP_ASN1_PDU_TRAP 4
+
+    err_t snmp_asn1_dec_type(struct pbuf *p, u16_t ofs, u8_t * type);
+    err_t snmp_asn1_dec_length(struct pbuf *p, u16_t ofs, u8_t * octets_used,
+                               u16_t * length);
+    err_t snmp_asn1_dec_u32t(struct pbuf *p, u16_t ofs, u16_t len,
+                             u32_t * value);
+    err_t snmp_asn1_dec_s32t(struct pbuf *p, u16_t ofs, u16_t len,
+                             s32_t * value);
+    err_t snmp_asn1_dec_oid(struct pbuf *p, u16_t ofs, u16_t len,
+                            struct snmp_obj_id *oid);
+    err_t snmp_asn1_dec_raw(struct pbuf *p, u16_t ofs, u16_t len, u16_t raw_len,
+                            u8_t * raw);
+
+    void snmp_asn1_enc_length_cnt(u16_t length, u8_t * octets_needed);
+    void snmp_asn1_enc_u32t_cnt(u32_t value, u16_t * octets_needed);
+    void snmp_asn1_enc_s32t_cnt(s32_t value, u16_t * octets_needed);
+    void snmp_asn1_enc_oid_cnt(u8_t ident_len, s32_t * ident,
+                               u16_t * octets_needed);
+    err_t snmp_asn1_enc_type(struct pbuf *p, u16_t ofs, u8_t type);
+    err_t snmp_asn1_enc_length(struct pbuf *p, u16_t ofs, u16_t length);
+    err_t snmp_asn1_enc_u32t(struct pbuf *p, u16_t ofs, u8_t octets_needed,
+                             u32_t value);
+    err_t snmp_asn1_enc_s32t(struct pbuf *p, u16_t ofs, u8_t octets_needed,
+                             s32_t value);
+    err_t snmp_asn1_enc_oid(struct pbuf *p, u16_t ofs, u8_t ident_len,
+                            s32_t * ident);
+    err_t snmp_asn1_enc_raw(struct pbuf *p, u16_t ofs, u8_t raw_len,
+                            u8_t * raw);
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* LWIP_SNMP */
+#endif                          /* __LWIP_SNMP_ASN1_H__ */
diff --git a/lib/lwip/src/include/lwip/snmp_msg.h b/lib/lwip/src/include/lwip/snmp_msg.h
new file mode 100644
index 0000000..8d63807
--- /dev/null
+++ b/lib/lwip/src/include/lwip/snmp_msg.h
@@ -0,0 +1,307 @@
+/**
+ * @file
+ * SNMP Agent message handling structures.
+ */
+
+/*
+ * Copyright (c) 2006 Axon Digital Design B.V., The Netherlands.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * Author: Christiaan Simons <christiaan.simons@axon.tv>
+ */
+
+#ifndef __LWIP_SNMP_MSG_H__
+#define __LWIP_SNMP_MSG_H__
+
+#include "lwip/opt.h"
+#include "lwip/snmp.h"
+#include "lwip/snmp_structs.h"
+
+#if LWIP_SNMP
+
+#if SNMP_PRIVATE_MIB
+#include "private_mib.h"
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* The listen port of the SNMP agent. Clients have to make their requests to
+   this port. Most standard clients won't work if you change this! */
+#ifndef SNMP_IN_PORT
+#define SNMP_IN_PORT 161
+#endif
+/* The remote port the SNMP agent sends traps to. Most standard trap sinks won't
+   work if you change this! */
+#ifndef SNMP_TRAP_PORT
+#define SNMP_TRAP_PORT 162
+#endif
+
+#define SNMP_ES_NOERROR 0
+#define SNMP_ES_TOOBIG 1
+#define SNMP_ES_NOSUCHNAME 2
+#define SNMP_ES_BADVALUE 3
+#define SNMP_ES_READONLY 4
+#define SNMP_ES_GENERROR 5
+
+#define SNMP_GENTRAP_COLDSTART 0
+#define SNMP_GENTRAP_WARMSTART 1
+#define SNMP_GENTRAP_AUTHFAIL 4
+#define SNMP_GENTRAP_ENTERPRISESPC 6
+
+    struct snmp_varbind {
+        /* next pointer, NULL for last in list */
+        struct snmp_varbind *next;
+        /* previous pointer, NULL for first in list */
+        struct snmp_varbind *prev;
+
+        /* object identifier length (in s32_t) */
+        u8_t ident_len;
+        /* object identifier array */
+        s32_t *ident;
+
+        /* object value ASN1 type */
+        u8_t value_type;
+        /* object value length (in u8_t) */
+        u8_t value_len;
+        /* object value */
+        void *value;
+
+        /* encoding varbind seq length length */
+        u8_t seqlenlen;
+        /* encoding object identifier length length */
+        u8_t olenlen;
+        /* encoding object value length length */
+        u8_t vlenlen;
+        /* encoding varbind seq length */
+        u16_t seqlen;
+        /* encoding object identifier length */
+        u16_t olen;
+        /* encoding object value length */
+        u16_t vlen;
+    };
+
+    struct snmp_varbind_root {
+        struct snmp_varbind *head;
+        struct snmp_varbind *tail;
+        /* number of variable bindings in list */
+        u8_t count;
+        /* encoding varbind-list seq length length */
+        u8_t seqlenlen;
+        /* encoding varbind-list seq length */
+        u16_t seqlen;
+    };
+
+/** output response message header length fields */
+    struct snmp_resp_header_lengths {
+        /* encoding error-index length length */
+        u8_t erridxlenlen;
+        /* encoding error-status length length */
+        u8_t errstatlenlen;
+        /* encoding request id length length */
+        u8_t ridlenlen;
+        /* encoding pdu length length */
+        u8_t pdulenlen;
+        /* encoding community length length */
+        u8_t comlenlen;
+        /* encoding version length length */
+        u8_t verlenlen;
+        /* encoding sequence length length */
+        u8_t seqlenlen;
+
+        /* encoding error-index length */
+        u16_t erridxlen;
+        /* encoding error-status length */
+        u16_t errstatlen;
+        /* encoding request id length */
+        u16_t ridlen;
+        /* encoding pdu length */
+        u16_t pdulen;
+        /* encoding community length */
+        u16_t comlen;
+        /* encoding version length */
+        u16_t verlen;
+        /* encoding sequence length */
+        u16_t seqlen;
+    };
+
+/** output response message header length fields */
+    struct snmp_trap_header_lengths {
+        /* encoding timestamp length length */
+        u8_t tslenlen;
+        /* encoding specific-trap length length */
+        u8_t strplenlen;
+        /* encoding generic-trap length length */
+        u8_t gtrplenlen;
+        /* encoding agent-addr length length */
+        u8_t aaddrlenlen;
+        /* encoding enterprise-id length length */
+        u8_t eidlenlen;
+        /* encoding pdu length length */
+        u8_t pdulenlen;
+        /* encoding community length length */
+        u8_t comlenlen;
+        /* encoding version length length */
+        u8_t verlenlen;
+        /* encoding sequence length length */
+        u8_t seqlenlen;
+
+        /* encoding timestamp length */
+        u16_t tslen;
+        /* encoding specific-trap length */
+        u16_t strplen;
+        /* encoding generic-trap length */
+        u16_t gtrplen;
+        /* encoding agent-addr length */
+        u16_t aaddrlen;
+        /* encoding enterprise-id length */
+        u16_t eidlen;
+        /* encoding pdu length */
+        u16_t pdulen;
+        /* encoding community length */
+        u16_t comlen;
+        /* encoding version length */
+        u16_t verlen;
+        /* encoding sequence length */
+        u16_t seqlen;
+    };
+
+/* Accepting new SNMP messages. */
+#define SNMP_MSG_EMPTY                 0
+/* Search for matching object for variable binding. */
+#define SNMP_MSG_SEARCH_OBJ            1
+/* Perform SNMP operation on in-memory object.
+   Pass-through states, for symmetry only. */
+#define SNMP_MSG_INTERNAL_GET_OBJDEF   2
+#define SNMP_MSG_INTERNAL_GET_VALUE    3
+#define SNMP_MSG_INTERNAL_SET_TEST     4
+#define SNMP_MSG_INTERNAL_GET_OBJDEF_S 5
+#define SNMP_MSG_INTERNAL_SET_VALUE    6
+/* Perform SNMP operation on object located externally.
+   In theory this could be used for building a proxy agent.
+   Practical use is for an enterprise spc. app. gateway. */
+#define SNMP_MSG_EXTERNAL_GET_OBJDEF   7
+#define SNMP_MSG_EXTERNAL_GET_VALUE    8
+#define SNMP_MSG_EXTERNAL_SET_TEST     9
+#define SNMP_MSG_EXTERNAL_GET_OBJDEF_S 10
+#define SNMP_MSG_EXTERNAL_SET_VALUE    11
+
+#define SNMP_COMMUNITY_STR_LEN 64
+    struct snmp_msg_pstat {
+        /* lwIP local port (161) binding */
+        struct udp_pcb *pcb;
+        /* source IP address */
+        struct ip_addr sip;
+        /* source UDP port */
+        u16_t sp;
+        /* request type */
+        u8_t rt;
+        /* request ID */
+        s32_t rid;
+        /* error status */
+        s32_t error_status;
+        /* error index */
+        s32_t error_index;
+        /* community name (zero terminated) */
+        u8_t community[SNMP_COMMUNITY_STR_LEN + 1];
+        /* community string length (exclusive zero term) */
+        u8_t com_strlen;
+        /* one out of MSG_EMPTY, MSG_DEMUX, MSG_INTERNAL, MSG_EXTERNAL_x */
+        u8_t state;
+        /* saved arguments for MSG_EXTERNAL_x */
+        struct mib_external_node *ext_mib_node;
+        struct snmp_name_ptr ext_name_ptr;
+        struct obj_def ext_object_def;
+        struct snmp_obj_id ext_oid;
+        /* index into input variable binding list */
+        u8_t vb_idx;
+        /* ptr into input variable binding list */
+        struct snmp_varbind *vb_ptr;
+        /* list of variable bindings from input */
+        struct snmp_varbind_root invb;
+        /* list of variable bindings to output */
+        struct snmp_varbind_root outvb;
+        /* output response lengths used in ASN encoding */
+        struct snmp_resp_header_lengths rhl;
+    };
+
+    struct snmp_msg_trap {
+        /* lwIP local port (161) binding */
+        struct udp_pcb *pcb;
+        /* destination IP address in network order */
+        struct ip_addr dip;
+
+        /* source enterprise ID (sysObjectID) */
+        struct snmp_obj_id *enterprise;
+        /* source IP address, raw network order format */
+        u8_t sip_raw[4];
+        /* generic trap code */
+        u32_t gen_trap;
+        /* specific trap code */
+        u32_t spc_trap;
+        /* timestamp */
+        u32_t ts;
+        /* list of variable bindings to output */
+        struct snmp_varbind_root outvb;
+        /* output trap lengths used in ASN encoding */
+        struct snmp_trap_header_lengths thl;
+    };
+
+/** Agent Version constant, 0 = v1 oddity */
+    extern const s32_t snmp_version;
+/** Agent default "public" community string */
+    extern const char snmp_publiccommunity[7];
+
+    extern struct snmp_msg_trap trap_msg;
+
+/** Agent setup, start listening to port 161. */
+    void snmp_init(void);
+    void snmp_trap_dst_enable(u8_t dst_idx, u8_t enable);
+    void snmp_trap_dst_ip_set(u8_t dst_idx, struct ip_addr *dst);
+
+/** Varbind-list functions. */
+    struct snmp_varbind *snmp_varbind_alloc(struct snmp_obj_id *oid, u8_t type,
+                                            u8_t len);
+    void snmp_varbind_free(struct snmp_varbind *vb);
+    void snmp_varbind_list_free(struct snmp_varbind_root *root);
+    void snmp_varbind_tail_add(struct snmp_varbind_root *root,
+                               struct snmp_varbind *vb);
+    struct snmp_varbind *snmp_varbind_tail_remove(struct snmp_varbind_root
+                                                  *root);
+
+/** Handle an internal (recv) or external (private response) event. */
+    void snmp_msg_event(u8_t request_id);
+    err_t snmp_send_response(struct snmp_msg_pstat *m_stat);
+    err_t snmp_send_trap(s8_t generic_trap, struct snmp_obj_id *eoid,
+                         s32_t specific_trap);
+    void snmp_coldstart_trap(void);
+    void snmp_authfail_trap(void);
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* LWIP_SNMP */
+#endif                          /* __LWIP_SNMP_MSG_H__ */
diff --git a/lib/lwip/src/include/lwip/snmp_structs.h b/lib/lwip/src/include/lwip/snmp_structs.h
new file mode 100644
index 0000000..a3f430d
--- /dev/null
+++ b/lib/lwip/src/include/lwip/snmp_structs.h
@@ -0,0 +1,273 @@
+/**
+ * @file
+ * Generic MIB tree structures.
+ *
+ * @todo namespace prefixes
+ */
+
+/*
+ * Copyright (c) 2006 Axon Digital Design B.V., The Netherlands.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * Author: Christiaan Simons <christiaan.simons@axon.tv>
+ */
+
+#ifndef __LWIP_SNMP_STRUCTS_H__
+#define __LWIP_SNMP_STRUCTS_H__
+
+#include "lwip/opt.h"
+
+#if LWIP_SNMP                   /* don't build if not configured for use in lwipopts.h */
+
+#include "lwip/snmp.h"
+
+#if SNMP_PRIVATE_MIB
+#include "private_mib.h"
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* MIB object instance */
+#define MIB_OBJECT_NONE 0
+#define MIB_OBJECT_SCALAR 1
+#define MIB_OBJECT_TAB 2
+
+/* MIB object access */
+#define MIB_OBJECT_READ_ONLY 0
+#define MIB_OBJECT_READ_WRITE 1
+#define MIB_OBJECT_WRITE_ONLY 2
+#define MIB_OBJECT_NOT_ACCESSIBLE 3
+
+/** object definition returned by (get_object_def)() */
+    struct obj_def {
+        /* MIB_OBJECT_NONE (0), MIB_OBJECT_SCALAR (1), MIB_OBJECT_TAB (2) */
+        u8_t instance;
+        /* 0 read-only, 1 read-write, 2 write-only, 3 not-accessible */
+        u8_t access;
+        /* ASN type for this object */
+        u8_t asn_type;
+        /* value length (host length) */
+        u16_t v_len;
+        /* length of instance part of supplied object identifier */
+        u8_t id_inst_len;
+        /* instance part of supplied object identifier */
+        s32_t *id_inst_ptr;
+    };
+
+    struct snmp_name_ptr {
+        u8_t ident_len;
+        s32_t *ident;
+    };
+
+/** MIB const scalar (.0) node */
+#define MIB_NODE_SC 0x01
+/** MIB const array node */
+#define MIB_NODE_AR 0x02
+/** MIB array node (mem_malloced from RAM) */
+#define MIB_NODE_RA 0x03
+/** MIB list root node (mem_malloced from RAM) */
+#define MIB_NODE_LR 0x04
+/** MIB node for external objects */
+#define MIB_NODE_EX 0x05
+
+/** node "base class" layout, the mandatory fields for a node  */
+    struct mib_node {
+  /** returns struct obj_def for the given object identifier */
+        void (*get_object_def) (u8_t ident_len, s32_t * ident,
+                                struct obj_def * od);
+  /** returns object value for the given object identifier,
+     @note the caller must allocate at least len bytes for the value */
+        void (*get_value) (struct obj_def * od, u16_t len, void *value);
+  /** tests length and/or range BEFORE setting */
+         u8_t(*set_test) (struct obj_def * od, u16_t len, void *value);
+  /** sets object value, only to be called when set_test()  */
+        void (*set_value) (struct obj_def * od, u16_t len, void *value);
+  /** One out of MIB_NODE_AR, MIB_NODE_LR or MIB_NODE_EX */
+        const u8_t node_type;
+        /* array or max list length */
+        const u16_t maxlength;
+    };
+
+/** derived node for scalars .0 index */
+    typedef struct mib_node mib_scalar_node;
+
+/** derived node, points to a fixed size const array
+    of sub-identifiers plus a 'child' pointer */
+    struct mib_array_node {
+        /* inherited "base class" members */
+        void (*const get_object_def) (u8_t ident_len, s32_t * ident,
+                                      struct obj_def * od);
+        void (*const get_value) (struct obj_def * od, u16_t len, void *value);
+         u8_t(*set_test) (struct obj_def * od, u16_t len, void *value);
+        void (*set_value) (struct obj_def * od, u16_t len, void *value);
+
+        const u8_t node_type;
+        const u16_t maxlength;
+
+        /* aditional struct members */
+        const s32_t *objid;
+        struct mib_node *const *nptr;
+    };
+
+/** derived node, points to a fixed size mem_malloced array
+    of sub-identifiers plus a 'child' pointer */
+    struct mib_ram_array_node {
+        /* inherited "base class" members */
+        void (*get_object_def) (u8_t ident_len, s32_t * ident,
+                                struct obj_def * od);
+        void (*get_value) (struct obj_def * od, u16_t len, void *value);
+         u8_t(*set_test) (struct obj_def * od, u16_t len, void *value);
+        void (*set_value) (struct obj_def * od, u16_t len, void *value);
+
+        u8_t node_type;
+        u16_t maxlength;
+
+        /* aditional struct members */
+        s32_t *objid;
+        struct mib_node **nptr;
+    };
+
+    struct mib_list_node {
+        struct mib_list_node *prev;
+        struct mib_list_node *next;
+        s32_t objid;
+        struct mib_node *nptr;
+    };
+
+/** derived node, points to a doubly linked list
+    of sub-identifiers plus a 'child' pointer */
+    struct mib_list_rootnode {
+        /* inherited "base class" members */
+        void (*get_object_def) (u8_t ident_len, s32_t * ident,
+                                struct obj_def * od);
+        void (*get_value) (struct obj_def * od, u16_t len, void *value);
+         u8_t(*set_test) (struct obj_def * od, u16_t len, void *value);
+        void (*set_value) (struct obj_def * od, u16_t len, void *value);
+
+        u8_t node_type;
+        u16_t maxlength;
+
+        /* aditional struct members */
+        struct mib_list_node *head;
+        struct mib_list_node *tail;
+        /* counts list nodes in list  */
+        u16_t count;
+    };
+
+/** derived node, has access functions for mib object in external memory or device
+    using 'tree_level' and 'idx', with a range 0 .. (level_length() - 1) */
+    struct mib_external_node {
+        /* inherited "base class" members */
+        void (*get_object_def) (u8_t ident_len, s32_t * ident,
+                                struct obj_def * od);
+        void (*get_value) (struct obj_def * od, u16_t len, void *value);
+         u8_t(*set_test) (struct obj_def * od, u16_t len, void *value);
+        void (*set_value) (struct obj_def * od, u16_t len, void *value);
+
+        u8_t node_type;
+        u16_t maxlength;
+
+        /* aditional struct members */
+  /** points to an extenal (in memory) record of some sort of addressing
+      information, passed to and interpreted by the funtions below */
+        void *addr_inf;
+  /** tree levels under this node */
+        u8_t tree_levels;
+  /** number of objects at this level */
+         u16_t(*level_length) (void *addr_inf, u8_t level);
+  /** compares object sub identifier with external id
+      return zero when equal, nonzero when unequal */
+         s32_t(*ident_cmp) (void *addr_inf, u8_t level, u16_t idx,
+                            s32_t sub_id);
+        void (*get_objid) (void *addr_inf, u8_t level, u16_t idx,
+                           s32_t * sub_id);
+
+  /** async Questions */
+        void (*get_object_def_q) (void *addr_inf, u8_t rid, u8_t ident_len,
+                                  s32_t * ident);
+        void (*get_value_q) (u8_t rid, struct obj_def * od);
+        void (*set_test_q) (u8_t rid, struct obj_def * od);
+        void (*set_value_q) (u8_t rid, struct obj_def * od, u16_t len,
+                             void *value);
+  /** async Answers */
+        void (*get_object_def_a) (u8_t rid, u8_t ident_len, s32_t * ident,
+                                  struct obj_def * od);
+        void (*get_value_a) (u8_t rid, struct obj_def * od, u16_t len,
+                             void *value);
+         u8_t(*set_test_a) (u8_t rid, struct obj_def * od, u16_t len,
+                            void *value);
+        void (*set_value_a) (u8_t rid, struct obj_def * od, u16_t len,
+                             void *value);
+  /** async Panic Close (agent returns error reply, 
+      e.g. used for external transaction cleanup) */
+        void (*get_object_def_pc) (u8_t rid, u8_t ident_len, s32_t * ident);
+        void (*get_value_pc) (u8_t rid, struct obj_def * od);
+        void (*set_test_pc) (u8_t rid, struct obj_def * od);
+        void (*set_value_pc) (u8_t rid, struct obj_def * od);
+    };
+
+/** export MIB tree from mib2.c */
+    extern const struct mib_array_node internet;
+
+/** dummy function pointers for non-leaf MIB nodes from mib2.c */
+    void noleafs_get_object_def(u8_t ident_len, s32_t * ident,
+                                struct obj_def *od);
+    void noleafs_get_value(struct obj_def *od, u16_t len, void *value);
+    u8_t noleafs_set_test(struct obj_def *od, u16_t len, void *value);
+    void noleafs_set_value(struct obj_def *od, u16_t len, void *value);
+
+    void snmp_oidtoip(s32_t * ident, struct ip_addr *ip);
+    void snmp_iptooid(struct ip_addr *ip, s32_t * ident);
+    void snmp_ifindextonetif(s32_t ifindex, struct netif **netif);
+    void snmp_netiftoifindex(struct netif *netif, s32_t * ifidx);
+
+    struct mib_list_node *snmp_mib_ln_alloc(s32_t id);
+    void snmp_mib_ln_free(struct mib_list_node *ln);
+    struct mib_list_rootnode *snmp_mib_lrn_alloc(void);
+    void snmp_mib_lrn_free(struct mib_list_rootnode *lrn);
+
+    s8_t snmp_mib_node_insert(struct mib_list_rootnode *rn, s32_t objid,
+                              struct mib_list_node **insn);
+    s8_t snmp_mib_node_find(struct mib_list_rootnode *rn, s32_t objid,
+                            struct mib_list_node **fn);
+    struct mib_list_rootnode *snmp_mib_node_delete(struct mib_list_rootnode *rn,
+                                                   struct mib_list_node *n);
+
+    struct mib_node *snmp_search_tree(struct mib_node *node, u8_t ident_len,
+                                      s32_t * ident, struct snmp_name_ptr *np);
+    struct mib_node *snmp_expand_tree(struct mib_node *node, u8_t ident_len,
+                                      s32_t * ident,
+                                      struct snmp_obj_id *oidret);
+    u8_t snmp_iso_prefix_tst(u8_t ident_len, s32_t * ident);
+    u8_t snmp_iso_prefix_expand(u8_t ident_len, s32_t * ident,
+                                struct snmp_obj_id *oidret);
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* LWIP_SNMP */
+#endif                          /* __LWIP_SNMP_STRUCTS_H__ */
diff --git a/lib/lwip/src/include/lwip/sock_chan_support.h b/lib/lwip/src/include/lwip/sock_chan_support.h
new file mode 100644
index 0000000..3b80e4a
--- /dev/null
+++ b/lib/lwip/src/include/lwip/sock_chan_support.h
@@ -0,0 +1,33 @@
+/**
+ * \file
+ * \brief Barrelfish waitset and channel support for LWIP.
+ */
+
+/*
+ * Copyright (c) 2012, 2013, ETH Zurich.
+ * All rights reserved.
+ *
+ * This file is distributed under the terms in the attached LICENSE file.
+ * If you do not find this file, copies can be found by writing to:
+ * ETH Zurich D-INFK, CAB F.78, Universitaetstr. 6, CH-8092 Zurich,
+ * Attn: Systems Group.
+ */
+
+#ifndef __LWIP_CHAN_SUPPORT_H__
+#define __LWIP_CHAN_SUPPORT_H__
+
+#include <barrelfish/waitset.h>
+#include <errors/errno.h>
+
+#include <stdbool.h>
+
+bool lwip_sock_is_open(int socket);
+bool lwip_sock_ready_read(int socket);
+bool lwip_sock_ready_write(int socket);
+
+errval_t lwip_sock_waitset_deregister_read(int socket);
+errval_t lwip_sock_waitset_register_read(int socket, struct waitset *ws);
+errval_t lwip_sock_waitset_deregister_write(int socket);
+errval_t lwip_sock_waitset_register_write(int socket, struct waitset *ws);
+
+#endif /* __LWIP_CHAN_SUPPORT_H__ */
diff --git a/lib/lwip/src/include/lwip/sock_serialise.h b/lib/lwip/src/include/lwip/sock_serialise.h
new file mode 100644
index 0000000..66246d9
--- /dev/null
+++ b/lib/lwip/src/include/lwip/sock_serialise.h
@@ -0,0 +1,23 @@
+#ifndef SOCK_SERIALISE_H
+#define SOCK_SERIALISE_H
+
+#include "lwip/sockets.h"
+#include "lwip/tcp.h"
+#include "lwip/api.h"
+
+// IK
+// ports are in host order
+struct lwip_sockinfo {
+    struct ip_addr local_ip;
+    u16_t local_port;
+    struct ip_addr remote_ip;
+    u16_t remote_port;
+    struct tcp_pcb tcp_state;
+    struct netconn netconn_state;
+
+};
+
+int lwip_serialise_sock(int s, struct lwip_sockinfo *si);
+int lwip_deserialise_sock(int s, struct lwip_sockinfo *si);
+
+#endif
diff --git a/lib/lwip/src/include/lwip/sockets.h b/lib/lwip/src/include/lwip/sockets.h
new file mode 100644
index 0000000..005ba3b
--- /dev/null
+++ b/lib/lwip/src/include/lwip/sockets.h
@@ -0,0 +1,362 @@
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved. 
+ * 
+ * Redistribution and use in source and binary forms, with or without modification, 
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission. 
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ * 
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+
+
+#ifndef __LWIP_SOCKETS_H__
+#define __LWIP_SOCKETS_H__
+
+#include "lwip/opt.h"
+
+#if LWIP_SOCKET                 /* don't build if not configured for use in lwipopts.h */
+
+#include <stddef.h>             /* for size_t */
+#include <fcntl.h>
+/* We use our own verions of FD_SETSIZE, FD_SET, FD_ISSET, FD_ZERO, FD_CLR */
+#include <sys/select.h>
+
+#include "lwip/ip_addr.h"
+#include "lwip/inet.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* members are in network byte order */
+    struct sockaddr_in {
+        u8_t sin_len;
+        u8_t sin_family;
+        u16_t sin_port;
+        struct in_addr sin_addr;
+        char sin_zero[8];
+    };
+
+    struct sockaddr {
+        u8_t sa_len;
+        u8_t sa_family;
+        char sa_data[14];
+    };
+
+#ifndef socklen_t
+#define socklen_t u32_t
+#endif
+
+/* Socket protocol types (TCP/UDP/RAW) */
+#define SOCK_STREAM     1
+#define SOCK_DGRAM      2
+#define SOCK_RAW        3
+
+/*
+ * Option flags per-socket. These must match the SOF_ flags in ip.h!
+ */
+#define  SO_DEBUG       0x0001  /* Unimplemented: turn on debugging info recording */
+#define  SO_ACCEPTCONN  0x0002  /* socket has had listen() */
+#define  SO_REUSEADDR   0x0004 /* Unimplemented: allow local address reuse */
+#define  SO_KEEPALIVE   0x0008  /* keep connections alive */
+#define  SO_DONTROUTE   0x0010  /* Unimplemented: just use interface addresses */
+#define  SO_BROADCAST   0x0020  /* permit to send and to receive broadcast messages (see IP_SOF_BROADCAST option) */
+#define  SO_USELOOPBACK 0x0040  /* Unimplemented: bypass hardware when possible */
+#define  SO_LINGER      0x0080  /* linger on close if data present */
+#define  SO_OOBINLINE   0x0100  /* Unimplemented: leave received OOB data in line */
+#define  SO_REUSEPORT   0x0200 /* Unimplemented: allow local address & port reuse */
+
+#define SO_DONTLINGER   ((int)(~SO_LINGER))
+
+/*
+ * Additional options, not kept in so_options.
+ */
+#define SO_SNDBUF    0x1001     /* Unimplemented: send buffer size */
+#define SO_RCVBUF    0x1002     /* receive buffer size */
+#define SO_SNDLOWAT  0x1003     /* Unimplemented: send low-water mark */
+#define SO_RCVLOWAT  0x1004     /* Unimplemented: receive low-water mark */
+#define SO_SNDTIMEO  0x1005     /* Unimplemented: send timeout */
+#define SO_RCVTIMEO  0x1006     /* receive timeout */
+#define SO_ERROR     0x1007     /* get error status and clear */
+#define SO_TYPE      0x1008     /* get socket type */
+#define SO_CONTIMEO  0x1009     /* Unimplemented: connect timeout */
+#define SO_NO_CHECK  0x100a     /* don't create UDP checksum */
+
+
+/*
+ * Structure used for manipulating linger option.
+ */
+    struct linger {
+        int l_onoff;            /* option on/off */
+        int l_linger;           /* linger time */
+    };
+
+/*
+ * Level number for (get/set)sockopt() to apply to socket itself.
+ */
+#define  SOL_SOCKET  0xfff      /* options for socket level */
+
+
+#define AF_UNSPEC       0
+#define AF_INET         2
+#define PF_INET         AF_INET
+#define PF_UNSPEC       AF_UNSPEC
+
+#define IPPROTO_IP      0
+#define IPPROTO_TCP     6
+#define IPPROTO_UDP     17
+#define IPPROTO_UDPLITE 136
+
+/* Flags we can use with send and recv. */
+#define MSG_PEEK       0x01     /* Peeks at an incoming message */
+#define MSG_WAITALL    0x02     /* Unimplemented: Requests that the function block until the full amount of data requested can be returned */
+#define MSG_OOB        0x04     /* Unimplemented: Requests out-of-band data. The significance and semantics of out-of-band data are protocol-specific */
+#define MSG_DONTWAIT   0x08     /* Nonblocking i/o for this operation only */
+#define MSG_MORE       0x10     /* Sender will send more */
+
+
+/*
+ * Options for level IPPROTO_IP
+ */
+#define IP_TOS             1
+#define IP_TTL             2
+
+#if LWIP_TCP
+/*
+ * Options for level IPPROTO_TCP
+ */
+#define TCP_NODELAY    0x01     /* don't delay send to coalesce packets */
+#define TCP_KEEPALIVE  0x02     /* send KEEPALIVE probes when idle for pcb->keep_idle milliseconds */
+#define TCP_KEEPIDLE   0x03     /* set pcb->keep_idle  - Same as TCP_KEEPALIVE, but use seconds for get/setsockopt */
+#define TCP_KEEPINTVL  0x04     /* set pcb->keep_intvl - Use seconds for get/setsockopt */
+#define TCP_KEEPCNT    0x05     /* set pcb->keep_cnt   - Use number of probes sent for get/setsockopt */
+#endif                          /* LWIP_TCP */
+
+#if LWIP_UDP && LWIP_UDPLITE
+/*
+ * Options for level IPPROTO_UDPLITE
+ */
+#define UDPLITE_SEND_CSCOV 0x01 /* sender checksum coverage */
+#define UDPLITE_RECV_CSCOV 0x02 /* minimal receiver checksum coverage */
+#endif                          /* LWIP_UDP && LWIP_UDPLITE */
+
+
+#if LWIP_IGMP
+/*
+ * Options and types for UDP multicast traffic handling
+ */
+#define IP_ADD_MEMBERSHIP  3
+#define IP_DROP_MEMBERSHIP 4
+#define IP_MULTICAST_TTL   5
+#define IP_MULTICAST_IF    6
+#define IP_MULTICAST_LOOP  7
+
+    typedef struct ip_mreq {
+        struct in_addr imr_multiaddr;   /* IP multicast address of group */
+        struct in_addr imr_interface;   /* local IP address of interface */
+    } ip_mreq;
+#endif                          /* LWIP_IGMP */
+
+/*
+ * The Type of Service provides an indication of the abstract
+ * parameters of the quality of service desired.  These parameters are
+ * to be used to guide the selection of the actual service parameters
+ * when transmitting a datagram through a particular network.  Several
+ * networks offer service precedence, which somehow treats high
+ * precedence traffic as more important than other traffic (generally
+ * by accepting only traffic above a certain precedence at time of high
+ * load).  The major choice is a three way tradeoff between low-delay,
+ * high-reliability, and high-throughput.
+ * The use of the Delay, Throughput, and Reliability indications may
+ * increase the cost (in some sense) of the service.  In many networks
+ * better performance for one of these parameters is coupled with worse
+ * performance on another.  Except for very unusual cases at most two
+ * of these three indications should be set.
+ */
+#define IPTOS_TOS_MASK          0x1E
+#define IPTOS_TOS(tos)          ((tos) & IPTOS_TOS_MASK)
+#define IPTOS_LOWDELAY          0x10
+#define IPTOS_THROUGHPUT        0x08
+#define IPTOS_RELIABILITY       0x04
+#define IPTOS_LOWCOST           0x02
+#define IPTOS_MINCOST           IPTOS_LOWCOST
+
+/*
+ * The Network Control precedence designation is intended to be used
+ * within a network only.  The actual use and control of that
+ * designation is up to each network. The Internetwork Control
+ * designation is intended for use by gateway control originators only.
+ * If the actual use of these precedence designations is of concern to
+ * a particular network, it is the responsibility of that network to
+ * control the access to, and use of, those precedence designations.
+ */
+#define IPTOS_PREC_MASK                 0xe0
+#define IPTOS_PREC(tos)                ((tos) & IPTOS_PREC_MASK)
+#define IPTOS_PREC_NETCONTROL           0xe0
+#define IPTOS_PREC_INTERNETCONTROL      0xc0
+#define IPTOS_PREC_CRITIC_ECP           0xa0
+#define IPTOS_PREC_FLASHOVERRIDE        0x80
+#define IPTOS_PREC_FLASH                0x60
+#define IPTOS_PREC_IMMEDIATE            0x40
+#define IPTOS_PREC_PRIORITY             0x20
+#define IPTOS_PREC_ROUTINE              0x00
+
+
+/*
+ * Commands for ioctlsocket(),  taken from the BSD file fcntl.h.
+ * lwip_ioctl only supports FIONREAD and FIONBIO, for now
+ *
+ * Ioctl's have the command encoded in the lower word,
+ * and the size of any in or out parameters in the upper
+ * word.  The high 2 bits of the upper word are used
+ * to encode the in/out status of the parameter; for now
+ * we restrict parameters to at most 128 bytes.
+ */
+#if !defined(FIONREAD) || !defined(FIONBIO)
+#include <sys/ioccom.h>
+#endif                          /* !defined(FIONREAD) || !defined(FIONBIO) */
+
+#ifndef FIONREAD
+#define FIONREAD    _IOR('f', 127, unsigned long)       /* get # bytes to read */
+#endif
+#ifndef FIONBIO
+#define FIONBIO     _IOW('f', 126, unsigned long)       /* set/clear non-blocking i/o */
+#endif
+
+/* Socket I/O Controls: unimplemented */
+#ifndef SIOCSHIWAT
+#define SIOCSHIWAT  _IOW('s',  0, unsigned long)        /* set high watermark */
+#define SIOCGHIWAT  _IOR('s',  1, unsigned long)        /* get high watermark */
+#define SIOCSLOWAT  _IOW('s',  2, unsigned long)        /* set low watermark */
+#define SIOCGLOWAT  _IOR('s',  3, unsigned long)        /* get low watermark */
+#define SIOCATMARK  _IOR('s',  7, unsigned long)        /* at oob mark? */
+#endif
+
+/* Socket flags: */
+#ifndef O_NONBLOCK
+#define O_NONBLOCK    04000U
+#endif
+#ifndef O_NDELAY
+#define O_NDELAY      O_NONBLOCK /* same as O_NONBLOCK, for compatibility */
+#endif
+
+#ifndef SHUT_RD
+  #define SHUT_RD   0
+  #define SHUT_WR   1
+  #define SHUT_RDWR 2
+#endif
+
+/* FD_SET used for lwip_select */
+#ifndef FD_SET
+#undef  FD_SETSIZE
+    /* Make FD_SETSIZE match NUM_SOCKETS in socket.c */
+#define FD_SETSIZE    MEMP_NUM_NETCONN
+#define FD_SET(n, p)  ((p)->fd_bits[(n)/8] |=  (1 << ((n) & 7)))
+#define FD_CLR(n, p)  ((p)->fd_bits[(n)/8] &= ~(1 << ((n) & 7)))
+#define FD_ISSET(n,p) ((p)->fd_bits[(n)/8] &   (1 << ((n) & 7)))
+#define FD_ZERO(p)    memset((void*)(p),0,sizeof(*(p)))
+
+    typedef struct fd_set {
+        unsigned char fd_bits[(FD_SETSIZE + 7) / 8];
+    } fd_set;
+
+#endif                          /* FD_SET */
+
+/** LWIP_TIMEVAL_PRIVATE: if you want to use the struct timeval provided
+ * by your system, set this to 0 and include <sys/time.h> in cc.h */
+#ifndef LWIP_TIMEVAL_PRIVATE
+#define LWIP_TIMEVAL_PRIVATE 0
+#endif
+
+#if LWIP_TIMEVAL_PRIVATE
+    struct timeval {
+        long tv_sec;            /* seconds */
+        long tv_usec;           /* and microseconds */
+    };
+#endif                          /* LWIP_TIMEVAL_PRIVATE */
+
+struct msghdr;
+
+    void lwip_socket_init(void);
+
+    int lwip_accept(int s, struct sockaddr *addr, socklen_t * addrlen);
+    int lwip_bind(int s, const struct sockaddr *name, socklen_t namelen);
+    int lwip_shutdown(int s, int how);
+    int lwip_getpeername(int s, struct sockaddr *name, socklen_t * namelen);
+    int lwip_getsockname(int s, struct sockaddr *name, socklen_t * namelen);
+    int lwip_getsockopt(int s, int level, int optname, void *optval,
+                        socklen_t * optlen);
+    int lwip_setsockopt(int s, int level, int optname, const void *optval,
+                        socklen_t optlen);
+    int lwip_close(int s);
+    int lwip_connect(int s, const struct sockaddr *name, socklen_t namelen);
+    int lwip_listen(int s, int backlog);
+    int lwip_recv(int s, void *mem, size_t len, int flags);
+    int lwip_read(int s, void *mem, size_t len);
+    int lwip_recvfrom(int s, void *mem, size_t len, int flags,
+                      struct sockaddr *from, socklen_t * fromlen);
+    int lwip_send(int s, const void *dataptr, size_t size, int flags);
+    int lwip_sendto(int s, const void *dataptr, size_t size, int flags,
+                    const struct sockaddr *to, socklen_t tolen);
+    int lwip_sendmsg(int s, const struct msghdr *msg, int flags);
+    int lwip_socket(int domain, int type, int protocol);
+    int lwip_write(int s, const void *dataptr, size_t size);
+    int lwip_select(int maxfdp1, fd_set * readset, fd_set * writeset,
+                    fd_set * exceptset, struct timeval *timeout);
+    int lwip_ioctl(int s, long cmd, void *argp);
+    int lwip_fcntl(int s, int cmd, int val);
+
+#if LWIP_COMPAT_SOCKETS
+#define accept(a,b,c)         lwip_accept(a,b,c)
+#define bind(a,b,c)           lwip_bind(a,b,c)
+#define shutdown(a,b)         lwip_shutdown(a,b)
+#define closesocket(s)        lwip_close(s)
+#define connect(a,b,c)        lwip_connect(a,b,c)
+#define getsockname(a,b,c)    lwip_getsockname(a,b,c)
+#define getpeername(a,b,c)    lwip_getpeername(a,b,c)
+#define setsockopt(a,b,c,d,e) lwip_setsockopt(a,b,c,d,e)
+#define getsockopt(a,b,c,d,e) lwip_getsockopt(a,b,c,d,e)
+#define listen(a,b)           lwip_listen(a,b)
+#define recv(a,b,c,d)         lwip_recv(a,b,c,d)
+#define recvfrom(a,b,c,d,e,f) lwip_recvfrom(a,b,c,d,e,f)
+#define send(a,b,c,d)         lwip_send(a,b,c,d)
+#define sendto(a,b,c,d,e,f)   lwip_sendto(a,b,c,d,e,f)
+#define socket(a,b,c)         lwip_socket(a,b,c)
+#define select(a,b,c,d,e)     lwip_select(a,b,c,d,e)
+#define ioctlsocket(a,b,c)    lwip_ioctl(a,b,c)
+
+#if LWIP_POSIX_SOCKETS_IO_NAMES
+#define read(a,b,c)           lwip_read(a,b,c)
+#define write(a,b,c)          lwip_write(a,b,c)
+#define close(s)              lwip_close(s)
+#endif                          /* LWIP_POSIX_SOCKETS_IO_NAMES */
+
+#endif                          /* LWIP_COMPAT_SOCKETS */
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* LWIP_SOCKET */
+#endif                          /* __LWIP_SOCKETS_H__ */
diff --git a/lib/lwip/src/include/lwip/stats.h b/lib/lwip/src/include/lwip/stats.h
new file mode 100644
index 0000000..a46a577
--- /dev/null
+++ b/lib/lwip/src/include/lwip/stats.h
@@ -0,0 +1,282 @@
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved. 
+ * 
+ * Redistribution and use in source and binary forms, with or without modification, 
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission. 
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ * 
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef __LWIP_STATS_H__
+#define __LWIP_STATS_H__
+
+#include "lwip/opt.h"
+
+#include "lwip/mem.h"
+#include "lwip/memp.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if LWIP_STATS
+
+#ifndef LWIP_STATS_LARGE
+#define LWIP_STATS_LARGE 0
+#endif
+
+#if LWIP_STATS_LARGE
+#define STAT_COUNTER     u32_t
+#define STAT_COUNTER_F   U32_F
+#else
+#define STAT_COUNTER     u16_t
+#define STAT_COUNTER_F   U16_F
+#endif
+
+    struct stats_proto {
+        STAT_COUNTER xmit;      /* Transmitted packets. */
+        STAT_COUNTER recv;      /* Received packets. */
+        STAT_COUNTER fw;        /* Forwarded packets. */
+        STAT_COUNTER drop;      /* Dropped packets. */
+        STAT_COUNTER chkerr;    /* Checksum error. */
+        STAT_COUNTER lenerr;    /* Invalid length error. */
+        STAT_COUNTER memerr;    /* Out of memory error. */
+        STAT_COUNTER rterr;     /* Routing error. */
+        STAT_COUNTER proterr;   /* Protocol error. */
+        STAT_COUNTER opterr;    /* Error in options. */
+        STAT_COUNTER err;       /* Misc error. */
+        STAT_COUNTER cachehit;
+    };
+
+    struct stats_igmp {
+        STAT_COUNTER lenerr;    /* Invalid length error. */
+        STAT_COUNTER chkerr;    /* Checksum error. */
+        STAT_COUNTER v1_rxed;   /* */
+        STAT_COUNTER join_sent; /* */
+        STAT_COUNTER leave_sent;        /* */
+        STAT_COUNTER unicast_query;     /* */
+        STAT_COUNTER report_sent;       /* */
+        STAT_COUNTER report_rxed;       /* */
+        STAT_COUNTER group_query_rxed;  /* */
+    };
+
+    struct stats_mem {
+        mem_size_t avail;
+        mem_size_t used;
+        mem_size_t max;
+        STAT_COUNTER err;
+        STAT_COUNTER illegal;
+    };
+
+    struct stats_syselem {
+        STAT_COUNTER used;
+        STAT_COUNTER max;
+        STAT_COUNTER err;
+    };
+
+    struct stats_sys {
+        struct stats_syselem sem;
+        struct stats_syselem mbox;
+    };
+
+    struct stats_ {
+#if LINK_STATS
+        struct stats_proto link;
+#endif
+#if ETHARP_STATS
+        struct stats_proto etharp;
+#endif
+#if IPFRAG_STATS
+        struct stats_proto ip_frag;
+#endif
+#if IP_STATS
+        struct stats_proto ip;
+#endif
+#if ICMP_STATS
+        struct stats_proto icmp;
+#endif
+#if IGMP_STATS
+        struct stats_igmp igmp;
+#endif
+#if UDP_STATS
+        struct stats_proto udp;
+#endif
+#if TCP_STATS
+        struct stats_proto tcp;
+#endif
+#if MEM_STATS
+        struct stats_mem mem;
+#endif
+#if MEMP_STATS
+        struct stats_mem memp[MEMP_MAX];
+#endif
+#if SYS_STATS
+        struct stats_sys sys;
+#endif
+    };
+
+    extern struct stats_ lwip_stats;
+
+#define stats_init()            /* Compatibility define, not init needed. */
+
+#define STATS_INC(x) ++lwip_stats.x
+#define STATS_DEC(x) --lwip_stats.x
+#else
+#define stats_init()
+#define STATS_INC(x)
+#define STATS_DEC(x)
+#endif                          /* LWIP_STATS */
+
+#if TCP_STATS
+#define TCP_STATS_INC(x) STATS_INC(x)
+#define TCP_STATS_DISPLAY() stats_display_proto(&lwip_stats.tcp, "TCP")
+#else
+#define TCP_STATS_INC(x)
+#define TCP_STATS_DISPLAY()
+#endif
+
+#if UDP_STATS
+#define UDP_STATS_INC(x) STATS_INC(x)
+#define UDP_STATS_DISPLAY() stats_display_proto(&lwip_stats.udp, "UDP")
+#else
+#define UDP_STATS_INC(x)
+#define UDP_STATS_DISPLAY()
+#endif
+
+#if ICMP_STATS
+#define ICMP_STATS_INC(x) STATS_INC(x)
+#define ICMP_STATS_DISPLAY() stats_display_proto(&lwip_stats.icmp, "ICMP")
+#else
+#define ICMP_STATS_INC(x)
+#define ICMP_STATS_DISPLAY()
+#endif
+
+#if IGMP_STATS
+#define IGMP_STATS_INC(x) STATS_INC(x)
+#define IGMP_STATS_DISPLAY() stats_display_igmp(&lwip_stats.igmp)
+#else
+#define IGMP_STATS_INC(x)
+#define IGMP_STATS_DISPLAY()
+#endif
+
+#if IP_STATS
+#define IP_STATS_INC(x) STATS_INC(x)
+#define IP_STATS_DISPLAY() stats_display_proto(&lwip_stats.ip, "IP")
+#else
+#define IP_STATS_INC(x)
+#define IP_STATS_DISPLAY()
+#endif
+
+#if IPFRAG_STATS
+#define IPFRAG_STATS_INC(x) STATS_INC(x)
+#define IPFRAG_STATS_DISPLAY() stats_display_proto(&lwip_stats.ip_frag, "IP_FRAG")
+#else
+#define IPFRAG_STATS_INC(x)
+#define IPFRAG_STATS_DISPLAY()
+#endif
+
+#if ETHARP_STATS
+#define ETHARP_STATS_INC(x) STATS_INC(x)
+#define ETHARP_STATS_DISPLAY() stats_display_proto(&lwip_stats.etharp, "ETHARP")
+#else
+#define ETHARP_STATS_INC(x)
+#define ETHARP_STATS_DISPLAY()
+#endif
+
+#if LINK_STATS
+#define LINK_STATS_INC(x) STATS_INC(x)
+#define LINK_STATS_DISPLAY() stats_display_proto(&lwip_stats.link, "LINK")
+#else
+#define LINK_STATS_INC(x)
+#define LINK_STATS_DISPLAY()
+#endif
+
+#if MEM_STATS
+#define MEM_STATS_AVAIL(x, y) lwip_stats.mem.x = y
+#define MEM_STATS_INC(x) STATS_INC(mem.x)
+#define MEM_STATS_INC_USED(x, y) do { lwip_stats.mem.used += y; \
+                                    if (lwip_stats.mem.max < lwip_stats.mem.used) { \
+                                        lwip_stats.mem.max = lwip_stats.mem.used; \
+                                    } \
+                                 } while(0)
+#define MEM_STATS_DEC_USED(x, y) lwip_stats.mem.x -= y
+#define MEM_STATS_DISPLAY() stats_display_mem(&lwip_stats.mem, "HEAP")
+#else
+#define MEM_STATS_AVAIL(x, y)
+#define MEM_STATS_INC(x)
+#define MEM_STATS_INC_USED(x, y)
+#define MEM_STATS_DEC_USED(x, y)
+#define MEM_STATS_DISPLAY()
+#endif
+
+#if MEMP_STATS
+#define MEMP_STATS_AVAIL(x, i, y) lwip_stats.memp[i].x = y
+#define MEMP_STATS_INC(x, i) STATS_INC(memp[i].x)
+#define MEMP_STATS_DEC(x, i) STATS_DEC(memp[i].x)
+#define MEMP_STATS_INC_USED(x, i) do { ++lwip_stats.memp[i].used; \
+                                    if (lwip_stats.memp[i].max < lwip_stats.memp[i].used) { \
+                                        lwip_stats.memp[i].max = lwip_stats.memp[i].used; \
+                                    } \
+                                 } while(0)
+#define MEMP_STATS_DISPLAY(i) stats_display_memp(&lwip_stats.memp[i], i)
+#else
+#define MEMP_STATS_AVAIL(x, i, y)
+#define MEMP_STATS_INC(x, i)
+#define MEMP_STATS_DEC(x, i)
+#define MEMP_STATS_INC_USED(x, i)
+#define MEMP_STATS_DISPLAY(i)
+#endif
+
+#if SYS_STATS
+#define SYS_STATS_INC(x) STATS_INC(sys.x)
+#define SYS_STATS_DEC(x) STATS_DEC(sys.x)
+#define SYS_STATS_DISPLAY() stats_display_sys(&lwip_stats.sys)
+#else
+#define SYS_STATS_INC(x)
+#define SYS_STATS_DEC(x)
+#define SYS_STATS_DISPLAY()
+#endif
+
+/* Display of statistics */
+#if LWIP_STATS_DISPLAY
+    void stats_display(void);
+    void stats_display_proto(struct stats_proto *proto, char *name);
+    void stats_display_igmp(struct stats_igmp *igmp);
+    void stats_display_mem(struct stats_mem *mem, char *name);
+    void stats_display_memp(struct stats_mem *mem, int index);
+    void stats_display_sys(struct stats_sys *sys);
+#else
+#define stats_display()
+#define stats_display_proto(proto, name)
+#define stats_display_igmp(igmp)
+#define stats_display_mem(mem, name)
+#define stats_display_memp(mem, index)
+#define stats_display_sys(sys)
+#endif                          /* LWIP_STATS_DISPLAY */
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* __LWIP_STATS_H__ */
diff --git a/lib/lwip/src/include/lwip/sys.h b/lib/lwip/src/include/lwip/sys.h
new file mode 100644
index 0000000..28a6a51
--- /dev/null
+++ b/lib/lwip/src/include/lwip/sys.h
@@ -0,0 +1,250 @@
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved. 
+ * 
+ * Redistribution and use in source and binary forms, with or without modification, 
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission. 
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ * 
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef __LWIP_SYS_H__
+#define __LWIP_SYS_H__
+
+#include "lwip/opt.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if NO_SYS
+
+/* For a totally minimal and standalone system, we provide null
+   definitions of the sys_ functions. */
+    typedef u8_t sys_sem_t;
+    typedef u8_t sys_mbox_t;
+    struct sys_timeo {
+        u8_t dummy;
+    };
+
+#define sys_init()
+#define sys_timeout(m,h,a)
+#define sys_untimeout(m,a)
+#define sys_sem_new(c) c
+#define sys_sem_signal(s)
+#define sys_sem_wait(s)
+#define sys_sem_wait_timeout(s,t)
+#define sys_arch_sem_wait(s,t)
+#define sys_sem_free(s)
+#define sys_mbox_new(s) 0
+#define sys_mbox_fetch(m,d)
+#define sys_mbox_tryfetch(m,d)
+#define sys_mbox_post(m,d)
+#define sys_mbox_trypost(m,d)
+#define sys_mbox_free(m)
+
+#define sys_thread_new(n,t,a,s,p)
+
+#else                           /* NO_SYS */
+
+/** Return code for timeouts from sys_arch_mbox_fetch and sys_arch_sem_wait */
+#define SYS_ARCH_TIMEOUT 0xffffffffUL
+
+/* sys_mbox_tryfetch returns SYS_MBOX_EMPTY if appropriate.
+ * For now we use the same magic value, but we allow this to change in future.
+ */
+#define SYS_MBOX_EMPTY SYS_ARCH_TIMEOUT
+
+#include "lwip/err.h"
+#include "arch/sys_arch.h"
+
+    typedef void (*sys_timeout_handler) (void *arg);
+
+    struct sys_timeo {
+        struct sys_timeo *next;
+        u32_t time;
+        sys_timeout_handler h;
+        void *arg;
+    };
+
+    struct sys_timeouts {
+        struct sys_timeo *next;
+    };
+
+/* sys_init() must be called before anthing else. */
+    void sys_init(void);
+
+/*
+ * sys_timeout():
+ *
+ * Schedule a timeout a specified amount of milliseconds in the
+ * future. When the timeout occurs, the specified timeout handler will
+ * be called. The handler will be passed the "arg" argument when
+ * called.
+ *
+ */
+    void sys_timeout(u32_t msecs, sys_timeout_handler h, void *arg);
+    void sys_untimeout(sys_timeout_handler h, void *arg);
+    struct sys_timeouts *sys_arch_timeouts(void);
+
+/* Semaphore functions. */
+    sys_sem_t sys_sem_new(u8_t count);
+    void sys_sem_signal(sys_sem_t sem);
+    u32_t sys_arch_sem_wait(sys_sem_t sem, u32_t timeout);
+    void sys_sem_free(sys_sem_t sem);
+    void sys_sem_wait(sys_sem_t sem);
+    int sys_sem_wait_timeout(sys_sem_t sem, u32_t timeout);
+
+/* Time functions. */
+#ifndef sys_msleep
+    void sys_msleep(u32_t ms);  /* only has a (close to) 1 jiffy resolution. */
+#endif
+#ifndef sys_jiffies
+    u32_t sys_jiffies(void);    /* since power up. */
+#endif
+
+/* Mailbox functions. */
+    sys_mbox_t sys_mbox_new(int size);
+    void sys_mbox_post(sys_mbox_t mbox, void *msg);
+    err_t sys_mbox_trypost(sys_mbox_t mbox, void *msg);
+    u32_t sys_arch_mbox_fetch(sys_mbox_t mbox, void **msg, u32_t timeout);
+#ifndef sys_arch_mbox_tryfetch  /* Allow port to override with a macro */
+    u32_t sys_arch_mbox_tryfetch(sys_mbox_t mbox, void **msg);
+#endif
+/* For now, we map straight to sys_arch implementation. */
+#define sys_mbox_tryfetch(mbox, msg) sys_arch_mbox_tryfetch(mbox, msg)
+    void sys_mbox_free(sys_mbox_t mbox);
+    void sys_mbox_fetch(sys_mbox_t mbox, void **msg);
+
+/* Thread functions. */
+    sys_thread_t sys_thread_new(char *name, void (*thread) (void *arg),
+                                void *arg, int stacksize, int prio);
+
+#endif                          /* NO_SYS */
+
+/** Returns the current time in milliseconds. */
+    u32_t sys_now(void);
+
+/* Critical Region Protection */
+/* These functions must be implemented in the sys_arch.c file.
+   In some implementations they can provide a more light-weight protection
+   mechanism than using semaphores. Otherwise semaphores can be used for
+   implementation */
+#ifndef SYS_ARCH_PROTECT
+/** SYS_LIGHTWEIGHT_PROT
+ * define SYS_LIGHTWEIGHT_PROT in lwipopts.h if you want inter-task protection
+ * for certain critical regions during buffer allocation, deallocation and memory
+ * allocation and deallocation.
+ */
+#if SYS_LIGHTWEIGHT_PROT
+
+/** SYS_ARCH_DECL_PROTECT
+ * declare a protection variable. This macro will default to defining a variable of
+ * type sys_prot_t. If a particular port needs a different implementation, then
+ * this macro may be defined in sys_arch.h.
+ */
+#define SYS_ARCH_DECL_PROTECT(lev) sys_prot_t lev
+/** SYS_ARCH_PROTECT
+ * Perform a "fast" protect. This could be implemented by
+ * disabling interrupts for an embedded system or by using a semaphore or
+ * mutex. The implementation should allow calling SYS_ARCH_PROTECT when
+ * already protected. The old protection level is returned in the variable
+ * "lev". This macro will default to calling the sys_arch_protect() function
+ * which should be implemented in sys_arch.c. If a particular port needs a
+ * different implementation, then this macro may be defined in sys_arch.h
+ */
+#define SYS_ARCH_PROTECT(lev) lev = sys_arch_protect()
+/** SYS_ARCH_UNPROTECT
+ * Perform a "fast" set of the protection level to "lev". This could be
+ * implemented by setting the interrupt level to "lev" within the MACRO or by
+ * using a semaphore or mutex.  This macro will default to calling the
+ * sys_arch_unprotect() function which should be implemented in
+ * sys_arch.c. If a particular port needs a different implementation, then
+ * this macro may be defined in sys_arch.h
+ */
+#define SYS_ARCH_UNPROTECT(lev) sys_arch_unprotect(lev)
+    sys_prot_t sys_arch_protect(void);
+    void sys_arch_unprotect(sys_prot_t pval);
+
+#else
+
+#define SYS_ARCH_DECL_PROTECT(lev)
+#define SYS_ARCH_PROTECT(lev)
+#define SYS_ARCH_UNPROTECT(lev)
+
+#endif                          /* SYS_LIGHTWEIGHT_PROT */
+
+#endif                          /* SYS_ARCH_PROTECT */
+
+/*
+ * Macros to set/get and increase/decrease variables in a thread-safe way.
+ * Use these for accessing variable that are used from more than one thread.
+ */
+
+#ifndef SYS_ARCH_INC
+#define SYS_ARCH_INC(var, val) do { \
+                                SYS_ARCH_DECL_PROTECT(old_level); \
+                                SYS_ARCH_PROTECT(old_level); \
+                                var += val; \
+                                SYS_ARCH_UNPROTECT(old_level); \
+                              } while(0)
+#endif                          /* SYS_ARCH_INC */
+
+#ifndef SYS_ARCH_DEC
+#define SYS_ARCH_DEC(var, val) do { \
+                                SYS_ARCH_DECL_PROTECT(old_level); \
+                                SYS_ARCH_PROTECT(old_level); \
+                                var -= val; \
+                                SYS_ARCH_UNPROTECT(old_level); \
+                              } while(0)
+#endif                          /* SYS_ARCH_DEC */
+
+#ifndef SYS_ARCH_GET
+#define SYS_ARCH_GET(var, ret) do { \
+                                SYS_ARCH_DECL_PROTECT(old_level); \
+                                SYS_ARCH_PROTECT(old_level); \
+                                ret = var; \
+                                SYS_ARCH_UNPROTECT(old_level); \
+                              } while(0)
+#endif                          /* SYS_ARCH_GET */
+
+#ifndef SYS_ARCH_SET
+#define SYS_ARCH_SET(var, val) do { \
+                                SYS_ARCH_DECL_PROTECT(old_level); \
+                                SYS_ARCH_PROTECT(old_level); \
+                                var = val; \
+                                SYS_ARCH_UNPROTECT(old_level); \
+                              } while(0)
+#endif                          /* SYS_ARCH_SET */
+
+
+#ifdef __cplusplus
+}
+#endif
+extern struct thread_mutex *lwip_mutex;
+
+void lwip_mutex_lock(void);
+void lwip_mutex_unlock(void);
+
+#endif                          /* __LWIP_SYS_H__ */
diff --git a/lib/lwip/src/include/lwip/tcp.h b/lib/lwip/src/include/lwip/tcp.h
new file mode 100644
index 0000000..bf4bdca
--- /dev/null
+++ b/lib/lwip/src/include/lwip/tcp.h
@@ -0,0 +1,695 @@
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved. 
+ * 
+ * Redistribution and use in source and binary forms, with or without modification, 
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission. 
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ * 
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef __LWIP_TCP_H__
+#define __LWIP_TCP_H__
+
+#include "lwip/opt.h"
+
+#if LWIP_TCP                    /* don't build if not configured for use in lwipopts.h */
+
+#include "lwip/sys.h"
+#include "lwip/mem.h"
+#include "lwip/pbuf.h"
+#include "lwip/ip.h"
+#include "lwip/icmp.h"
+#include "lwip/err.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+    struct tcp_pcb;
+
+/* Functions for interfacing with TCP: */
+
+/* Lower layer interface to TCP: */
+#define tcp_init()              /* Compatibility define, not init needed. */
+    void tcp_tmr(void);         /* Must be called every
+                                   TCP_TMR_INTERVAL
+                                   ms. (Typically 250 ms). */
+/* Application program's interface: */
+    struct tcp_pcb *tcp_new(void);
+    struct tcp_pcb *tcp_alloc(u8_t prio);
+
+    void tcp_arg(struct tcp_pcb *pcb, void *arg);
+    void tcp_accept(struct tcp_pcb *pcb,
+                    err_t(*accept) (void *arg, struct tcp_pcb * newpcb,
+                                    err_t err));
+    void tcp_recv(struct tcp_pcb *pcb,
+                  err_t(*recv) (void *arg, struct tcp_pcb * tpcb,
+                                struct pbuf * p, err_t err));
+    void tcp_sent(struct tcp_pcb *pcb,
+                  err_t(*sent) (void *arg, struct tcp_pcb * tpcb, u16_t len));
+    void tcp_poll(struct tcp_pcb *pcb,
+                  err_t(*poll) (void *arg, struct tcp_pcb * tpcb),
+                  u8_t interval);
+    void tcp_err(struct tcp_pcb *pcb, void (*err) (void *arg, err_t err));
+
+#define          tcp_mss(pcb)      ((pcb)->mss)
+#define          tcp_sndbuf(pcb)   ((pcb)->snd_buf)
+
+#if TCP_LISTEN_BACKLOG
+#define          tcp_accepted(pcb) (((struct tcp_pcb_listen *)(pcb))->accepts_pending--)
+#else                           /* TCP_LISTEN_BACKLOG */
+#define          tcp_accepted(pcb)
+#endif                          /* TCP_LISTEN_BACKLOG */
+
+    void tcp_recved(struct tcp_pcb *pcb, u16_t len);
+    err_t tcp_bind(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port);
+    err_t tcp_redirect(struct tcp_pcb *pcb,
+                       struct ip_addr *local_ip,
+                       u16_t local_port,
+                       struct ip_addr *remote_ip, u16_t remote_port);
+     err_t
+      tcp_pause(struct tcp_pcb *pcb, struct ip_addr *local_ip, u16_t local_port,
+                struct ip_addr *remote_ip, u16_t remote_port);
+    err_t tcp_connect(struct tcp_pcb *pcb, struct ip_addr *ipaddr,
+                      u16_t port, err_t(*connected) (void *arg,
+                                                     struct tcp_pcb * tpcb,
+                                                     err_t err));
+
+    struct tcp_pcb *tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog);
+#define          tcp_listen(pcb) tcp_listen_with_backlog(pcb, TCP_DEFAULT_LISTEN_BACKLOG)
+
+    void tcp_abandon(struct tcp_pcb *pcb, int reset);
+#define          tcp_abort(pcb) tcp_abandon((pcb), 1)
+    err_t tcp_close(struct tcp_pcb *pcb);
+
+/* Flags for "apiflags" parameter in tcp_write and tcp_enqueue */
+#define TCP_WRITE_FLAG_COPY 0x01
+#define TCP_WRITE_FLAG_MORE 0x02
+
+    err_t tcp_write(struct tcp_pcb *pcb, const void *dataptr, u16_t len,
+                    u8_t apiflags);
+
+    void tcp_setprio(struct tcp_pcb *pcb, u8_t prio);
+
+#define TCP_PRIO_MIN    1
+#define TCP_PRIO_NORMAL 64
+#define TCP_PRIO_MAX    127
+
+/* It is also possible to call these two functions at the right
+   intervals (instead of calling tcp_tmr()). */
+    void tcp_slowtmr(void);
+    void tcp_fasttmr(void);
+
+
+/* Only used by IP to pass a TCP segment to TCP: */
+    void tcp_input(struct pbuf *p, struct netif *inp);
+/* Used within the TCP code only: */
+    err_t tcp_output(struct tcp_pcb *pcb);
+    void tcp_rexmit(struct tcp_pcb *pcb);
+    void tcp_rexmit_rto(struct tcp_pcb *pcb);
+    u32_t tcp_update_rcv_ann_wnd(struct tcp_pcb *pcb);
+
+/**
+ * This is the Nagle algorithm: try to combine user data to send as few TCP
+ * segments as possible. Only send if
+ * - no previously transmitted data on the connection remains unacknowledged or
+ * - the TF_NODELAY flag is set (nagle algorithm turned off for this pcb) or
+ * - the only unsent segment is at least pcb->mss bytes long (or there is more
+ *   than one unsent segment - with lwIP, this can happen although unsent->len < mss)
+ */
+#define tcp_do_output_nagle(tpcb) ((((tpcb)->unacked == NULL) || \
+                            ((tpcb)->flags & TF_NODELAY) || \
+                            (((tpcb)->unsent != NULL) && (((tpcb)->unsent->next != NULL) || \
+                              ((tpcb)->unsent->len >= (tpcb)->mss))) \
+                            ) ? 1 : 0)
+#define tcp_output_nagle(tpcb) (tcp_do_output_nagle(tpcb) ? tcp_output(tpcb) : ERR_OK)
+
+
+#define TCP_SEQ_LT(a,b)     ((s32_t)((a)-(b)) < 0)
+#define TCP_SEQ_LEQ(a,b)    ((s32_t)((a)-(b)) <= 0)
+#define TCP_SEQ_GT(a,b)     ((s32_t)((a)-(b)) > 0)
+#define TCP_SEQ_GEQ(a,b)    ((s32_t)((a)-(b)) >= 0)
+/* is b<=a<=c? */
+#if 0                           /* see bug #10548 */
+#define TCP_SEQ_BETWEEN(a,b,c) ((c)-(b) >= (a)-(b))
+#endif
+#define TCP_SEQ_BETWEEN(a,b,c) (TCP_SEQ_GEQ(a,b) && TCP_SEQ_LEQ(a,c))
+#define TCP_FIN 0x01U
+#define TCP_SYN 0x02U
+#define TCP_RST 0x04U
+#define TCP_PSH 0x08U
+#define TCP_ACK 0x10U
+#define TCP_URG 0x20U
+#define TCP_ECE 0x40U
+#define TCP_CWR 0x80U
+
+#define TCP_FLAGS 0x3fU
+
+/* Length of the TCP header, excluding options. */
+#define TCP_HLEN 20
+
+#ifndef TCP_TMR_INTERVAL
+#define TCP_TMR_INTERVAL       250      /* The TCP timer interval in milliseconds. */
+#endif                          /* TCP_TMR_INTERVAL */
+
+#ifndef TCP_FAST_INTERVAL
+#define TCP_FAST_INTERVAL      TCP_TMR_INTERVAL /* the fine grained timeout in milliseconds */
+#endif                          /* TCP_FAST_INTERVAL */
+
+#ifndef TCP_SLOW_INTERVAL
+#define TCP_SLOW_INTERVAL      (2*TCP_TMR_INTERVAL)     /* the coarse grained timeout in milliseconds */
+#endif                          /* TCP_SLOW_INTERVAL */
+
+#define TCP_FIN_WAIT_TIMEOUT 20000      /* milliseconds */
+#define TCP_SYN_RCVD_TIMEOUT 20000      /* milliseconds */
+
+#define TCP_OOSEQ_TIMEOUT        6U     /* x RTO */
+
+#ifndef TCP_MSL
+#define TCP_MSL 60000UL         /* The maximum segment lifetime in milliseconds */
+#endif
+
+/* Keepalive values, compliant with RFC 1122. Don't change this unless you know what you're doing */
+#ifndef  TCP_KEEPIDLE_DEFAULT
+#define  TCP_KEEPIDLE_DEFAULT     7200000UL     /* Default KEEPALIVE timer in milliseconds */
+#endif
+
+#ifndef  TCP_KEEPINTVL_DEFAULT
+#define  TCP_KEEPINTVL_DEFAULT    75000UL       /* Default Time between KEEPALIVE probes in milliseconds */
+#endif
+
+#ifndef  TCP_KEEPCNT_DEFAULT
+#define  TCP_KEEPCNT_DEFAULT      9U    /* Default Counter for KEEPALIVE probes */
+#endif
+
+#define  TCP_MAXIDLE              TCP_KEEPCNT_DEFAULT * TCP_KEEPINTVL_DEFAULT   /* Maximum KEEPALIVE probe time */
+
+/* Fields are (of course) in network byte order.
+ * Some fields are converted to host byte order in tcp_input().
+ */
+#ifdef PACK_STRUCT_USE_INCLUDES
+#include "arch/bpstruct.h"
+#endif
+     PACK_STRUCT_BEGIN struct tcp_hdr {
+        PACK_STRUCT_FIELD(u16_t src);
+        PACK_STRUCT_FIELD(u16_t dest);
+        PACK_STRUCT_FIELD(u32_t seqno);
+        PACK_STRUCT_FIELD(u32_t ackno);
+        PACK_STRUCT_FIELD(u16_t _hdrlen_rsvd_flags);
+        PACK_STRUCT_FIELD(u16_t wnd);
+        PACK_STRUCT_FIELD(u16_t chksum);
+        PACK_STRUCT_FIELD(u16_t urgp);
+    } PACK_STRUCT_STRUCT;
+     PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#include "arch/epstruct.h"
+#endif
+#define TCPH_OFFSET(phdr) (ntohs((phdr)->_hdrlen_rsvd_flags) >> 8)
+#define TCPH_HDRLEN(phdr) (ntohs((phdr)->_hdrlen_rsvd_flags) >> 12)
+#define TCPH_FLAGS(phdr)  (ntohs((phdr)->_hdrlen_rsvd_flags) & TCP_FLAGS)
+#define TCPH_OFFSET_SET(phdr, offset) (phdr)->_hdrlen_rsvd_flags = htons(((offset) << 8) | TCPH_FLAGS(phdr))
+#define TCPH_HDRLEN_SET(phdr, len) (phdr)->_hdrlen_rsvd_flags = htons(((len) << 12) | TCPH_FLAGS(phdr))
+#define TCPH_FLAGS_SET(phdr, flags) (phdr)->_hdrlen_rsvd_flags = htons((ntohs((phdr)->_hdrlen_rsvd_flags) & ~TCP_FLAGS) | (flags))
+#define TCPH_SET_FLAG(phdr, flags ) (phdr)->_hdrlen_rsvd_flags = htons(ntohs((phdr)->_hdrlen_rsvd_flags) | (flags))
+#define TCPH_UNSET_FLAG(phdr, flags) (phdr)->_hdrlen_rsvd_flags = htons(ntohs((phdr)->_hdrlen_rsvd_flags) | (TCPH_FLAGS(phdr) & ~(flags)) )
+#define TCP_TCPLEN(seg) ((seg)->len + ((TCPH_FLAGS((seg)->tcphdr) & TCP_FIN || \
+          TCPH_FLAGS((seg)->tcphdr) & TCP_SYN)? 1: 0))
+      enum tcp_state {
+        CLOSED = 0,
+        LISTEN = 1,
+        SYN_SENT = 2,
+        SYN_RCVD = 3,
+        ESTABLISHED = 4,
+        FIN_WAIT_1 = 5,
+        FIN_WAIT_2 = 6,
+        CLOSE_WAIT = 7,
+        CLOSING = 8,
+        LAST_ACK = 9,
+        TIME_WAIT = 10
+    };
+
+/** Flags used on input processing, not on pcb->flags
+*/
+#define TF_RESET     (u8_t)0x08U        /* Connection was reset. */
+#define TF_CLOSED    (u8_t)0x10U        /* Connection was sucessfully closed. */
+#define TF_GOT_FIN   (u8_t)0x20U        /* Connection was closed by the remote end. */
+
+
+#if LWIP_CALLBACK_API
+    /* Function to call when a listener has been connected.
+     * @param arg user-supplied argument (tcp_pcb.callback_arg)
+     * @param pcb a new tcp_pcb that now is connected
+     * @param err an error argument (TODO: that is current always ERR_OK?)
+     * @return ERR_OK: accept the new connection,
+     *                 any other err_t abortsthe new connection
+     */
+#define DEF_ACCEPT_CALLBACK  err_t (* accept)(void *arg, struct tcp_pcb *newpcb, err_t err)
+#else                           /* LWIP_CALLBACK_API */
+#define DEF_ACCEPT_CALLBACK
+#endif                          /* LWIP_CALLBACK_API */
+
+/**
+ * members common to struct tcp_pcb and struct tcp_listen_pcb
+ */
+#define TCP_PCB_COMMON(type) \
+  type *next; /* for the linked list */ \
+  enum tcp_state state; /* TCP state */ \
+  u8_t prio; \
+  void *callback_arg; \
+  /* ports are in host byte order */ \
+  u16_t local_port; \
+  /* the accept callback for listen- and normal pcbs, if LWIP_CALLBACK_API */ \
+  DEF_ACCEPT_CALLBACK
+
+
+/* the TCP protocol control block */
+    struct tcp_pcb {
+/** common PCB members */
+        IP_PCB;
+/** protocol specific PCB members */
+        TCP_PCB_COMMON(struct tcp_pcb);
+
+        /* ports are in host byte order */
+        u16_t remote_port;
+
+        u8_t flags;
+#define TF_ACK_DELAY   ((u8_t)0x01U)    /* Delayed ACK. */
+#define TF_ACK_NOW     ((u8_t)0x02U)    /* Immediate ACK. */
+#define TF_INFR        ((u8_t)0x04U)    /* In fast recovery. */
+#define TF_TIMESTAMP   ((u8_t)0x08U)    /* Timestamp option enabled */
+#define TF_FIN         ((u8_t)0x20U)    /* Connection was closed locally (FIN segment enqueued). */
+#define TF_NODELAY     ((u8_t)0x40U)    /* Disable Nagle algorithm */
+#define TF_NAGLEMEMERR ((u8_t)0x80U)    /* nagle enabled, memerr, try to output to prevent delayed ACK to happen */
+
+        /* the rest of the fields are in host byte order
+           as we have to do some math with them */
+        /* receiver variables */
+        u32_t rcv_nxt;          /* next seqno expected */
+        u16_t rcv_wnd;          /* receiver window available */
+        u16_t rcv_ann_wnd;      /* receiver window to announce */
+        u32_t rcv_ann_right_edge;       /* announced right edge of window */
+
+        /* Timers */
+        u32_t tmr;
+        u8_t polltmr, pollinterval;
+
+        /* Retransmission timer. */
+        s16_t rtime;
+
+        u16_t mss;              /* maximum segment size */
+
+        /* RTT (round trip time) estimation variables */
+        u32_t rttest;           /* RTT estimate in 500ms ticks */
+        u32_t rtseq;            /* sequence number being timed */
+        s16_t sa, sv;           /* @todo document this */
+
+        s16_t rto;              /* retransmission time-out */
+        u8_t nrtx;              /* number of retransmissions */
+
+        /* fast retransmit/recovery */
+        u32_t lastack;          /* Highest acknowledged seqno. */
+        u8_t dupacks;
+
+        /* congestion avoidance/control variables */
+        u16_t cwnd;
+        u16_t ssthresh;
+
+        /* sender variables */
+        u32_t snd_nxt;          /* next new seqno to be sent */
+        u16_t snd_wnd;          /* sender window */
+        u32_t snd_wl1, snd_wl2; /* Sequence and acknowledgement numbers of last
+                                   window update. */
+        u32_t snd_lbb;          /* Sequence number of next byte to be buffered. */
+
+        u16_t acked;
+
+        u16_t snd_buf;          /* Available buffer space for sending (in bytes). */
+#define TCP_SNDQUEUELEN_OVERFLOW (0xffff-3)
+        u16_t snd_queuelen;     /* Available buffer space for sending (in tcp_segs). */
+
+
+        /* These are ordered by sequence number: */
+        struct tcp_seg *unsent; /* Unsent (queued) segments. */
+        struct tcp_seg *unacked;        /* Sent but unacknowledged segments. */
+#if TCP_QUEUE_OOSEQ
+        struct tcp_seg *ooseq;  /* Received out of sequence segments. */
+#endif                          /* TCP_QUEUE_OOSEQ */
+
+        struct pbuf *refused_data;      /* Data previously received but not yet taken by upper layer */
+
+#if LWIP_CALLBACK_API
+        /* Function to be called when more send buffer space is available.
+         * @param arg user-supplied argument (tcp_pcb.callback_arg)
+         * @param pcb the tcp_pcb which has send buffer space available
+         * @param space the amount of bytes available
+         * @return ERR_OK: try to send some data by calling tcp_output
+         */
+         err_t(*sent) (void *arg, struct tcp_pcb * pcb, u16_t space);
+
+        /* Function to be called when (in-sequence) data has arrived.
+         * @param arg user-supplied argument (tcp_pcb.callback_arg)
+         * @param pcb the tcp_pcb for which data has arrived
+         * @param p the packet buffer which arrived
+         * @param err an error argument (TODO: that is current always ERR_OK?)
+         * @return ERR_OK: try to send some data by calling tcp_output
+         */
+         err_t(*recv) (void *arg, struct tcp_pcb * pcb, struct pbuf * p,
+                       err_t err);
+
+        /* Function to be called when a connection has been set up.
+         * @param arg user-supplied argument (tcp_pcb.callback_arg)
+         * @param pcb the tcp_pcb that now is connected
+         * @param err an error argument (TODO: that is current always ERR_OK?)
+         * @return value is currently ignored
+         */
+         err_t(*connected) (void *arg, struct tcp_pcb * pcb, err_t err);
+
+        /* Function which is called periodically.
+         * The period can be adjusted in multiples of the TCP slow timer interval
+         * by changing tcp_pcb.polltmr.
+         * @param arg user-supplied argument (tcp_pcb.callback_arg)
+         * @param pcb the tcp_pcb to poll for
+         * @return ERR_OK: try to send some data by calling tcp_output
+         */
+         err_t(*poll) (void *arg, struct tcp_pcb * pcb);
+
+        /* Function to be called whenever a fatal error occurs.
+         * There is no pcb parameter since most of the times, the pcb is
+         * already deallocated (or there is no pcb) when this function is called.
+         * @param arg user-supplied argument (tcp_pcb.callback_arg)
+         * @param err an indication why the error callback is called:
+         *            ERR_ABRT: aborted through tcp_abort or by a TCP timer
+         *            ERR_RST: the connection was reset by the remote host
+         */
+        void (*errf) (void *arg, err_t err);
+#endif                          /* LWIP_CALLBACK_API */
+
+#if LWIP_TCP_TIMESTAMPS
+        u32_t ts_lastacksent;
+        u32_t ts_recent;
+#endif                          /* LWIP_TCP_TIMESTAMPS */
+
+        /* idle time before KEEPALIVE is sent */
+        u32_t keep_idle;
+#if LWIP_TCP_KEEPALIVE
+        u32_t keep_intvl;
+        u32_t keep_cnt;
+#endif                          /* LWIP_TCP_KEEPALIVE */
+
+        /* Persist timer counter */
+        u32_t persist_cnt;
+        /* Persist timer back-off */
+        u8_t persist_backoff;
+
+        /* KEEPALIVE counter */
+        u8_t keep_cnt_sent;
+    };
+
+    struct tcp_pcb_listen {
+/* Common members of all PCB types */
+        IP_PCB;
+/* Protocol specific PCB members */
+        TCP_PCB_COMMON(struct tcp_pcb_listen);
+
+#if TCP_LISTEN_BACKLOG
+        u8_t backlog;
+        u8_t accepts_pending;
+#endif                          /* TCP_LISTEN_BACKLOG */
+    };
+
+#if LWIP_EVENT_API
+
+    enum lwip_event {
+        LWIP_EVENT_ACCEPT,
+        LWIP_EVENT_SENT,
+        LWIP_EVENT_RECV,
+        LWIP_EVENT_CONNECTED,
+        LWIP_EVENT_POLL,
+        LWIP_EVENT_ERR
+    };
+
+    err_t lwip_tcp_event(void *arg, struct tcp_pcb *pcb,
+                         enum lwip_event,
+                         struct pbuf *p, u16_t size, err_t err);
+
+#define TCP_EVENT_ACCEPT(pcb,err,ret)    ret = lwip_tcp_event((pcb)->callback_arg, (pcb),\
+                LWIP_EVENT_ACCEPT, NULL, 0, err)
+#define TCP_EVENT_SENT(pcb,space,ret) ret = lwip_tcp_event((pcb)->callback_arg, (pcb),\
+                   LWIP_EVENT_SENT, NULL, space, ERR_OK)
+#define TCP_EVENT_RECV(pcb,p,err,ret) ret = lwip_tcp_event((pcb)->callback_arg, (pcb),\
+                LWIP_EVENT_RECV, (p), 0, (err))
+#define TCP_EVENT_CONNECTED(pcb,err,ret) ret = lwip_tcp_event((pcb)->callback_arg, (pcb),\
+                LWIP_EVENT_CONNECTED, NULL, 0, (err))
+#define TCP_EVENT_POLL(pcb,ret)       ret = lwip_tcp_event((pcb)->callback_arg, (pcb),\
+                LWIP_EVENT_POLL, NULL, 0, ERR_OK)
+#define TCP_EVENT_ERR(errf,arg,err)  lwip_tcp_event((arg), NULL, \
+                LWIP_EVENT_ERR, NULL, 0, (err))
+#else                           /* LWIP_EVENT_API */
+
+#define TCP_EVENT_ACCEPT(pcb,err,ret)                          \
+  do {                                                         \
+    if((pcb)->accept != NULL)                                  \
+      (ret) = (pcb)->accept((pcb)->callback_arg,(pcb),(err));  \
+    else (ret) = ERR_OK;                                       \
+  } while (0)
+
+#define TCP_EVENT_SENT(pcb,space,ret)                          \
+  do {                                                         \
+    if((pcb)->sent != NULL)                                    \
+      (ret) = (pcb)->sent((pcb)->callback_arg,(pcb),(space));  \
+    else (ret) = ERR_OK;                                       \
+  } while (0)
+
+#define TCP_EVENT_RECV(pcb,p,err,ret)                           \
+  do {                                                          \
+    if((pcb)->recv != NULL) {                                   \
+      (ret) = (pcb)->recv((pcb)->callback_arg,(pcb),(p),(err)); \
+    } else {                                                    \
+      (ret) = ERR_OK;                                           \
+      if (p != NULL)                                            \
+        pbuf_free(p);                                           \
+    }                                                           \
+  } while (0)
+
+#define TCP_EVENT_CONNECTED(pcb,err,ret)                         \
+  do {                                                           \
+    if((pcb)->connected != NULL)                                 \
+      (ret) = (pcb)->connected((pcb)->callback_arg,(pcb),(err)); \
+    else (ret) = ERR_OK;                                         \
+  } while (0)
+
+#define TCP_EVENT_POLL(pcb,ret)                                \
+  do {                                                         \
+    if((pcb)->poll != NULL)                                    \
+      (ret) = (pcb)->poll((pcb)->callback_arg,(pcb));          \
+    else (ret) = ERR_OK;                                       \
+  } while (0)
+
+#define TCP_EVENT_ERR(errf,arg,err)                            \
+  do {                                                         \
+    if((errf) != NULL)                                         \
+      (errf)((arg),(err));                                     \
+  } while (0)
+
+#endif                          /* LWIP_EVENT_API */
+
+/* This structure represents a TCP segment on the unsent and unacked queues */
+    struct tcp_seg {
+        struct tcp_seg *next;   /* used when putting segements on a queue */
+        struct pbuf *p;         /* buffer containing data + TCP header */
+        void *dataptr;          /* pointer to the TCP data in the pbuf */
+        u16_t len;              /* the TCP length of this segment */
+        u8_t flags;
+#define TF_SEG_OPTS_MSS   (u8_t)0x01U   /* Include MSS option. */
+#define TF_SEG_OPTS_TS    (u8_t)0x02U   /* Include timestamp option. */
+        struct tcp_hdr *tcphdr; /* the TCP header */
+    };
+
+#define LWIP_TCP_OPT_LENGTH(flags)              \
+  (flags & TF_SEG_OPTS_MSS ? 4  : 0) +          \
+  (flags & TF_SEG_OPTS_TS  ? 12 : 0)
+
+/** This returns a TCP header option for MSS in an u32_t */
+#define TCP_BUILD_MSS_OPTION(x) (x) = htonl(((u32_t)2 << 24) |          \
+                                            ((u32_t)4 << 16) |          \
+                                            (((u32_t)TCP_MSS / 256) << 8) | \
+                                            (TCP_MSS & 255))
+
+/* Internal functions and global variables: */
+    struct tcp_pcb *tcp_pcb_copy(struct tcp_pcb *pcb);
+    void tcp_pcb_purge(struct tcp_pcb *pcb);
+    void tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb);
+
+    u8_t tcp_segs_free(struct tcp_seg *seg);
+    u8_t tcp_seg_free(struct tcp_seg *seg);
+    struct tcp_seg *tcp_seg_copy(struct tcp_seg *seg);
+
+#define tcp_ack(pcb)                               \
+  do {                                             \
+    if((pcb)->flags & TF_ACK_DELAY) {              \
+      (pcb)->flags &= ~TF_ACK_DELAY;               \
+      (pcb)->flags |= TF_ACK_NOW;                  \
+      tcp_output(pcb);                             \
+    }                                              \
+    else {                                         \
+      (pcb)->flags |= TF_ACK_DELAY;                \
+    }                                              \
+  } while (0)
+
+#define tcp_ack_now(pcb)                           \
+  do {                                             \
+    (pcb)->flags |= TF_ACK_NOW;                    \
+    tcp_output(pcb);                               \
+  } while (0)
+
+    err_t tcp_send_ctrl(struct tcp_pcb *pcb, u8_t flags);
+    err_t tcp_enqueue(struct tcp_pcb *pcb, void *dataptr, u16_t len,
+                      u8_t flags, u8_t apiflags, u8_t optflags);
+
+    void tcp_rexmit_seg(struct tcp_pcb *pcb, struct tcp_seg *seg);
+
+    void tcp_rst(u32_t seqno, u32_t ackno,
+                 struct ip_addr *local_ip, struct ip_addr *remote_ip,
+                 u16_t local_port, u16_t remote_port);
+
+    u32_t tcp_next_iss(void);
+
+    void tcp_keepalive(struct tcp_pcb *pcb);
+    void tcp_zero_window_probe(struct tcp_pcb *pcb);
+
+#if TCP_CALCULATE_EFF_SEND_MSS
+    u16_t tcp_eff_send_mss(u16_t sendmss, struct ip_addr *addr);
+#endif                          /* TCP_CALCULATE_EFF_SEND_MSS */
+
+    extern struct tcp_pcb *tcp_input_pcb;
+    extern u32_t tcp_ticks;
+
+#if TCP_DEBUG || TCP_INPUT_DEBUG || TCP_OUTPUT_DEBUG
+    void tcp_debug_print(struct tcp_hdr *tcphdr);
+    void tcp_debug_print_flags(u8_t flags);
+    void tcp_debug_print_state(enum tcp_state s);
+    void tcp_debug_print_pcbs(void);
+    s16_t tcp_pcbs_sane(void);
+#else
+#define tcp_debug_print(tcphdr)
+#define tcp_debug_print_flags(flags)
+#define tcp_debug_print_state(s)
+#define tcp_debug_print_pcbs()
+#define tcp_pcbs_sane() 1
+#endif                          /* TCP_DEBUG */
+
+#if NO_SYS
+#define tcp_timer_needed()
+#else
+    void tcp_timer_needed(void);
+#endif
+
+/* The TCP PCB lists. */
+    union tcp_listen_pcbs_t {   /* List of all TCP PCBs in LISTEN state. */
+        struct tcp_pcb_listen *listen_pcbs;
+        struct tcp_pcb *pcbs;
+    };
+    extern union tcp_listen_pcbs_t tcp_listen_pcbs;
+    extern struct tcp_pcb *tcp_active_pcbs;     /* List of all TCP PCBs that are in a
+                                                   state in which they accept or send
+                                                   data. */
+    extern struct tcp_pcb *tcp_tw_pcbs; /* List of all TCP PCBs in TIME-WAIT. */
+
+    extern struct tcp_pcb *tcp_tmp_pcb; /* Only used for temporary storage. */
+
+/* Axioms about the above lists:   
+   1) Every TCP PCB that is not CLOSED is in one of the lists.
+   2) A PCB is only in one of the lists.
+   3) All PCBs in the tcp_listen_pcbs list is in LISTEN state.
+   4) All PCBs in the tcp_tw_pcbs list is in TIME-WAIT state.
+*/
+
+/* Define two macros, TCP_REG and TCP_RMV that registers a TCP PCB
+   with a PCB list or removes a PCB from a list, respectively. */
+#if 0
+#define TCP_REG(pcbs, npcb) do {\
+                            LWIP_DEBUGF(TCP_DEBUG, ("TCP_REG %p local port %d\n", npcb, npcb->local_port)); \
+                            for(tcp_tmp_pcb = *pcbs; \
+          tcp_tmp_pcb != NULL; \
+        tcp_tmp_pcb = tcp_tmp_pcb->next) { \
+                                LWIP_ASSERT("TCP_REG: already registered\n", tcp_tmp_pcb != npcb); \
+                            } \
+                            LWIP_ASSERT("TCP_REG: pcb->state != CLOSED", npcb->state != CLOSED); \
+                            npcb->next = *pcbs; \
+                            LWIP_ASSERT("TCP_REG: npcb->next != npcb", npcb->next != npcb); \
+                            *(pcbs) = npcb; \
+                            LWIP_ASSERT("TCP_RMV: tcp_pcbs sane", tcp_pcbs_sane()); \
+              tcp_timer_needed(); \
+                            } while(0)
+#define TCP_RMV(pcbs, npcb) do { \
+                            LWIP_ASSERT("TCP_RMV: pcbs != NULL", *pcbs != NULL); \
+                            LWIP_DEBUGF(TCP_DEBUG, ("TCP_RMV: removing %p from %p\n", npcb, *pcbs)); \
+                            if(*pcbs == npcb) { \
+                               *pcbs = (*pcbs)->next; \
+                            } else for(tcp_tmp_pcb = *pcbs; tcp_tmp_pcb != NULL; tcp_tmp_pcb = tcp_tmp_pcb->next) { \
+                               if(tcp_tmp_pcb->next != NULL && tcp_tmp_pcb->next == npcb) { \
+                                  tcp_tmp_pcb->next = npcb->next; \
+                                  break; \
+                               } \
+                            } \
+                            npcb->next = NULL; \
+                            LWIP_ASSERT("TCP_RMV: tcp_pcbs sane", tcp_pcbs_sane()); \
+                            LWIP_DEBUGF(TCP_DEBUG, ("TCP_RMV: removed %p from %p\n", npcb, *pcbs)); \
+                            } while(0)
+
+#else                           /* LWIP_DEBUG */
+
+#define TCP_REG(pcbs, npcb)                        \
+  do {                                             \
+    npcb->next = *pcbs;                            \
+    *(pcbs) = npcb;                                \
+    tcp_timer_needed();                            \
+  } while (0)
+
+#define TCP_RMV(pcbs, npcb)                        \
+  do {                                             \
+    if(*(pcbs) == npcb) {                          \
+      (*(pcbs)) = (*pcbs)->next;                   \
+    }                                              \
+    else {                                         \
+      for(tcp_tmp_pcb = *pcbs;                                         \
+          tcp_tmp_pcb != NULL;                                         \
+          tcp_tmp_pcb = tcp_tmp_pcb->next) {                           \
+        if(tcp_tmp_pcb->next != NULL && tcp_tmp_pcb->next == npcb) {   \
+          tcp_tmp_pcb->next = npcb->next;          \
+          break;                                   \
+        }                                          \
+      }                                            \
+    }                                              \
+    npcb->next = NULL;                             \
+  } while(0)
+
+#endif                          /* LWIP_DEBUG */
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* LWIP_TCP */
+#endif                          /* __LWIP_TCP_H__ */
diff --git a/lib/lwip/src/include/lwip/tcpip.h b/lib/lwip/src/include/lwip/tcpip.h
new file mode 100644
index 0000000..acd6fbc
--- /dev/null
+++ b/lib/lwip/src/include/lwip/tcpip.h
@@ -0,0 +1,141 @@
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef __LWIP_TCPIP_H__
+#define __LWIP_TCPIP_H__
+
+#include "lwip/opt.h"
+
+#if !NO_SYS                     /* don't build if not configured for use in lwipopts.h */
+
+#include "lwip/api_msg.h"
+#include "lwip/netifapi.h"
+#include "lwip/pbuf.h"
+#include "lwip/api.h"
+#include "lwip/sys.h"
+#include "lwip/netif.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if LWIP_TCPIP_CORE_LOCKING
+/** The global semaphore to lock the stack. */
+    extern sys_sem_t lock_tcpip_core;
+#define LOCK_TCPIP_CORE()     sys_sem_wait(lock_tcpip_core)
+#define UNLOCK_TCPIP_CORE()   sys_sem_signal(lock_tcpip_core)
+#define TCPIP_APIMSG(m)       tcpip_apimsg_lock(m)
+#define TCPIP_APIMSG_ACK(m)
+#define TCPIP_NETIFAPI(m)     tcpip_netifapi_lock(m)
+#define TCPIP_NETIFAPI_ACK(m)
+#else
+#define LOCK_TCPIP_CORE()
+#define UNLOCK_TCPIP_CORE()
+#define TCPIP_APIMSG(m)       tcpip_apimsg(m)
+#define TCPIP_APIMSG_ACK(m)   sys_sem_signal(m->conn->op_completed)
+#define TCPIP_NETIFAPI(m)     tcpip_netifapi(m)
+#define TCPIP_NETIFAPI_ACK(m) sys_sem_signal(m->sem)
+#endif                          /* LWIP_TCPIP_CORE_LOCKING */
+
+    void tcpip_init(void (*tcpip_init_done) (void *),
+                    void *arg);
+
+#if LWIP_NETCONN
+    err_t tcpip_apimsg(struct api_msg *apimsg);
+#if LWIP_TCPIP_CORE_LOCKING
+    err_t tcpip_apimsg_lock(struct api_msg *apimsg);
+#endif                          /* LWIP_TCPIP_CORE_LOCKING */
+#endif                          /* LWIP_NETCONN */
+
+    err_t tcpip_input(struct pbuf *p, struct netif *inp);
+
+#if LWIP_NETIF_API
+    err_t tcpip_netifapi(struct netifapi_msg *netifapimsg);
+#if LWIP_TCPIP_CORE_LOCKING
+    err_t tcpip_netifapi_lock(struct netifapi_msg *netifapimsg);
+#endif                          /* LWIP_TCPIP_CORE_LOCKING */
+#endif                          /* LWIP_NETIF_API */
+
+    err_t tcpip_callback_with_block(void (*f) (void *ctx), void *ctx,
+                                    u8_t block);
+#define tcpip_callback(f, ctx)              tcpip_callback_with_block(f, ctx, 1)
+
+/* free pbufs or heap memory from another context without blocking */
+    err_t pbuf_free_callback(struct pbuf *p);
+    err_t mem_free_callback(void *m);
+
+    err_t tcpip_timeout(u32_t msecs, sys_timeout_handler h, void *arg);
+    err_t tcpip_untimeout(sys_timeout_handler h, void *arg);
+
+    enum tcpip_msg_type {
+#if LWIP_NETCONN
+        TCPIP_MSG_API,
+#endif                          /* LWIP_NETCONN */
+        TCPIP_MSG_INPKT,
+#if LWIP_NETIF_API
+        TCPIP_MSG_NETIFAPI,
+#endif                          /* LWIP_NETIF_API */
+        TCPIP_MSG_CALLBACK,
+        TCPIP_MSG_TIMEOUT,
+        TCPIP_MSG_UNTIMEOUT
+    };
+
+    struct tcpip_msg {
+        enum tcpip_msg_type type;
+        sys_sem_t *sem;
+        union {
+#if LWIP_NETCONN
+            struct api_msg *apimsg;
+#endif                          /* LWIP_NETCONN */
+#if LWIP_NETIF_API
+            struct netifapi_msg *netifapimsg;
+#endif                          /* LWIP_NETIF_API */
+            struct {
+                struct pbuf *p;
+                struct netif *netif;
+            } inp;
+            struct {
+                void (*f) (void *ctx);
+                void *ctx;
+            } cb;
+            struct {
+                u32_t msecs;
+                sys_timeout_handler h;
+                void *arg;
+            } tmo;
+        } msg;
+    };
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* !NO_SYS */
+#endif                          /* __LWIP_TCPIP_H__ */
diff --git a/lib/lwip/src/include/lwip/udp.h b/lib/lwip/src/include/lwip/udp.h
new file mode 100644
index 0000000..77b04c5
--- /dev/null
+++ b/lib/lwip/src/include/lwip/udp.h
@@ -0,0 +1,145 @@
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved. 
+ * 
+ * Redistribution and use in source and binary forms, with or without modification, 
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission. 
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ * 
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef __LWIP_UDP_H__
+#define __LWIP_UDP_H__
+
+#include "lwip/opt.h"
+
+#if LWIP_UDP                    /* don't build if not configured for use in lwipopts.h */
+
+#include "lwip/pbuf.h"
+#include "lwip/netif.h"
+#include "lwip/ip_addr.h"
+#include "lwip/ip.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define UDP_HLEN 8
+
+/* Fields are (of course) in network byte order. */
+#ifdef PACK_STRUCT_USE_INCLUDES
+#include "arch/bpstruct.h"
+#endif
+    PACK_STRUCT_BEGIN struct udp_hdr {
+        PACK_STRUCT_FIELD(u16_t src);
+        PACK_STRUCT_FIELD(u16_t dest);  /* src/dest UDP ports */
+        PACK_STRUCT_FIELD(u16_t len);
+        PACK_STRUCT_FIELD(u16_t chksum);
+    } PACK_STRUCT_STRUCT;
+     PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#include "arch/epstruct.h"
+#endif
+#define UDP_FLAGS_NOCHKSUM 0x01U
+#define UDP_FLAGS_UDPLITE  0x02U
+#define UDP_FLAGS_CONNECTED  0x04U
+      struct udp_pcb {
+/* Common members of all PCB types */
+        IP_PCB;
+
+/* Protocol specific PCB members */
+
+        struct udp_pcb *next;
+
+        u8_t flags;
+        /* ports are in host byte order */
+        u16_t local_port, remote_port;
+
+#if LWIP_IGMP
+        /* outgoing network interface for multicast packets */
+        struct ip_addr multicast_ip;
+#endif                          /* LWIP_IGMP */
+
+#if LWIP_UDPLITE
+        /* used for UDP_LITE only */
+        u16_t chksum_len_rx, chksum_len_tx;
+#endif                          /* LWIP_UDPLITE */
+
+        /* receive callback function
+         * addr and port are in same byte order as in the pcb
+         * The callback is responsible for freeing the pbuf
+         * if it's not used any more.
+         *
+         * @param arg user supplied argument (udp_pcb.recv_arg)
+         * @param pcb the udp_pcb which received data
+         * @param p the packet buffer that was received
+         * @param addr the remote IP address from which the packet was received
+         * @param port the remote port from which the packet was received
+         */
+        void (*recv) (void *arg, struct udp_pcb * pcb, struct pbuf * p,
+                      struct ip_addr * addr, u16_t port);
+        /* user-supplied argument for the recv callback */
+        void *recv_arg;
+    };
+/* udp_pcbs export for exernal reference (e.g. SNMP agent) */
+    extern struct udp_pcb *udp_pcbs;
+
+/* The following functions is the application layer interface to the
+   UDP code. */
+    struct udp_pcb *udp_new(void);
+    void udp_remove(struct udp_pcb *pcb);
+    err_t udp_bind(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port);
+    err_t udp_connect(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port);
+    void udp_disconnect(struct udp_pcb *pcb);
+    void udp_recv(struct udp_pcb *pcb,
+                  void (*recv) (void *arg, struct udp_pcb * upcb,
+                                struct pbuf * p,
+                                struct ip_addr * addr,
+                                u16_t port), void *recv_arg);
+    err_t udp_sendto_if(struct udp_pcb *pcb, struct pbuf *p,
+                        struct ip_addr *dst_ip, u16_t dst_port,
+                        struct netif *netif);
+    err_t udp_sendto(struct udp_pcb *pcb, struct pbuf *p,
+                     struct ip_addr *dst_ip, u16_t dst_port);
+    err_t udp_send(struct udp_pcb *pcb, struct pbuf *p);
+
+#define          udp_flags(pcb)  ((pcb)->flags)
+#define          udp_setflags(pcb, f)  ((pcb)->flags = (f))
+
+/* The following functions are the lower layer interface to UDP. */
+    void udp_input(struct pbuf *p, struct netif *inp);
+
+#define udp_init()              /* Compatibility define, not init needed. */
+
+#if UDP_DEBUG
+    void udp_debug_print(struct udp_hdr *udphdr);
+#else
+#define udp_debug_print(udphdr)
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* LWIP_UDP */
+#endif                          /* __LWIP_UDP_H__ */
diff --git a/lib/lwip/src/include/lwipopts.h b/lib/lwip/src/include/lwipopts.h
new file mode 100644
index 0000000..f34e082
--- /dev/null
+++ b/lib/lwip/src/include/lwipopts.h
@@ -0,0 +1,115 @@
+/**
+ * \file
+ * \brief lwIP configuration file for Barrelfish.
+ */
+
+/*
+ * Copyright (c) 2007, 2008, 2009, 2011, ETH Zurich.
+ * All rights reserved.
+ *
+ * This file is distributed under the terms in the attached LICENSE file.
+ * If you do not find this file, copies can be found by writing to:
+ * ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich. Attn: Systems Group.
+ */
+
+#ifndef LWIPOPTS_H
+#define LWIPOPTS_H
+
+#include <barrelfish/net_constants.h>
+/// Build DHCP client
+#define LWIP_DHCP               1
+
+/// Build DNS client
+#define LWIP_DNS		1
+
+/// Don't want lwip POSIX socket wrappers
+#define LWIP_POSIX_SOCKETS_IO_NAMES     0
+
+/// We do not want LWIP to provide POSIX errno
+#undef LWIP_PROVIDE_ERRNO
+
+/// Don't want socket functions overriden by lwIP. We provide our own.
+#define LWIP_COMPAT_SOCKETS     0
+
+/// Use malloc() from libc
+//#define MEM_LIBC_MALLOC         1
+
+/// We want to be informed about interface up/down
+#define LWIP_NETIF_STATUS_CALLBACK      1
+
+/// Don't do ARP lookup to test IP
+#define DHCP_DOES_ARP_CHECK     0
+
+/// Disable locks (we lock the whole stack)
+#define SYS_LIGHTWEIGHT_PROT    0
+
+
+/// Number of simultaneously active TCP connections
+#define MEMP_NUM_TCP_PCB        200
+//#define MEMP_NUM_TCP_PCB        512
+
+
+
+/// Number of TCP segments
+#define MEMP_NUM_TCP_SEG        512
+//#define MEMP_NUM_TCP_SEG        1024
+//#define MEMP_NUM_TCP_SEG            4096
+
+/// TCP window size
+#define TCP_WND                 11680
+
+/// TCP maximum segment size
+#define TCP_MSS                 1460
+
+/// TCP send buffer size
+#define TCP_SND_BUF             8192
+
+/// TCP send queue length (pbufs)
+#define TCP_SND_QUEUELEN       (16 * (TCP_SND_BUF/TCP_MSS))
+
+/// Enable debugging
+// #define LWIP_DEBUG              1
+
+/// Enable have loopif (localhost hostname translation)
+#define LWIP_HAVE_LOOPIF 1
+
+/* Place to control the LWIP debugging.
+ Enable debugging of these subsystems */
+
+#define ETHARP_DEBUG     LWIP_DBG_ON
+#define NETIF_DEBUG      LWIP_DBG_ON
+// #define PBUF_DEBUG       LWIP_DBG_ON
+#define DHCP_DEBUG       LWIP_DBG_ON
+#define UDP_DEBUG        LWIP_DBG_ON
+#define IP_DEBUG         LWIP_DBG_ON
+// #define TCP_DEBUG        LWIP_DBG_ON
+// #define TCPIP_DEBUG      LWIP_DBG_ON
+// #define TCP_INPUT_DEBUG  LWIP_DBG_ON
+// #define TCP_OUTPUT_DEBUG LWIP_DBG_ON
+#define SOCKETS_DEBUG    LWIP_DBG_ON
+
+#ifndef CHECKSUM_GEN_IP
+#define CHECKSUM_GEN_IP                 1
+#endif
+
+#ifndef CHECKSUM_GEN_UDP
+#define CHECKSUM_GEN_UDP                1
+#endif
+
+#ifndef CHECKSUM_GEN_TCP
+#define CHECKSUM_GEN_TCP                1
+#endif
+
+#ifndef CHECKSUM_CHECK_IP
+#define CHECKSUM_CHECK_IP               1
+#endif
+
+#ifndef CHECKSUM_CHECK_UDP
+#define CHECKSUM_CHECK_UDP              1
+#endif
+
+#ifndef CHECKSUM_CHECK_TCP
+#define CHECKSUM_CHECK_TCP              1
+#endif
+
+#endif
diff --git a/lib/lwip/src/include/netif/bfeth.h b/lib/lwip/src/include/netif/bfeth.h
new file mode 100644
index 0000000..8d030bc
--- /dev/null
+++ b/lib/lwip/src/include/netif/bfeth.h
@@ -0,0 +1,19 @@
+/*
+ * Copyright (c) 2007, 2008, 2009, ETH Zurich.
+ * All rights reserved.
+ *
+ * This file is distributed under the terms in the attached LICENSE file.
+ * If you do not find this file, copies can be found by writing to:
+ * ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich. Attn: Systems Group.
+ */
+
+#ifndef BFETH_H
+#define BFETH_H
+
+#include <lwip/netif.h>
+
+void bfeth_input(struct netif *netif, uint64_t pbuf_id, uint64_t paddr,
+        uint64_t len, uint64_t packet_len, struct pbuf *pp);
+err_t bfeth_init(struct netif *netif);
+
+#endif
diff --git a/lib/lwip/src/include/netif/e1000.h b/lib/lwip/src/include/netif/e1000.h
new file mode 100644
index 0000000..0a31562
--- /dev/null
+++ b/lib/lwip/src/include/netif/e1000.h
@@ -0,0 +1,35 @@
+/*
+ * Copyright (c) 2007, 2008, 2009, 2013, ETH Zurich.
+ * All rights reserved.
+ *
+ * This file is distributed under the terms in the attached LICENSE file.
+ * If you do not find this file, copies can be found by writing to:
+ * ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich. Attn: Systems Group.
+ */
+
+#ifndef E1000_H
+#define E1000_H
+
+#include <lwip/netif.h>
+#include <net_queue_manager/net_queue_manager.h>
+
+err_t ethernetif_init(struct netif *netif);
+void e1000n_polling_loop(struct waitset *ws);
+bool e1000n_queue_empty(void);
+int e1000n_driver_init(int argc, char **argv);
+
+void ethernetif_backend_init(char *service_name, uint64_t queueid,
+                             ether_get_mac_address_t get_mac_ptr,
+                             ether_terminate_queue terminate_queue_ptr,
+                             ether_transmit_pbuf_list_t transmit_ptr,
+                             ether_get_tx_free_slots tx_free_slots_ptr,
+                             ether_handle_free_TX_slot handle_free_tx_slot_ptr,
+                             size_t rx_bufsz,
+                             ether_rx_register_buffer rx_register_buffer_ptr,
+                             ether_rx_get_free_slots rx_get_free_slots_ptr);
+
+void lwip_arrakis_start(int *argc, char ***argv);
+
+void arranet_polling_loop(void);
+
+#endif
diff --git a/lib/lwip/src/include/netif/etharp.h b/lib/lwip/src/include/netif/etharp.h
new file mode 100644
index 0000000..6342c16
--- /dev/null
+++ b/lib/lwip/src/include/netif/etharp.h
@@ -0,0 +1,180 @@
+/*
+ * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
+ * Copyright (c) 2003-2004 Leon Woestenberg <leon.woestenberg@axon.tv>
+ * Copyright (c) 2003-2004 Axon Digital Design B.V., The Netherlands.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+
+#ifndef __NETIF_ETHARP_H__
+#define __NETIF_ETHARP_H__
+
+#include "lwip/opt.h"
+
+#if LWIP_ARP                    /* don't build if not configured for use in lwipopts.h */
+
+#include "lwip/pbuf.h"
+#include "lwip/ip_addr.h"
+#include "lwip/netif.h"
+#include "lwip/ip.h"
+#include <stdbool.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef ETH_PAD_SIZE
+#define ETH_PAD_SIZE          0
+#endif
+
+#ifndef ETHARP_HWADDR_LEN
+#define ETHARP_HWADDR_LEN     6
+#endif
+
+#ifdef PACK_STRUCT_USE_INCLUDES
+#include "arch/bpstruct.h"
+#endif
+    PACK_STRUCT_BEGIN struct eth_addr {
+        PACK_STRUCT_FIELD(u8_t addr[ETHARP_HWADDR_LEN]);
+    } PACK_STRUCT_STRUCT;
+     PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#include "arch/epstruct.h"
+#endif
+#ifdef PACK_STRUCT_USE_INCLUDES
+#include "arch/bpstruct.h"
+#endif
+     PACK_STRUCT_BEGIN struct eth_hdr {
+#if ETH_PAD_SIZE
+        PACK_STRUCT_FIELD(u8_t padding[ETH_PAD_SIZE]);
+#endif
+        PACK_STRUCT_FIELD(struct eth_addr dest);
+         PACK_STRUCT_FIELD(struct eth_addr src);
+         PACK_STRUCT_FIELD(u16_t type);
+    } PACK_STRUCT_STRUCT;
+     PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#include "arch/epstruct.h"
+#endif
+#ifdef PACK_STRUCT_USE_INCLUDES
+#include "arch/bpstruct.h"
+#endif
+     PACK_STRUCT_BEGIN
+/** the ARP message */
+      struct etharp_hdr {
+        PACK_STRUCT_FIELD(struct eth_hdr ethhdr);
+         PACK_STRUCT_FIELD(u16_t hwtype);
+         PACK_STRUCT_FIELD(u16_t proto);
+         PACK_STRUCT_FIELD(u16_t _hwlen_protolen);
+         PACK_STRUCT_FIELD(u16_t opcode);
+         PACK_STRUCT_FIELD(struct eth_addr shwaddr);
+         PACK_STRUCT_FIELD(struct ip_addr2 sipaddr);
+         PACK_STRUCT_FIELD(struct eth_addr dhwaddr);
+         PACK_STRUCT_FIELD(struct ip_addr2 dipaddr);
+    } PACK_STRUCT_STRUCT;
+     PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#include "arch/epstruct.h"
+#endif
+#ifdef PACK_STRUCT_USE_INCLUDES
+#include "arch/bpstruct.h"
+#endif
+     PACK_STRUCT_BEGIN struct ethip_hdr {
+        PACK_STRUCT_FIELD(struct eth_hdr eth);
+         PACK_STRUCT_FIELD(struct ip_hdr ip);
+    } PACK_STRUCT_STRUCT;
+     PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#include "arch/epstruct.h"
+#endif
+/** 5 seconds period */
+#define ARP_TMR_INTERVAL 5000
+#define ETHTYPE_ARP       0x0806
+#define ETHTYPE_IP        0x0800
+#define ETHTYPE_PPPOEDISC 0x8863        /* PPP Over Ethernet Discovery Stage */
+#define ETHTYPE_PPPOE     0x8864        /* PPP Over Ethernet Session Stage */
+/** ARP message types (opcodes) */
+#define ARP_REQUEST 1
+#define ARP_REPLY   2
+#if ARP_QUEUEING
+/** struct for queueing outgoing packets for unknown address
+  * defined here to be accessed by memp.h
+  */
+      struct etharp_q_entry {
+        struct etharp_q_entry *next;
+        struct pbuf *p;
+    };
+#endif                          /* ARP_QUEUEING */
+
+#define etharp_init()           /* Compatibility define, not init needed. */
+    void etharp_tmr(void);
+    s8_t etharp_find_addr(struct netif *netif, struct ip_addr *ipaddr,
+                          struct eth_addr **eth_ret, struct ip_addr **ip_ret);
+    void etharp_ip_input(struct netif *netif, struct pbuf *p);
+    void etharp_arp_input(struct netif *netif, struct eth_addr *ethaddr,
+                          struct pbuf *p);
+    err_t etharp_output(struct netif *netif, struct pbuf *q,
+                        struct ip_addr *ipaddr);
+    err_t etharp_query(struct netif *netif, struct ip_addr *ipaddr,
+                       struct pbuf *q);
+
+
+    struct eth_addr convert_uint64_to_eth_addr(uint64_t given_mac);
+    bool is_ip_present_in_arp_cache(struct ip_addr *ipaddr);
+    uint64_t find_ip_arp_cache(struct ip_addr *ipaddr);
+
+
+
+    err_t etharp_request(struct netif *netif, struct ip_addr *ipaddr);
+/** For Ethernet network interfaces, we might want to send "gratuitous ARP";
+ *  this is an ARP packet sent by a node in order to spontaneously cause other
+ *  nodes to update an entry in their ARP cache.
+ *  From RFC 3220 "IP Mobility Support for IPv4" section 4.6. */
+#define etharp_gratuitous(netif) etharp_request((netif), &(netif)->ip_addr)
+
+    err_t ethernet_input(struct pbuf *p, struct netif *netif);
+
+#if LWIP_AUTOIP
+    err_t etharp_raw(struct netif *netif, const struct eth_addr *ethsrc_addr,
+                     const struct eth_addr *ethdst_addr,
+                     const struct eth_addr *hwsrc_addr,
+                     const struct ip_addr *ipsrc_addr,
+                     const struct eth_addr *hwdst_addr,
+                     const struct ip_addr *ipdst_addr, const u16_t opcode);
+#endif                          /* LWIP_AUTOIP */
+
+#define eth_addr_cmp(addr1, addr2) (memcmp((addr1)->addr, (addr2)->addr, ETHARP_HWADDR_LEN) == 0)
+
+    extern const struct eth_addr ethbroadcast, ethzero;
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* LWIP_ARP */
+#endif                          /* __NETIF_ARP_H__ */
diff --git a/lib/lwip/src/include/netif/loopif.h b/lib/lwip/src/include/netif/loopif.h
new file mode 100644
index 0000000..5303592
--- /dev/null
+++ b/lib/lwip/src/include/netif/loopif.h
@@ -0,0 +1,52 @@
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved. 
+ * 
+ * Redistribution and use in source and binary forms, with or without modification, 
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission. 
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ * 
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef __NETIF_LOOPIF_H__
+#define __NETIF_LOOPIF_H__
+
+#include "lwip/opt.h"
+#include "lwip/netif.h"
+#include "lwip/err.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if !LWIP_NETIF_LOOPBACK_MULTITHREADING
+#define loopif_poll netif_poll
+#endif                          /* !LWIP_NETIF_LOOPBACK_MULTITHREADING */
+
+    err_t loopif_init(struct netif *netif);
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* __NETIF_LOOPIF_H__ */
diff --git a/lib/lwip/src/include/netif/slipif.h b/lib/lwip/src/include/netif/slipif.h
new file mode 100644
index 0000000..a764d87
--- /dev/null
+++ b/lib/lwip/src/include/netif/slipif.h
@@ -0,0 +1,48 @@
+/*
+ * Copyright (c) 2001, Swedish Institute of Computer Science.
+ * All rights reserved. 
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions 
+ * are met: 
+ * 1. Redistributions of source code must retain the above copyright 
+ *    notice, this list of conditions and the following disclaimer. 
+ * 2. Redistributions in binary form must reproduce the above copyright 
+ *    notice, this list of conditions and the following disclaimer in the 
+ *    documentation and/or other materials provided with the distribution. 
+ * 3. Neither the name of the Institute nor the names of its contributors 
+ *    may be used to endorse or promote products derived from this software 
+ *    without specific prior written permission. 
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND 
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE 
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS 
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY 
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
+ * SUCH DAMAGE. 
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ * 
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef __NETIF_SLIPIF_H__
+#define __NETIF_SLIPIF_H__
+
+#include "lwip/netif.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+    err_t slipif_init(struct netif *netif);
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/lib/newlib/newlib/libc/Hakefile b/lib/newlib/newlib/libc/Hakefile
index b6ed5cb..0cc1586 100644
--- a/lib/newlib/newlib/libc/Hakefile
+++ b/lib/newlib/newlib/libc/Hakefile
@@ -1,15 +1,4 @@
 if Config.libc == "newlib" then
-let
-    arch_srcs "x86_64"  = [ "machine/x86_64/" ++ x | x <- ["setjmp.S", "memcpy.S", "memset.S"]]
-    arch_srcs "x86_32"  = [ "machine/i386/" ++ x   | x <- ["setjmp.S", "memcpy.S", "memset.S"]]
-    arch_srcs "scc"     = [ "machine/i386/" ++ x   | x <- ["setjmp.S", "memcpy.S", "memset.S"]]
-    arch_srcs "armv5"   = [ "machine/arm/setjmp.S" ]
-    arch_srcs "arm11mp" = [ "machine/arm/setjmp.S" ]
-    arch_srcs "xscale"  = [ "machine/arm/setjmp.S" ]
-    arch_srcs "armv7"   = [ "machine/arm/setjmp.S" ]
-    arch_srcs "armv7-m" = [ "machine/arm/setjmp.S" ]
-    arch_srcs  x        = error ("Unknown architecture for newlib: " ++ x)
-in
 [ build library {
   target = "newc",
   addCFlags  = Config.newlibAddCFlags,
@@ -30,8 +19,9 @@ in
     , "reent"
     , "errno"
     , "misc"
-    , "sys" ],
-  cFiles = arch_srcs arch,
+    , "sys"
+    , "machine" -- put this last, so machine-specific symbols overwrite generic ones
+    ],
   architectures = [arch]
 } | arch <- allArchitectures ]
 else []
diff --git a/lib/newlib/newlib/libc/machine/Hakefile b/lib/newlib/newlib/libc/machine/Hakefile
new file mode 100644
index 0000000..483bfce
--- /dev/null
+++ b/lib/newlib/newlib/libc/machine/Hakefile
@@ -0,0 +1,23 @@
+if Config.libc == "newlib" then
+let
+    arch_srcs "x86_64"  = [ "x86_64/" ++ x | x <- ["setjmp.S", "memcpy.S", "memset.S"]]
+    arch_srcs "x86_32"  = [ "i386/" ++ x   | x <- ["setjmp.S", "memcpy.S", "memset.S"]]
+    arch_srcs "scc"     = [ "i386/" ++ x   | x <- ["setjmp.S", "memcpy.S", "memset.S"]]
+    arch_srcs "armv5"   = [ "arm/setjmp.S" ]
+    arch_srcs "arm11mp" = [ "arm/setjmp.S" ]
+    arch_srcs "xscale"  = [ "arm/setjmp.S" ]
+    arch_srcs "armv7"   = [ "arm/setjmp.S" ]
+    arch_srcs "armv7-m" = [ "arm/setjmp.S" ]
+    arch_srcs  x        = error ("Unknown architecture for newlib: " ++ x)
+in
+[ build library {
+  target = "machine",
+  addCFlags  = Config.newlibAddCFlags,
+  omitCFlags = [ "-Wmissing-prototypes",
+                 "-Wmissing-declarations",
+                 "-Wimplicit-function-declaration",
+                 "-Werror"],
+  assemblyFiles = arch_srcs arch,
+  architectures = [arch]
+} | arch <- allArchitectures ]
+else []
diff --git a/lib/newlib/newlib/libc/sys/barrelfish/syscalls.c b/lib/newlib/newlib/libc/sys/barrelfish/syscalls.c
index 980b7c7..576eccc 100644
--- a/lib/newlib/newlib/libc/sys/barrelfish/syscalls.c
+++ b/lib/newlib/newlib/libc/sys/barrelfish/syscalls.c
@@ -4,6 +4,7 @@
 #include <errno.h>
 #include <stdio.h>
 #include <stdlib.h>
+#include <assert.h>
 
 size_t (*_libc_terminal_read_func)(char *, size_t);
 size_t (*_libc_terminal_write_func)(const char *, size_t);
@@ -26,7 +27,22 @@ clock_t times(struct tms *buf)
   return -1;
 }
 
-void (*_libc_exit_func)(int);
+clock_t _times_r(struct _reent *r, struct tms *buf)
+{
+  return -1;
+}
+
+int _getpid_r(struct _reent *r)
+{
+    assert(!"NYI");
+}
+
+int _stat_r(struct _reent *r, const char *path, struct stat *buf)
+{
+    assert(!"NYI");
+}
+
+void (*_libc_exit_func)(int) __attribute__((noreturn));
 void _Exit(int status)
 {
     _libc_exit_func(status);
diff --git a/lib/oldc/src/fileno.c b/lib/oldc/src/fileno.c
index 00bdf97..ca02649 100644
--- a/lib/oldc/src/fileno.c
+++ b/lib/oldc/src/fileno.c
@@ -27,6 +27,7 @@ int fileno(FILE *f)
     struct fdtab_entry e = {
         .type = FDTAB_TYPE_FILE,
         .handle = f->handle,
+        .epoll_fd = -1,
     };
     return fdtab_search_alloc(&e);
 }
diff --git a/lib/pcre/pcre.h b/lib/pcre/pcre.h
deleted file mode 100644
index 42a109a..0000000
--- a/lib/pcre/pcre.h
+++ /dev/null
@@ -1,370 +0,0 @@
-/*************************************************
-*       Perl-Compatible Regular Expressions      *
-*************************************************/
-
-/* This is the public header file for the PCRE library, to be #included by
-applications that call the PCRE functions.
-
-           Copyright (c) 1997-2011 University of Cambridge
-
------------------------------------------------------------------------------
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-    * Redistributions of source code must retain the above copyright notice,
-      this list of conditions and the following disclaimer.
-
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-
-    * Neither the name of the University of Cambridge nor the names of its
-      contributors may be used to endorse or promote products derived from
-      this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
-LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGE.
------------------------------------------------------------------------------
-*/
-
-#ifndef _PCRE_H
-#define _PCRE_H
-
-/* The current PCRE version information. */
-
-#define PCRE_MAJOR          8
-#define PCRE_MINOR          20
-#define PCRE_PRERELEASE     
-#define PCRE_DATE           2011-10-21
-
-/* When an application links to a PCRE DLL in Windows, the symbols that are
-imported have to be identified as such. When building PCRE, the appropriate
-export setting is defined in pcre_internal.h, which includes this file. So we
-don't change existing definitions of PCRE_EXP_DECL and PCRECPP_EXP_DECL. */
-
-#if defined(_WIN32) && !defined(PCRE_STATIC)
-#  ifndef PCRE_EXP_DECL
-#    define PCRE_EXP_DECL  extern __declspec(dllimport)
-#  endif
-#  ifdef __cplusplus
-#    ifndef PCRECPP_EXP_DECL
-#      define PCRECPP_EXP_DECL  extern __declspec(dllimport)
-#    endif
-#    ifndef PCRECPP_EXP_DEFN
-#      define PCRECPP_EXP_DEFN  __declspec(dllimport)
-#    endif
-#  endif
-#endif
-
-/* By default, we use the standard "extern" declarations. */
-
-#ifndef PCRE_EXP_DECL
-#  ifdef __cplusplus
-#    define PCRE_EXP_DECL  extern "C"
-#  else
-#    define PCRE_EXP_DECL  extern
-#  endif
-#endif
-
-#ifdef __cplusplus
-#  ifndef PCRECPP_EXP_DECL
-#    define PCRECPP_EXP_DECL  extern
-#  endif
-#  ifndef PCRECPP_EXP_DEFN
-#    define PCRECPP_EXP_DEFN
-#  endif
-#endif
-
-/* Have to include stdlib.h in order to ensure that size_t is defined;
-it is needed here for malloc. */
-
-#include <stdlib.h>
-
-/* Allow for C++ users */
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* Options. Some are compile-time only, some are run-time only, and some are
-both, so we keep them all distinct. However, almost all the bits in the options
-word are now used. In the long run, we may have to re-use some of the
-compile-time only bits for runtime options, or vice versa. */
-
-#define PCRE_CASELESS           0x00000001  /* Compile */
-#define PCRE_MULTILINE          0x00000002  /* Compile */
-#define PCRE_DOTALL             0x00000004  /* Compile */
-#define PCRE_EXTENDED           0x00000008  /* Compile */
-#define PCRE_ANCHORED           0x00000010  /* Compile, exec, DFA exec */
-#define PCRE_DOLLAR_ENDONLY     0x00000020  /* Compile */
-#define PCRE_EXTRA              0x00000040  /* Compile */
-#define PCRE_NOTBOL             0x00000080  /* Exec, DFA exec */
-#define PCRE_NOTEOL             0x00000100  /* Exec, DFA exec */
-#define PCRE_UNGREEDY           0x00000200  /* Compile */
-#define PCRE_NOTEMPTY           0x00000400  /* Exec, DFA exec */
-#define PCRE_UTF8               0x00000800  /* Compile */
-#define PCRE_NO_AUTO_CAPTURE    0x00001000  /* Compile */
-#define PCRE_NO_UTF8_CHECK      0x00002000  /* Compile, exec, DFA exec */
-#define PCRE_AUTO_CALLOUT       0x00004000  /* Compile */
-#define PCRE_PARTIAL_SOFT       0x00008000  /* Exec, DFA exec */
-#define PCRE_PARTIAL            0x00008000  /* Backwards compatible synonym */
-#define PCRE_DFA_SHORTEST       0x00010000  /* DFA exec */
-#define PCRE_DFA_RESTART        0x00020000  /* DFA exec */
-#define PCRE_FIRSTLINE          0x00040000  /* Compile */
-#define PCRE_DUPNAMES           0x00080000  /* Compile */
-#define PCRE_NEWLINE_CR         0x00100000  /* Compile, exec, DFA exec */
-#define PCRE_NEWLINE_LF         0x00200000  /* Compile, exec, DFA exec */
-#define PCRE_NEWLINE_CRLF       0x00300000  /* Compile, exec, DFA exec */
-#define PCRE_NEWLINE_ANY        0x00400000  /* Compile, exec, DFA exec */
-#define PCRE_NEWLINE_ANYCRLF    0x00500000  /* Compile, exec, DFA exec */
-#define PCRE_BSR_ANYCRLF        0x00800000  /* Compile, exec, DFA exec */
-#define PCRE_BSR_UNICODE        0x01000000  /* Compile, exec, DFA exec */
-#define PCRE_JAVASCRIPT_COMPAT  0x02000000  /* Compile */
-#define PCRE_NO_START_OPTIMIZE  0x04000000  /* Compile, exec, DFA exec */
-#define PCRE_NO_START_OPTIMISE  0x04000000  /* Synonym */
-#define PCRE_PARTIAL_HARD       0x08000000  /* Exec, DFA exec */
-#define PCRE_NOTEMPTY_ATSTART   0x10000000  /* Exec, DFA exec */
-#define PCRE_UCP                0x20000000  /* Compile */
-
-/* Exec-time and get/set-time error codes */
-
-#define PCRE_ERROR_NOMATCH         (-1)
-#define PCRE_ERROR_NULL            (-2)
-#define PCRE_ERROR_BADOPTION       (-3)
-#define PCRE_ERROR_BADMAGIC        (-4)
-#define PCRE_ERROR_UNKNOWN_OPCODE  (-5)
-#define PCRE_ERROR_UNKNOWN_NODE    (-5)  /* For backward compatibility */
-#define PCRE_ERROR_NOMEMORY        (-6)
-#define PCRE_ERROR_NOSUBSTRING     (-7)
-#define PCRE_ERROR_MATCHLIMIT      (-8)
-#define PCRE_ERROR_CALLOUT         (-9)  /* Never used by PCRE itself */
-#define PCRE_ERROR_BADUTF8        (-10)
-#define PCRE_ERROR_BADUTF8_OFFSET (-11)
-#define PCRE_ERROR_PARTIAL        (-12)
-#define PCRE_ERROR_BADPARTIAL     (-13)
-#define PCRE_ERROR_INTERNAL       (-14)
-#define PCRE_ERROR_BADCOUNT       (-15)
-#define PCRE_ERROR_DFA_UITEM      (-16)
-#define PCRE_ERROR_DFA_UCOND      (-17)
-#define PCRE_ERROR_DFA_UMLIMIT    (-18)
-#define PCRE_ERROR_DFA_WSSIZE     (-19)
-#define PCRE_ERROR_DFA_RECURSE    (-20)
-#define PCRE_ERROR_RECURSIONLIMIT (-21)
-#define PCRE_ERROR_NULLWSLIMIT    (-22)  /* No longer actually used */
-#define PCRE_ERROR_BADNEWLINE     (-23)
-#define PCRE_ERROR_BADOFFSET      (-24)
-#define PCRE_ERROR_SHORTUTF8      (-25)
-#define PCRE_ERROR_RECURSELOOP    (-26)
-#define PCRE_ERROR_JIT_STACKLIMIT (-27)
-
-/* Specific error codes for UTF-8 validity checks */
-
-#define PCRE_UTF8_ERR0               0
-#define PCRE_UTF8_ERR1               1
-#define PCRE_UTF8_ERR2               2
-#define PCRE_UTF8_ERR3               3
-#define PCRE_UTF8_ERR4               4
-#define PCRE_UTF8_ERR5               5
-#define PCRE_UTF8_ERR6               6
-#define PCRE_UTF8_ERR7               7
-#define PCRE_UTF8_ERR8               8
-#define PCRE_UTF8_ERR9               9
-#define PCRE_UTF8_ERR10             10
-#define PCRE_UTF8_ERR11             11
-#define PCRE_UTF8_ERR12             12
-#define PCRE_UTF8_ERR13             13
-#define PCRE_UTF8_ERR14             14
-#define PCRE_UTF8_ERR15             15
-#define PCRE_UTF8_ERR16             16
-#define PCRE_UTF8_ERR17             17
-#define PCRE_UTF8_ERR18             18
-#define PCRE_UTF8_ERR19             19
-#define PCRE_UTF8_ERR20             20
-#define PCRE_UTF8_ERR21             21
-
-/* Request types for pcre_fullinfo() */
-
-#define PCRE_INFO_OPTIONS            0
-#define PCRE_INFO_SIZE               1
-#define PCRE_INFO_CAPTURECOUNT       2
-#define PCRE_INFO_BACKREFMAX         3
-#define PCRE_INFO_FIRSTBYTE          4
-#define PCRE_INFO_FIRSTCHAR          4  /* For backwards compatibility */
-#define PCRE_INFO_FIRSTTABLE         5
-#define PCRE_INFO_LASTLITERAL        6
-#define PCRE_INFO_NAMEENTRYSIZE      7
-#define PCRE_INFO_NAMECOUNT          8
-#define PCRE_INFO_NAMETABLE          9
-#define PCRE_INFO_STUDYSIZE         10
-#define PCRE_INFO_DEFAULT_TABLES    11
-#define PCRE_INFO_OKPARTIAL         12
-#define PCRE_INFO_JCHANGED          13
-#define PCRE_INFO_HASCRORLF         14
-#define PCRE_INFO_MINLENGTH         15
-#define PCRE_INFO_JIT               16
-
-/* Request types for pcre_config(). Do not re-arrange, in order to remain
-compatible. */
-
-#define PCRE_CONFIG_UTF8                    0
-#define PCRE_CONFIG_NEWLINE                 1
-#define PCRE_CONFIG_LINK_SIZE               2
-#define PCRE_CONFIG_POSIX_MALLOC_THRESHOLD  3
-#define PCRE_CONFIG_MATCH_LIMIT             4
-#define PCRE_CONFIG_STACKRECURSE            5
-#define PCRE_CONFIG_UNICODE_PROPERTIES      6
-#define PCRE_CONFIG_MATCH_LIMIT_RECURSION   7
-#define PCRE_CONFIG_BSR                     8
-#define PCRE_CONFIG_JIT                     9
-
-/* Request types for pcre_study(). Do not re-arrange, in order to remain
-compatible. */
-
-#define PCRE_STUDY_JIT_COMPILE            0x0001
-
-/* Bit flags for the pcre_extra structure. Do not re-arrange or redefine
-these bits, just add new ones on the end, in order to remain compatible. */
-
-#define PCRE_EXTRA_STUDY_DATA             0x0001
-#define PCRE_EXTRA_MATCH_LIMIT            0x0002
-#define PCRE_EXTRA_CALLOUT_DATA           0x0004
-#define PCRE_EXTRA_TABLES                 0x0008
-#define PCRE_EXTRA_MATCH_LIMIT_RECURSION  0x0010
-#define PCRE_EXTRA_MARK                   0x0020
-#define PCRE_EXTRA_EXECUTABLE_JIT         0x0040
-
-/* Types */
-
-struct real_pcre;                 /* declaration; the definition is private  */
-typedef struct real_pcre pcre;
-
-struct real_pcre_jit_stack;       /* declaration; the definition is private  */
-typedef struct real_pcre_jit_stack pcre_jit_stack;
-
-/* When PCRE is compiled as a C++ library, the subject pointer type can be
-replaced with a custom type. For conventional use, the public interface is a
-const char *. */
-
-#ifndef PCRE_SPTR
-#define PCRE_SPTR const char *
-#endif
-
-/* The structure for passing additional data to pcre_exec(). This is defined in
-such as way as to be extensible. Always add new fields at the end, in order to
-remain compatible. */
-
-typedef struct pcre_extra {
-  unsigned long int flags;        /* Bits for which fields are set */
-  void *study_data;               /* Opaque data from pcre_study() */
-  unsigned long int match_limit;  /* Maximum number of calls to match() */
-  void *callout_data;             /* Data passed back in callouts */
-  const unsigned char *tables;    /* Pointer to character tables */
-  unsigned long int match_limit_recursion; /* Max recursive calls to match() */
-  unsigned char **mark;           /* For passing back a mark pointer */
-  void *executable_jit;           /* Contains a pointer to a compiled jit code */
-} pcre_extra;
-
-/* The structure for passing out data via the pcre_callout_function. We use a
-structure so that new fields can be added on the end in future versions,
-without changing the API of the function, thereby allowing old clients to work
-without modification. */
-
-typedef struct pcre_callout_block {
-  int          version;           /* Identifies version of block */
-  /* ------------------------ Version 0 ------------------------------- */
-  int          callout_number;    /* Number compiled into pattern */
-  int         *offset_vector;     /* The offset vector */
-  PCRE_SPTR    subject;           /* The subject being matched */
-  int          subject_length;    /* The length of the subject */
-  int          start_match;       /* Offset to start of this match attempt */
-  int          current_position;  /* Where we currently are in the subject */
-  int          capture_top;       /* Max current capture */
-  int          capture_last;      /* Most recently closed capture */
-  void        *callout_data;      /* Data passed in with the call */
-  /* ------------------- Added for Version 1 -------------------------- */
-  int          pattern_position;  /* Offset to next item in the pattern */
-  int          next_item_length;  /* Length of next item in the pattern */
-  /* ------------------- Added for Version 2 -------------------------- */
-  const unsigned char *mark;      /* Pointer to current mark or NULL    */
-  /* ------------------------------------------------------------------ */
-} pcre_callout_block;
-
-/* Indirection for store get and free functions. These can be set to
-alternative malloc/free functions if required. Special ones are used in the
-non-recursive case for "frames". There is also an optional callout function
-that is triggered by the (?) regex item. For Virtual Pascal, these definitions
-have to take another form. */
-
-#ifndef VPCOMPAT
-PCRE_EXP_DECL void *(*pcre_malloc)(size_t);
-PCRE_EXP_DECL void  (*pcre_free)(void *);
-PCRE_EXP_DECL void *(*pcre_stack_malloc)(size_t);
-PCRE_EXP_DECL void  (*pcre_stack_free)(void *);
-PCRE_EXP_DECL int   (*pcre_callout)(pcre_callout_block *);
-#else   /* VPCOMPAT */
-PCRE_EXP_DECL void *pcre_malloc(size_t);
-PCRE_EXP_DECL void  pcre_free(void *);
-PCRE_EXP_DECL void *pcre_stack_malloc(size_t);
-PCRE_EXP_DECL void  pcre_stack_free(void *);
-PCRE_EXP_DECL int   pcre_callout(pcre_callout_block *);
-#endif  /* VPCOMPAT */
-
-/* User defined callback which provides a stack just before the match starts. */
-
-typedef pcre_jit_stack *(*pcre_jit_callback)(void *);
-
-/* Exported PCRE functions */
-
-PCRE_EXP_DECL pcre *pcre_compile(const char *, int, const char **, int *,
-                  const unsigned char *);
-PCRE_EXP_DECL pcre *pcre_compile2(const char *, int, int *, const char **,
-                  int *, const unsigned char *);
-PCRE_EXP_DECL int  pcre_config(int, void *);
-PCRE_EXP_DECL int  pcre_copy_named_substring(const pcre *, const char *,
-                  int *, int, const char *, char *, int);
-PCRE_EXP_DECL int  pcre_copy_substring(const char *, int *, int, int, char *,
-                  int);
-PCRE_EXP_DECL int  pcre_dfa_exec(const pcre *, const pcre_extra *,
-                  const char *, int, int, int, int *, int , int *, int);
-PCRE_EXP_DECL int  pcre_exec(const pcre *, const pcre_extra *, PCRE_SPTR,
-                   int, int, int, int *, int);
-PCRE_EXP_DECL void pcre_free_substring(const char *);
-PCRE_EXP_DECL void pcre_free_substring_list(const char **);
-PCRE_EXP_DECL int  pcre_fullinfo(const pcre *, const pcre_extra *, int,
-                  void *);
-PCRE_EXP_DECL int  pcre_get_named_substring(const pcre *, const char *,
-                  int *, int, const char *, const char **);
-PCRE_EXP_DECL int  pcre_get_stringnumber(const pcre *, const char *);
-PCRE_EXP_DECL int  pcre_get_stringtable_entries(const pcre *, const char *,
-                  char **, char **);
-PCRE_EXP_DECL int  pcre_get_substring(const char *, int *, int, int,
-                  const char **);
-PCRE_EXP_DECL int  pcre_get_substring_list(const char *, int *, int,
-                  const char ***);
-PCRE_EXP_DECL int  pcre_info(const pcre *, int *, int *);
-PCRE_EXP_DECL const unsigned char *pcre_maketables(void);
-PCRE_EXP_DECL int  pcre_refcount(pcre *, int);
-PCRE_EXP_DECL pcre_extra *pcre_study(const pcre *, int, const char **);
-PCRE_EXP_DECL void pcre_free_study(pcre_extra *);
-PCRE_EXP_DECL const char *pcre_version(void);
-
-/* JIT compiler related functions. */
-
-PCRE_EXP_DECL pcre_jit_stack *pcre_jit_stack_alloc(int, int);
-PCRE_EXP_DECL void pcre_jit_stack_free(pcre_jit_stack *);
-PCRE_EXP_DECL void pcre_assign_jit_stack(pcre_extra *, pcre_jit_callback, void *);
-
-#ifdef __cplusplus
-}  /* extern "C" */
-#endif
-
-#endif /* End of pcre.h */
diff --git a/lib/posixcompat/Hakefile b/lib/posixcompat/Hakefile
index ebe15a1..54ecba5 100644
--- a/lib/posixcompat/Hakefile
+++ b/lib/posixcompat/Hakefile
@@ -1,5 +1,5 @@
 --------------------------------------------------------------------------
--- Copyright (c) 2007-2009, 2011, 2012, ETH Zurich.
+-- Copyright (c) 2007-2009, 2011, 2012, 2013, ETH Zurich.
 -- All rights reserved.
 --
 -- This file is distributed under the terms in the attached LICENSE file.
@@ -30,7 +30,6 @@
                              "fsync.c",
                              "ftruncate.c",
                              "getcwd.c",
-                             "getegid.c",
                              "geteuid.c",
                              "getgroups.c",
                              "gethostid.c",
@@ -75,8 +74,15 @@
                              "unlink.c",
                              "utime.c",
                              "wait.c",
-                             "write.c" ],
-                  flounderDefs = [ "unixsock", "octopus", "monitor" ],
+                             "write.c",
+                             "mkfifo.c",
+                             "setrlimit.c",
+                             "pthreads.c", 
+                             "sleep.c", 
+                             "epoll.c", 
+                             "inet_ntop.c", 
+                             "inet_pton.c" ],
+                  flounderDefs = [ "unixsock", "octopus", "monitor", "terminal" ],
                   flounderBindings = [ "unixsock", "octopus" ],
 		  flounderExtraBindings = [ ("octopus", [ "rpcclient" ]) ],
                   flounderTHCStubs = [ "octopus" ]
diff --git a/lib/posixcompat/alarm.c b/lib/posixcompat/alarm.c
index 8a592c8..67c5e13 100644
--- a/lib/posixcompat/alarm.c
+++ b/lib/posixcompat/alarm.c
@@ -26,7 +26,7 @@ unsigned int alarm(unsigned int seconds)
         // Nothing to be done.
         return 0;
     } else {
-        assert(!"NYI");
+        /* assert(!"NYI"); */
         return 0;
     }
 }
diff --git a/lib/posixcompat/close.c b/lib/posixcompat/close.c
index cfab14a..37a85e0 100644
--- a/lib/posixcompat/close.c
+++ b/lib/posixcompat/close.c
@@ -14,6 +14,7 @@
 #include <stdio.h>
 #include <lwip/sockets.h>
 #include <vfs/fdtab.h>
+#include <sys/epoll.h>
 #include "posixcompat.h"
 #include "pty.h"
 
@@ -25,6 +26,12 @@ int close(int fd)
         return -1;
     }
 
+    // Might need to remove from epoll list
+    if(e->epoll_fd != -1) {
+        ret = epoll_ctl(e->epoll_fd, EPOLL_CTL_DEL, fd, NULL);
+        assert(ret == 0);
+    }
+
     switch(e->type) {
     case FDTAB_TYPE_LWIP_SOCKET:
         if (e->inherited) {
diff --git a/lib/posixcompat/epoll.c b/lib/posixcompat/epoll.c
new file mode 100644
index 0000000..2b33f43
--- /dev/null
+++ b/lib/posixcompat/epoll.c
@@ -0,0 +1,501 @@
+/*
+ * Copyright (c) 2011, 2012, 2013, ETH Zurich.
+ * All rights reserved.
+ *
+ * This file is distributed under the terms in the attached LICENSE file.
+ * If you do not find this file, copies can be found by writing to:
+ * ETH Zurich D-INFK, CAB F.78, Universitaetstr. 6, CH-8092 Zurich,
+ * Attn: Systems Group.
+ */
+
+#include <barrelfish/barrelfish.h>
+#include <barrelfish/waitset.h>
+#include <barrelfish/deferred.h>
+#include <if/monitor_defs.h>
+#include <lwip/sys.h>
+#include <lwip/sockets.h>
+#include <lwip/sock_chan_support.h>
+#include <vfs/fdtab.h>
+
+#include "posixcompat.h"
+#include "unixsock.h"
+
+#include <assert.h>
+#include <sys/epoll.h>
+
+#define MAX_EPOLL_EVENTS    16
+
+struct _epoll_fd {
+    struct waitset ws;
+    struct _epoll_events_list *events;
+};
+
+int epoll_create(int size)
+{
+    // size is ignored these days, even on Linux
+    return epoll_create1(0);
+}
+
+int epoll_create1(int flags)
+{
+    struct fdtab_entry e;
+    struct _epoll_fd *efd = malloc(sizeof(struct _epoll_fd));
+    assert(efd != NULL);
+
+    memset(efd, 0, sizeof(struct _epoll_fd));
+    waitset_init(&efd->ws);
+
+    e.type = FDTAB_TYPE_EPOLL_INSTANCE;
+    e.handle = efd;
+    e.inherited = false;
+    e.epoll_fd = -1;
+
+    int fd = fdtab_alloc(&e);
+    POSIXCOMPAT_DEBUG("epoll_create1(%d) as fd %d\n", flags, fd);
+    if (fd < 0) {
+        return -1;
+    } else {
+        return fd;
+    }
+}
+
+int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)
+{
+    struct fdtab_entry *mye = fdtab_get(epfd);
+    assert(mye->type == FDTAB_TYPE_EPOLL_INSTANCE);
+    struct _epoll_fd *efd = mye->handle;
+    int ret = 0;
+
+    if(op != EPOLL_CTL_DEL) {
+        assert(!(event->events & EPOLLRDHUP));
+        assert(!(event->events & EPOLLPRI));
+        assert(!(event->events & EPOLLERR));
+        assert(!(event->events & EPOLLHUP));
+        assert(!(event->events & EPOLLET));
+        assert(!(event->events & EPOLLONESHOT));
+    }
+
+    switch(op) {
+    case EPOLL_CTL_ADD:
+        // Add event/FD to events/FDs list
+        {
+            // Check that it's not already in the list
+            /* for(struct _epoll_events_list *i = efd->events; i != NULL; i = i->next) { */
+            /*     assert(i->fd != fd); */
+            /* } */
+
+            struct fdtab_entry *e = fdtab_get(fd);
+            if(e->epoll_fd == epfd) {
+                errno = EEXIST;
+                ret = -1;
+                break;
+            }
+            assert(e->epoll_fd == -1);
+            e->epoll_fd = epfd;
+            struct _epoll_events_list *li = &e->epoll_events;
+            li->prev = NULL;
+            li->next = efd->events;
+            if(li->next != NULL) {
+                li->next->prev = li;
+            }
+            li->event = *event;
+            li->fd = fd;
+            efd->events = li;
+        }
+        break;
+
+    case EPOLL_CTL_DEL:
+        {
+#if 0
+            struct _epoll_events_list *lasti = NULL, *i;
+            for(i = efd->events; i != NULL; i = i->next) {
+                if(i->fd == fd) {
+                    if(lasti == NULL) {
+                        // First entry in list
+                        efd->events = i->next;
+                    } else {
+                        // Anywhere else
+                        lasti->next = i->next;
+                    }
+
+                    free(i);
+
+                    struct fdtab_entry *e = fdtab_get(fd);
+                    assert(e->epoll_fd != -1);
+                    e->epoll_fd = -1;
+                    break;
+                }
+
+                lasti = i;
+            }
+
+            if(i == NULL) {
+                errno = ENOENT;
+                ret = -1;
+            }
+#else
+            struct fdtab_entry *e = fdtab_get(fd);
+            assert(e->epoll_fd != -1);
+            e->epoll_fd = -1;
+            if(&e->epoll_events == efd->events) {
+                // First entry in list -- update head
+                efd->events = e->epoll_events.next;
+            }
+            if(e->epoll_events.next != NULL) {
+                e->epoll_events.next->prev = e->epoll_events.prev;
+            }
+            if(e->epoll_events.prev != NULL) {
+                e->epoll_events.prev->next = e->epoll_events.next;
+            }
+#endif
+        }
+        break;
+
+    case EPOLL_CTL_MOD:
+        {
+            struct _epoll_events_list *i;
+            for(i = efd->events; i != NULL; i = i->next) {
+                if(i->fd == fd) {
+                    // Found
+                    i->event = *event;
+                    break;
+                }
+            }
+
+            if(i == NULL) {
+                errno = ENOENT;
+                ret = -1;
+            }
+        }
+        break;
+
+    default:
+        errno = EINVAL;
+        return -1;
+    }
+
+    return ret;
+}
+
+struct timeout_event {
+  bool fired;
+};
+
+static void timeout_fired(void *arg)
+{
+  struct timeout_event *toe = arg;
+  assert(toe != NULL);
+  toe->fired = true;
+}
+
+int epoll_wait(int epfd, struct epoll_event *events,
+               int maxevents, int timeout)
+{
+    struct fdtab_entry *mye = fdtab_get(epfd);
+    assert(mye->type == FDTAB_TYPE_EPOLL_INSTANCE);
+    struct _epoll_fd *efd = mye->handle;
+    struct monitor_binding *mb = get_monitor_binding();
+    errval_t err;
+
+    /* waitset_init(&efd->ws); */
+    assert(maxevents >= 1);
+
+    for(struct _epoll_events_list *i = efd->events; i != NULL; i = i->next) {
+        struct fdtab_entry *e = fdtab_get(i->fd);
+        struct epoll_event *event = &i->event;
+
+        switch (e->type) {
+        case FDTAB_TYPE_LWIP_SOCKET:
+            {
+                int retval;
+
+                lwip_mutex_lock();
+                if(event->events & EPOLLIN) {
+                    retval = lwip_sock_waitset_register_read(e->fd, &efd->ws);
+                    assert(retval == 0);
+                }
+                if(event->events & EPOLLOUT) {
+                    retval = lwip_sock_waitset_register_write(e->fd, &efd->ws);
+                    assert(retval == 0);
+                }
+                lwip_mutex_unlock();
+            }
+            break;
+
+        case FDTAB_TYPE_UNIX_SOCKET:
+            {
+                struct _unix_socket *us = e->handle;
+
+                if(event->events & EPOLLIN) {
+                    if (us->passive) { /* passive side */
+                        int j;
+
+                        /* Check for pending connection requests. */
+                        for (j = 0; j < us->u.passive.max_backlog; j++)
+                            {
+                                if (us->u.passive.backlog[j] != NULL) {
+                                    break;
+                                }
+                            }
+
+                        /*
+                         * If there are not pending connection request
+                         * wait on monitor binding.
+                         */
+                        if (j == us->u.passive.max_backlog) {
+                            /* wait on monitor */
+                            err = mb->change_waitset(mb, &efd->ws);
+                            if (err_is_fail(err)) {
+                                USER_PANIC_ERR(err, "change_waitset");
+                            }
+                        }
+                    }
+                }
+
+                if(event->events & EPOLLOUT) {
+                    assert(!us->passive);
+
+                    if(us->u.active.mode == _UNIX_SOCKET_MODE_CONNECTING) {
+                        /* wait on monitor */
+                        err = mb->change_waitset(mb, &efd->ws);
+                        if (err_is_fail(err)) {
+                            USER_PANIC_ERR(err, "change_waitset");
+                        }
+                    }
+                }
+
+                assert(event->events & (EPOLLIN | EPOLLOUT));
+
+                // Change waitset
+                err = us->u.active.binding->change_waitset
+                    (us->u.active.binding, &efd->ws);
+                if (err_is_fail(err)) {
+                    USER_PANIC_ERR(err, "change waitset");
+                }
+
+            }
+            break;
+
+        default:
+            {
+                fprintf(stderr, "change waitset on FD type %d NYI.\n",
+                        e->type);
+                assert(!"NYI");
+                errno = EBADF;
+                return -1;
+            }
+        }
+    }
+
+    // Timeout handling
+    struct timeout_event toe = {
+      .fired = false
+    };
+    struct deferred_event timeout_event;
+    if (timeout > 0) {
+        deferred_event_init(&timeout_event);
+        err = deferred_event_register(&timeout_event, &efd->ws, timeout,
+                                      MKCLOSURE(timeout_fired, &toe));
+        if (err_is_fail(err)) {
+            errno = EINVAL;
+            return -1;
+        }
+    }
+
+    int retevents = 0;
+    while(!toe.fired && retevents == 0) {
+        if(timeout == 0) {
+            // Just poll once, don't block
+            err = event_dispatch_non_block(&efd->ws);
+            assert(err_is_ok(err) || err_no(err) == LIB_ERR_NO_EVENT);
+            toe.fired = true;
+        } else {
+            err = event_dispatch(&efd->ws);
+            if (err_is_fail(err)) {
+                USER_PANIC_ERR(err, "Error in event_dispatch.");
+            }
+        }
+
+        // Return ready file descriptors
+        for(struct _epoll_events_list *i = efd->events; i != NULL; i = i->next) {
+            struct epoll_event *event = &i->event;
+            struct fdtab_entry *e = fdtab_get(i->fd);
+
+            assert(retevents < maxevents);
+            events[retevents] = *event;
+            events[retevents].events = 0;
+
+            // Check errors (hangup)
+            {
+                switch (e->type) {
+                case FDTAB_TYPE_LWIP_SOCKET:
+                    {
+                        lwip_mutex_lock();
+                        if (!lwip_sock_is_open(e->fd)) {
+                            events[retevents].events |= EPOLLHUP;
+                        }
+                        lwip_mutex_unlock();
+                    }
+                    break;
+
+                default:
+                    // No-Op
+                    break;
+                }
+            }
+
+            // Check readable FDs
+            if(event->events & EPOLLIN) {
+                switch (e->type) {
+                case FDTAB_TYPE_LWIP_SOCKET:
+                    {
+                        lwip_mutex_lock();
+                        if (lwip_sock_ready_read(e->fd)) {
+                            events[retevents].events |= EPOLLIN;
+                        }
+                        lwip_mutex_unlock();
+                    }
+                    break;
+
+                case FDTAB_TYPE_UNIX_SOCKET:
+                    {
+                        struct _unix_socket *us = e->handle;
+
+                        if (us->passive) { /* passive side */
+                            /* Check for pending connection requests. */
+                            for (int j = 0; j < us->u.passive.max_backlog; j++)
+                                {
+                                    if (us->u.passive.backlog[j] != NULL) {
+                                        events[retevents].events |= EPOLLIN;
+                                        break;
+                                    }
+                                }
+                        } else { /* active side */
+                            /* Check for incoming data. */
+                            if (us->recv_buf_valid > 0) {
+                                events[retevents].events |= EPOLLIN;
+                            }
+                        }
+                    }
+                    break;
+
+                default:
+                    {
+                        fprintf(stderr, "epoll_wait() on FD type %d NYI.\n",
+                                e->type);
+                        assert(!"NYI");
+                        errno = EBADF;
+                        return -1;
+                    }
+                }
+            }
+
+            // Check writeable FDs
+            if(event->events & EPOLLOUT) {
+                switch (e->type) {
+                case FDTAB_TYPE_LWIP_SOCKET:
+                    {
+                        lwip_mutex_lock();
+                        if (lwip_sock_ready_write(e->fd)) {
+                            events[retevents].events |= EPOLLOUT;
+                        }
+                        lwip_mutex_unlock();
+                    }
+                    break;
+
+                case FDTAB_TYPE_UNIX_SOCKET:
+                    {
+                        struct _unix_socket *us = e->handle;
+                        assert(!us->passive);
+
+                        switch (us->u.active.mode) {
+                        case _UNIX_SOCKET_MODE_CONNECTING:
+                            break;
+
+                        case _UNIX_SOCKET_MODE_CONNECTED:
+                            if (us->send_buf == NULL) {
+                                events[retevents].events |= EPOLLOUT;
+                            }
+                            break;
+                        }
+                    }
+                    break;
+
+                default:
+                    {
+                        fprintf(stderr, "epoll_wait() on FD type %d NYI.\n",
+                                e->type);
+                        assert(!"NYI");
+                        errno = EBADF;
+                        return -1;
+                    }
+                }
+            }
+
+            // If any events were returned, go to next entry in array
+            if(events[retevents].events != 0) {
+                retevents++;
+            }
+        }
+    }
+
+    // Remove timeout from waitset if it was set and not fired
+    if(timeout > 0 && !toe.fired) {
+        deferred_event_cancel(&timeout_event);
+    }
+
+    // Restore old waitsets
+    for(struct _epoll_events_list *i = efd->events; i != NULL; i = i->next) {
+        struct fdtab_entry *e = fdtab_get(i->fd);
+        struct epoll_event *event = &i->event;
+
+        switch (e->type) {
+        case FDTAB_TYPE_LWIP_SOCKET:
+            {
+                lwip_mutex_lock();
+                if(event->events & EPOLLIN) {
+                    err = lwip_sock_waitset_deregister_read(e->fd);
+                    if (err_is_fail(err) &&
+                        err_no(err) != LIB_ERR_CHAN_NOT_REGISTERED) {
+                        USER_PANIC_ERR(err, "error deregister read channel for "
+                                       "lwip socket");
+                    }
+                }
+                if(event->events & EPOLLOUT) {
+                    err = lwip_sock_waitset_deregister_write(e->fd);
+                    if (err_is_fail(err) &&
+                        err_no(err) != LIB_ERR_CHAN_NOT_REGISTERED) {
+                        USER_PANIC_ERR(err, "error deregister write channel for "
+                                       "lwip socket");
+                    }
+                }
+                lwip_mutex_unlock();
+            }
+            break;
+
+        case FDTAB_TYPE_UNIX_SOCKET:
+            {
+                // NYI
+            }
+            break;
+
+        default:
+            {
+                fprintf(stderr, "change waitset on FD type %d NYI.\n",
+                        e->type);
+                assert(!"NYI");
+                errno = EBADF;
+                return -1;
+            }
+        }
+    }
+
+    return retevents;
+}
+
+int epoll_pwait(int epfd, struct epoll_event *events,
+                int maxevents, int timeout,
+                const sigset_t *sigmask)
+{
+    assert(!"NYI");
+}
diff --git a/lib/posixcompat/fcntl.c b/lib/posixcompat/fcntl.c
index 0e0833a..b478d37 100644
--- a/lib/posixcompat/fcntl.c
+++ b/lib/posixcompat/fcntl.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011, 2012, ETH Zurich.
+ * Copyright (c) 2011, 2013, ETH Zurich.
  * All rights reserved.
  *
  * This file is distributed under the terms in the attached LICENSE file.
@@ -13,6 +13,7 @@
 #include <stdarg.h>
 #include <errno.h>
 #include <vfs/fdtab.h>
+#include <lwip/sockets.h>
 #include "posixcompat.h"
 #include "unixsock.h"
 #include "pty.h"
@@ -49,8 +50,13 @@ int fcntl(int fd, int cmd, ...)
             default:
                 /* do nothing */
                 break;
-            }
-        }
+	    }
+	}
+	break;
+
+    case F_GETFD:
+        // XXX: No flags are supported ATM
+        retval = 0;
         break;
 
     case F_SETFD:
@@ -80,6 +86,10 @@ int fcntl(int fd, int cmd, ...)
                 }
                 break;
 
+            case FDTAB_TYPE_LWIP_SOCKET:
+                retval = lwip_fcntl(e->fd, cmd, flags);
+                break;
+
             case FDTAB_TYPE_PTS:
             case FDTAB_TYPE_PTM:
                 {
@@ -89,11 +99,11 @@ int fcntl(int fd, int cmd, ...)
                 break;
 
             default:
-                return -1;
+                retval = -1;
+                break;
             }
-
-            break;
         }
+        break;
 
     case F_GETFL:
         {
@@ -101,10 +111,20 @@ int fcntl(int fd, int cmd, ...)
 
             switch(e->type) {
             case FDTAB_TYPE_FILE:
+                // no flags set
+                retval = 0;
+                break;
+
             case FDTAB_TYPE_LWIP_SOCKET:
+                retval = lwip_fcntl(e->fd, cmd, 0);
+                break;
+
+            case FDTAB_TYPE_UNIX_SOCKET:
                 {
-                    // no flags set
-                    return 0;
+                    // XXX: We only handle non-blocking here
+                    struct _unix_socket *us = e->handle;
+                    retval = 0;
+                    retval |= us->nonblocking ? O_NONBLOCK : 0;
                 }
                 break;
 
@@ -117,10 +137,11 @@ int fcntl(int fd, int cmd, ...)
 
             default:
                 assert(!"NYI");
-                return -1;
+                retval = -1;
                 break;
             }
         }
+        break;
 
     default:
         assert(!"NYI");
diff --git a/lib/posixcompat/getegid.c b/lib/posixcompat/getegid.c
deleted file mode 100644
index a042e5a..0000000
--- a/lib/posixcompat/getegid.c
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- * Copyright (c) 2012, ETH Zurich.
- * All rights reserved.
- *
- * This file is distributed under the terms in the attached LICENSE file.
- * If you do not find this file, copies can be found by writing to:
- * ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich. Attn: Systems Group.
- */
-
-#include <assert.h>
-#include <unistd.h>
-
-#include "posixcompat.h"
-
-/**
- * \brief Get the effective group ID.
- */
-gid_t getegid(void)
-{
-    assert(!"NYI");
-    return 0;
-}
-
-/**
- * \brief Get the real group ID.
- */
-gid_t getgid(void)
-{
-    assert(!"NYI");
-    return 0;
-}
-
-/**
- * \brief Set the effective group ID.
- */
-int setegid(gid_t gid)
-{
-    assert(!"NYI");
-    return -1;
-}
-
-/**
- * \brief Set-group-ID.
- */
-int setgid(gid_t gid)
-{
-    assert(!"NYI");
-    return -1;
-}
diff --git a/lib/posixcompat/geteuid.c b/lib/posixcompat/geteuid.c
index 3a59dcf..50e61c8 100644
--- a/lib/posixcompat/geteuid.c
+++ b/lib/posixcompat/geteuid.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011, 2012, ETH Zurich.
+ * Copyright (c) 2011, 2012, 2013, ETH Zurich.
  * All rights reserved.
  *
  * This file is distributed under the terms in the attached LICENSE file.
@@ -48,6 +48,42 @@ struct passwd *getpwuid(uid_t uid)
     return NULL;
 }
 
+/**
+ * \brief Get the effective group ID.
+ */
+gid_t getegid(void)
+{
+    POSIXCOMPAT_DEBUG("getegid(): returning %d\n", dummyuser->pw_gid);
+    return dummyuser->pw_gid;
+}
+
+/**
+ * \brief Get the real group ID.
+ */
+gid_t getgid(void)
+{
+    POSIXCOMPAT_DEBUG("getgid(): returning %d\n", dummyuser->pw_gid);
+    return dummyuser->pw_gid;
+}
+
+/**
+ * \brief Set the effective group ID.
+ */
+int setegid(gid_t gid)
+{
+    assert(!"NYI");
+    return -1;
+}
+
+/**
+ * \brief Set-group-ID.
+ */
+int setgid(gid_t gid)
+{
+    assert(!"NYI");
+    return -1;
+}
+
 struct passwd *getpwnam(const char *name)
 {
     struct passwd* user = NULL;
diff --git a/lib/posixcompat/gettimeofday.c b/lib/posixcompat/gettimeofday.c
index f0610bb..5e4d8e3 100644
--- a/lib/posixcompat/gettimeofday.c
+++ b/lib/posixcompat/gettimeofday.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011, ETH Zurich.
+ * Copyright (c) 2011, 2013, ETH Zurich.
  * All rights reserved.
  *
  * This file is distributed under the terms in the attached LICENSE file.
@@ -18,12 +18,14 @@
 int gettimeofday(struct timeval *tv, struct timezone *tz)
 {
     uint64_t now = rdtsc();
-    uint64_t tscperms;
+    static uint64_t tscperms = 0;
 
-    errval_t err = sys_debug_get_tsc_per_ms(&tscperms);
-    assert(err_is_ok(err));
+    if(tscperms == 0) {
+        errval_t err = sys_debug_get_tsc_per_ms(&tscperms);
+        assert(err_is_ok(err));
+        assert(tscperms >= 1000);
+    }
 
-    assert(tscperms >= 1000);
     uint64_t tod_us = (TOD_OFFSET * 1000000) + (now / (tscperms / 1000));
 
     if(tv != NULL) {
diff --git a/lib/posixcompat/inet_ntop.c b/lib/posixcompat/inet_ntop.c
new file mode 100644
index 0000000..d456cb5
--- /dev/null
+++ b/lib/posixcompat/inet_ntop.c
@@ -0,0 +1,191 @@
+/*
+ * Copyright (c) 2004 by Internet Systems Consortium, Inc. ("ISC")
+ * Copyright (c) 1996-1999 by Internet Software Consortium.
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+ * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#if defined(LIBC_SCCS) && !defined(lint)
+static const char rcsid[] = "$Id: inet_ntop.c,v 1.3.18.2 2005/11/03 23:02:22 marka Exp $";
+#endif /* LIBC_SCCS and not lint */
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/param.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+
+#include <netinet/in.h>
+#include <arpa/inet.h>
+
+#include <errno.h>
+#include <stdio.h>
+#include <string.h>
+
+/*%
+ * WARNING: Don't even consider trying to compile this on a system where
+ * sizeof(int) < 4.  sizeof(int) > 4 is fine; all the world's not a VAX.
+ */
+
+static const char *inet_ntop4(const u_char *src, char *dst, socklen_t size);
+static const char *inet_ntop6(const u_char *src, char *dst, socklen_t size);
+
+/* char *
+ * inet_ntop(af, src, dst, size)
+ *	convert a network format address to presentation format.
+ * return:
+ *	pointer to presentation format address (`dst'), or NULL (see errno).
+ * author:
+ *	Paul Vixie, 1996.
+ */
+const char *
+inet_ntop(int af, const void * __restrict src, char * __restrict dst,
+    socklen_t size)
+{
+	switch (af) {
+	case AF_INET:
+		return (inet_ntop4(src, dst, size));
+	case AF_INET6:
+		return (inet_ntop6(src, dst, size));
+	default:
+		errno = EAFNOSUPPORT;
+		return (NULL);
+	}
+	/* NOTREACHED */
+}
+
+/* const char *
+ * inet_ntop4(src, dst, size)
+ *	format an IPv4 address
+ * return:
+ *	`dst' (as a const)
+ * notes:
+ *	(1) uses no statics
+ *	(2) takes a u_char* not an in_addr as input
+ * author:
+ *	Paul Vixie, 1996.
+ */
+static const char *
+inet_ntop4(const u_char *src, char *dst, socklen_t size)
+{
+	static const char fmt[] = "%u.%u.%u.%u";
+	char tmp[sizeof "255.255.255.255"];
+	int l;
+
+	l = snprintf(tmp, sizeof(tmp), fmt, src[0], src[1], src[2], src[3]);
+	if (l <= 0 || (socklen_t) l >= size) {
+		errno = ENOSPC;
+		return (NULL);
+	}
+	strlcpy(dst, tmp, size);
+	return (dst);
+}
+
+/* const char *
+ * inet_ntop6(src, dst, size)
+ *	convert IPv6 binary address into presentation (printable) format
+ * author:
+ *	Paul Vixie, 1996.
+ */
+static const char *
+inet_ntop6(const u_char *src, char *dst, socklen_t size)
+{
+	/*
+	 * Note that int32_t and int16_t need only be "at least" large enough
+	 * to contain a value of the specified size.  On some systems, like
+	 * Crays, there is no such thing as an integer variable with 16 bits.
+	 * Keep this in mind if you think this function should have been coded
+	 * to use pointer overlays.  All the world's not a VAX.
+	 */
+	char tmp[sizeof "ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255"], *tp;
+	struct { int base, len; } best, cur;
+#define NS_IN6ADDRSZ    16
+#define NS_INT16SZ      2
+	u_int words[NS_IN6ADDRSZ / NS_INT16SZ];
+	int i;
+
+	/*
+	 * Preprocess:
+	 *	Copy the input (bytewise) array into a wordwise array.
+	 *	Find the longest run of 0x00's in src[] for :: shorthanding.
+	 */
+	memset(words, '\0', sizeof words);
+	for (i = 0; i < NS_IN6ADDRSZ; i++)
+		words[i / 2] |= (src[i] << ((1 - (i % 2)) << 3));
+	best.base = -1;
+	best.len = 0;
+	cur.base = -1;
+	cur.len = 0;
+	for (i = 0; i < (NS_IN6ADDRSZ / NS_INT16SZ); i++) {
+		if (words[i] == 0) {
+			if (cur.base == -1)
+				cur.base = i, cur.len = 1;
+			else
+				cur.len++;
+		} else {
+			if (cur.base != -1) {
+				if (best.base == -1 || cur.len > best.len)
+					best = cur;
+				cur.base = -1;
+			}
+		}
+	}
+	if (cur.base != -1) {
+		if (best.base == -1 || cur.len > best.len)
+			best = cur;
+	}
+	if (best.base != -1 && best.len < 2)
+		best.base = -1;
+
+	/*
+	 * Format the result.
+	 */
+	tp = tmp;
+	for (i = 0; i < (NS_IN6ADDRSZ / NS_INT16SZ); i++) {
+		/* Are we inside the best run of 0x00's? */
+		if (best.base != -1 && i >= best.base &&
+		    i < (best.base + best.len)) {
+			if (i == best.base)
+				*tp++ = ':';
+			continue;
+		}
+		/* Are we following an initial run of 0x00s or any real hex? */
+		if (i != 0)
+			*tp++ = ':';
+		/* Is this address an encapsulated IPv4? */
+		if (i == 6 && best.base == 0 && (best.len == 6 ||
+		    (best.len == 7 && words[7] != 0x0001) ||
+		    (best.len == 5 && words[5] == 0xffff))) {
+			if (!inet_ntop4(src+12, tp, sizeof tmp - (tp - tmp)))
+				return (NULL);
+			tp += strlen(tp);
+			break;
+		}
+		tp += sprintf(tp, "%x", words[i]);
+	}
+	/* Was it a trailing run of 0x00's? */
+	if (best.base != -1 && (best.base + best.len) == 
+	    (NS_IN6ADDRSZ / NS_INT16SZ))
+		*tp++ = ':';
+	*tp++ = '\0';
+
+	/*
+	 * Check for overflow, copy, and we're done.
+	 */
+	if ((socklen_t)(tp - tmp) > size) {
+		errno = ENOSPC;
+		return (NULL);
+	}
+	strcpy(dst, tmp);
+	return (dst);
+}
diff --git a/lib/posixcompat/inet_pton.c b/lib/posixcompat/inet_pton.c
new file mode 100644
index 0000000..c360d5c
--- /dev/null
+++ b/lib/posixcompat/inet_pton.c
@@ -0,0 +1,216 @@
+/*
+ * Copyright (c) 2004 by Internet Systems Consortium, Inc. ("ISC")
+ * Copyright (c) 1996,1999 by Internet Software Consortium.
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+ * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#if defined(LIBC_SCCS) && !defined(lint)
+static const char rcsid[] = "$Id: inet_pton.c,v 1.3.18.2 2005/07/28 07:38:07 marka Exp $";
+#endif /* LIBC_SCCS and not lint */
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/param.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <string.h>
+#include <errno.h>
+
+/*%
+ * WARNING: Don't even consider trying to compile this on a system where
+ * sizeof(int) < 4.  sizeof(int) > 4 is fine; all the world's not a VAX.
+ */
+
+static int	inet_pton4(const char *src, u_char *dst);
+static int	inet_pton6(const char *src, u_char *dst);
+
+/* int
+ * inet_pton(af, src, dst)
+ *	convert from presentation format (which usually means ASCII printable)
+ *	to network format (which is usually some kind of binary format).
+ * return:
+ *	1 if the address was valid for the specified address family
+ *	0 if the address wasn't valid (`dst' is untouched in this case)
+ *	-1 if some other error occurred (`dst' is untouched in this case, too)
+ * author:
+ *	Paul Vixie, 1996.
+ */
+int
+inet_pton(int af, const char * __restrict src, void * __restrict dst)
+{
+	switch (af) {
+	case AF_INET:
+		return (inet_pton4(src, dst));
+	case AF_INET6:
+		return (inet_pton6(src, dst));
+	default:
+		errno = EAFNOSUPPORT;
+		return (-1);
+	}
+	/* NOTREACHED */
+}
+
+/* int
+ * inet_pton4(src, dst)
+ *	like inet_aton() but without all the hexadecimal and shorthand.
+ * return:
+ *	1 if `src' is a valid dotted quad, else 0.
+ * notice:
+ *	does not touch `dst' unless it's returning 1.
+ * author:
+ *	Paul Vixie, 1996.
+ */
+static int
+inet_pton4(const char *src, u_char *dst)
+{
+	static const char digits[] = "0123456789";
+	int saw_digit, octets, ch;
+#define NS_INADDRSZ     4
+	u_char tmp[NS_INADDRSZ], *tp;
+
+	saw_digit = 0;
+	octets = 0;
+	*(tp = tmp) = 0;
+	while ((ch = *src++) != '\0') {
+		const char *pch;
+
+		if ((pch = strchr(digits, ch)) != NULL) {
+			u_int new = *tp * 10 + (pch - digits);
+
+			if (saw_digit && *tp == 0)
+				return (0);
+			if (new > 255)
+				return (0);
+			*tp = new;
+			if (!saw_digit) {
+				if (++octets > 4)
+					return (0);
+				saw_digit = 1;
+			}
+		} else if (ch == '.' && saw_digit) {
+			if (octets == 4)
+				return (0);
+			*++tp = 0;
+			saw_digit = 0;
+		} else
+			return (0);
+	}
+	if (octets < 4)
+		return (0);
+	memcpy(dst, tmp, NS_INADDRSZ);
+	return (1);
+}
+
+/* int
+ * inet_pton6(src, dst)
+ *	convert presentation level address to network order binary form.
+ * return:
+ *	1 if `src' is a valid [RFC1884 2.2] address, else 0.
+ * notice:
+ *	(1) does not touch `dst' unless it's returning 1.
+ *	(2) :: in a full address is silently ignored.
+ * credit:
+ *	inspired by Mark Andrews.
+ * author:
+ *	Paul Vixie, 1996.
+ */
+static int
+inet_pton6(const char *src, u_char *dst)
+{
+	static const char xdigits_l[] = "0123456789abcdef",
+			  xdigits_u[] = "0123456789ABCDEF";
+#define NS_IN6ADDRSZ    16
+#define NS_INT16SZ      2
+	u_char tmp[NS_IN6ADDRSZ], *tp, *endp, *colonp;
+	const char *xdigits, *curtok;
+	int ch, seen_xdigits;
+	u_int val;
+
+	memset((tp = tmp), '\0', NS_IN6ADDRSZ);
+	endp = tp + NS_IN6ADDRSZ;
+	colonp = NULL;
+	/* Leading :: requires some special handling. */
+	if (*src == ':')
+		if (*++src != ':')
+			return (0);
+	curtok = src;
+	seen_xdigits = 0;
+	val = 0;
+	while ((ch = *src++) != '\0') {
+		const char *pch;
+
+		if ((pch = strchr((xdigits = xdigits_l), ch)) == NULL)
+			pch = strchr((xdigits = xdigits_u), ch);
+		if (pch != NULL) {
+			val <<= 4;
+			val |= (pch - xdigits);
+			if (++seen_xdigits > 4)
+				return (0);
+			continue;
+		}
+		if (ch == ':') {
+			curtok = src;
+			if (!seen_xdigits) {
+				if (colonp)
+					return (0);
+				colonp = tp;
+				continue;
+			} else if (*src == '\0') {
+				return (0);
+			}
+			if (tp + NS_INT16SZ > endp)
+				return (0);
+			*tp++ = (u_char) (val >> 8) & 0xff;
+			*tp++ = (u_char) val & 0xff;
+			seen_xdigits = 0;
+			val = 0;
+			continue;
+		}
+		if (ch == '.' && ((tp + NS_INADDRSZ) <= endp) &&
+		    inet_pton4(curtok, tp) > 0) {
+			tp += NS_INADDRSZ;
+			seen_xdigits = 0;
+			break;	/*%< '\\0' was seen by inet_pton4(). */
+		}
+		return (0);
+	}
+	if (seen_xdigits) {
+		if (tp + NS_INT16SZ > endp)
+			return (0);
+		*tp++ = (u_char) (val >> 8) & 0xff;
+		*tp++ = (u_char) val & 0xff;
+	}
+	if (colonp != NULL) {
+		/*
+		 * Since some memmove()'s erroneously fail to handle
+		 * overlapping regions, we'll do the shift by hand.
+		 */
+		const int n = tp - colonp;
+		int i;
+
+		if (tp == endp)
+			return (0);
+		for (i = 1; i <= n; i++) {
+			endp[- i] = colonp[n - i];
+			colonp[n - i] = 0;
+		}
+		tp = endp;
+	}
+	if (tp != endp)
+		return (0);
+	memcpy(dst, tmp, NS_IN6ADDRSZ);
+	return (1);
+}
diff --git a/lib/posixcompat/mkfifo.c b/lib/posixcompat/mkfifo.c
new file mode 100644
index 0000000..e5a0517
--- /dev/null
+++ b/lib/posixcompat/mkfifo.c
@@ -0,0 +1,7 @@
+#include <sys/stat.h>
+#include <assert.h>
+
+int mkfifo(const char *pathname, mode_t mode)
+{
+    assert(!"NYI");
+}
diff --git a/lib/posixcompat/pipe.c b/lib/posixcompat/pipe.c
index 34a9847..b454622 100644
--- a/lib/posixcompat/pipe.c
+++ b/lib/posixcompat/pipe.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2007, 2008, 2009, ETH Zurich.
+ * Copyright (c) 2007, 2008, 2009, 2013, ETH Zurich.
  * All rights reserved.
  *
  * This file is distributed under the terms in the attached LICENSE file.
@@ -12,6 +12,8 @@
 
 int pipe(int pipefd[2])
 {
-    USER_PANIC("pipe() NYI");
-    return (-1);
+    // XXX: Emulate pipe via a pair of AF_UNIX sockets
+    // This means they are bi-directional, but this is fine, as pipe()
+    // doesn't specify bi-directionality.
+    return socketpair(AF_UNIX, SOCK_STREAM, 0, pipefd);
 }
diff --git a/lib/posixcompat/pthreads.c b/lib/posixcompat/pthreads.c
new file mode 100644
index 0000000..62804d4
--- /dev/null
+++ b/lib/posixcompat/pthreads.c
@@ -0,0 +1,274 @@
+#include <pthread.h>
+#include <assert.h>
+#include <barrelfish/barrelfish.h>
+#include <errno.h>
+#include <string.h>
+
+typedef void (*destructor_fn_t)(void *);
+typedef void *(*start_fn_t)(void *);
+
+struct pthread_mutex {
+    struct thread_mutex mutex;
+    int locked;
+};
+
+struct pthread_cond {
+    struct thread_cond cond;
+};
+
+struct pthread {
+    struct thread *thread;
+    const void *keys[PTHREAD_KEYS_MAX];
+    start_fn_t start_fn;
+    void *arg;
+    void *retval;
+};
+
+static pthread_key_t key_index = 0;
+static struct thread_mutex key_mutex = THREAD_MUTEX_INITIALIZER;
+static destructor_fn_t destructors[PTHREAD_KEYS_MAX];
+
+static int start_pthread(void *arg)
+{
+    struct pthread *myself = arg;
+
+    // Initialize TLS
+    thread_set_tls_key(0, myself);
+
+    // Run the thread
+    myself->retval = myself->start_fn(myself->arg);
+
+    // Call all key destructors
+    for(pthread_key_t i = 0; i < key_index; i++) {
+        if(destructors[i] != NULL) {
+            destructors[i]((void *)myself->keys[i]);
+        }
+    }
+
+    // 'myself' data structure is freed when joined with this thread
+    return 0;
+}
+
+int pthread_create(pthread_t *pthread, const pthread_attr_t *attr,
+                   void *(*start_routine) (void *), void *arg)
+{
+    *pthread = malloc(sizeof(struct pthread));
+    assert(*pthread != NULL);
+    memset(*pthread, 0, sizeof(struct pthread));
+
+    // XXX: attributes are ignored.
+    (*pthread)->start_fn = start_routine;
+    (*pthread)->arg = arg;
+
+    // Start the thread
+    (*pthread)->thread = thread_create(start_pthread, *pthread);
+    return 0;
+}
+
+pthread_t pthread_self(void)
+{
+    pthread_t self = thread_get_tls_key(0);
+
+    // If NULL, we're the first thread, not created via pthreads.
+    // Create a pthread structure.
+    if(self == NULL) {
+        struct pthread *myself = malloc(sizeof(struct pthread));
+        assert(myself != NULL);
+        memset(myself, 0, sizeof(struct pthread));
+        myself->thread = thread_self();
+        thread_set_tls_key(0, myself);
+        self = myself;
+    }
+
+    return self;
+}
+
+void *pthread_getspecific(pthread_key_t key)
+{
+    if(key >= PTHREAD_KEYS_MAX) {
+        return NULL;
+    }
+
+    return (void *)pthread_self()->keys[key];
+}
+
+int pthread_setspecific(pthread_key_t key, const void *val)
+{
+    if(key >= PTHREAD_KEYS_MAX) {
+        return EINVAL;
+    }
+
+    pthread_self()->keys[key] = val;
+    return 0;
+}
+
+int pthread_attr_init(pthread_attr_t *attr)
+{
+    // No attributes
+    return 0;
+}
+
+static struct thread_mutex mutex_mutex = THREAD_MUTEX_INITIALIZER;
+
+int pthread_mutex_init(pthread_mutex_t *mutex,
+                       const pthread_mutexattr_t *attr)
+{
+    // XXX: Attributes ignored.
+    *mutex = malloc(sizeof(struct pthread_mutex));
+    if(*mutex == NULL) {
+        return -1;
+    }
+
+    thread_mutex_init(&(*mutex)->mutex);
+    (*mutex)->locked = 0;
+    return 0;
+}
+
+int pthread_mutex_destroy(pthread_mutex_t *mutex)
+{
+    if(*mutex != PTHREAD_MUTEX_INITIALIZER) {
+        free(*mutex);
+    }
+
+    return 0;
+}
+
+int pthread_mutex_lock(pthread_mutex_t *mutex)
+{
+    thread_mutex_lock(&mutex_mutex);
+
+    if(*mutex == PTHREAD_MUTEX_INITIALIZER) {
+        pthread_mutex_init(mutex, NULL);
+    }
+
+    (*mutex)->locked++;
+    thread_mutex_unlock(&mutex_mutex);
+    thread_mutex_lock(&(*mutex)->mutex);
+    return 0;
+}
+
+int pthread_mutex_unlock(pthread_mutex_t *mutex)
+{
+    thread_mutex_lock(&mutex_mutex);
+
+    if(*mutex == PTHREAD_MUTEX_INITIALIZER) {
+        pthread_mutex_init(mutex, NULL);
+    }
+
+    if((*mutex)->locked == 0) {
+        thread_mutex_unlock(&mutex_mutex);
+        return 0;
+    }
+
+    (*mutex)->locked--;
+    thread_mutex_unlock(&mutex_mutex);
+    thread_mutex_unlock(&(*mutex)->mutex);
+    return 0;
+}
+
+int pthread_mutex_trylock(pthread_mutex_t *mutex)
+{
+    thread_mutex_lock(&mutex_mutex);
+
+    if(*mutex == PTHREAD_MUTEX_INITIALIZER) {
+        pthread_mutex_init(mutex, NULL);
+    }
+
+    thread_mutex_unlock(&mutex_mutex);
+
+    int retval = (thread_mutex_trylock(&(*mutex)->mutex) ? 0 : EBUSY);
+
+    if(retval != EBUSY) {
+        thread_mutex_lock(&mutex_mutex);
+        (*mutex)->locked++;
+        thread_mutex_unlock(&mutex_mutex);
+    }
+
+    return retval;
+}
+
+int pthread_cond_init(pthread_cond_t *cond,
+			const pthread_condattr_t *attr)
+{
+    *cond = malloc(sizeof(struct pthread_cond));
+    if(*cond == NULL) {
+        return -1;
+    }
+
+    thread_cond_init(&(*cond)->cond);
+    return 0;
+}
+
+int pthread_cond_signal(pthread_cond_t *cond)
+{
+    thread_mutex_lock(&mutex_mutex);
+    if(*cond == PTHREAD_COND_INITIALIZER) {
+        pthread_cond_init(cond, NULL);
+    }
+    thread_mutex_unlock(&mutex_mutex);
+
+    thread_cond_signal(&(*cond)->cond);
+    return 0;
+}
+
+int pthread_cond_timedwait(pthread_cond_t *cond,
+                           pthread_mutex_t *mutex,
+                           const struct timespec *timeout)
+{
+    thread_mutex_lock(&mutex_mutex);
+    if(*cond == PTHREAD_COND_INITIALIZER) {
+        pthread_cond_init(cond, NULL);
+    }
+    if(*mutex == PTHREAD_MUTEX_INITIALIZER) {
+        pthread_mutex_init(mutex, NULL);
+    }
+    thread_mutex_unlock(&mutex_mutex);
+
+    assert(!"NYI");
+}
+
+int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex)
+{
+    thread_mutex_lock(&mutex_mutex);
+    if(*cond == PTHREAD_COND_INITIALIZER) {
+        pthread_cond_init(cond, NULL);
+    }
+    if(*mutex == PTHREAD_MUTEX_INITIALIZER) {
+        pthread_mutex_init(mutex, NULL);
+    }
+    thread_mutex_unlock(&mutex_mutex);
+
+    thread_cond_wait(&(*cond)->cond, &(*mutex)->mutex);
+    return 0;
+}
+
+int pthread_join(pthread_t thread, void **retval)
+{
+    errval_t err = thread_join(thread->thread, NULL);
+    assert(err_is_ok(err));
+
+    *retval = thread->retval;
+    free(thread);
+    return 0;
+}
+
+int pthread_key_create(pthread_key_t *key,
+                       void (*callback) (void *))
+{
+    int retval = 0;
+
+    thread_mutex_lock(&key_mutex);
+
+    if(key_index == PTHREAD_KEYS_MAX) {
+        retval = EAGAIN;
+        goto out;
+    }
+
+    *key = key_index;
+    destructors[key_index] = callback;
+    key_index++;
+
+ out:
+    thread_mutex_unlock(&key_mutex);
+    return retval;
+}
diff --git a/lib/posixcompat/read.c b/lib/posixcompat/read.c
index 4963fec..4639fb6 100644
--- a/lib/posixcompat/read.c
+++ b/lib/posixcompat/read.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2007, 2008, 2009, 2011, 2012, ETH Zurich.
+ * Copyright (c) 2007, 2008, 2009, 2011, 2013, ETH Zurich.
  * All rights reserved.
  *
  * This file is distributed under the terms in the attached LICENSE file.
@@ -21,13 +21,17 @@ int read(int fd, void *buf, size_t len)
     int ret;
     struct fdtab_entry *e = fdtab_get(fd);
 
-    switch (e->type) {
+    switch(e->type) {
     case FDTAB_TYPE_LWIP_SOCKET:
         lwip_mutex_lock();
         ret = lwip_read(e->fd, buf, len);
         lwip_mutex_unlock();
         break;
 
+    case FDTAB_TYPE_UNIX_SOCKET:
+        ret = recv(fd, buf, len, 0);
+        break;
+
     case FDTAB_TYPE_PTM:
         ret = ptm_read(fd, buf, len);
         break;
diff --git a/lib/posixcompat/readv.c b/lib/posixcompat/readv.c
index 1da7097..cca9f63 100644
--- a/lib/posixcompat/readv.c
+++ b/lib/posixcompat/readv.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012, ETH Zurich.
+ * Copyright (c) 2012, 2013, ETH Zurich.
  * All rights reserved.
  *
  * This file is distributed under the terms in the attached LICENSE file.
@@ -18,3 +18,9 @@ ssize_t readv(int fd, const struct iovec *iov, int iovcnt)
     assert(!"NYI");
     return -1;
 }
+
+ssize_t writev(int fd, const struct iovec *iov, int iovcnt)
+{
+    assert(!"NYI");
+    return -1;
+}
diff --git a/lib/posixcompat/select.c b/lib/posixcompat/select.c
index 93c15cc..f89b558 100644
--- a/lib/posixcompat/select.c
+++ b/lib/posixcompat/select.c
@@ -360,6 +360,11 @@ finish:
     }
 
 finish_no_ws_changed:
+    // Remove timeout from waitset if it was set
+    if(timeout != NULL) {
+        deferred_event_cancel(&timeout_event);
+    }
+
     err = waitset_destroy(&ws);
     if (err_is_fail(err)) {
         SELECT_DEBUG("Error destroying waitset.\n");
diff --git a/lib/posixcompat/setrlimit.c b/lib/posixcompat/setrlimit.c
new file mode 100644
index 0000000..7d44933
--- /dev/null
+++ b/lib/posixcompat/setrlimit.c
@@ -0,0 +1,29 @@
+#include <sys/resource.h>
+#include <assert.h>
+#include <string.h>
+#include "posixcompat.h"
+
+int setrlimit(int resource, const struct rlimit *rlim)
+{
+    POSIXCOMPAT_DEBUG("setrlimit(%d, %p) ignored.\n", resource, rlim);
+    return 0;
+}
+
+int getrlimit(int resource, struct rlimit *rlim)
+{
+    static struct rlimit infty = {
+        .rlim_cur = RLIM_INFINITY,
+        .rlim_max = RLIM_INFINITY,
+    };
+
+    POSIXCOMPAT_DEBUG("getrlimit(%d, %p) always returns infinity.\n", resource, rlim);
+    *rlim = infty;
+    return 0;
+}
+
+int getrusage(int who, struct rusage *usage)
+{
+    // XXX: No fields are supported
+    memset(usage, 0, sizeof(struct rusage));
+    return 0;
+}
diff --git a/lib/posixcompat/signal.c b/lib/posixcompat/signal.c
index 8e17411..702e50d 100644
--- a/lib/posixcompat/signal.c
+++ b/lib/posixcompat/signal.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2007, 2008, 2009, 2011, ETH Zurich.
+ * Copyright (c) 2007, 2008, 2009, 2011, 2013, ETH Zurich.
  * All rights reserved.
  *
  * This file is distributed under the terms in the attached LICENSE file.
@@ -110,3 +110,16 @@ int sigismember(const sigset_t *set, int signo)
     }
     return ((set->__bits[_SIG_WORD(signo)] & _SIG_BIT(signo)) ? 1 : 0);
 }
+
+int sigaction(int signum, const struct sigaction *act,
+              struct sigaction *oldact)
+{
+    POSIXCOMPAT_DEBUG("Warning: sigaction(%d, %p, %p) ignored\n",
+                      signum, act, oldact);
+    return 0;
+}
+
+int raise(int sig)
+{
+    assert(!"NYI");
+}
diff --git a/lib/posixcompat/sleep.c b/lib/posixcompat/sleep.c
new file mode 100644
index 0000000..74800d4
--- /dev/null
+++ b/lib/posixcompat/sleep.c
@@ -0,0 +1,16 @@
+#include <unistd.h>
+#include <barrelfish/barrelfish.h>
+#include <barrelfish/deferred.h>
+#include <assert.h>
+
+int usleep(useconds_t usec)
+{
+    errval_t err = barrelfish_usleep(usec);
+    assert(err_is_ok(err));
+    return 0;
+}
+
+unsigned int sleep(unsigned int seconds)
+{
+    return usleep((useconds_t)seconds * 1000000);
+}
diff --git a/lib/posixcompat/sockets.c b/lib/posixcompat/sockets.c
index 76e6e42..80e52e1 100644
--- a/lib/posixcompat/sockets.c
+++ b/lib/posixcompat/sockets.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011, 2012, ETH Zurich.
+ * Copyright (c) 2011, 2012, 2013, ETH Zurich.
  * All rights reserved.
  *
  * This file is distributed under the terms in the attached LICENSE file.
@@ -11,6 +11,7 @@
 #include <sys/socket.h>
 #include <netdb.h>
 #include <errno.h>
+#include <unistd.h>
 #include <barrelfish/barrelfish.h>
 #include <lwip/sys.h>
 #include "posixcompat.h"
@@ -31,9 +32,12 @@ ssize_t recv(int sockfd, void *buf, size_t len, int flags)
             // XXX: Don't support flags
             assert(flags == 0);
 
+            thread_mutex_lock(&us->mutex);
+
             if(us->passive
                || us->u.active.mode != _UNIX_SOCKET_MODE_CONNECTED) {
                 errno = ENOTCONN;
+                thread_mutex_unlock(&us->mutex);
                 return -1;
             }
 
@@ -41,6 +45,7 @@ ssize_t recv(int sockfd, void *buf, size_t len, int flags)
                 // No more data
                 if(us->nonblocking) {
                     errno = EAGAIN;
+                    thread_mutex_unlock(&us->mutex);
                     return -1;
                 } else {
                     struct waitset ws;
@@ -97,6 +102,7 @@ ssize_t recv(int sockfd, void *buf, size_t len, int flags)
                 }
             }
 
+            thread_mutex_unlock(&us->mutex);
             return recved;
         }
 
@@ -119,8 +125,27 @@ ssize_t recv(int sockfd, void *buf, size_t len, int flags)
 ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,
                  struct sockaddr *src_addr, socklen_t *addrlen)
 {
-    assert(!"NYI");
-    return -1;
+    struct fdtab_entry *e = fdtab_get(sockfd);
+
+    switch(e->type) {
+    case FDTAB_TYPE_UNIX_SOCKET:
+        assert(!"NYI");
+        break;
+
+    case FDTAB_TYPE_LWIP_SOCKET:
+        lwip_mutex_lock();
+        ssize_t ret = lwip_recvfrom(e->fd, buf, len, flags, src_addr, addrlen);
+        lwip_mutex_unlock();
+        return ret;
+
+    case FDTAB_TYPE_AVAILABLE:
+        errno = EBADF;
+        return -1;
+
+    default:
+        errno = ENOTSOCK;
+        return -1;
+    }
 }
 
 static void unixsock_sent(void *arg)
@@ -146,15 +171,19 @@ ssize_t send(int sockfd, const void *buf, size_t len, int flags)
             // XXX: Don't support flags
             assert(flags == 0);
 
+            thread_mutex_lock(&us->mutex);
+
             if(us->passive
                || us->u.active.mode != _UNIX_SOCKET_MODE_CONNECTED) {
                 errno = ENOTCONN;
+                thread_mutex_unlock(&us->mutex);
                 return -1;
             }
 
             if(us->send_buf != NULL) {
                 if(us->nonblocking) {
                     errno = EAGAIN;
+                    thread_mutex_unlock(&us->mutex);
                     return -1;
                 } else {
                     assert(!"NYI");
@@ -175,6 +204,7 @@ ssize_t send(int sockfd, const void *buf, size_t len, int flags)
                 send(us->u.active.binding, ec, us->send_buf, len);
             if(err_is_fail(err)) {
                 USER_PANIC_ERR(err, "unixsock->send");
+                thread_mutex_unlock(&us->mutex);
                 return -1;
             }
 
@@ -210,6 +240,7 @@ ssize_t send(int sockfd, const void *buf, size_t len, int flags)
             }
 
             // XXX: We send all or nothing
+            thread_mutex_unlock(&us->mutex);
             return len;
         }
 
@@ -232,8 +263,79 @@ ssize_t send(int sockfd, const void *buf, size_t len, int flags)
 ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,
                const struct sockaddr *dest_addr, socklen_t addrlen)
 {
-    assert(!"NYI");
-    return -1;
+    struct fdtab_entry *e = fdtab_get(sockfd);
+
+    switch(e->type) {
+    case FDTAB_TYPE_UNIX_SOCKET:
+        assert(!"NYI");
+        break;
+
+    case FDTAB_TYPE_LWIP_SOCKET:
+        lwip_mutex_lock();
+        ssize_t ret = lwip_sendto(e->fd, buf, len, flags, dest_addr, addrlen);
+        lwip_mutex_unlock();
+        return ret;
+
+    case FDTAB_TYPE_AVAILABLE:
+        errno = EBADF;
+        return -1;
+
+    default:
+        errno = ENOTSOCK;
+        return -1;
+    }
+}
+
+ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags)
+{
+    struct fdtab_entry *e = fdtab_get(sockfd);
+
+    switch(e->type) {
+    case FDTAB_TYPE_UNIX_SOCKET:
+        assert(!"NYI");
+        break;
+
+    case FDTAB_TYPE_LWIP_SOCKET:
+        assert(msg != NULL);
+        assert(msg->msg_control == NULL);
+        assert(msg->msg_controllen == 0);
+
+#if 0
+        // XXX: Copy all buffers into one. Should instead have an lwIP interface for this.
+        size_t totalsize = 0;
+        for(int i = 0; i < msg->msg_iovlen; i++) {
+            totalsize += msg->msg_iov[i].iov_len;
+        }
+
+        char *buf = malloc(totalsize);
+
+        size_t pos = 0;
+        for(int i = 0; i < msg->msg_iovlen; i++) {
+            memcpy(&buf[pos], msg->msg_iov[i].iov_base, msg->msg_iov[i].iov_len);
+            pos += msg->msg_iov[i].iov_len;
+        }
+
+        lwip_mutex_lock();
+        ssize_t ret = lwip_sendto(e->fd, buf, totalsize, flags,
+                                  msg->msg_name, msg->msg_namelen);
+        lwip_mutex_unlock();
+        free(buf);
+#else
+        lwip_mutex_lock();
+        ssize_t ret = lwip_sendmsg(e->fd, msg, flags);
+        lwip_mutex_unlock();
+#endif
+
+        return ret;
+
+    case FDTAB_TYPE_AVAILABLE:
+        errno = EBADF;
+        return -1;
+
+    default:
+        errno = ENOTSOCK;
+        return -1;
+    }
 }
 
 int socket(int domain, int type, int protocol)
@@ -270,6 +372,8 @@ int socket(int domain, int type, int protocol)
 
         e.type = FDTAB_TYPE_UNIX_SOCKET;
         e.handle = us;
+        e.inherited = false;
+        e.epoll_fd = -1;
         break;
 
     case AF_INET:
@@ -284,6 +388,8 @@ int socket(int domain, int type, int protocol)
 			
             e.type = FDTAB_TYPE_LWIP_SOCKET;
             e.fd = fd;
+            e.inherited = false;
+            e.epoll_fd = -1;
         }
         break;
 
@@ -330,7 +436,7 @@ int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen)
         int ret = lwip_bind(e->fd, addr, addrlen);
         lwip_mutex_unlock();
         return ret;
-		
+
     default:
         return -1;
     }
@@ -522,6 +628,8 @@ int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen)
                     struct fdtab_entry newe;
                     newe.type = FDTAB_TYPE_LWIP_SOCKET;
                     newe.fd = newfd;
+                    newe.inherited = false;
+                    newe.epoll_fd = -1;
 
                     newfd = fdtab_alloc(&newe);
                     POSIXCOMPAT_DEBUG("accept(%d, _, _) as fd %d\n", sockfd, newfd);
@@ -578,11 +686,11 @@ int getsockopt(int sockfd, int level, int optname, void *restrict optval,
             }
         }
 
-	case FDTAB_TYPE_LWIP_SOCKET:
-		lwip_mutex_lock();
-		int ret = lwip_getsockopt(e->fd, level, optname, optval, optlen);
-		lwip_mutex_unlock();
-		return ret;
+    case FDTAB_TYPE_LWIP_SOCKET:
+        lwip_mutex_lock();
+        int ret = lwip_getsockopt(e->fd, level, optname, optval, optlen);
+        lwip_mutex_unlock();
+        return ret;
 
     case FDTAB_TYPE_AVAILABLE:
         errno = EBADF;
@@ -600,7 +708,15 @@ int setsockopt(int sockfd, int level, int optname, const void *optval,
                socklen_t optlen)
 {
     struct fdtab_entry *e = fdtab_get(sockfd);
-    return lwip_setsockopt(e->fd, level, optname, optval, optlen);
+
+    switch(e->type) {
+    case FDTAB_TYPE_LWIP_SOCKET:
+        return lwip_setsockopt(e->fd, level, optname, optval, optlen);
+
+    default:
+        assert(!"NYI");
+        break;
+    }
 }
 
 static void unixsock_bound(void *st, errval_t err, struct unixsock_binding *b)
@@ -684,11 +800,11 @@ int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen)
             return 0;
         }
 
-	case FDTAB_TYPE_LWIP_SOCKET:
-            lwip_mutex_lock();
-            int ret =  lwip_connect(e->fd, addr, addrlen);
-            lwip_mutex_unlock();
-            return ret;
+    case FDTAB_TYPE_LWIP_SOCKET:
+        lwip_mutex_lock();
+        int ret =  lwip_connect(e->fd, addr, addrlen);
+        lwip_mutex_unlock();
+        return ret;
 
     default:
         return -1;
@@ -826,6 +942,55 @@ int shutdown(int sockfd, int how)
  */
 int socketpair(int domain, int type, int protocol, int sockfd[2])
 {
-    assert(!"NYI");
-    return -1;
+    int sock;
+    struct sockaddr_un tmpaddr = {
+        .sun_family = AF_UNIX,
+    };
+
+    // Only support AF_UNIX sockets
+    if(domain != AF_UNIX) {
+        errno = EOPNOTSUPP;
+        return -1;
+    }
+
+    snprintf(tmpaddr.sun_path, 104, "/tmp/posixcompat.tmp.socket.%" PRIu64, rdtsc());
+
+    if((sockfd[0] = socket(domain, type, protocol)) == -1) {
+        return -1;
+    }
+    if((sockfd[1] = socket(domain, type, protocol)) == -1) {
+        return -1;
+    }
+
+    if(bind(sockfd[0], (struct sockaddr *)&tmpaddr, sizeof(tmpaddr)) != 0) {
+        close(sockfd[0]);
+        close(sockfd[1]);
+        return -1;
+    }
+
+    if(listen(sockfd[0], 1) != 0) {
+        close(sockfd[0]);
+        close(sockfd[1]);
+        return -1;
+    }
+
+    if(connect(sockfd[1], (struct sockaddr *)&tmpaddr, sizeof(tmpaddr)) != 0) {
+        close(sockfd[0]);
+        close(sockfd[1]);
+        return -1;
+    }
+
+    if((sock = accept(sockfd[0], NULL, NULL)) == -1) {
+        close(sockfd[0]);
+        close(sockfd[1]);
+        return -1;
+    }
+
+    // Delete listening socket and return connected socket
+    close(sockfd[0]);
+    sockfd[0] = sock;
+
+    // XXX: Should delete temporary socket name
+
+    return 0;
 }
diff --git a/lib/posixcompat/unixsock.h b/lib/posixcompat/unixsock.h
index 6361dc4..338eae6 100644
--- a/lib/posixcompat/unixsock.h
+++ b/lib/posixcompat/unixsock.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2010, 2011, ETH Zurich.
+ * Copyright (c) 2010, 2011, 2013, ETH Zurich.
  * All rights reserved.
  *
  * This file is distributed under the terms in the attached LICENSE file.
@@ -35,6 +35,7 @@ struct _unix_socket {
     int protocol;       // Protocol subtype == 0
     bool passive;       // true iff socket is passive (used to listen)
     bool nonblocking;   // True iff socket is non-blocking
+    struct thread_mutex mutex;  // Mutex for this socket
 
     // Local and peer Sockaddr (includes filename)
     struct sockaddr_un sockaddr, peer;
diff --git a/lib/posixcompat/wait.c b/lib/posixcompat/wait.c
index 38f9f53..ec28673 100644
--- a/lib/posixcompat/wait.c
+++ b/lib/posixcompat/wait.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011, ETH Zurich.
+ * Copyright (c) 2011, 2013, ETH Zurich.
  * All rights reserved.
  *
  * This file is distributed under the terms in the attached LICENSE file.
@@ -37,22 +37,22 @@ pid_t waitpid(pid_t pid, int *status, int options)
             if(children[i] != 0) {
                 break;
             }
+        }
 
-            if(i == MAX_CHILDREN) {
-                errno = ECHILD;
-                return -1;
-            }
+        if(i == MAX_CHILDREN) {
+            errno = ECHILD;
+            return -1;
         }
     } else {
         for(i = 0; i < MAX_CHILDREN; i++) {
             if(children[i] == pid) {
                 break;
             }
+        }
 
-            if(i == MAX_CHILDREN) {
-                errno = ECHILD;
-                return -1;
-            }
+        if(i == MAX_CHILDREN) {
+            errno = ECHILD;
+            return -1;
         }
     }
 
diff --git a/lib/posixcompat/write.c b/lib/posixcompat/write.c
index 83eff6a..59f51b1 100644
--- a/lib/posixcompat/write.c
+++ b/lib/posixcompat/write.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2007, 2008, 2009, 2011, 2012, ETH Zurich.
+ * Copyright (c) 2007, 2008, 2009, 2011, 2013, ETH Zurich.
  * All rights reserved.
  *
  * This file is distributed under the terms in the attached LICENSE file.
@@ -22,14 +22,17 @@ int write(int fd, const void *buf, size_t len)
     int ret;
     struct fdtab_entry *e = fdtab_get(fd);
 
-    switch (e->type)
-    {
+    switch(e->type) {
     case FDTAB_TYPE_LWIP_SOCKET:
         lwip_mutex_lock();
         ret = lwip_write(e->fd, buf, len);
         lwip_mutex_unlock();
         break;
 
+    case FDTAB_TYPE_UNIX_SOCKET:
+        ret = send(fd, buf, len, 0);
+        break;
+
     case FDTAB_TYPE_PTM:
         ret = ptm_write(fd, buf, len);
         break;
@@ -40,6 +43,7 @@ int write(int fd, const void *buf, size_t len)
 
     default:
         ret = vfsfd_write(fd, buf, len);
+        break;
     }
 
     return ret;
diff --git a/lib/skb/skb_functions.c b/lib/skb/skb_functions.c
index d694149..f8cd30d 100644
--- a/lib/skb/skb_functions.c
+++ b/lib/skb/skb_functions.c
@@ -18,8 +18,8 @@
 #include <skb/skb.h>
 #include "skb_debug.h"
 
-#define BUFFER_SIZE 16384
-#define OUTPUT_SIZE 16384
+#define BUFFER_SIZE (16384 * 2)
+#define OUTPUT_SIZE (16384 * 2)
 
 /* XXX: The following static chars make the skb connection not thread
    safe and we probably don't want to put them in the per dispatcher
diff --git a/lib/spawndomain/arch/x86/spawn_arch.c b/lib/spawndomain/arch/x86/spawn_arch.c
index b63c85d..05b3fc0 100644
--- a/lib/spawndomain/arch/x86/spawn_arch.c
+++ b/lib/spawndomain/arch/x86/spawn_arch.c
@@ -165,6 +165,9 @@ static errval_t elf_allocate(void *state, genvaddr_t base, size_t size,
         }
     }
 
+    si->vregion[si->vregions] = vregion;
+    si->base[si->vregions++] = base;
+
     genvaddr_t genvaddr = vregion_get_base_addr(vregion) + base_offset;
     *retbase = (void*)vspace_genvaddr_to_lvaddr(genvaddr);
     return SYS_ERR_OK;
@@ -181,6 +184,7 @@ errval_t spawn_arch_load(struct spawninfo *si,
 
     // Reset the elfloader_slot
     si->elfload_slot = 0;
+    si->vregions = 0;
 
     struct capref cnode_cap = {
         .cnode = si->rootcn,
diff --git a/lib/spawndomain/spawn.c b/lib/spawndomain/spawn.c
index 9a3989b..d32e028 100644
--- a/lib/spawndomain/spawn.c
+++ b/lib/spawndomain/spawn.c
@@ -723,6 +723,37 @@ errval_t spawn_load_image(struct spawninfo *si, lvaddr_t binary,
         return err_push(err, SPAWN_ERR_SETUP_ARGCN);
     }
  
+    // Add vspace-pspace mapping to environment
+    char envstr[2048];
+    snprintf(envstr, 2048, "ARRAKIS_PMAP=");
+    for(int i = 0; i < si->vregions; i++) {
+        struct memobj_anon *m = (struct memobj_anon *)si->vregion[i]->memobj;
+        assert(m->m.type == ANONYMOUS);
+        for(struct memobj_frame_list *f = m->frame_list; f != NULL; f = f->next) {
+            struct frame_identity id;
+            err = invoke_frame_identify(f->frame, &id);
+            assert(err_is_ok(err));
+
+            char str[128];
+            snprintf(str, 128, "%" PRIxGENVADDR ":%" PRIxGENPADDR ":%zx ", si->base[i] + f->offset, id.base, f->size);
+            strcat(envstr, str);
+        }
+    }
+
+    char **myenv = (char **)envp;
+    for(int i = 0; i < MAX_ENVIRON_VARS; i++) {
+        if(i + 1 == MAX_ENVIRON_VARS) {
+            printf("spawnd: Couldn't set environemnt. Out of variables!\n");
+            abort();
+        }
+
+        if(myenv[i] == NULL) {
+            myenv[i] = envstr;
+            myenv[i+1] = NULL;
+            break;
+        }
+    }
+
     /* Setup cmdline args */
     err = spawn_setup_env(si, argv, envp);
     if (err_is_fail(err)) {
diff --git a/lib/vfs/Hakefile b/lib/vfs/Hakefile
index 397d52f..24abd53 100644
--- a/lib/vfs/Hakefile
+++ b/lib/vfs/Hakefile
@@ -34,7 +34,8 @@
                   cFiles = [ "vfs.c", "vfs_path.c", "fopen.c", "vfs_ramfs.c",
                              "cache.c", "vfs_blockdevfs.c",
                              "vfs_blockdevfs_ahci.c", "vfs_blockdevfs_ata.c",
-                             "vfs_cache.c", "vfs_fat.c", "vfs_fat_conv.c"
+                             "vfs_cache.c", "vfs_fat.c", "vfs_fat_conv.c",
+                             "fdtab.c", "vfs_fd.c"
                            ],
                   addCFlags = [ "-DDISABLE_NFS" ],
                   mackerelDevices = [ "ata_identify", "fat_bpb", "fat16_ebpb",
diff --git a/lib/vfs/vfs_fd.c b/lib/vfs/vfs_fd.c
index 76f4494..aece30a 100644
--- a/lib/vfs/vfs_fd.c
+++ b/lib/vfs/vfs_fd.c
@@ -75,6 +75,7 @@ int vfsfd_open(const char *pathname, int flags)
     struct fdtab_entry e = {
         .type = FDTAB_TYPE_FILE,
         .handle = vh,
+        .epoll_fd = -1,
     };
     int fd = fdtab_alloc(&e);
     VFSFD_DEBUG("open(%s) as fd %d\n", pathname, fd);
diff --git a/tools/debug.gdb b/tools/debug.gdb
index 6925d38..5f59ff6 100644
--- a/tools/debug.gdb
+++ b/tools/debug.gdb
@@ -1,5 +1,5 @@
 ##########################################################################
-# Copyright (c) 2007, 2008, 2009, ETH Zurich.
+# Copyright (c) 2007, 2008, 2009, 2013, ETH Zurich.
 # All rights reserved.
 #
 # This file is distributed under the terms in the attached LICENSE file.
@@ -13,6 +13,19 @@ define debug_hw
   target remote | console -f $arg0
 end
 
+# Resets kernel symbols previously set with debug_kernel_at.
+# Used when context switching to a different user binary.
+define reset_kernel_symbols_fn
+  file $arg0
+  symbol-file
+  add-symbol-file $arg0 $text_addr -s .rodata $rodata_addr -s .data $data_addr -s .data.rel $data_rel_addr -s .data.rel.local $data_rel_local_addr -s .bss $bss_addr
+end
+
+# Helper function that uses the stored kernel filename.
+define reset_kernel_symbols
+  source barrelfish_reset_kernel_symbols.tmp
+end
+
 # Command to debug kernel at an arbitrary location. $arg0 specifies
 # kernel binary file name. $arg1 specifies position of kernel in
 # memory (kernel prints this at startup).
@@ -30,7 +43,17 @@ define debug_kernel_at
   set $data_rel_local_addr = $arg1 + $data_rel_local_offset
   set $bss_addr = $arg1 + $bss_offset
 
-  file $arg0
-  symbol-file
-  add-symbol-file $arg0 $text_addr -s .rodata $rodata_addr -s .data $data_addr -s .data.rel $data_rel_addr -s .data.rel.local $data_rel_local_addr -s .bss $bss_addr
+  shell echo reset_kernel_symbols_fn $arg0 > barrelfish_reset_kernel_symbols.tmp
+  reset_kernel_symbols
+end
+
+define get_section_start
+  shell echo set \$cur_section_start = 0x`objdump -h $arg1 | awk "\\$2 == \"$arg0\" { print \\$4 }"` > barrelfish_debug.tmp
+  source barrelfish_debug.tmp
+end
+
+define switch-user-binary
+  reset_kernel_symbols
+  get_section_start .text $arg0
+  add-symbol-file $arg0 $cur_section_start
 end
diff --git a/tools/debug.sh b/tools/debug.sh
index 7498585..1c916df 100755
--- a/tools/debug.sh
+++ b/tools/debug.sh
@@ -1,7 +1,7 @@
 #!/bin/bash
 
 ##########################################################################
-# Copyright (c) 2007, 2008, 2009, 2010, ETH Zurich.
+# Copyright (c) 2007, 2008, 2009, 2010, 2013, ETH Zurich.
 # All rights reserved.
 #
 # This file is distributed under the terms in the attached LICENSE file.
@@ -43,7 +43,7 @@ target remote localhost:$PORT
 EOF
 
 QEMU_INVOCATION="${QEMU_CMD} -serial $SERIAL_OUTPUT -gdb tcp::$PORT -S -daemonize -pidfile $PIDFILE"
-${QEMU_INVOCATION}
+eval ${QEMU_INVOCATION}
 if [ $? -eq 0 ] ; then 
     stty sane
     trap '' SIGINT
diff --git a/tools/elver/elver.c b/tools/elver/elver.c
index 741f663..f1057f0 100644
--- a/tools/elver/elver.c
+++ b/tools/elver/elver.c
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright (c) 2007, 2008, 2009, 2010, ETH Zurich.
+ * Copyright (c) 2007, 2008, 2009, 2010, 2013, ETH Zurich.
  * All rights reserved.
  *
  * This file is distributed under the terms in the attached LICENSE file.
@@ -244,6 +244,7 @@ static void set_elf_headers(uint32_t base)
     multiboot_info->syms.elf.size = head->e_shentsize;
     multiboot_info->syms.elf.addr = base + head->e_shoff;
     multiboot_info->syms.elf.shndx = head->e_shstrndx;
+    multiboot_info->flags |= MULTIBOOT_INFO_FLAG_HAS_ELF_SYMS;
 }
 
 int startup(uint32_t magic, struct multiboot_info *mb);
diff --git a/tools/harness/machines/uw.py b/tools/harness/machines/uw.py
new file mode 100644
index 0000000..cbf4d9d
--- /dev/null
+++ b/tools/harness/machines/uw.py
@@ -0,0 +1,155 @@
+##########################################################################
+# Copyright (c) 2009-2011, 2013, ETH Zurich.
+# All rights reserved.
+#
+# This file is distributed under the terms in the attached LICENSE file.
+# If you do not find this file, copies can be found by writing to:
+# ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich. Attn: Systems Group.
+##########################################################################
+
+import sys, os, signal, time, getpass, subprocess, socket, pty
+import debug, machines, uw_machinedata
+from machines import Machine, MachineLockedError
+
+TFTP_PATH='/var/lib/tftpboot'
+TOOLS_PATH='/usr/local/bin'
+RACKBOOT=os.path.join(TOOLS_PATH, 'rackboot.sh')
+RACKPOWER=os.path.join(TOOLS_PATH, 'rackpower')
+
+class UWMachine(Machine):
+    _uw_machines = uw_machinedata.machines
+
+    def __init__(self, options):
+        super(UWMachine, self).__init__(options)
+        self.lockprocess = None
+        self.masterfd = None
+
+    def get_bootarch(self):
+        b = self._uw_machines[self.name]['bootarch']
+        assert(b in self.get_buildarchs())
+        return b
+
+    def get_machine_name(self):
+        return self._uw_machines[self.name]['machine_name']
+
+    def get_buildarchs(self):
+        return self._uw_machines[self.name]['buildarchs']
+
+    def get_ncores(self):
+        return self._uw_machines[self.name]['ncores']
+
+    def get_cores_per_socket(self):
+        return self._uw_machines[self.name]['cores_per_socket']
+
+    def get_tickrate(self):
+        return self._uw_machines[self.name]['tickrate']
+
+    def get_perfcount_type(self):
+        return self._uw_machines[self.name]['perfcount_type']
+
+    def get_kernel_args(self):
+        return self._uw_machines[self.name].get('kernel_args')
+
+    def get_boot_timeout(self):
+        return self._uw_machines[self.name].get('boot_timeout')
+
+    def get_hostname(self):
+        return self.get_machine_name() + '.cs.washington.edu'
+
+    def get_ip(self):
+        return socket.gethostbyname(self.get_hostname())
+
+    def get_tftp_dir(self):
+        user = getpass.getuser()
+        return os.path.join(TFTP_PATH, user, self.name + "_harness")
+
+    def _write_menu_lst(self, data, path):
+        debug.verbose('writing %s' % path)
+        debug.debug(data)
+        f = open(path, 'w')
+        f.write(data)
+        f.close()
+
+    def _set_menu_lst(self, relpath):
+        ip_menu_name = os.path.join(TFTP_PATH, "menu.lst." + self.get_ip())
+        debug.verbose('relinking %s to %s' % (ip_menu_name, relpath))
+        os.remove(ip_menu_name)
+        os.symlink(relpath, ip_menu_name)
+
+    def set_bootmodules(self, modules):
+        fullpath = os.path.join(self.get_tftp_dir(), 'menu.lst')
+        relpath = os.path.relpath(fullpath, TFTP_PATH)
+        tftppath = '/' + os.path.relpath(self.get_tftp_dir(), TFTP_PATH)
+        self._write_menu_lst(modules.get_menu_data(tftppath), fullpath)
+        self._set_menu_lst(relpath)
+
+    def lock(self):
+        """Use conserver to lock the machine."""
+
+        # find out current status of console
+        debug.verbose('executing "console -i %s" to check state' %
+                      self.get_machine_name())
+        proc = subprocess.Popen(["console", "-i", self.get_machine_name()],
+                                stdout=subprocess.PIPE)
+        line = proc.communicate()[0]
+        assert(proc.returncode == 0)
+
+        # check that nobody else has it open for writing
+        myuser = getpass.getuser()
+        parts = line.strip().split(':')
+        conname, child, contype, details, users, state = parts[:6]
+        if users:
+            for userinfo in users.split(','):
+                mode, username, host, port = userinfo.split('@')[:4]
+                if 'w' in mode and username != myuser:
+                    raise MachineLockedError # Machine is not free
+
+        # run a console in the background to 'hold' the lock and read output
+        debug.verbose('starting "console %s"' % self.get_machine_name())
+        # run on a PTY to work around terminal mangling code in console
+        (self.masterfd, slavefd) = pty.openpty()
+        self.lockprocess = subprocess.Popen(["console", self.get_machine_name()],
+                                            close_fds=True,
+                                            stdout=slavefd, stdin=slavefd)
+        os.close(slavefd)
+        # XXX: open in binary mode with no buffering
+        # otherwise select.select() may block when there is data in the buffer
+        self.console_out = os.fdopen(self.masterfd, 'rb', 0)
+
+    def unlock(self):
+        if self.lockprocess is None:
+            return # noop
+        debug.verbose('quitting console process (%d)' % self.lockprocess.pid)
+        # os.kill(self.lockprocess.pid, signal.SIGTERM)
+        os.write(self.masterfd, "\x05c.")
+        self.lockprocess.wait()
+        self.lockprocess = None
+        self.masterfd = None
+
+    def __rackboot(self, args):
+        debug.checkcmd([RACKBOOT] + args + [self.get_machine_name()])
+
+    def setup(self):
+        self.__rackboot(["-b", "-n"])
+
+    def __rackpower(self, arg):
+        try:
+            debug.checkcmd([RACKPOWER, arg, self.get_machine_name()])
+        except subprocess.CalledProcessError:
+            debug.warning("rackpower %s %s failed" %
+                          (arg, self.get_machine_name()))
+
+    def reboot(self):
+        self.__rackpower('-r')
+
+    def shutdown(self):
+        self.__rackpower('-d')
+
+    def get_output(self):
+        return self.console_out
+
+
+for n in sorted(UWMachine._uw_machines.keys()):
+    class TmpMachine(UWMachine):
+        name = n
+    machines.add_machine(TmpMachine)
diff --git a/tools/harness/machines/uw_machinedata.py b/tools/harness/machines/uw_machinedata.py
new file mode 100644
index 0000000..f582042
--- /dev/null
+++ b/tools/harness/machines/uw_machinedata.py
@@ -0,0 +1,27 @@
+##########################################################################
+# Copyright (c) 2009, 2013, ETH Zurich.
+# All rights reserved.
+#
+# This file is distributed under the terms in the attached LICENSE file.
+# If you do not find this file, copies can be found by writing to:
+# ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich. Attn: Systems Group.
+##########################################################################
+
+machines = {
+    'bigfish': {'ncores'      : 64,
+                'machine_name' : 'bigfish',
+                'bootarch' : 'x86_64',
+                'buildarchs' : ['x86_64', 'x86_32'],
+                'cores_per_socket': 12,
+                'perfcount_type': 'amd10',
+                'tickrate'    : 1600,
+                'boot_timeout': 360},
+    'bigfish-32': {'ncores'      : 64,
+                   'machine_name' : 'bigfish',
+                   'bootarch' : 'x86_32',
+                   'buildarchs' : ['x86_64', 'x86_32'],
+                   'cores_per_socket': 12,
+                   'perfcount_type': 'amd10',
+                   'tickrate'    : 1600,
+                   'boot_timeout': 360},
+    }
diff --git a/tools/harness/siteconfig/__init__.py b/tools/harness/siteconfig/__init__.py
index 7b472ca..2f1a4e7 100644
--- a/tools/harness/siteconfig/__init__.py
+++ b/tools/harness/siteconfig/__init__.py
@@ -1,5 +1,5 @@
 ##########################################################################
-# Copyright (c) 2009, ETH Zurich.
+# Copyright (c) 2009, 2013, ETH Zurich.
 # All rights reserved.
 #
 # This file is distributed under the terms in the attached LICENSE file.
@@ -28,6 +28,8 @@ if os.path.isdir('/home/netos') and socket.getfqdn().endswith('.ethz.ch'):
     import eth
 elif socket.getfqdn().endswith('.europe.corp.microsoft.com'):
     import msrc
+elif socket.getfqdn().endswith('triangle') or socket.getfqdn().endswith('.cs.washington.edu'):
+    import uw
 else:
     debug.warning("unable to guess site, using ETH... expect breakage!")
     import eth
diff --git a/tools/harness/siteconfig/uw.py b/tools/harness/siteconfig/uw.py
new file mode 100644
index 0000000..1e2b295
--- /dev/null
+++ b/tools/harness/siteconfig/uw.py
@@ -0,0 +1,40 @@
+##########################################################################
+# Copyright (c) 2009, 2013, ETH Zurich.
+# All rights reserved.
+#
+# This file is distributed under the terms in the attached LICENSE file.
+# If you do not find this file, copies can be found by writing to:
+# ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich. Attn: Systems Group.
+##########################################################################
+
+import getpass
+import siteconfig
+
+LOADGEN_HOSTS = []
+
+class UW(siteconfig.BaseSite):
+    # site-specific configuration variables for UW
+    WEBSERVER_NFS_HOST = 'triangle'
+    # NFS_SERVER_HOST = 'tomme1.in.barrelfish.org'
+    WEBSERVER_NFS_PATH = '/home/netos/notexist'
+    WEBSERVER_LOCAL_PATH = WEBSERVER_NFS_PATH
+    HTTPERF_PATH = 'httperf.notexist'
+    HTTPERF_MAXCLIENTS = len(LOADGEN_HOSTS * 2) # max number of load generators
+    IPBENCH_PATH = 'ipbench.notexist'
+    IPBENCHD_PATH = 'ipbenchd.notexist'
+    SSH_ARGS='-x -o StrictHostKeyChecking=no -o ControlPath=none'
+
+    def __init__(self):
+        self._loadgen_hosts = LOADGEN_HOSTS
+
+    def get_load_generator(self):
+        # take the first host, but put it on the back in case we
+        # need more clients than available hosts (ie. rotate the list)
+        host = self._loadgen_hosts.pop(0)
+        self._loadgen_hosts.append(host)
+        return getpass.getuser(), host
+
+siteconfig.site = UW()
+
+# also cause the UW machines to be loaded/initialised
+import machines.uw
diff --git a/usr/acpi/acpi_service.c b/usr/acpi/acpi_service.c
index 80ff97c..c20fa02 100644
--- a/usr/acpi/acpi_service.c
+++ b/usr/acpi/acpi_service.c
@@ -26,11 +26,12 @@
 static void mm_alloc_range_proxy_handler(struct acpi_binding* b, uint8_t sizebits,
 		                                 genpaddr_t minbase, genpaddr_t maxlimit)
 {
-    ACPI_DEBUG("mm_alloc_range_proxy_handler: sizebits: %d, minbase: %lu maxlimit: %lu\n",
-               sizebits, minbase, maxlimit);
+    ACPI_DEBUG("mm_alloc_range_proxy_handler: sizebits: %d, minbase: 0x%lx maxlimit: 0x%lx\n",
+	       sizebits, minbase, maxlimit);
 
     struct capref devframe = NULL_CAP;
-    errval_t err = mm_alloc_range(&pci_mm_physaddr, sizebits, minbase, maxlimit, &devframe, NULL);
+    /* errval_t err = mm_alloc_range(&pci_mm_physaddr, sizebits, minbase, maxlimit, &devframe, NULL); */
+    errval_t err = mm_realloc_range(&pci_mm_physaddr, sizebits, minbase, &devframe);
     if (err_is_fail(err)) {
     	DEBUG_ERR(err, "mm realloc range failed...\n");
     }
diff --git a/usr/arrakismon/Hakefile b/usr/arrakismon/Hakefile
new file mode 100644
index 0000000..2235abd
--- /dev/null
+++ b/usr/arrakismon/Hakefile
@@ -0,0 +1,26 @@
+--------------------------------------------------------------------------
+-- Copyright (c) 2007-2009, 2013, ETH Zurich.
+-- All rights reserved.
+--
+-- This file is distributed under the terms in the attached LICENSE file.
+-- If you do not find this file, copies can be found by writing to:
+-- ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich. Attn: Systems Group.
+--
+-- Hakefile for /usr/vmkitmon
+--
+--------------------------------------------------------------------------
+
+[ build application { target = "arrakismon",
+                      cFiles = [ "vmkitmon.c", "guest.c", "realmode.c",
+                                 "hdd.c", "keyboard.c", "console.c",
+                                 "apic.c", "lpc.c", "pc16550d.c", "pci.c",
+				 "pci_host.c", "pci_hostbridge.c", "ps.c" ],
+                      mackerelDevices = [ "amd_vmcb", "lpc_timer",
+                                          "pc16550d_mem", "pci_hdr0_mem" ],
+                      addLibraries = libDeps [ "spawndomain", "x86emu", "vfs", "elf", "timer", "lwip" ],
+                      flounderDefs = [ "monitor", "monitor_blocking", "arrakis" ],
+                      flounderExtraDefs = [ ("monitor_blocking",["rpcclient"]) ],
+  		      flounderBindings = [ "arrakis" ],
+                      architectures = ["x86_64"]
+                    }
+]
diff --git a/usr/arrakismon/apic.c b/usr/arrakismon/apic.c
new file mode 100644
index 0000000..3e04ca0
--- /dev/null
+++ b/usr/arrakismon/apic.c
@@ -0,0 +1,143 @@
+/**
+ * \file
+ */
+
+/*
+ * Copyright (c) 2009, ETH Zurich.
+ * All rights reserved.
+ *
+ * This file is distributed under the terms in the attached LICENSE file.
+ * If you do not find this file, copies can be found by writing to:
+ * ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich. Attn: Systems Group.
+ */
+
+#include "vmkitmon.h"
+#include "apic.h"
+#include <stdlib.h>
+
+struct apic *
+apic_new (uint64_t mmio_base_va)
+{
+    struct apic *ret = calloc(1, sizeof(struct apic));
+
+    ret->mmio_base_va = mmio_base_va;
+    ret->spurious_intr_vec_reg = 0xff;
+    ret->lvt_timer_reg = 0x10000;
+    ret->lvt_thermal_monitor_reg = 0x10000;
+    ret->lvt_perf_counter_reg = 0x10000;
+    ret->lvt_lint0_reg = 0x10000;
+    ret->lvt_lint1_reg = 0x10000;
+    ret->lvt_err_reg = 0x10000;
+
+    return ret;
+}
+
+int apic_handle_mmio_read (struct apic *a, uint64_t addr, enum opsize size,
+                           uint64_t *val)
+{
+    uint32_t reg = addr - a->mmio_base_va;
+
+    switch (reg) {
+    // APIC Version Register
+    case 0x30:
+        *val = 0x80050010;
+        return HANDLER_ERR_OK;
+    // Spurious Interrupt Vector Register
+    case 0xf0:
+        *val = a->spurious_intr_vec_reg;
+        return HANDLER_ERR_OK;
+    // Error Status Register
+    case 0x280:
+        *val = a->err_stat_reg;
+        return HANDLER_ERR_OK;
+    // LVT Timer Register
+    case 0x320:
+        *val = a->lvt_timer_reg;
+        return HANDLER_ERR_OK;
+    // LVT Thermal Monitor Register
+    case 0x330:
+        *val = a->lvt_thermal_monitor_reg;
+        return HANDLER_ERR_OK;
+    // LVT Performance Counter RegisterNode
+    case 0x340:
+        *val = a->lvt_perf_counter_reg;
+        return HANDLER_ERR_OK;
+    // LVT LINT0 Register
+    case 0x350:
+        *val = a->lvt_lint0_reg;
+        return HANDLER_ERR_OK;
+    // LVT LINT1 Register
+    case 0x360:
+        *val = a->lvt_lint1_reg;
+        return HANDLER_ERR_OK;
+    // LVT Error Register
+    case 0x370:
+        *val = a->lvt_err_reg;
+        return HANDLER_ERR_OK;
+    }
+
+    printf("APIC: unhandeled read access to APIC reg %x\n", reg);
+    return -1;
+}
+
+int
+apic_handle_mmio_write (struct apic *a, uint64_t addr, enum opsize size,
+                        uint64_t val)
+{
+    uint32_t reg = addr - a->mmio_base_va;
+
+    switch (reg) {
+    // Spurious Interrupt Vector Register
+    case 0xf0:
+        a->spurious_intr_vec_reg = val;
+        // the apic needs to be enabled for now
+        assert(val & 0x100);
+        return HANDLER_ERR_OK;
+    // Error Status Register
+    case 0x280:
+        // ignore the incoming value
+        // according to the specification the ESR should now be loaded with the
+        // current errors, we keep it loaded all the time
+        return HANDLER_ERR_OK;
+    // LVT Timer Register
+    case 0x320:
+        a->lvt_timer_reg = val;
+        // This assert is here to detect if the OS enables the APIC timer
+        // as long as it is not implemented
+        assert(val & 0x10000);
+        return HANDLER_ERR_OK;
+    // LVT Thermal Monitor Register
+    case 0x330:
+        a->lvt_thermal_monitor_reg = val;
+        return HANDLER_ERR_OK;
+    // LVT Performance Counter RegisterNode
+    case 0x340:
+        a->lvt_perf_counter_reg = val;
+        return HANDLER_ERR_OK;
+    // LVT LINT0 Register
+    case 0x350:
+        a->lvt_lint0_reg = val;
+        return HANDLER_ERR_OK;
+    // LVT LINT1 Register
+    case 0x360:
+        a->lvt_lint1_reg = val;
+        return HANDLER_ERR_OK;
+    // LVT Error Register
+    case 0x370:
+        a->lvt_err_reg = val;
+        return HANDLER_ERR_OK;
+    }
+
+    printf("APIC: unhandeled write access to APIC reg %x, val %lx\n", reg, val);
+    return -1;
+}
+
+void
+apic_assert_irq (struct apic *a, uint8_t irq)
+{
+}
+
+void
+apic_assert_pic_irq (struct apic *a, uint8_t irq)
+{
+}
diff --git a/usr/arrakismon/apic.h b/usr/arrakismon/apic.h
new file mode 100644
index 0000000..955d435
--- /dev/null
+++ b/usr/arrakismon/apic.h
@@ -0,0 +1,43 @@
+/**
+ * \file
+ */
+
+/*
+ * Copyright (c) 2009, ETH Zurich.
+ * All rights reserved.
+ *
+ * This file is distributed under the terms in the attached LICENSE file.
+ * If you do not find this file, copies can be found by writing to:
+ * ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich. Attn: Systems Group.
+ */
+
+#ifndef APIC_H
+#define APIC_H
+
+#include <stdint.h>
+
+// Source material from AMD64 Manual, System Programming, Chapter 16: APIC
+
+struct apic {
+    uint64_t mmio_base_va;
+
+    // registers
+    uint32_t spurious_intr_vec_reg;
+    uint32_t lvt_timer_reg;
+    uint32_t err_stat_reg;
+    uint32_t lvt_thermal_monitor_reg;
+    uint32_t lvt_perf_counter_reg;
+    uint32_t lvt_lint0_reg;
+    uint32_t lvt_lint1_reg;
+    uint32_t lvt_err_reg;
+};
+
+struct apic * apic_new (uint64_t mmio_base_va);
+int apic_handle_mmio_read (struct apic *a, uint64_t addr, enum opsize size,
+                           uint64_t *val);
+int apic_handle_mmio_write (struct apic *a, uint64_t addr, enum opsize size,
+                            uint64_t val);
+void apic_assert_irq (struct apic *a, uint8_t irq);
+void apic_assert_pic_irq (struct apic *a, uint8_t irq);
+
+#endif // APIC_H
diff --git a/usr/arrakismon/console.c b/usr/arrakismon/console.c
new file mode 100644
index 0000000..96404c4
--- /dev/null
+++ b/usr/arrakismon/console.c
@@ -0,0 +1,209 @@
+/**
+ * \file
+ */
+
+/*
+ * Copyright (c) 2009, ETH Zurich.
+ * All rights reserved.
+ *
+ * This file is distributed under the terms in the attached LICENSE file.
+ * If you do not find this file, copies can be found by writing to:
+ * ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich. Attn: Systems Group.
+ */
+
+#include "vmkitmon.h"
+#include "console.h"
+#include <stdlib.h>
+#include <barrelfish/terminal.h>
+
+struct console *
+console_new (void)
+{
+    struct console *ret = calloc(1, sizeof(struct console));
+    return ret;
+}
+
+static int
+handle_set_cursor_position (struct console *c, struct guest *g)
+{
+    // only support mode 0 for now
+    if (guest_get_bh(g) != 0) {
+        return HANDLER_ERR_UNHANDELED;
+    }
+
+    c->cursor_pos_x = guest_get_dl(g);
+    c->cursor_pos_y = guest_get_dh(g);
+
+    return HANDLER_ERR_OK;
+}
+
+static int
+handle_write_char_with_attr (struct console *c, struct guest *g)
+{
+    // only support mode 0 for now
+    if (guest_get_bh(g) != 0) {
+        return HANDLER_ERR_UNHANDELED;
+    }
+    // we only support "normal" text output atm
+    if (guest_get_bl(g) != 7) {
+        return HANDLER_ERR_UNHANDELED;
+    }
+
+    // FIXME: Here we completely ignore the postition of the cursor atm since we
+    //        do not have proper terminal support in BF.
+    //        We also ignore multiple char writes, they make no sense atm.
+    int r;
+    char chr = guest_get_al(g);
+
+    r = terminal_write(&chr, 1);
+    assert(r == 1);
+
+    return HANDLER_ERR_OK;
+}
+
+static int
+handle_teletype_output (struct console *c, struct guest *g)
+{
+    // only support mode 0 for now
+    if (guest_get_bh(g) != 0) {
+        return HANDLER_ERR_UNHANDELED;
+    }
+
+    // we do not yet have a real understanding of the terminal, assume it is
+    // 80x25 and we simply insert new lines at the end of the "screen"
+    int r;
+    char chr = guest_get_al(g);
+
+    // treat CR and LF as column clearing chars
+    if (chr == '\r' || chr == '\n') {
+        c->cursor_pos_x = 0;
+    }
+    // insert a CR if we are passed the last column of the screen
+    else if (c->cursor_pos_x > 79) {
+        r = terminal_write("\n", 1);
+        assert(r == 1);
+        c->cursor_pos_x = 0;
+    }
+    // in all other cases just increase the column
+    else {
+        c->cursor_pos_x++;
+    }
+
+    r = terminal_write(&chr, 1);
+    assert(r == 1);
+
+    return HANDLER_ERR_OK;
+}
+
+static int
+handle_get_cursor_pos_and_size (struct console *c, struct guest *g)
+{
+    // only support mode 0 for now
+    if (guest_get_bh(g) != 0) {
+        return HANDLER_ERR_UNHANDELED;
+    }
+
+    // set ax to 0
+    guest_set_ax(g, 0);
+    // we do not support scan-lines
+    guest_set_cx(g, 0);
+
+    // set the position
+    guest_set_dl(g, c->cursor_pos_x);
+    guest_set_dh(g, c->cursor_pos_y);
+
+    return HANDLER_ERR_OK;
+}
+
+static int
+handle_set_text_cursor_shape (struct console *c, struct guest *g)
+{
+    // we only handle primitive cursors
+    if (guest_get_cx(g) != 0) {
+        printf("console: Unsupported cursor requested\n");
+        return HANDLER_ERR_FATAL;
+    }
+
+    return HANDLER_ERR_OK;
+}
+
+static int
+handle_get_current_video_mode (struct console *c, struct guest *g)
+{
+    // FIXME: for the terminal to be more flexible this should not be hardcoded
+    guest_set_ah(g, 80),
+    guest_set_al(g, 0x6); // VGA, 80x25, 8x8 box, res 640x200, 2 colors
+    guest_set_bh(g, 0);
+
+    return HANDLER_ERR_OK;
+}
+
+static int
+handle_get_ega_info (struct console *c, struct guest *g)
+{
+    // FIXME: only partially implemented, linux wants BX to be 0x10 to believe
+    //        it is confronted with a CGA card.
+    guest_set_bx(g, 0x10);
+
+    return HANDLER_ERR_OK;
+}
+
+static int
+handle_get_svga_info (struct console *c, struct guest *g)
+{
+    // we do not support vesa yet
+    guest_set_ax(g, 0);
+
+    return HANDLER_ERR_OK;
+}
+
+static int
+handle_set_video_mode (struct console *c, struct guest *g)
+{
+    // FIXME: Ignored for now.
+
+    return HANDLER_ERR_OK;
+}
+
+int
+console_handle_int10 (struct console *c, struct guest *g)
+{
+    // VESA SuperVGA BIOS (VBE) - GET SuperVGA INFORMATION
+    if (guest_get_ax(g) == 0x4f00) {
+        return handle_get_svga_info(c, g);
+    }
+    // VIDEO - SET VIDEO MODE
+    if (guest_get_ah(g) == 0x0) {
+        return handle_set_video_mode(c, g);
+    }
+    // VIDEO - SET TEXT-MODE CURSOR SHAPE
+    if (guest_get_ah(g) == 0x1) {
+        return handle_set_text_cursor_shape(c, g);
+    }
+    // VIDEO - SET CURSOR POSITION
+    else if (guest_get_ah(g) == 0x2) {
+        return handle_set_cursor_position(c, g);
+    }
+    // VIDEO - GET CURSOR POSITION AND SIZE
+    else if (guest_get_ah(g) == 0x3) {
+        return handle_get_cursor_pos_and_size(c, g);
+    }
+    // VIDEO - WRITE CHARACTER AND ATTRIBUTE AT CURSOR POSITION
+    else if (guest_get_ah(g) == 0x9) {
+        return handle_write_char_with_attr(c, g);
+    }
+    // VIDEO - TELETYPE OUTPUT
+    else if (guest_get_ah(g) == 0xe) {
+        return handle_teletype_output(c, g);
+    }
+    // VIDEO - GET CURRENT VIDEO MODEL_CGA
+    else if (guest_get_ah(g) == 0xf) {
+        return handle_get_current_video_mode(c, g);
+    }
+    // VIDEO - ALTERNATE FUNCTION SELECT (PS, EGA, VGA, MCGA) - GET EGA INFO
+    else if (guest_get_ah(g) == 0x12 && guest_get_bl(g) == 0x10) {
+        return handle_get_ega_info(c, g);
+    }
+
+    return HANDLER_ERR_UNHANDELED;
+}
diff --git a/usr/arrakismon/console.h b/usr/arrakismon/console.h
new file mode 100644
index 0000000..7980283
--- /dev/null
+++ b/usr/arrakismon/console.h
@@ -0,0 +1,27 @@
+/**
+ * \file
+ */
+
+/*
+ * Copyright (c) 2009, ETH Zurich.
+ * All rights reserved.
+ *
+ * This file is distributed under the terms in the attached LICENSE file.
+ * If you do not find this file, copies can be found by writing to:
+ * ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich. Attn: Systems Group.
+ */
+
+#ifndef CONSOLE_H
+#define CONSOLE_H
+
+#include <stdint.h>
+#include <guest.h>
+
+struct console {
+    uint8_t cursor_pos_x, cursor_pos_y;
+};
+
+struct console * console_new (void);
+int console_handle_int10 (struct console *c, struct guest *g);
+
+#endif // CONSOLE_H
diff --git a/usr/arrakismon/guest.c b/usr/arrakismon/guest.c
new file mode 100644
index 0000000..f2dac34
--- /dev/null
+++ b/usr/arrakismon/guest.c
@@ -0,0 +1,2214 @@
+
+/**
+ * \file
+ */
+
+/*
+ * Copyright (c) 2009, 2010, 2013, ETH Zurich.
+ * All rights reserved.
+ *
+ * This file is distributed under the terms in the attached LICENSE file.
+ * If you do not find this file, copies can be found by writing to:
+ * ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich. Attn: Systems Group.
+ */
+
+#include <stdlib.h>
+#include <string.h>
+#include "vmkitmon.h"
+#include <barrelfish/barrelfish.h>
+#include <barrelfish/lmp_endpoints.h>
+#include <barrelfish/dispatcher_arch.h>
+#include "x86.h"
+#include "svm.h"
+/* #include "realmode.h" */
+#include "hdd.h"
+#include "console.h"
+#include "pc16550d.h"
+#include "apic.h"
+#include "lpc.h"
+#include "pci.h"
+#include "pci_host.h"
+
+#define VMCB_SIZE       0x1000      // 4KB
+#define IOPM_SIZE       0x3000      // 12KB
+#define MSRPM_SIZE      0x2000      // 8KB
+#define RM_MEM_SIZE     (0x100000 + BASE_PAGE_SIZE)    // 1MB + A20 gate space
+
+#define APIC_BASE       0xfee00000
+
+#define MIN(x,y) ((x)<(y)?(x):(y))
+
+lvaddr_t guest_offset = 0;
+/// stores the last used guest ASID
+static uint32_t last_guest_asid = 0;
+
+// FIXME: this is somewhat broken by design... we should emit proper exceptions
+//        to the guest opposed to just halt the VM
+#define guest_assert(g, e) \
+    ((e) ? (void)0 : (handle_vmexit_unhandeled(g), assert(e)))
+
+static errval_t
+guest_slot_alloc(struct guest *g, struct capref *ret)
+{
+    return g->slot_alloc.a.alloc(&g->slot_alloc.a, ret);
+}
+
+static errval_t guest_vspace_map_wrapper(struct vspace *vspace, lvaddr_t vaddr,
+                                         struct capref frame,  size_t size)
+{
+    errval_t err;
+    struct vregion *vregion = NULL;
+    struct memobj_one_frame *memobj = NULL;
+
+    // Allocate space
+    vregion = malloc(sizeof(struct vregion));
+    if (!vregion) {
+        err = LIB_ERR_MALLOC_FAIL;
+        goto error;
+    }
+    memobj = malloc(sizeof(struct memobj_one_frame));
+    if (!memobj) {
+        err = LIB_ERR_MALLOC_FAIL;
+        goto error;
+    }
+
+    // Create the objects
+    err = memobj_create_one_frame(memobj, size, 0);
+    if (err_is_fail(err)) {
+        err = err_push(err, LIB_ERR_MEMOBJ_CREATE_ANON);
+        goto error;
+    }
+    err = memobj->m.f.fill(&memobj->m, 0, frame, size);
+    if (err_is_fail(err)) {
+        err = err_push(err, LIB_ERR_MEMOBJ_FILL);
+        goto error;
+    }
+    err = vregion_map_fixed(vregion, vspace, &memobj->m, 0, size, vaddr,
+                            VREGION_FLAGS_READ | VREGION_FLAGS_WRITE | VREGION_FLAGS_EXECUTE);
+    if (err_is_fail(err)) {
+        err = LIB_ERR_VSPACE_MAP;
+        goto error;
+    }
+    err = memobj->m.f.pagefault(&memobj->m, vregion, 0, 0);
+    if (err_is_fail(err)) {
+        err = err_push(err, LIB_ERR_MEMOBJ_PAGEFAULT_HANDLER);
+        goto error;
+    }
+
+    return SYS_ERR_OK;
+
+ error: // XXX: proper cleanup
+    if (vregion) {
+        free(vregion);
+    }
+    if (memobj) {
+        free(memobj);
+    }
+    return err;
+}
+
+#define GUEST_VSPACE_SIZE (1ul<<32) // GB
+
+static errval_t vspace_map_wrapper(lvaddr_t vaddr, struct capref frame,
+                                   size_t size)
+{
+    errval_t err;
+    static struct memobj_anon *memobj = NULL;
+    static struct vregion *vregion = NULL;
+    static bool initialized = false;
+
+    if (!initialized) {
+        // Allocate space
+        memobj = malloc(sizeof(struct memobj_anon));
+        if (!memobj) {
+            return LIB_ERR_MALLOC_FAIL;
+        }
+        vregion = malloc(sizeof(struct vregion));
+        if (!vregion) {
+            return LIB_ERR_MALLOC_FAIL;
+        }
+
+        // Create a memobj and vregion
+        err = memobj_create_anon(memobj, GUEST_VSPACE_SIZE, 0);
+        if (err_is_fail(err)) {
+            return err_push(err, LIB_ERR_MEMOBJ_CREATE_ANON);
+        }
+        err = vregion_map(vregion, get_current_vspace(), &memobj->m, 0,
+                          GUEST_VSPACE_SIZE, VREGION_FLAGS_READ_WRITE);
+        if (err_is_fail(err)) {
+            return err_push(err, LIB_ERR_VREGION_MAP);
+        }
+
+        guest_offset = vregion_get_base_addr(vregion);
+        initialized = true;
+    }
+
+    // Create mapping
+    err = memobj->m.f.fill(&memobj->m, vaddr, frame, size);
+    if (err_is_fail(err)) {
+        return err_push(err, LIB_ERR_MEMOBJ_FILL);
+    }
+    err = memobj->m.f.pagefault(&memobj->m, vregion, vaddr, 0);
+    if (err_is_fail(err)) {
+        return err_push(err, LIB_ERR_MEMOBJ_PAGEFAULT_HANDLER);
+    }
+
+    return SYS_ERR_OK;
+}
+// allocates some bytes of memory for the guest starting at a specific addr
+// also performs the mapping into the vspace of the monitor
+static errval_t
+alloc_guest_mem(struct guest *g, lvaddr_t guest_paddr, size_t bytes)
+{
+    errval_t err;
+
+    // only allow multiple of page sizes to be allocated
+    assert(bytes > 0 && (bytes & BASE_PAGE_MASK) == 0);
+    // do not allow allocation outside of the guests physical memory
+    assert(guest_paddr + bytes <= g->mem_high_va);
+
+    // Allocate frame
+    struct capref cap;
+    err = guest_slot_alloc(g, &cap);
+    if (err_is_fail(err)) {
+        return err_push(err, LIB_ERR_SLOT_ALLOC);
+    }
+    err = frame_create(cap, bytes, NULL);
+    if (err_is_fail(err)) {
+        return err_push(err, LIB_ERR_FRAME_CREATE);
+    }
+
+    // Map into the guest vspace
+    err = guest_vspace_map_wrapper(g->vspace, guest_paddr, cap, bytes);
+    if (err_is_fail(err)) {
+        return err;
+    }
+
+    // Create a copy of the capability to map in our vspace
+    struct capref host_cap;
+    err = slot_alloc(&host_cap);
+    if (err_is_fail(err)) {
+        return err;
+    }
+    err = cap_copy(host_cap, cap);
+    if (err_is_fail(err)) {
+        return err;
+    }
+
+    // Map into my vspace
+    err = vspace_map_wrapper(guest_to_host(guest_paddr), host_cap, bytes);
+    if (err_is_fail(err)) {
+        return err;
+    }
+
+    return SYS_ERR_OK;
+}
+
+static void
+initialize_iopm (struct guest *self) {
+    // intercept all IO port accesses (for now)
+    memset((void*)self->iopm_va, 0xFF, IOPM_SIZE);
+}
+
+// access_mode: 0 all access, 1 read intercept, 2 write intercept, 3 all interc.
+static inline void
+set_msr_access (struct guest *g, uint32_t msr, int access_mode)
+{
+    assert(access_mode >= 0 && access_mode <= 3);
+
+    // a region a 2K bytes represents the access bits of 8K MSRs, therefore each
+    // MSR takes two bits (one for rdmsr and one for wrmsr)
+    uintptr_t byte_offset = (msr & 0xffff) / 4;
+    int bit_offset = ((msr & 0xffff) % 4) * 2;
+
+    if (msr < 0x2000) {
+        // do nothing
+    } else if (msr >= 0xc0000000 && msr < 0xc0002000) {
+        byte_offset += 0x800;
+    } else if (msr >= 0xc0010000 && msr < 0xc0012000) {
+        byte_offset += 0x1000;
+    } else {
+        assert(!"not reached");
+    }
+
+    assert(byte_offset < MSRPM_SIZE);
+
+    // read the byte holding the relevant bits
+    uint8_t val = *(uint8_t *)(g->msrpm_va + byte_offset);
+    // set the access params according to the arguments
+    val = (val & ~(0x3 << bit_offset)) | (access_mode << bit_offset);
+    // store the modified value back in the map
+    *(uint8_t *)(g->msrpm_va + byte_offset) = val;
+
+    //printf("MSR: msr %x, byte_offset %lx, bit_offset %x, val %x\n", msr, byte_offset, bit_offset, val);
+}
+
+static void
+initialize_msrpm (struct guest *g) {
+    // intercept all MSR accesses (for now)
+    memset((void*)g->msrpm_va, 0xff, MSRPM_SIZE);
+
+#if 0
+    // allow performance counters and evnets MSR accesses
+    set_msr_access (g, 0xc0010000, 0);
+    set_msr_access (g, 0xc0010001, 0);
+    set_msr_access (g, 0xc0010002, 0);
+    set_msr_access (g, 0xc0010003, 0);
+    set_msr_access (g, 0xc0010004, 0);
+    set_msr_access (g, 0xc0010005, 0);
+    set_msr_access (g, 0xc0010006, 0);
+    set_msr_access (g, 0xc0010007, 0);
+#endif
+}
+
+#define INIT_DATA_SEGREG(vmcb,x)                 \
+do {                                             \
+    amd_vmcb_seg_attrib_t __sa = {               \
+        .segtype = 2,                            \
+        .s = 1,                                  \
+        .dpl = 0,				 \
+        .p = 1,                                  \
+        .l = 0,					 \
+        .db = 1,				 \
+        .g = 1,					 \
+    };                                           \
+    amd_vmcb_##x## _attrib_wr((vmcb), __sa);     \
+    amd_vmcb_##x## _selector_wr((vmcb), 0x10);   \
+    amd_vmcb_##x## _base_wr((vmcb), 0x0);        \
+    amd_vmcb_##x## _limit_wr((vmcb), 0xffffffff);   \
+} while (0)
+
+#define INIT_CODE_SEGREG(vmcb,x)                 \
+do {                                             \
+    amd_vmcb_seg_attrib_t __sa = {               \
+        .segtype = 0xa,                          \
+        .s = 1,                                  \
+        .dpl = 0,				 \
+        .p = 1,                                  \
+        .l = 1,					 \
+        .db = 0,				 \
+        .g = 1,					 \
+    };                                           \
+    amd_vmcb_##x## _attrib_wr((vmcb), __sa);     \
+    amd_vmcb_##x## _selector_wr((vmcb), 8); 	 \
+    amd_vmcb_##x## _base_wr((vmcb), 0x0);        \
+    amd_vmcb_##x## _limit_wr((vmcb), 0xffffffff);   \
+} while (0)
+
+#define INIT_SYS_SEGREG(vmcb,x)                  \
+do {                                             \
+    amd_vmcb_seg_attrib_t __sa = {               \
+        .segtype = 2,                            \
+        .s = 1,                                  \
+        .dpl = 0,				 \
+        .p = 1,                                  \
+        .l = 0,					 \
+        .db = 1,				 \
+        .g = 1,					 \
+    };                                           \
+    amd_vmcb_##x## _attrib_wr((vmcb), __sa);     \
+    amd_vmcb_##x## _selector_wr((vmcb), 0x10);   \
+    amd_vmcb_##x## _base_wr((vmcb), 0x0);        \
+    amd_vmcb_##x## _limit_wr((vmcb), 0xffffffff);   \
+} while (0)
+
+/* This method initializes a new VMCB memory regsion and sets the initial
+ * machine state as defined by the AMD64 architecture specification */
+static void
+initialize_vmcb (struct guest *self) {
+    amd_vmcb_initialize(&self->vmcb, (mackerel_addr_t)self->vmcb_va);
+
+    // 1. Initialize intercepts
+
+    /* For now we intercept just everything */
+
+    amd_vmcb_cr_access_wr_raw(&self->vmcb, ~0u);
+    amd_vmcb_cr_access_rdcr2_wrf(&self->vmcb, 0);
+    amd_vmcb_cr_access_wrcr2_wrf(&self->vmcb, 0);
+    amd_vmcb_cr_access_rdcr4_wrf(&self->vmcb, 0);
+    amd_vmcb_cr_access_wrcr4_wrf(&self->vmcb, 0);
+
+    // FIXME: ignoring DR accesses may be insecure
+    //amd_vmcb_dr_access_wr_raw(&self->vmcb, ~0u);
+    amd_vmcb_exceptions_wr_raw(&self->vmcb, 0);
+    /* amd_vmcb_exceptions_vector7_wrf(&self->vmcb, 0); */
+    /* amd_vmcb_exceptions_vector14_wrf(&self->vmcb, 0); */
+
+    amd_vmcb_intercepts_wr_raw(&self->vmcb, 0x1fffffffffff);
+    amd_vmcb_intercepts_pushf_wrf(&self->vmcb, 0);
+    amd_vmcb_intercepts_popf_wrf(&self->vmcb, 0);
+    amd_vmcb_intercepts_invlpg_wrf(&self->vmcb, 0);
+    amd_vmcb_intercepts_rdtsc_wrf(&self->vmcb, 0);
+    amd_vmcb_intercepts_rdtscp_wrf(&self->vmcb, 0);
+    amd_vmcb_intercepts_iret_wrf(&self->vmcb, 0);
+    amd_vmcb_intercepts_wbinvd_wrf(&self->vmcb, 0);
+    amd_vmcb_intercepts_pause_wrf(&self->vmcb, 0);
+    amd_vmcb_intercepts_vintr_wrf(&self->vmcb, 0);
+
+    // 2. Setup some config fields
+
+    // physical addresses of IOPM and MSRPM_SIZE
+    amd_vmcb_iopm_base_pa_wr(&self->vmcb, self->iopm_pa);
+    amd_vmcb_msrpm_base_pa_wr(&self->vmcb, self->msrpm_pa);
+    // assign guest ASID
+    // FIXME: use real asid allocator. BF does not know about tagged TLBs atm
+    amd_vmcb_tlb_guest_asid_wrf(&self->vmcb, ++last_guest_asid);
+    // enable virtual intr masking
+    amd_vmcb_vintr_vintr_masking_wrf(&self->vmcb, 1);
+    // enable nested paging
+    amd_vmcb_np_enable_wrf(&self->vmcb, 1);
+
+    /* 3. Guest state initialization
+     * according to Intels Manual 3A: Table 9-1. */
+
+    // The second bit of rflags needs to be 1, also indicate that we support the
+    // CPUID instruction.
+    amd_vmcb_rflags_wr_raw(&self->vmcb, 0x00200002);
+    amd_vmcb_rip_wr(&self->vmcb, 0x0000fff0);
+    amd_vmcb_cr0_wr_raw(&self->vmcb, 0x60000010);
+
+    INIT_CODE_SEGREG(&self->vmcb, cs);
+    INIT_DATA_SEGREG(&self->vmcb, ss);
+    INIT_DATA_SEGREG(&self->vmcb, ds);
+    INIT_DATA_SEGREG(&self->vmcb, es);
+    INIT_DATA_SEGREG(&self->vmcb, fs);
+    INIT_DATA_SEGREG(&self->vmcb, gs);
+
+    INIT_SYS_SEGREG(&self->vmcb, gdtr);
+    INIT_SYS_SEGREG(&self->vmcb, idtr);
+    INIT_SYS_SEGREG(&self->vmcb, ldtr);
+    INIT_SYS_SEGREG(&self->vmcb, tr);
+
+    amd_vmcb_dr6_wr(&self->vmcb, 0xffff0ff0);
+    amd_vmcb_dr7_wr(&self->vmcb, 0x00000400);
+
+    // taken from the linux SVM source
+    amd_vmcb_gpat_wr(&self->vmcb, 0x0007040600070406ul);
+
+    // svm requires guest EFER.SVME to be set
+    amd_vmcb_efer_svme_wrf(&self->vmcb, 1);
+}
+
+static void
+idc_handler(void *arg)
+{
+    struct guest *g = arg;
+    errval_t err;
+
+    // consume message
+    struct lmp_recv_buf buf = { .buflen = 0 };
+    err = lmp_endpoint_recv(g->monitor_ep, &buf, NULL);
+    assert(err_is_ok(err));
+
+    // run real handler
+    guest_handle_vmexit(g);
+
+    // re-register
+    struct event_closure cl = {
+        .handler = idc_handler,
+        .arg = arg,
+    };
+    err = lmp_endpoint_register(g->monitor_ep, get_default_waitset(), cl);
+    assert(err_is_ok(err));
+}
+
+/* This method duplicates some code from spawndomain since we need to spawn very
+ * special domains */
+void
+spawn_guest_domain (struct guest *g, struct spawninfo *si) {
+    errval_t err;
+
+#if 0
+    // create the guest virtual address space
+    struct capref vnode_cap;
+    err = guest_slot_alloc(self, &vnode_cap);
+    assert(err_is_ok(err));
+    err = vnode_create(vnode_cap, ObjType_VNode_x86_64_pml4);
+    assert(err_is_ok(err));
+
+    struct pmap *pmap = malloc(sizeof(struct pmap_x86));
+    assert(pmap);
+    err = pmap_x86_64_init(pmap, &self->vspace, vnode_cap, NULL);
+    assert(err_is_ok(err));
+    err = vspace_init(&self->vspace, pmap);
+    assert(err_is_ok(err));
+
+    // create DCB
+    err = guest_slot_alloc(self, &self->dcb_cap);
+    assert(err_is_ok(err));
+    err = dispatcher_create(self->dcb_cap);
+    assert(err_is_ok(err));
+#endif
+
+    // create end point
+    struct capref ep_cap;
+
+    // use minimum-sized endpoint, because we don't need to buffer >1 vmexit
+    err = endpoint_create(LMP_RECV_LENGTH, &ep_cap, &g->monitor_ep);
+    assert(err_is_ok(err));
+
+    // register to receive on this endpoint
+    struct event_closure cl = {
+        .handler = idc_handler,
+        .arg = g,
+    };
+    err = lmp_endpoint_register(g->monitor_ep, get_default_waitset(), cl);
+    assert(err_is_ok(err));
+
+    // setup the DCB
+    g->vspace = si->vspace;
+    g->dcb_cap = si->dcb;
+    err = invoke_dispatcher_setup_guest(g->dcb_cap, ep_cap, si->vtree,
+                                        g->vmcb_cap, g->ctrl_cap);
+    assert(err_is_ok(err));
+
+    err = invoke_dispatcher(si->dcb, cap_dispatcher, si->rootcn_cap,
+			    si->vtree, si->dispframe, false);
+    assert(err_is_ok(err));
+
+    // Setup virtual machine
+    arch_registers_state_t *regs =
+        dispatcher_get_disabled_save_area(si->handle);
+    amd_vmcb_rax_wr(&g->vmcb, regs->rax);
+    memcpy(&g->ctrl->regs, regs, sizeof(arch_registers_state_t));
+    amd_vmcb_rsp_wr(&g->vmcb, regs->rsp);
+    amd_vmcb_rip_wr(&g->vmcb, regs->rip);
+    amd_vmcb_rflags_wr_raw(&g->vmcb, regs->eflags);
+
+    // Enable long mode
+    amd_vmcb_cr0_pe_wrf(&g->vmcb, 1);
+    amd_vmcb_cr0_pg_wrf(&g->vmcb, 1);
+    amd_vmcb_cr4_pae_wrf(&g->vmcb, 1);
+    amd_vmcb_efer_lme_wrf(&g->vmcb, 1);
+    amd_vmcb_efer_lma_wrf(&g->vmcb, 1);
+
+    // More "default" settings
+    amd_vmcb_cr4_mce_wrf(&g->vmcb, 1);
+    amd_vmcb_cr4_pge_wrf(&g->vmcb, 1);
+    amd_vmcb_cr4_pce_wrf(&g->vmcb, 1);
+    amd_vmcb_cr4_osfxsr_wrf(&g->vmcb, 1);
+    amd_vmcb_efer_sce_wrf(&g->vmcb, 1);
+    amd_vmcb_efer_nxe_wrf(&g->vmcb, 1);
+
+    // disable GDTR intercept
+    amd_vmcb_intercepts_rdgdtr_wrf(&g->vmcb, 0);
+    amd_vmcb_intercepts_wrgdtr_wrf(&g->vmcb, 0);
+    // disable GDTR intercept
+    amd_vmcb_intercepts_rdldtr_wrf(&g->vmcb, 0);
+    amd_vmcb_intercepts_wrldtr_wrf(&g->vmcb, 0);
+    // disable IDTR intercept
+    amd_vmcb_intercepts_rdidtr_wrf(&g->vmcb, 0);
+    amd_vmcb_intercepts_wridtr_wrf(&g->vmcb, 0);
+    // disable TR intercept
+    amd_vmcb_intercepts_rdtr_wrf(&g->vmcb, 0);
+    amd_vmcb_intercepts_wrtr_wrf(&g->vmcb, 0);
+    // disable non essential CR0 access intercepts
+    amd_vmcb_cr_access_rdcr0_wrf(&g->vmcb, 0);
+    amd_vmcb_cr_access_wrcr0_wrf(&g->vmcb, 0);
+    // disable CR3 access intercepts
+    amd_vmcb_cr_access_rdcr3_wrf(&g->vmcb, 0);
+    amd_vmcb_cr_access_wrcr3_wrf(&g->vmcb, 0);
+    // disable INTn intercept
+    /* amd_vmcb_intercepts_intn_wrf(&g->vmcb, 0); */
+
+    // Disable nested paging
+    amd_vmcb_np_enable_wrf(&g->vmcb, 0);
+
+    for(int i = 0; i < si->vregions; i++) {
+      printf("vregion %d: base = %" PRIxGENVADDR ", region = %" PRIxGENVADDR "\n",
+	     i, si->base[i], vregion_get_base_addr(si->vregion[i]));
+    }
+
+#if 0
+    // set up the guests physical address space
+    self->mem_low_va = 0;
+    // FIXME: Hardcoded guest memory size
+    self->mem_high_va = 0x1000000;   // 2 GiB
+    // allocate the memory used for real mode
+    // This is not 100% necessary since one could also catch the pagefaults.
+    // If we allocate the whole memory at once we use less caps and reduce
+    // the risk run out of CSpace.
+    err = alloc_guest_mem(self, 0x0, 0x1000000);
+    assert_err(err, "alloc_guest_mem");
+#endif
+}
+
+#if 0
+static void
+install_grub_stage2 (struct guest *g, void *img, size_t img_size)
+{
+    assert(img != NULL);
+
+    /* the grub image goes to 0x8000 according to
+     * http://www.gnu.org/software/grub/manual/html_node/Memory-map.html */
+    memcpy((void *)(guest_to_host(g->mem_low_va + 0x8000)), img, img_size);
+    // according to grub stage2 source its entry point is at 0x8200
+    amd_vmcb_rip_wr(&g->vmcb, 0x8200);
+    // switch to the first segment
+    amd_vmcb_cs_selector_wr(&g->vmcb, 0x0);
+    amd_vmcb_cs_base_wr(&g->vmcb, 0x0);
+    amd_vmcb_cs_limit_wr(&g->vmcb, 0xffff);
+}
+#endif
+
+#if 0
+static void
+install_debug_app (struct guest *g)
+{
+    //static uint8_t app[] = { 0xcd, 0x20 };
+    static uint8_t app[] = { 0xcd, 0x20, 0x90, 0x90, 0x90, 0x90, 0x90 };
+    /* static uint8_t app[] = { 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90 }; */
+    memcpy((void *)(guest_to_host(g->mem_low_va + 0xf000)), app, sizeof(app));
+    amd_vmcb_rip_wr(&g->vmcb, 0xf000);
+    amd_vmcb_rsp_wr(&g->vmcb, 0x10000);
+
+#if 0
+    static uint8_t gdt[] = {
+      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+      0xff,0xff,0x00,0x00,0x00,0x9a,0xaf,0x00, // 64bit code segment, D _cleared_ => "16bit"
+      0xff,0xff,0x00,0x00,0x00,0x92,0xcf,0x00, // data
+      0xff,0xff,0x00,0x00,0x00,0x9a,0xcf,0x00, // 32bit code segment for protected-mode
+      0xff,0xff,0x00,0x80,0x0b,0x92,0xff,0x00, // screen
+      0xff,0xff,0x00,0x60,0x00,0x9a,0xcf,0x00, // segment at linear address 0x6000
+      0xff,0xff,0x00,0x00,0x00,0x92,0xaf,0x00  // stack segment in 64bit mode
+    };
+    memcpy((void *)(guest_to_host(g->mem_low_va)), gdt, sizeof(gdt));
+
+    amd_vmcb_gdtr_base_wr(&g->vmcb, 0);
+    amd_vmcb_gdtr_limit_wr(&g->vmcb, sizeof(gdt));
+#endif
+
+    // disable nested pageing in real mode
+    /* amd_vmcb_np_enable_wrf(&g->vmcb, 1); */
+    // enable paged real mode
+    //amd_vmcb_cr0_pg_wrf(&g->vmcb, 0x1);
+    //g->save_area->cr0 |= X86_CR0_PE_MASK;
+
+#if 0
+    // Write page table
+    static uint64_t pml4[512] = {
+      0xffffffffffffffffUL,
+      0x00002007,
+      0
+    };
+    memcpy((void *)(guest_to_host(g->mem_low_va + 0x1000)), pml4, sizeof(pml4));
+
+    static uint64_t pdpt[512] = {
+      0x00003007,
+      0
+    };
+    memcpy((void *)(guest_to_host(g->mem_low_va + 0x2000)), pdpt, sizeof(pdpt));
+
+    static uint64_t pdir[512] = {
+      0x00000087,
+      0x00200087,
+      0x00400087,
+      0x00600087,
+      0x00800087,
+      0x00a00087,
+      0x00c00087,
+      0x00e00087,
+      0x01000087,
+      0
+    };
+    memcpy((void *)(guest_to_host(g->mem_low_va + 0x3000)), pdir, sizeof(pdir));
+
+    amd_vmcb_cr3_wr(&g->vmcb, 0x1000);
+#endif
+
+    // Enable long mode
+    amd_vmcb_cr0_pe_wrf(&g->vmcb, 1);
+    amd_vmcb_cr0_pg_wrf(&g->vmcb, 1);
+    amd_vmcb_cr4_pae_wrf(&g->vmcb, 1);
+    amd_vmcb_efer_lme_wrf(&g->vmcb, 1);
+    amd_vmcb_efer_lma_wrf(&g->vmcb, 1);
+
+    // Disable nested paging
+    amd_vmcb_np_enable_wrf(&g->vmcb, 0);
+
+    /* amd_vmcb_cs_selector_wr(&g->vmcb, 0x0); */
+    /* amd_vmcb_cs_base_wr(&g->vmcb, 0x0); */
+    /* amd_vmcb_cs_limit_wr(&g->vmcb, 0xfffff); */
+    /* amd_vmcb_cs_attrib_wr(&g->vmcb,  */
+    //g->save_area->cs.selector = 0x1000;
+    //g->save_area->cs.base = 0x10000;
+    //g->save_area->cs.base = 0x1ffff;
+}
+#endif
+
+static bool
+virq_pending (void *ud, uint8_t *irq, uint8_t *irq_prio)
+{
+    assert(ud != NULL);
+
+    struct guest *g = ud;
+
+    if (amd_vmcb_vintr_rd(&g->vmcb).virq == 1) {
+        if (irq != NULL) {
+            *irq = amd_vmcb_vintr_rd(&g->vmcb).vintr_vector;
+        }
+        if (irq_prio != NULL) {
+            *irq_prio = amd_vmcb_vintr_rd(&g->vmcb).vintr_prio;
+        }
+        return true;
+    } else {
+        return false;
+    }
+}
+
+#if 1
+static void
+virq_handler (void *ud, uint8_t irq, uint8_t irq_prio)
+{
+    assert(ud != NULL);
+
+    struct guest *g = ud;
+
+    // tell the hw extensions that there is a virtual IRQ pending
+    amd_vmcb_vintr_virq_wrf(&g->vmcb, 1);
+    amd_vmcb_vintr_vintr_prio_wrf(&g->vmcb, irq_prio);
+    amd_vmcb_vintr_vintr_vector_wrf(&g->vmcb, irq);
+    amd_vmcb_vintr_v_ign_tpr_wrf(&g->vmcb, 1);
+
+    // if the guest is currently waiting then we have to restart it to make
+    // forward progress
+    if (!g->runnable) {
+        g->runnable = true;
+        guest_make_runnable(g, true);
+    }
+}
+#endif
+
+static void
+guest_setup (struct guest *g)
+{
+    errval_t err;
+
+    // initialize the guests slot_allocator
+    err = multi_slot_alloc_init(&g->slot_alloc, DEFAULT_CNODE_SLOTS, NULL);
+    assert_err(err, "multi_cspace_alloc_init_raw");
+
+    struct frame_identity fi;
+
+    // allocate memory for the vmcb
+    err = guest_slot_alloc(g, &g->vmcb_cap);
+    assert_err(err, "guest_cspace_alloc");
+    err = frame_create(g->vmcb_cap, VMCB_SIZE, NULL);
+    assert_err(err, "frame_create");
+    err = invoke_frame_identify(g->vmcb_cap, &fi);
+    assert_err(err, "frame_identify");
+    g->vmcb_pa = fi.base;
+    err = vspace_map_one_frame_attr((void**)&g->vmcb_va, VMCB_SIZE, g->vmcb_cap,
+                                    VREGION_FLAGS_READ_WRITE_NOCACHE,
+                                    NULL, NULL);
+    if (err_is_fail(err)) {
+        DEBUG_ERR(err, "vspace_map_one_frame_attr failed");
+    }
+
+    // guest control
+    err = frame_alloc(&g->ctrl_cap, sizeof(struct guest_control), NULL);
+    assert_err(err, "frame_alloc");
+    size_t size = ROUND_UP(sizeof(struct guest_control), BASE_PAGE_SIZE);
+    err = vspace_map_one_frame_attr((void**)&g->ctrl, size, g->ctrl_cap,
+                                    VREGION_FLAGS_READ_WRITE_NOCACHE,
+                                    NULL, NULL);
+    if (err_is_fail(err)) {
+        DEBUG_ERR(err, "vspace_map_one_frame_attr failed");
+    }
+    g->ctrl->num_vm_exits_with_monitor_invocation = 0;
+    g->ctrl->num_vm_exits_without_monitor_invocation = 0;
+
+    // allocate memory for the iopm
+    err = frame_alloc(&g->iopm_cap, IOPM_SIZE, NULL);
+    assert_err(err, "frame_alloc");
+    err = invoke_frame_identify(g->iopm_cap, &fi);
+    assert_err(err, "frame_identify");
+    g->iopm_pa = fi.base;
+    err = vspace_map_one_frame_attr((void**)&g->iopm_va, IOPM_SIZE, g->iopm_cap,
+                                    VREGION_FLAGS_READ_WRITE_NOCACHE,
+                                    NULL, NULL);
+    if (err_is_fail(err)) {
+        DEBUG_ERR(err, "vspace_map_one_frame_attr failed");
+    }
+
+    // allocate memory fot the msrpm
+    err = frame_alloc(&g->msrpm_cap, MSRPM_SIZE, NULL);
+    assert_err(err, "frame_alloc");
+    err = invoke_frame_identify(g->msrpm_cap, &fi);
+    assert_err(err, "frame_identify");
+    g->msrpm_pa = fi.base;
+    err = vspace_map_one_frame_attr((void**)&g->msrpm_va, MSRPM_SIZE,
+                                    g->msrpm_cap,
+                                    VREGION_FLAGS_READ_WRITE_NOCACHE,
+                                    NULL, NULL);
+    if (err_is_fail(err)) {
+        DEBUG_ERR(err, "vspace_map_one_frame_attr failed");
+    }
+
+    // initialize the allocated structures
+    initialize_iopm(g);
+    initialize_msrpm(g);
+    initialize_vmcb(g);
+
+    // spawn the guest domain
+    /* spawn_guest_domain(g); */
+    /* assert (grub_image != NULL); */
+    //install_grub_stage2(g, grub_image, grub_image_size);
+    /* install_debug_app(g); */
+
+    // add virtual hardware
+    g->apic = apic_new(APIC_BASE);
+    g->lpc = lpc_new(virq_handler, virq_pending, g, g->apic);
+#if 0
+    if (hdd0_image != NULL) {
+        g->hdds[0] = hdd_new_from_memory(hdd0_image, hdd0_image_size);
+        g->hdd_count++;
+    }
+    g->console = console_new();
+    g->serial_ports[0] = pc16550d_new(0x3f8, 4, g->lpc);
+    pc16550d_attach_to_console(g->serial_ports[0]);
+    g->serial_ports[1] = pc16550d_new(0x2f8, 3, g->lpc);
+    g->serial_ports[2] = pc16550d_new(0x3e8, 4, g->lpc);
+    g->serial_ports[3] = pc16550d_new(0x2e8, 3, g->lpc);
+    g->serial_port_count = 4;
+
+    g->pci = pci_new();
+    init_host_devices(g->pci);
+
+    // set up bios memory
+    // FIXME: find a modular way to do this
+    *(uint16_t *)guest_to_host(g->mem_low_va + 0x400) = 0x3f8;  // COM1
+    *(uint16_t *)guest_to_host(g->mem_low_va + 0x402) = 0x2f8;  // COM2
+#endif
+
+    g->runnable = true;
+}
+
+/**
+ * \brief Create a new guest.
+ *
+ * This function creates a new guest. It will do everything necessary to make
+ * the guest accept images to run. It will create a new domain and assign some
+ * memory to that domain. Afterwards it will load a bios into the memory and
+ * set the guest initial IP to the POST entry of the bios.
+ *
+ * \return The pointer to the newly created structure describing the guest.
+ */
+struct guest *
+guest_create (void)
+{
+  struct guest *newguest = malloc(sizeof(struct guest));
+  memset(newguest, 0, sizeof(struct guest));
+  guest_setup(newguest);
+  return newguest;
+}
+
+#if 0
+static int
+run_realmode (struct guest *g)
+{
+    int r;
+
+    realmode_switch_to(g);
+    r = realmode_exec();
+    assert(r == REALMODE_ERR_OK);
+    realmode_switch_from(g);
+
+    guest_handle_vmexit(g);
+
+    return 0;
+};
+#endif
+
+/**
+ * \brief Marks a guest as runnable.
+ *
+ * A call to this method will update the guest's runnable state and, if made
+ * runnable, yield the remaining time slice to the guest domain.
+ *
+ * \return Zero on success, non-zero on error
+ */
+errval_t
+guest_make_runnable (struct guest *g, bool run)
+{
+    assert(g->runnable);
+
+    errval_t err;
+
+#if 0
+    /* If the guest is currently in real mode (CR0.PE flag clear) then we do not
+     * schedule the domain to run the virtualization but run the real-mode
+     * emulation */
+    if (UNLIKELY(run && amd_vmcb_cr0_rd(&g->vmcb).pe == 0)) {
+        if (!g->emulated_before_exit) {
+            // do the inverse of the code below
+            amd_vmcb_intercepts_rdgdtr_wrf(&g->vmcb, 1);
+            amd_vmcb_intercepts_wrgdtr_wrf(&g->vmcb, 1);
+            amd_vmcb_intercepts_rdldtr_wrf(&g->vmcb, 1);
+            amd_vmcb_intercepts_wrldtr_wrf(&g->vmcb, 1);
+            amd_vmcb_intercepts_rdidtr_wrf(&g->vmcb, 1);
+            amd_vmcb_intercepts_wridtr_wrf(&g->vmcb, 1);
+            amd_vmcb_intercepts_rdtr_wrf(&g->vmcb, 1);
+            amd_vmcb_intercepts_wrtr_wrf(&g->vmcb, 1);
+            amd_vmcb_cr_access_rdcr0_wrf(&g->vmcb, 1);
+            amd_vmcb_cr_access_wrcr0_wrf(&g->vmcb, 1);
+            amd_vmcb_cr_access_rdcr3_wrf(&g->vmcb, 1);
+            amd_vmcb_cr_access_wrcr3_wrf(&g->vmcb, 1);
+            amd_vmcb_intercepts_intn_wrf(&g->vmcb, 1);
+
+            // mark guest as emulated
+            g->emulated_before_exit = true;
+        }
+        run_realmode(g);
+        return SYS_ERR_OK;
+    }
+
+    /* every time we move the machine from the emulated to virtualized we need
+     * to adjust some intercepts */
+    if (UNLIKELY(run && g->emulated_before_exit)) {
+        // we enforce NP to be enabled (no shadow paging support)
+        assert(amd_vmcb_np_rd(&g->vmcb).enable == 1);
+
+        // disable GDTR intercept
+        amd_vmcb_intercepts_rdgdtr_wrf(&g->vmcb, 0);
+        amd_vmcb_intercepts_wrgdtr_wrf(&g->vmcb, 0);
+        // disable GDTR intercept
+        amd_vmcb_intercepts_rdldtr_wrf(&g->vmcb, 0);
+        amd_vmcb_intercepts_wrldtr_wrf(&g->vmcb, 0);
+        // disable IDTR intercept
+        amd_vmcb_intercepts_rdidtr_wrf(&g->vmcb, 0);
+        amd_vmcb_intercepts_wridtr_wrf(&g->vmcb, 0);
+        // disable TR intercept
+        amd_vmcb_intercepts_rdtr_wrf(&g->vmcb, 0);
+        amd_vmcb_intercepts_wrtr_wrf(&g->vmcb, 0);
+        // disable non essential CR0 access intercepts_t
+        amd_vmcb_cr_access_rdcr0_wrf(&g->vmcb, 0);
+        amd_vmcb_cr_access_wrcr0_wrf(&g->vmcb, 0);
+        // disable CR3 access intercepts
+        assert(amd_vmcb_np_rd(&g->vmcb).enable != 0);
+        amd_vmcb_cr_access_rdcr3_wrf(&g->vmcb, 0);
+        amd_vmcb_cr_access_wrcr3_wrf(&g->vmcb, 0);
+        // disable INTn intercept
+        // we have to be outside of real mode for this to work
+        assert(amd_vmcb_cr0_rd(&g->vmcb).pe != 0);
+        amd_vmcb_intercepts_intn_wrf(&g->vmcb, 0);
+
+        // mark guest as not emulated
+        g->emulated_before_exit = false;
+    }
+#endif
+
+    // update the guets domain's runnable state
+    err = invoke_dispatcher(g->dcb_cap, NULL_CAP, NULL_CAP, NULL_CAP, NULL_CAP, run);
+    assert_err(err, "dispatcher_make_runnable");
+    // yield the dispatcher
+    if (run) {
+        thread_yield_dispatcher(NULL_CAP);
+    }
+
+    return SYS_ERR_OK;
+}
+
+/* VMEXIT hanlders */
+
+#define HANDLER_ERR_OK          (0)
+#define HANDLER_ERR_FATAL       (-1)
+
+static int
+handle_vmexit_unhandeled (struct guest *g)
+{
+    printf("Unhandeled guest vmexit:\n");
+    printf(" code:\t  %lx\n", amd_vmcb_exitcode_rd(&g->vmcb));
+    printf(" info1:\t  %lx\n", amd_vmcb_exitinfo1_rd(&g->vmcb));
+    printf(" info2:\t  %lx\n", amd_vmcb_exitinfo2_rd(&g->vmcb));
+    printf(" intinfo: %lx\n", amd_vmcb_exitintinfo_rd(&g->vmcb));
+
+    printf("VMCB save area:\n");
+    printf(" cr0:\t%lx\n", amd_vmcb_cr0_rd_raw(&g->vmcb));
+    printf(" cr2:\t%lx\n", amd_vmcb_cr2_rd_raw(&g->vmcb));
+    printf(" cr3:\t%lx\n", amd_vmcb_cr3_rd_raw(&g->vmcb));
+    printf(" cr4:\t%lx\n", amd_vmcb_cr4_rd_raw(&g->vmcb));
+    printf(" efer:\t%lx\n", amd_vmcb_efer_rd_raw(&g->vmcb));
+    printf(" rip:\t%lx\n", amd_vmcb_rip_rd_raw(&g->vmcb));
+    printf(" rsp:\t%lx\n", amd_vmcb_rsp_rd_raw(&g->vmcb));
+    printf(" cs:\tselector %x, base %lx, limit %x, attrib %x\n",
+           amd_vmcb_cs_selector_rd(&g->vmcb), amd_vmcb_cs_base_rd(&g->vmcb),
+           amd_vmcb_cs_limit_rd(&g->vmcb), amd_vmcb_cs_attrib_rd_raw(&g->vmcb));
+    printf(" ds:\tselector %x, base %lx, limit %x, attrib %x\n",
+           amd_vmcb_ds_selector_rd(&g->vmcb), amd_vmcb_ds_base_rd(&g->vmcb),
+           amd_vmcb_ds_limit_rd(&g->vmcb), amd_vmcb_ds_attrib_rd_raw(&g->vmcb));
+    printf(" es:\tselector %x, base %lx, limit %x, attrib %x\n",
+           amd_vmcb_es_selector_rd(&g->vmcb), amd_vmcb_es_base_rd(&g->vmcb),
+           amd_vmcb_es_limit_rd(&g->vmcb), amd_vmcb_es_attrib_rd_raw(&g->vmcb));
+    printf(" ss:\tselector %x, base %lx, limit %x, attrib %x\n",
+           amd_vmcb_ss_selector_rd(&g->vmcb), amd_vmcb_ss_base_rd(&g->vmcb),
+           amd_vmcb_ss_limit_rd(&g->vmcb), amd_vmcb_ss_attrib_rd_raw(&g->vmcb));
+    printf(" rax:\t%lx\n", amd_vmcb_rax_rd_raw(&g->vmcb));
+    printf(" rbx:\t%lx\n", g->ctrl->regs.rbx);
+    printf(" rcx:\t%lx\n", g->ctrl->regs.rcx);
+    printf(" rdx:\t%lx\n", g->ctrl->regs.rdx);
+    printf(" rsi:\t%lx\n", g->ctrl->regs.rsi);
+    printf(" rdi:\t%lx\n", g->ctrl->regs.rdi);
+
+    return HANDLER_ERR_FATAL;
+}
+
+static inline uint64_t
+lookup_paddr_long_mode (struct guest *g, uint64_t vaddr)
+{
+    union x86_lm_va va = { .raw = vaddr };
+    uint64_t *page_table;
+
+    // get a pointer to the pml4 table
+    page_table = (uint64_t *)guest_to_host(amd_vmcb_cr3_rd(&g->vmcb));
+    // get pml4 entry
+    union x86_lm_pml4_entry pml4e = { .raw = page_table[va.u.pml4_idx] };
+    assert (pml4e.u.p == 1);
+
+    // get a pointer to the pdp table
+    page_table = (uint64_t *)guest_to_host(pml4e.u.pdp_base_pa << 12);
+    // get pdp entry
+    union x86_lm_pdp_entry pdpe = { .raw = page_table[va.u.pdp_idx] };
+    assert(pdpe.u.p == 1);
+    // check for 1GB page (PS bit set)
+    if (pdpe.u.ps == 1) {
+        return (pdpe.u1gb.base_pa << 30) | va.u1gb.pa_offset;
+    }
+
+    // get a pointer to the pd table
+    page_table = (uint64_t *)guest_to_host(pdpe.u.pd_base_pa << 12);
+    // get pd entry
+    union x86_lm_pd_entry pde = { .raw = page_table[va.u.pd_idx] };
+    if (pde.u.p == 0) {
+        printf("g2h %lx, pml4e %p %lx, pdpe %p %lx, pde %p %lx\n", guest_to_host(0), &pml4e, pml4e.raw, &pdpe, pdpe.raw, &pde, pde.raw);
+    }
+    assert(pde.u.p == 1);
+    // check for 2MB page (PS bit set)
+    if (pde.u.ps == 1) {
+        return (pde.u2mb.base_pa << 21) | va.u2mb.pa_offset;
+    }
+
+    // get a pointer to the page table
+    page_table = (uint64_t *)guest_to_host(pde.u.pt_base_pa << 12);
+    // get the page table entry
+    union x86_lm_pt_entry pte = { .raw = page_table[va.u.pt_idx] };
+    assert(pte.u.p == 1);
+
+    return (pte.u.base_pa << 12) | va.u.pa_offset;
+}
+
+static inline uint32_t
+lookup_paddr_legacy_mode (struct guest *g, uint32_t vaddr)
+{
+    // PAE not supported
+    guest_assert(g, amd_vmcb_cr4_rd(&g->vmcb).pae == 0);
+
+    union x86_legm_va va = { .raw = vaddr };
+    uint32_t *page_table;
+
+    // get a pointer to the pd table
+    page_table = (uint32_t *)guest_to_host(amd_vmcb_cr3_rd(&g->vmcb));
+    // get pd entry
+    union x86_legm_pd_entry pde = { .raw = page_table[va.u.pd_idx] };
+    assert (pde.u.p == 1);
+    // check for 4MB page (PS bit set)
+    if (pde.u.ps == 1) {
+        return (pde.u4mb.base_pa << 22) | va.u4mb.pa_offset;
+    }
+
+    // get a pointer to the page table
+    page_table = (uint32_t *)guest_to_host(pde.u.pt_base_pa << 12);
+    // get the page table entry
+    union x86_legm_pt_entry pte = { .raw = page_table[va.u.pt_idx] };
+    assert(pte.u.p == 1);
+
+    return (pte.u.base_pa << 12) | va.u.pa_offset;
+}
+
+// retunrs a pointer to a byte array starting at the current instruction
+static inline int
+get_instr_arr (struct guest *g, uint8_t **arr)
+{
+  if (amd_vmcb_cr0_rd(&g->vmcb).pg == 0 || !amd_vmcb_np_rd(&g->vmcb).enable) {
+        // without paging
+        // take segmentation into account
+        *arr = (uint8_t *)(guest_to_host(g->mem_low_va) +
+               amd_vmcb_cs_base_rd(&g->vmcb) +
+               amd_vmcb_rip_rd(&g->vmcb));
+    } else {
+        // with paging
+        if (amd_vmcb_efer_rd(&g->vmcb).lma == 1) {
+            // long mode
+            if (amd_vmcb_cs_attrib_rd(&g->vmcb).l == 1) {
+                // 64-bit mode
+                *arr = (uint8_t *)guest_to_host(lookup_paddr_long_mode(g,
+                                                amd_vmcb_rip_rd(&g->vmcb)));
+            } else {
+                // cmpatibility mode
+                guest_assert(g, !"compatiblity mode not supported yet");
+            }
+        } else {
+            // Legacy (aka. Paged Protected) Mode
+            assert(amd_vmcb_cr0_rd(&g->vmcb).pe == 1);
+
+            *arr = (uint8_t *)guest_to_host(lookup_paddr_legacy_mode(g,
+                                            amd_vmcb_rip_rd(&g->vmcb)));
+        }
+    }
+
+    return HANDLER_ERR_OK;
+}
+
+static inline uint64_t
+get_reg_val_by_reg_num (struct guest *g, uint8_t regnum) {
+    switch (regnum) {
+    case 0:
+        return guest_get_rax(g);
+    case 1:
+        return guest_get_rcx(g);
+    case 2:
+        return guest_get_rdx(g);
+    case 3:
+        return guest_get_rbx(g);
+    case 4:
+        return guest_get_rsp(g);
+    case 5:
+        return guest_get_rbp(g);
+    case 6:
+        return guest_get_rsi(g);
+    case 7:
+        return guest_get_rdi(g);
+    default:
+        assert(!"not reached");
+        return 0;
+    }
+}
+
+static inline void
+set_reg_val_by_reg_num (struct guest *g, uint8_t regnum, uint64_t val) {
+    switch (regnum) {
+    case 0:
+        guest_set_rax(g, val);
+        break;
+    case 1:
+        guest_set_rcx(g, val);
+        break;
+    case 2:
+        guest_set_rdx(g, val);
+        break;
+    case 3:
+        guest_set_rbx(g, val);
+        break;
+    case 4:
+        guest_set_rsp(g, val);
+        break;
+    case 5:
+        guest_set_rbp(g, val);
+        break;
+    case 6:
+        guest_set_rsi(g, val);
+        break;
+    case 7:
+        guest_set_rdi(g, val);
+        break;
+    default:
+        assert(!"not reached");
+        break;
+    }
+}
+
+static int
+handle_vmexit_cr_access (struct guest *g)
+{
+    int r;
+    uint8_t *code = NULL;
+
+    // fetch the location to the code
+    r = get_instr_arr(g, &code);
+    if (r != HANDLER_ERR_OK) {
+        return r;
+    }
+    assert(code != NULL);
+
+    assert(code[0] == 0x0f && (code[1] == 0x20 || code[1] == 0x22));
+
+    uint64_t val;
+    bool read = (code[1] == 0x20);
+    union x86_modrm mod;
+    mod.raw = code[2];
+
+    // FIXME: use proper exception
+    assert(mod.u.mod == 3);
+
+    // source
+    if (read) {
+        // read from CR
+        switch (mod.u.regop) {
+        case 0:
+            val = amd_vmcb_cr0_rd_raw(&g->vmcb);
+            break;
+        default:
+            printf("CR access: unknown CR source register\n");
+            return handle_vmexit_unhandeled(g);
+        }
+    } else {
+        // read from GPR
+        val = get_reg_val_by_reg_num(g, mod.u.rm);
+    }
+
+    // destination
+    if (read) {
+        // write to GPR
+        switch (mod.u.rm) {
+        case 0:
+            guest_set_rax(g, val);
+            break;
+        case 1:
+            guest_set_rcx(g, val);
+            break;
+        case 2:
+            guest_set_rdx(g, val);
+            break;
+        case 3:
+            guest_set_rbx(g, val);
+            break;
+        default:
+            printf("CR access: unknown GPR destination register\n");
+            return handle_vmexit_unhandeled(g);
+        }
+    } else {
+        // write to CR
+        switch (mod.u.regop) {
+        case 0:
+            amd_vmcb_cr0_wr_raw(&g->vmcb, val);
+            break;
+        default:
+            printf("CR access: unknown CR destination register\n");
+            return handle_vmexit_unhandeled(g);
+        }
+    }
+
+    // advance the rip beyond the instruction
+    amd_vmcb_rip_wr(&g->vmcb, amd_vmcb_rip_rd(&g->vmcb) + 3);
+
+    return HANDLER_ERR_OK;
+}
+
+static int
+handle_vmexit_ldt (struct guest *g)
+{
+    int r;
+    uint8_t *code = NULL;
+    uint8_t *mem;
+
+    // this handler supports only real-mode
+    assert(amd_vmcb_cr0_rd(&g->vmcb).pe == 0);
+
+    // fetch the location to the code
+    r = get_instr_arr(g, &code);
+    if (r != HANDLER_ERR_OK) {
+        return r;
+    }
+    mem = (uint8_t *)guest_to_host(g->mem_low_va);
+    assert(code != NULL);
+
+    assert (code[0] == 0x0f && code[1] == 0x01);
+
+    // check for relevant instruction prefixes
+    bool addr32 = code[-2] == 0x67 || code[-1] == 0x67;
+    bool op32 = code[-2] == 0x66 || code[-1] == 0x66;
+    // fetch modrm
+    union x86_modrm modrm = { .raw = code[2] };
+
+    assert(modrm.u.regop == 2 || modrm.u.regop == 3);
+    guest_assert(g, op32);
+
+    uint32_t addr;
+    if (addr32) {
+        // byte 3-6 hold a 32 bit address to a mem location where the first word
+        // holds the limit and the following dword holds the base
+        addr = *(uint32_t *)&code[3];
+    } else {
+        // byte 3-4 hold a 16 bit address to a mem location where the first word
+        // holds the limit and the following dword holds the base
+        // this address is relative to DS base
+        addr = *(uint16_t *)&code[3] + amd_vmcb_ds_base_rd(&g->vmcb);
+    }
+
+    // santity check on the addr
+    // FIXME: raise a proper exception
+    if (addr > g->mem_high_va) {
+        printf("Memory access beyond physical address space\n");
+        return HANDLER_ERR_FATAL;
+    }
+
+    // load the actual register
+    if (modrm.u.regop == 2) {
+        // LGDT
+        amd_vmcb_gdtr_limit_wr(&g->vmcb, *(uint16_t*)(mem + addr));
+        amd_vmcb_gdtr_base_wr(&g->vmcb, *(uint32_t*)(mem + addr + 2));
+    } else if (modrm.u.regop == 3) {
+        // LIDT
+        amd_vmcb_idtr_limit_wr(&g->vmcb, *(uint16_t*)(mem + addr));
+        amd_vmcb_idtr_base_wr(&g->vmcb, *(uint32_t*)(mem + addr + 2));
+    } else {
+        assert(!"not reached");
+    }
+
+    // advance the rip beyond the instruction
+    if (addr32) {
+        amd_vmcb_rip_wr(&g->vmcb, amd_vmcb_rip_rd(&g->vmcb) + 7);
+    } else {
+        amd_vmcb_rip_wr(&g->vmcb, amd_vmcb_rip_rd(&g->vmcb) + 5);
+    }
+
+    return HANDLER_ERR_OK;
+}
+
+static int
+handle_vmexit_swint (struct guest *g)
+{
+    int r;
+    uint8_t *code = NULL;
+
+    r = get_instr_arr(g, &code);
+    if (r != HANDLER_ERR_OK) {
+        return r;
+    }
+    assert (code != NULL);
+
+    // check for correct instruciton
+    assert(code[0] == 0xcd);
+
+    // the number of the interrupt is followed by the INT (0xcd) opcode
+    uint8_t int_num = code[1];
+
+    // check whether the guest is in real mode
+    if (amd_vmcb_cr0_rd(&g->vmcb).pe == 0) {
+        // in real mode the interrupts starting at 10 have different meaning
+        // examine the sw interrupt
+        switch (int_num) {
+            case 0x10:
+                r = console_handle_int10(g->console, g);
+                if (r != HANDLER_ERR_OK) {
+                    printf("Unhandeled method on INT 0x10\n");
+                    return handle_vmexit_unhandeled(g);
+                }
+                break;
+            case 0x12:
+                switch (guest_get_ax(g)) {
+                    case 0: // GET MEMORY SIZE
+                        // our VM always has 1MB of base memory
+                        // AX holds the amount of 1KB memory blocks starting at
+                        // addr 0 which is 640 (640 KiB)
+                        guest_set_ax(g, 640);
+                        break;
+                    default:
+                        printf("Unhandeled method on INT 0x12\n");
+                        return handle_vmexit_unhandeled(g);
+                }
+                break;
+            case 0x13:
+                // Bootable CD-ROM - GET STATUS
+                if (guest_get_ax(g) == 0x4b01) {
+                    // no cdrom support
+                    amd_vmcb_rflags_cf_wrf(&g->vmcb, 1);
+                }
+                // DISK RESET
+                else if (guest_get_ah(g) == 0) {
+                    for (int i = 0; i < g->hdd_count; i++) {
+                        hdd_reset(g->hdds[i]);
+                    }
+                }
+                // DISK - GET DRIVE PARAMETERS (PC,XT286,CONV,PS,ESDI,SCSI)
+                else if (guest_get_ah(g) == 0x08) {
+                    uint8_t dl = guest_get_dl(g);
+
+                    // only respond to installed hard disks
+                    if ((dl >> 7) && ((dl & 0x7f) < g->hdd_count)) {
+                        uint16_t c;
+                        uint8_t h, s;
+
+                        r = hdd_get_geometry_chs(g->hdds[dl & 0x7f], &c, &h, &s);
+                        assert(r == 0);
+
+                        // set some return values for success
+                        guest_set_ah(g, 0);
+                        amd_vmcb_rflags_cf_wrf(&g->vmcb, 0);
+                        guest_set_bl(g, 0);
+                        // store the geometry into the correct registers
+                        guest_set_cx(g, c << 6 | (s & 0x3f));
+                        guest_set_dh(g, h);
+                        guest_set_dl(g, g->hdd_count);
+                    } else {
+                        amd_vmcb_rflags_cf_wrf(&g->vmcb, 1);
+                        // it is not really clear to me what ah should contain
+                        // when the drive is not present, so set it to FF
+                        guest_set_ah(g, 1);
+                    }
+                }
+                // INT 13 Extensions - INSTALLATION CHECK
+                else if (guest_get_ah(g) == 0x41 && guest_get_bx(g) == 0x55aa) {
+                    amd_vmcb_rflags_cf_wrf(&g->vmcb, 0);
+                    guest_set_bx(g, 0xaa55);
+                    guest_set_ah(g, 0x01); // Drive extensions 1.x
+                    guest_set_al(g, 0);
+                    guest_set_cx(g, 0x5);
+                }
+                // IBM/MS INT 13 Extensions - EXTENDED READ
+                else if (guest_get_ah(g) == 0x42) {
+                    uint8_t dl = guest_get_dl(g);
+
+                    // only respond to installed hard disks
+                    if ((dl >> 7) && ((dl & 0x7f) < g->hdd_count)) {
+                        amd_vmcb_rflags_cf_wrf(&g->vmcb, 0);
+                        guest_set_ah(g, 0);
+
+                        struct disk_access_block {
+                            uint8_t     size;
+                            uint8_t     reserved;
+                            uint16_t    count;
+                            // pointer to the data buffer formated like
+                            // SEGMENT:ADDRESS
+                            uint32_t    transfer_buffer;
+                            uint64_t    abs_block_number;
+                        } __attribute__ ((packed));
+
+                        // memory location of the disk access block
+                        uintptr_t mem = guest_to_host(g->mem_low_va) +
+                                        amd_vmcb_ds_base_rd(&g->vmcb) +
+                                        guest_get_si(g);
+                        struct disk_access_block *dap = (void *)mem;
+
+                        if (dap->size < 0x10) {
+                            amd_vmcb_rflags_cf_wrf(&g->vmcb, 1);
+                            guest_set_ah(g, 1);
+                        } else {
+                            // dap->transfer buffer points to a real-mode segment
+                            // resolve it according to that rules
+                            mem = guest_to_host(g->mem_low_va) +
+                                  ((dap->transfer_buffer >> 16) << 4) +
+                                  (dap->transfer_buffer & 0xffff);
+
+                            size_t count = dap->count;
+                            r = hdd_read_blocks(g->hdds[dl & 0x7f],
+                                                dap->abs_block_number,
+                                                &count, mem);
+                            dap->count = count;
+
+                            if (r != HANDLER_ERR_OK) {
+                                amd_vmcb_rflags_cf_wrf(&g->vmcb, 1);
+                                guest_set_ah(g, 1);
+                            }
+                        }
+                    } else {
+                        amd_vmcb_rflags_cf_wrf(&g->vmcb, 1);
+                        // it is not really clear to me what ah should contain
+                        // when the drive is not present, so set it to FF
+                        guest_set_ah(g, 1);
+                    }
+                }
+                // IBM/MS INT 13 Extensions - GET DRIVE PARAMETERS
+                else if (guest_get_ah(g) == 0x48) {
+                    uint8_t dl = guest_get_dl(g);
+
+                    // only respond to installed hard disks
+                    if ((dl >> 7) && ((dl & 0x7f) < g->hdd_count)) {
+                        // structure to hold drive info
+                        struct drive_params {
+                            uint16_t size;
+                            uint16_t flags;
+                            uint32_t cylinders;
+                            uint32_t heads;
+                            uint32_t sectors;
+                            uint64_t total_sectors;
+                            uint16_t bytes_per_sector;
+                        } __attribute__ ((packed));
+
+                        // memory where the drive info shall be stored
+                        uintptr_t mem = guest_to_host(g->mem_low_va) +
+                                        amd_vmcb_ds_base_rd(&g->vmcb) +
+                                        guest_get_si(g);
+                        struct drive_params *drp = (void *)mem;
+
+                        // sanity check
+                        if (drp->size < sizeof(struct drive_params)) {
+                            amd_vmcb_rflags_cf_wrf(&g->vmcb, 1);
+                        } else {
+                            amd_vmcb_rflags_cf_wrf(&g->vmcb, 0);
+                            guest_set_ah(g, 0);
+
+                            drp->size = sizeof(struct drive_params);
+                            // CHS invalid, no removable drive, etc
+                            drp->flags = 0;
+                            drp->cylinders = 0;
+                            drp->heads = 0;
+                            drp->sectors = 0;
+                            drp->total_sectors = hdd_get_blocks_count(
+                                                    g->hdds[dl & 0x7f]);
+                            drp->bytes_per_sector = 512; // FIXME: Hardcoded
+                        }
+                    } else {
+                        amd_vmcb_rflags_cf_wrf(&g->vmcb, 1);
+                        // it is not really clear to me what ah should contain
+                        // when the drive is not present, so set it to FF
+                        guest_set_ah(g, 0x1);
+                    }
+                } else {
+                    printf("Unhandeled method on INT 0x13\n");
+                    return handle_vmexit_unhandeled(g);
+                }
+                break;
+            case 0x15:
+                // ENABLE A20 GATE
+                if (guest_get_ax(g) == 0x2401) {
+                    g->a20_gate_enabled = true;
+                    amd_vmcb_rflags_cf_wrf(&g->vmcb, 0);
+                    guest_set_ah(g, 0);
+                }
+                // APM INSTALLATION CHECK
+                else if (guest_get_ax(g) == 0x5300) {
+                    // we do not support APM - set carry flag to indicate error
+                    amd_vmcb_rflags_cf_wrf(&g->vmcb, 1);
+                }
+                // APM DISCONNECT
+                else if (guest_get_ax(g) == 0x5304) {
+                    // we do not support APM - set carry flag to indicate error
+                    amd_vmcb_rflags_cf_wrf(&g->vmcb, 1);
+                }
+                // GET MEMORY SIZE FOR >64M CONFIGURATIONS
+                else if (guest_get_ax(g) == 0xe801) {
+                    // we do not support this BIOS call
+                    // both grub and linux may also use the 0xe820 call
+                    amd_vmcb_rflags_cf_wrf(&g->vmcb, 1);
+                }
+                // GET SYSTEM MEMORY MAP
+                // EDX has to contain 0x534d4150 (== 'SMAP')
+                else if (guest_get_ax(g) == 0xe820 &&
+                         guest_get_edx(g) == 0x534d4150) {
+                    // for now we return only one entry containing the real mem
+                    if (guest_get_ebx(g) > 1 || guest_get_ecx(g) < 20) {
+                        // wrong input params -> report error
+                        amd_vmcb_rflags_cf_wrf(&g->vmcb, 1);
+                    } else {
+                        // taken from http://www.ctyme.com/intr/rb-1741.htm
+                        uintptr_t addr = guest_to_host(g->mem_low_va) +
+                                         amd_vmcb_es_base_rd(&g->vmcb) +
+                                         guest_get_di(g);
+
+                        // set EAX to 'SMAP'
+                        guest_set_eax(g, 0x534D4150);
+                        // returned bytes (always 20)
+                        guest_set_ecx(g, 20);
+
+                        switch (guest_get_ebx(g)) {
+                        case 0x0:
+                            // base memory
+                            assert(g->mem_low_va == 0);
+                            // base address
+                            *(uint64_t *)addr = 0;
+                            // size of the memory block
+                            *(uint64_t *)(addr + 8) = 0xa0000; // 640 KiB
+                            // mem type, 1 == "memory, available to the OS"
+                            *(uint32_t *)(addr + 16) = 1;
+                            // indicate that there is more data
+                            guest_set_ebx(g, 1);
+                            break;
+                        case 0x1:
+                            // extended memory
+                            assert(g->mem_high_va > 0x100000);
+                            // base address
+                            *(uint64_t *)addr = 0x100000;   // 1 MiB
+                            // size of the memory block
+                            *(uint64_t *)(addr + 8) = g->mem_high_va - 0x100000;
+                            // mem type, 1 == "memory, available to the OS"
+                            *(uint32_t *)(addr + 16) = 1;
+                            // indicate that there is no more data
+                            guest_set_ebx(g, 0);
+                            break;
+                        default:
+                            assert(!"not reached");
+                            break;
+                        }
+
+                        // mark success
+                        amd_vmcb_rflags_cf_wrf(&g->vmcb, 0);
+                    }
+                }
+                // SYSTEM - Get Intel SpeedStep (IST) information
+                else if (guest_get_ax(g) == 0xe980) {
+                    // not supportet yet
+                    amd_vmcb_rflags_cf_wrf(&g->vmcb, 1);
+                }
+                // SYSTEM - GET CONFIGURATION (XT >1986/1/10,AT mdl 3x9,
+                // CONV,XT286,PS)
+                // GRUB BUG: it puts 0xc0 into AX instead of AH
+                else if (guest_get_ax(g) == 0xc0) {
+                    // we do not support this
+                    amd_vmcb_rflags_cf_wrf(&g->vmcb, 1);
+                    guest_set_ah(g, 0x80);
+                }
+                // GET EXTENDED MEMORY SIZE
+                else if (guest_get_ah(g) == 0x88) {
+                    // calculate number of 1KB chunks starting from 1MB but not
+                    // beyond 16MB
+                    assert(((g->mem_high_va - g->mem_low_va) & 0x3ff) == 0);
+                    guest_set_ax(g, MIN(0x3c00 /* 16MB */,
+                                 (g->mem_high_va - g->mem_low_va) / 1024));
+                    // indicate no error occured
+                    amd_vmcb_rflags_cf_wrf(&g->vmcb, 0);
+                }
+                // SYSTEM - GET CONFIGURATION (XT >1986/1/10,AT mdl 3x9,
+                // CONV,XT286,PS)
+                else if (guest_get_ah(g) == 0xc0) {
+                    // we do not support this
+                    amd_vmcb_rflags_cf_wrf(&g->vmcb, 1);
+                    guest_set_ah(g, 0x80);
+                // SYSTEM - SET BIOS MODE
+                } else if (guest_get_ah(g) == 0xec) {
+                    // I do no really know the use of this bios call and linux
+                    // expects no action what so ever
+                } else {
+                    printf("Unhandeled method on INT 0x15\n");
+                    return handle_vmexit_unhandeled(g);
+                }
+                break;
+            case 0x16:
+                // KEYBOARD - SET TYPEMATIC RATE AND DELAY
+                if (guest_get_ah(g) == 0x3) {
+                    // ignore this
+                } else {
+                    printf("Unhandeled method on INT 0x16\n");
+                    return handle_vmexit_unhandeled(g);
+                }
+                break;
+            case 0x1a:
+                // TIME - GET REAL-TIME CLOCK TIME (AT,XT286,PS)
+                if (guest_get_ah(g) == 0x2) {
+                    uint8_t h, m, s;
+                    lpc_rtc_get_time_bcd(g->lpc, &h, &m, &s);
+                    guest_set_ch(g, h);
+                    guest_set_cl(g, m);
+                    guest_set_dh(g, s);
+                    guest_set_dl(g, 0);
+                    // mark success
+                    amd_vmcb_rflags_cf_wrf(&g->vmcb, 0);
+                } else {
+                    printf("Unhandeled method on INT 0x1a\n");
+                    return handle_vmexit_unhandeled(g);
+                }
+                break;
+            default:
+                printf("handle_vmexit_swint: Unhandeled real-mode interrupt "
+                       "0x%x (%d).\n", int_num, int_num);
+                return handle_vmexit_unhandeled(g);
+        }
+    } else {
+        printf("vmkitmon: encountered INT instruction outside real mode\n");
+        return handle_vmexit_unhandeled(g);
+    }
+
+    // advance the rip beyond the instruction
+    amd_vmcb_rip_wr(&g->vmcb, amd_vmcb_rip_rd(&g->vmcb) + 2);
+
+    return HANDLER_ERR_OK;
+}
+
+static inline enum opsize
+io_access_size_to_opsize (enum x86_io_access io)
+{
+    if (io & X86_IO_ACCESS_SZ8) {
+        return OPSIZE_8;
+    } else if (io & X86_IO_ACCESS_SZ16) {
+        return OPSIZE_16;
+    } else if (io & X86_IO_ACCESS_SZ32) {
+        return OPSIZE_32;
+    } else {
+        assert(!"NYI");
+        return 0;
+    }
+}
+
+static int
+handle_vmexit_ioio (struct guest *g)
+{
+    int r;
+    uint64_t info1 = amd_vmcb_exitinfo1_rd(&g->vmcb);
+    enum x86_io_access io;
+    uint16_t port = info1 >> 16;
+    bool write;
+    enum opsize size;
+    uint32_t val;
+    bool newapi = false; // needed as a transition
+
+    // copy the access flags
+    // FIXME: this severely exploits the way the x86_io_access flags are set up
+    io = (info1 >> 1);
+    io |= info1 & SVM_IOIO_TYPE_MASK;
+
+    // gather some params for the io access
+    write = (io & X86_IO_ACCESS_TYPE) == 0;
+    size = OPSIZE_8; // make gcc happy
+    if (io & X86_IO_ACCESS_SZ8) {
+        size = OPSIZE_8;
+    } else if (io & X86_IO_ACCESS_SZ16) {
+        size = OPSIZE_16;
+    } else if (io & X86_IO_ACCESS_SZ32) {
+        size = OPSIZE_32;
+    }
+
+    // fetch the source val if neccessary
+    if (write) {
+        switch (size) {
+        case OPSIZE_8:
+            val = guest_get_al(g);
+            break;
+        case OPSIZE_16:
+            val = guest_get_ax(g);
+            break;
+        case OPSIZE_32:
+            val = guest_get_eax(g);
+            break;
+        default:
+            assert(!"not reached");
+            break;
+        }
+    }
+
+    // assign the request to the corresponding subsystem
+    switch (port) {
+        // LPC devices
+        case 0x20:  // primary PIC
+        case 0x21:  // primary PIC
+        case 0x40:  // Timer
+        case 0x41:  // Timer
+        case 0x42:  // Timer
+        case 0x43:  // Timer
+        case 0x61:  // NMI Controller
+        case 0x70:  // RTC
+        case 0x71:  // RTC
+        case 0x72:  // RTC
+        case 0x73:  // RTC
+        case 0x74:  // RTC
+        case 0x75:  // RTC
+        case 0x76:  // RTC
+        case 0x77:  // RTC
+        case 0xa0:  // secondary PIC
+        case 0xa1:  // secondary PIC
+            if (write) {
+                r = lpc_handle_pio_write(g->lpc, port, size, val);
+                guest_assert(g, r == 0);
+            } else {
+                r = lpc_handle_pio_read(g->lpc, port, size, &val);
+                assert(r == 0);
+            }
+            newapi = true;
+            break;
+        // Keyboard
+        case 0x60:
+        case 0x64:
+            // we currently do not support a keyboard
+            if (!write) {
+                val = ~0;
+            }
+            newapi = true;
+            break;
+        case 0x80:
+            // some apps use writing to this port as a method to delay execution
+            // so we just do noting
+            break;
+        // Coprocessor
+        case 0xf0:
+        case 0xf1:
+            // coprocessor IGNNE# - do nothing for now
+            break;
+
+        // serial COM1 port
+        // FIXME: this should not be hardcoded !
+        case 0x3f8:
+        case 0x3f9:
+        case 0x3fa:
+        case 0x3fb:
+        case 0x3fc:
+        case 0x3fd:
+        case 0x3fe:
+        case 0x3ff:
+        // COM2
+        case 0x2f8:
+        case 0x2f9:
+        case 0x2fa:
+        case 0x2fb:
+        case 0x2fc:
+        case 0x2fd:
+        case 0x2fe:
+        case 0x2ff:
+        // COM3
+        case 0x3e8:
+        case 0x3e9:
+        case 0x3ea:
+        case 0x3eb:
+        case 0x3ec:
+        case 0x3ed:
+        case 0x3ee:
+        case 0x3ef:
+        // COM4
+        case 0x2e8:
+        case 0x2e9:
+        case 0x2ea:
+        case 0x2eb:
+        case 0x2ec:
+        case 0x2ed:
+        case 0x2ee:
+        case 0x2ef: {
+            int com;
+
+            com = (port & 0xf0) == 0xf0 ? !(port & 0x100) : !(port & 0x100) + 2;
+            assert(com >= 0 && com < 4);
+            if (write) {
+                r = pc16550d_handle_pio_write(g->serial_ports[com], port,
+                                              size, val);
+                assert(r == 0);
+            } else {
+                r = pc16550d_handle_pio_read(g->serial_ports[com], port,
+                                             size, &val);
+                assert(r == 0);
+            }
+            newapi = true;
+            break;
+        }
+
+            // PCI config space (address)
+    case 0xcf8:
+    case 0xcf9:
+    case 0xcfa:
+    case 0xcfb:
+            // PCI config space (data)
+    case 0xcfc:
+    case 0xcfd:
+    case 0xcfe:
+    case 0xcff:
+        if(write) {
+            r = pci_handle_pio_write(g->pci, port, size, val);
+        } else {
+            r = pci_handle_pio_read(g->pci, port, size, &val);
+        }
+        assert(r == 0);
+        newapi = true;
+        break;
+
+        default:
+            // the default is to return 0xff and to ignore writes
+            if (!write) {
+                val = 0xffffffff;
+            }
+            newapi = true;
+    };
+
+    // set the destination when neccessary
+    if (newapi && !write) {
+        switch (size) {
+        case OPSIZE_8:
+            guest_set_al(g, val);
+            break;
+        case OPSIZE_16:
+            guest_set_ax(g, val);
+            break;
+        case OPSIZE_32:
+            guest_set_eax(g, val);
+            break;
+        default:
+            assert(!"not reached");
+            break;
+        }
+    }
+
+    // the following IP is stored in the exitinfo2 field
+    amd_vmcb_rip_wr(&g->vmcb, amd_vmcb_exitinfo2_rd(&g->vmcb));
+
+    return HANDLER_ERR_OK;
+}
+
+static int
+handle_vmexit_msr (struct guest *g) {
+    bool write = amd_vmcb_exitinfo1_rd(&g->vmcb) == 1;
+    uint32_t msr = guest_get_ecx(g);
+    uint64_t val;
+
+    // there may be writes or reads to MSRs
+    if (write) {
+        // fetch the value to write from EDX:EAX
+        val = ((uint64_t)guest_get_edx(g) << 32) | guest_get_eax(g);
+
+        // store the read value into the corresponding location
+        switch (msr) {
+        case X86_MSR_SYSENTER_CS:
+            amd_vmcb_sysenter_cs_wr(&g->vmcb, val);
+            break;
+        case X86_MSR_SYSENTER_ESP:
+            amd_vmcb_sysenter_esp_wr(&g->vmcb, val);
+            break;
+        case X86_MSR_SYSENTER_EIP:
+            amd_vmcb_sysenter_eip_wr(&g->vmcb, val);
+            break;
+        case X86_MSR_EFER:
+            amd_vmcb_efer_wr_raw(&g->vmcb, val);
+            break;
+        case X86_MSR_FS_BASE:
+            amd_vmcb_fs_base_wr(&g->vmcb, val);
+            break;
+        case X86_MSR_GS_BASE:
+            amd_vmcb_gs_base_wr(&g->vmcb, val);
+            break;
+        case X86_MSR_KERNEL_GS_BASE:
+            amd_vmcb_kernel_gs_base_wr(&g->vmcb, val);
+            break;
+        case X86_MSR_STAR:
+            amd_vmcb_star_wr(&g->vmcb, val);
+            break;
+        case X86_MSR_LSTAR:
+            amd_vmcb_lstar_wr(&g->vmcb, val);
+            break;
+        case X86_MSR_CSTAR:
+            amd_vmcb_cstar_wr(&g->vmcb, val);
+            break;
+        case X86_MSR_SFMASK:
+            amd_vmcb_sfmask_wr(&g->vmcb, val);
+            break;
+        default:
+            printf("MSR: unhandeled MSR write access to %x\n", msr);
+            return handle_vmexit_unhandeled(g);
+        }
+    } else {
+        // read the value from the corresponding location
+        switch (msr) {
+        case X86_MSR_SYSENTER_CS:
+            val = amd_vmcb_sysenter_cs_rd(&g->vmcb);
+            break;
+        case X86_MSR_SYSENTER_ESP:
+            val = amd_vmcb_sysenter_esp_rd(&g->vmcb);
+            break;
+        case X86_MSR_SYSENTER_EIP:
+            val = amd_vmcb_sysenter_eip_rd(&g->vmcb);
+            break;
+        case X86_MSR_EFER:
+            val = amd_vmcb_efer_rd_raw(&g->vmcb);
+            break;
+        case X86_MSR_FS_BASE:
+            val = amd_vmcb_fs_base_rd(&g->vmcb);
+            break;
+        case X86_MSR_GS_BASE:
+            val = amd_vmcb_gs_base_rd(&g->vmcb);
+            break;
+        case X86_MSR_KERNEL_GS_BASE:
+            val = amd_vmcb_kernel_gs_base_rd(&g->vmcb);
+            break;
+        case X86_MSR_STAR:
+            val = amd_vmcb_star_rd(&g->vmcb);
+            break;
+        case X86_MSR_LSTAR:
+            val = amd_vmcb_lstar_rd(&g->vmcb);
+            break;
+        case X86_MSR_CSTAR:
+            val = amd_vmcb_cstar_rd(&g->vmcb);
+            break;
+        case X86_MSR_SFMASK:
+            val = amd_vmcb_sfmask_rd(&g->vmcb);
+            break;
+        default:
+            printf("MSR: unhandeled MSR read access to %x\n", msr);
+            return handle_vmexit_unhandeled(g);
+        }
+
+        // store the value in EDX:EAX
+        guest_set_eax(g, val);
+        guest_set_edx(g, val >> 32);
+    }
+
+    // advance the rip beyond the current instruction
+    amd_vmcb_rip_wr(&g->vmcb, amd_vmcb_rip_rd(&g->vmcb) + 2);
+
+    return HANDLER_ERR_OK;
+}
+
+static int
+handle_vmexit_cpuid (struct guest *g) {
+    uint32_t eax, ebx, ecx, edx;
+    uint32_t func = guest_get_eax(g);
+
+    switch (func) {
+    // Processor Vendor and Largest Standard Function Number
+    case 0:
+    case 0x80000000:
+        // max standard function offset
+        eax = func == 0 ? 0x1 : 0x80000000;
+        // string "AuthenticAMD"
+        ebx = 0x68747541;
+        ecx = 0x444d4163;
+        edx = 0x69746e65;
+    break;
+
+    // Family, Model, Stepping Identifiers
+    case 1:
+        // we simulate a AMD K6-3D
+        // Family 5, Model 8, Stepping 12
+        eax = 0x58c;
+        // no brand, clflush size 16, no mulitprocessing, no local apic
+        ebx = 0x0f00;
+        // support the popcnt instr
+        ecx = 0x800000;
+        // support some basic features
+        edx = 0x89a91b;
+    break;
+
+    default:
+        // use the answer of the host if there is any other request
+        // FIXME: this is probably not a good idea ;)
+        cpuid(func, &eax, &ebx, &ecx, &edx);
+        printf("handle_vmexit_cpuid: CPUID: func %x, host reports: eax %x, "
+                "ebx %x, ecx %x, edx %x\n", func, eax, ebx, ecx, edx);
+        break;
+    }
+
+    guest_set_eax(g, eax);
+    guest_set_ebx(g, ebx);
+    guest_set_ecx(g, ecx);
+    guest_set_edx(g, edx);
+
+    // advance the rip beyond the instruction
+    amd_vmcb_rip_wr(&g->vmcb, amd_vmcb_rip_rd(&g->vmcb) + 2);
+
+    return HANDLER_ERR_OK;
+}
+
+static int
+handle_vmexit_vmmcall (struct guest *g) {
+    printf("VMMCALL: tsc %lu, exits with mon invocation %lu, exits w/o mon "
+           "invocation %lu\n", rdtsc(),
+           g->ctrl->num_vm_exits_with_monitor_invocation,
+           g->ctrl->num_vm_exits_without_monitor_invocation);
+
+    // advance the rip beyond the instruction
+    amd_vmcb_rip_wr(&g->vmcb, amd_vmcb_rip_rd(&g->vmcb) + 3);
+
+    return HANDLER_ERR_OK;
+}
+
+static int
+handle_vmexit_hlt (struct guest *g) {
+    // the guest has nothing to do - poll out irq sources for pending IRQs
+    // if they do not assert a virtual IRQ then we will do nothing
+    lpc_pic_process_irqs(g->lpc);
+
+    // advance the rip beyond the instruction
+    amd_vmcb_rip_wr(&g->vmcb, amd_vmcb_rip_rd(&g->vmcb) + 1);
+
+    // running HLT with IRQs masked does not make any sense
+    // FIXME: this assert silly, shutting down the VM would be the right way
+    guest_assert(g, amd_vmcb_rflags_rd(&g->vmcb).intrf == 1);
+    if (virq_pending(g, NULL, NULL)) {
+        // there is an IRQ pending, proceed as normal, the CPU will take it
+    } else {
+        // there is really nothing to do - stop the VM and wait
+        g->runnable = false;
+    }
+
+    return HANDLER_ERR_OK;
+}
+
+static inline int
+decode_mov_instr_length (struct guest *g, uint8_t *code)
+{
+    int len;
+
+    // we only support long mode for now
+    assert(amd_vmcb_efer_rd(&g->vmcb).lma == 1);
+
+    // all non special MOV instructions use one byte as opcode and at least a
+    // ModR/M byte
+    len = 2;
+    // check for the REX prefix
+    if ((code[0] >> 4) == 0x4) {
+        len++;
+        code++;
+    }
+    // precaution because I did no check all variants of MOV, at least these two
+    // variants are supported
+    assert(code[0] == 0x89 || code[0] == 0x8b);
+
+    union x86_modrm modrm = { .raw = code[1] };
+    // check for displacements
+    if (modrm.u.mod == 0x1) {
+        // 1B displacement
+        len++;
+    } else if (modrm.u.mod == 0x2) {
+        // 4B displacement
+        len += 4;
+    }
+
+    // check for SIB byte
+    if (modrm.u.rm == 0x4 && modrm.u.mod != 0x3) {
+        len++;
+    }
+
+    return len;
+}
+
+// finds out whether a move instruction is a read or a write with respect to
+// memory
+static inline bool
+decode_mov_is_write (struct guest *g, uint8_t *code)
+{
+    // check for the REX prefix
+    if ((code[0] >> 4) == 0x4) {
+        code++;
+    }
+
+    // we only support one move variant (in each direction) for now
+    assert(code[0] == 0x89 || code[0] == 0x8b);
+
+    union x86_modrm modrm = { .raw = code[1] };
+    // not defined for reg to reg moves
+    assert(modrm.u.mod != 3);
+
+    return code[0] == 0x89; // 0x89 ==> MOV reg -> mem
+}
+
+static inline enum opsize
+decode_mov_op_size (struct guest *g, uint8_t *code)
+{
+    // we only support long mode for now
+    assert(amd_vmcb_efer_rd(&g->vmcb).lma == 1);
+
+    // check for the REX prefix
+    if ((code[0] >> 4) == 0x4 && code[0] & 0x48) {
+        return OPSIZE_64;
+    }
+    return OPSIZE_32;
+}
+
+
+static inline uint64_t
+decode_mov_src_val (struct guest *g, uint8_t *code) {
+    // we only support long mode for now
+    assert(amd_vmcb_efer_rd(&g->vmcb).lma == 1);
+
+    // check for the REX prefix
+    if ((code[0] >> 4) == 0x4) {
+        code++;
+    }
+
+    // we only support one variant for now
+    assert(code[0] == 0x89);
+
+    union x86_modrm modrm = { .raw = code[1] };
+    return get_reg_val_by_reg_num(g, modrm.u.regop);
+}
+
+
+static inline void
+decode_mov_dest_val (struct guest *g, uint8_t *code, uint64_t val)
+{
+    // we only support long mode for now
+    assert(amd_vmcb_efer_rd(&g->vmcb).lma == 1);
+
+    // check for the REX prefix
+    if ((code[0] >> 4) == 0x4) {
+        code++;
+    }
+
+    // we only support one variant for now
+    assert(code[0] == 0x8b);
+
+    union x86_modrm modrm = { .raw = code[1] };
+    set_reg_val_by_reg_num(g, modrm.u.regop, val);
+}
+
+static int
+handle_vmexit_npf (struct guest *g) {
+    int r;
+    uint64_t fault_addr = amd_vmcb_exitinfo2_rd(&g->vmcb);
+    uint8_t *code = NULL;
+
+    // check for fault inside the guest physical memory region
+    if (fault_addr >= g->mem_low_va && fault_addr < g->mem_high_va) {
+        // allocate the missing memory
+        alloc_guest_mem(g, fault_addr & ~BASE_PAGE_MASK, BASE_PAGE_SIZE);
+        // do not advance the RIP, it is safe (and neccessary) to
+        // replay the faulting instruction
+        return HANDLER_ERR_OK;
+    }
+
+    // fetch the location to the code
+    r = get_instr_arr(g, &code);
+    assert (r == 0);
+
+    // virtual devices
+    switch (fault_addr & ~BASE_PAGE_MASK) {
+    case APIC_BASE: {
+        uint64_t val;
+        enum opsize size;
+
+        assert(g->apic != NULL);
+        size = decode_mov_op_size(g, code);
+        if (decode_mov_is_write(g, code)) {
+            val = decode_mov_src_val(g, code);
+            r = apic_handle_mmio_write(g->apic, fault_addr, size, val);
+            assert(r == 0);
+        } else {
+            r = apic_handle_mmio_read(g->apic, fault_addr, size, &val);
+            assert(r == 0);
+            decode_mov_dest_val(g, code, val);
+        }
+
+        // advance the rip beyond the instruction
+        amd_vmcb_rip_wr(&g->vmcb, amd_vmcb_rip_rd(&g->vmcb) +
+                        decode_mov_instr_length(g, code));
+
+        return HANDLER_ERR_OK;
+    }
+    }
+
+    printf("vmkitmon: access to an unknown memory location: %lx\n", fault_addr);
+    return handle_vmexit_unhandeled(g);
+}
+
+typedef int (*vmexit_handler)(struct guest *g);
+
+static vmexit_handler vmexit_handlers[0x8c] = {
+    [SVM_VMEXIT_CR0_READ] = handle_vmexit_cr_access,
+    [SVM_VMEXIT_CR0_WRITE] = handle_vmexit_cr_access,
+    [SVM_VMEXIT_CR0_SEL_WRITE] = handle_vmexit_cr_access,
+    [SVM_VMEXIT_SWINT] = handle_vmexit_swint,
+    [SVM_VMEXIT_IDTR_WRITE] = handle_vmexit_ldt,
+    [SVM_VMEXIT_GDTR_WRITE] = handle_vmexit_ldt,
+    [SVM_VMEXIT_IOIO] = handle_vmexit_ioio,
+    [SVM_VMEXIT_MSR] = handle_vmexit_msr,
+    [SVM_VMEXIT_CPUID] = handle_vmexit_cpuid,
+    [SVM_VMEXIT_VMMCALL] = handle_vmexit_vmmcall,
+    [SVM_VMEXIT_HLT] = handle_vmexit_hlt
+};
+
+void
+guest_handle_vmexit (struct guest *g) {
+    uint64_t exitcode = amd_vmcb_exitcode_rd(&g->vmcb);
+
+    vmexit_handler handler;
+
+    printf("arrakis: VMEXIT\n");
+
+    if (exitcode == SVM_VMEXIT_NPF) {
+        handler = handle_vmexit_npf;
+    } else if (LIKELY(vmexit_handlers[exitcode] != NULL)) {
+        handler = vmexit_handlers[exitcode];
+    } else {
+        handle_vmexit_unhandeled(g);
+        return;
+    }
+
+    int r = handler(g);
+    if (LIKELY(r == HANDLER_ERR_OK)) {
+        if (g->runnable) {
+            guest_make_runnable(g, true);
+        }
+    }
+}
diff --git a/usr/arrakismon/guest.h b/usr/arrakismon/guest.h
new file mode 100644
index 0000000..ae46795
--- /dev/null
+++ b/usr/arrakismon/guest.h
@@ -0,0 +1,438 @@
+/**
+ * \file
+ */
+
+/*
+ * Copyright (c) 2009, ETH Zurich.
+ * All rights reserved.
+ *
+ * This file is distributed under the terms in the attached LICENSE file.
+ * If you do not find this file, copies can be found by writing to:
+ * ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich. Attn: Systems Group.
+ */
+
+#ifndef GUEST_H
+#define GUEST_H
+
+#include <barrelfish/barrelfish.h>
+#include <spawndomain/spawndomain.h>
+#include "amd_vmcb_dev.h"
+
+struct guest {
+    // indicates whether the guest is runnable atm or waiting
+    bool                    runnable;
+    // Monitor endpoint for this guest
+    struct lmp_endpoint     *monitor_ep;
+    // The allocator for the slot this guests uses
+    struct multi_slot_allocator slot_alloc;
+    // VMCB data
+    struct capref           vmcb_cap;
+    lpaddr_t                 vmcb_pa;
+    lvaddr_t                 vmcb_va;
+    // guest control data
+    struct capref           ctrl_cap;
+    struct guest_control    *ctrl;
+    // IOPM data (IO port access)
+    struct capref           iopm_cap;
+    lpaddr_t                 iopm_pa;
+    lvaddr_t                 iopm_va;
+    // MSRPM data (MSR access)
+    struct capref           msrpm_cap;
+    lpaddr_t                 msrpm_pa;
+    lvaddr_t                 msrpm_va;
+    // Mackerel data structure to VMCV
+    amd_vmcb_t              vmcb;
+    // Guest dispatcher
+    struct capref           dcb_cap;
+    // Guests physical address space (virtual to the domain)
+    struct vspace           *vspace;
+    lpaddr_t		    pml4_pa;
+    // Guest physical memory
+    lvaddr_t                 mem_low_va;
+    lvaddr_t                 mem_high_va;
+    // indicates whether the guest was in emulation before the exit
+    bool                    emulated_before_exit;
+    // virtual hardware
+    struct hdd              *hdds[8];
+    size_t                  hdd_count;
+    struct console          *console;
+    struct pc16550d         *serial_ports[4];
+    size_t                  serial_port_count;
+    struct apic             *apic;
+    struct lpc              *lpc;
+    struct pci              *pci;
+    // some settings which belong to an upcomming CPU abstraction
+    bool                    a20_gate_enabled;
+};
+
+/**
+ * \brief This enum is used to indicate the size of operands to some operations.
+ */
+enum opsize {
+    OPSIZE_8,
+    OPSIZE_16,
+    OPSIZE_32,
+    OPSIZE_64
+};
+
+extern lvaddr_t guest_offset;
+static inline lvaddr_t
+        host_to_guest (lvaddr_t addr)
+{
+    return addr - guest_offset;
+}
+
+static inline lvaddr_t
+        guest_to_host (lvaddr_t addr)
+{
+    return addr + guest_offset;
+}
+
+// REGISTER ACCESS HELPERS
+
+// RAX
+
+static inline uint64_t
+guest_get_rax (struct guest *g)
+{
+    return amd_vmcb_rax_rd(&g->vmcb);
+}
+
+static inline void
+guest_set_rax (struct guest *g, uint64_t val)
+{
+    amd_vmcb_rax_wr(&g->vmcb, val);
+}
+
+static inline uint32_t
+guest_get_eax (struct guest *g)
+{
+    return amd_vmcb_rax_rd(&g->vmcb) & 0xffffffff;
+}
+
+static inline void
+guest_set_eax (struct guest *g, uint32_t val)
+{
+    uint64_t buf = amd_vmcb_rax_rd(&g->vmcb);
+    buf = (buf & ~0xffffffff) | val;
+    amd_vmcb_rax_wr(&g->vmcb, buf);
+}
+
+static inline uint16_t
+guest_get_ax (struct guest *g)
+{
+    return amd_vmcb_rax_rd(&g->vmcb) & 0xffff;
+}
+
+static inline void
+guest_set_ax (struct guest *g, uint16_t val)
+{
+    uint64_t buf = amd_vmcb_rax_rd(&g->vmcb);
+    buf = (buf & ~0xffff) | val;
+    amd_vmcb_rax_wr(&g->vmcb, buf);
+}
+
+static inline uint8_t
+guest_get_ah (struct guest *g)
+{
+    return amd_vmcb_rax_rd(&g->vmcb) >> 8;
+}
+
+static inline void
+guest_set_ah (struct guest *g, uint8_t val)
+{
+    uint64_t buf = amd_vmcb_rax_rd(&g->vmcb);
+    buf = (buf & ~0xff00) | ((uint64_t)val) << 8;
+    amd_vmcb_rax_wr(&g->vmcb, buf);
+}
+
+static inline uint8_t
+guest_get_al (struct guest *g)
+{
+    return amd_vmcb_rax_rd(&g->vmcb);
+}
+
+static inline void
+guest_set_al (struct guest *g, uint8_t val)
+{
+    uint64_t buf = amd_vmcb_rax_rd(&g->vmcb);
+    buf = (buf & ~0xff) | val;
+    amd_vmcb_rax_wr(&g->vmcb, buf);
+}
+
+
+// RBX
+
+static inline uint64_t
+guest_get_rbx (struct guest *g)
+{
+    return g->ctrl->regs.rbx;
+}
+
+static inline void
+guest_set_rbx (struct guest *g, uint64_t val)
+{
+    g->ctrl->regs.rbx = val;
+}
+
+static inline uint32_t
+guest_get_ebx (struct guest *g) {
+    return g->ctrl->regs.rbx;
+}
+
+static inline void
+guest_set_ebx (struct guest *g, uint32_t val) {
+    uint64_t buf = g->ctrl->regs.rbx;
+    g->ctrl->regs.rbx = (buf & ~0xffffffff) | val;
+}
+
+static inline uint16_t
+guest_get_bx (struct guest *g)
+{
+    return g->ctrl->regs.rbx & 0xffff;
+}
+
+static inline void
+guest_set_bx (struct guest *g, uint16_t val)
+{
+    uint64_t buf = g->ctrl->regs.rbx;
+    g->ctrl->regs.rbx = (buf & ~0xffff) | val;
+}
+
+static inline uint8_t
+guest_get_bl (struct guest *g)
+{
+    return g->ctrl->regs.rbx & 0xff;
+}
+
+static inline void
+guest_set_bl (struct guest *g, uint8_t val)
+{
+    uint64_t buf = g->ctrl->regs.rbx;
+    g->ctrl->regs.rbx = (buf & ~0xff) | val;
+}
+
+static inline uint8_t
+guest_get_bh (struct guest *g)
+{
+    return g->ctrl->regs.rbx >> 8;
+}
+
+static inline void
+guest_set_bh (struct guest *g, uint8_t val)
+{
+    uint64_t buf = g->ctrl->regs.rbx;
+    g->ctrl->regs.rbx = (buf & ~0xff00) | ((uint64_t)val) << 8;
+}
+
+
+// RCX
+
+static inline uint64_t
+guest_get_rcx (struct guest *g)
+{
+    return g->ctrl->regs.rcx;
+}
+
+static inline void
+guest_set_rcx (struct guest *g, uint64_t val)
+{
+    g->ctrl->regs.rcx = val;
+}
+
+static inline uint32_t
+guest_get_ecx (struct guest *g) {
+    return g->ctrl->regs.rcx;
+}
+
+static inline void
+guest_set_ecx (struct guest *g, uint32_t val) {
+    uint64_t buf = g->ctrl->regs.rcx;
+    g->ctrl->regs.rcx = (buf & ~0xffffffff) | val;
+}
+
+static inline uint16_t
+guest_get_cx (struct guest *g)
+{
+    return g->ctrl->regs.rcx & 0xffff;
+}
+
+static inline void
+guest_set_cx (struct guest *g, uint16_t val)
+{
+    uint64_t buf = g->ctrl->regs.rcx;
+    g->ctrl->regs.rcx = (buf & ~0xffff) | val;
+}
+
+static inline uint8_t
+guest_get_ch (struct guest *g)
+{
+    return g->ctrl->regs.rcx >> 8;
+}
+
+static inline void
+guest_set_ch (struct guest *g, uint8_t val)
+{
+    uint64_t buf = g->ctrl->regs.rcx;
+    g->ctrl->regs.rcx = (buf & ~0xff00) | ((uint64_t)val) << 8;
+}
+
+static inline uint8_t
+guest_get_cl (struct guest *g)
+{
+    return g->ctrl->regs.rcx;
+}
+
+static inline void
+guest_set_cl (struct guest *g, uint8_t val)
+{
+    uint64_t buf = g->ctrl->regs.rcx;
+    buf = (buf & ~0xff) | val;
+    g->ctrl->regs.rcx = val;
+}
+
+
+// RDX
+
+static inline uint64_t
+guest_get_rdx (struct guest *g)
+{
+    return g->ctrl->regs.rdx;
+}
+
+static inline void
+guest_set_rdx (struct guest *g, uint64_t val)
+{
+    g->ctrl->regs.rdx = val;
+}
+
+static inline uint32_t
+guest_get_edx (struct guest *g) {
+    return g->ctrl->regs.rdx;
+}
+
+static inline void
+guest_set_edx (struct guest *g, uint32_t val) {
+    uint64_t buf = g->ctrl->regs.rdx;
+    g->ctrl->regs.rdx = (buf & ~0xffffffff) | val;
+}
+
+static inline uint8_t
+guest_get_dh (struct guest *g)
+{
+    return g->ctrl->regs.rdx >> 8;
+}
+
+static inline void
+guest_set_dh (struct guest *g, uint8_t val)
+{
+    uint64_t buf = g->ctrl->regs.rdx;
+    g->ctrl->regs.rdx = (buf & ~0xff00) | ((uint64_t)val) << 8;
+}
+
+static inline uint8_t
+guest_get_dl (struct guest *g)
+{
+    return g->ctrl->regs.rdx & 0xff;
+}
+
+static inline void
+guest_set_dl (struct guest *g, uint8_t val)
+{
+    uint64_t buf = g->ctrl->regs.rdx;
+    g->ctrl->regs.rdx = (buf & ~0xff) | val;
+}
+
+
+// RDI
+
+static inline uint64_t
+guest_get_rdi (struct guest *g)
+{
+    return g->ctrl->regs.rdi;
+}
+
+static inline void
+guest_set_rdi (struct guest *g, uint64_t val)
+{
+    g->ctrl->regs.rdi = val;
+}
+
+static inline uint16_t
+guest_get_di (struct guest *g)
+{
+    return g->ctrl->regs.rdi & 0xffff;
+}
+
+static inline void
+guest_set_di (struct guest *g, uint16_t val)
+{
+    uint64_t buf = g->ctrl->regs.rdi;
+    g->ctrl->regs.rdi = (buf & ~0xffff) | val;
+}
+
+
+// RSI
+
+static inline uint64_t
+guest_get_rsi (struct guest *g)
+{
+    return g->ctrl->regs.rsi;
+}
+
+static inline void
+guest_set_rsi (struct guest *g, uint64_t val)
+{
+    g->ctrl->regs.rsi = val;
+}
+
+static inline uint16_t
+guest_get_si (struct guest *g)
+{
+    return g->ctrl->regs.rsi & 0xffff;
+}
+
+static inline void
+guest_set_si (struct guest *g, uint16_t val)
+{
+    uint64_t buf = g->ctrl->regs.rsi;
+    g->ctrl->regs.rsi = (buf & ~0xffff) | val;
+}
+
+
+// RSP
+
+static inline uint64_t
+guest_get_rsp (struct guest *g)
+{
+    return amd_vmcb_rsp_rd(&g->vmcb);
+}
+
+static inline void
+guest_set_rsp (struct guest *g, uint64_t val)
+{
+    amd_vmcb_rsp_wr(&g->vmcb, val);
+}
+
+
+// RBP
+
+static inline uint64_t
+guest_get_rbp (struct guest *g)
+{
+    return g->ctrl->regs.rbp;
+}
+
+static inline void
+guest_set_rbp (struct guest *g, uint64_t val)
+{
+    g->ctrl->regs.rbp = val;
+}
+
+
+struct guest *guest_create (void);
+errval_t guest_make_runnable (struct guest *g, bool run);
+void guest_handle_vmexit (struct guest *g);
+void spawn_guest_domain (struct guest *self, struct spawninfo *si);
+
+#endif // GUEST_H
diff --git a/usr/arrakismon/hdd.c b/usr/arrakismon/hdd.c
new file mode 100644
index 0000000..208e262
--- /dev/null
+++ b/usr/arrakismon/hdd.c
@@ -0,0 +1,104 @@
+/**
+ * \file
+ */
+
+/*
+ * Copyright (c) 2009, ETH Zurich.
+ * All rights reserved.
+ *
+ * This file is distributed under the terms in the attached LICENSE file.
+ * If you do not find this file, copies can be found by writing to:
+ * ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich. Attn: Systems Group.
+ */
+
+#include "vmkitmon.h"
+#include "hdd.h"
+#include <stdlib.h>
+#include <string.h>
+
+#define BLOCK_SIZE 512
+
+static void
+calc_chs (struct hdd *hdd)
+{
+    // assure there is disk with at least 516096 bytes space (16H, 63S, 1C)
+    assert(hdd->disk_image != NULL && hdd->disk_image_size >= 516096);
+
+    /* Here we use a predefined sceme to calculate the CHS of the disk. If the
+     * disk is bigger then 8MiB we use 255 heads, if it is smaller we use 16
+     * heads. This conforms (at least for 8MiB and bigger disks) with the Linux
+     * fdisk tools and their undestanding of the geometry of non physical disks.
+     * Secotors are always 63 per track wich leaves the cylinder value to be the
+     * only one which really needs to be calculated.
+     * Personally I have no idea how wide spread this understanding is!. */
+
+    // set the heads
+    if (hdd->disk_image_size >= 0x800000) {
+        hdd->heads = 255;
+    } else {
+        hdd->heads = 16;
+    }
+
+    // set the sectors per track
+    hdd->sectors = 63;
+
+    // calculate the size
+    hdd->track_size = hdd->sectors * BLOCK_SIZE;
+    hdd->cylinder_size = hdd->heads * hdd->track_size;
+    // the disk has to be a multiple of the cylinder size, so we round the real
+    // disk size down the nearest multiple of cylinder size
+    size_t real_disk_size = hdd->disk_image_size -
+                            (hdd->disk_image_size % hdd->cylinder_size);
+    assert(real_disk_size >= 516096);
+    // now we may safely calculate the cylinders count
+    hdd->cylinders = real_disk_size / hdd->cylinder_size;
+}
+
+struct hdd *
+hdd_new_from_memory (void *disk_image, size_t disk_image_size)
+{
+    struct hdd *ret = calloc(1, sizeof(struct hdd));
+
+    ret->disk_image = disk_image;
+    ret->disk_image_size = disk_image_size;
+
+    calc_chs(ret);
+
+    return ret;
+}
+
+void
+hdd_reset (struct hdd *hdd)
+{
+}
+
+int
+hdd_get_geometry_chs (struct hdd *hdd, uint16_t *cylinders, uint8_t *heads,
+                      uint8_t *sectors)
+{
+    *cylinders = hdd->cylinders;
+    *heads = hdd->heads;
+    *sectors = hdd->sectors;
+
+    return 0;
+}
+
+size_t
+hdd_get_blocks_count (struct hdd *hdd)
+{
+    return hdd->disk_image_size / BLOCK_SIZE;
+}
+
+int
+hdd_read_blocks (struct hdd *hdd, size_t start_block, size_t *count,
+                 uintptr_t buffer)
+{
+    if (((start_block + *count) * BLOCK_SIZE) > hdd->disk_image_size) {
+        *count = hdd->disk_image_size/BLOCK_SIZE - start_block;
+    }
+
+    memcpy((void *)buffer, (void *)(hdd->disk_image + start_block*BLOCK_SIZE),
+           *count * BLOCK_SIZE);
+
+    return HANDLER_ERR_OK;
+}
diff --git a/usr/arrakismon/hdd.h b/usr/arrakismon/hdd.h
new file mode 100644
index 0000000..8d5049b
--- /dev/null
+++ b/usr/arrakismon/hdd.h
@@ -0,0 +1,37 @@
+/**
+ * \file
+ */
+
+/*
+ * Copyright (c) 2009, ETH Zurich.
+ * All rights reserved.
+ *
+ * This file is distributed under the terms in the attached LICENSE file.
+ * If you do not find this file, copies can be found by writing to:
+ * ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich. Attn: Systems Group.
+ */
+
+#ifndef DISK_H
+#define DISK_H
+
+#include <stdint.h>
+
+struct hdd {
+    void *disk_image;
+    size_t disk_image_size;
+    uint16_t cylinders;
+    uint8_t heads;
+    uint8_t sectors;
+    size_t cylinder_size;
+    size_t track_size;
+};
+
+struct hdd * hdd_new_from_memory (void *disk_image, size_t disk_image_size);
+void hdd_reset (struct hdd *hdd);
+int hdd_get_geometry_chs (struct hdd *hdd, uint16_t *cylinders, uint8_t *heads,
+                          uint8_t *sectors);
+size_t hdd_get_blocks_count (struct hdd *hdd);
+int hdd_read_blocks (struct hdd *hdd, size_t start_block, size_t *count,
+                     uintptr_t buffer);
+
+#endif // DISK_H
diff --git a/usr/arrakismon/keyboard.c b/usr/arrakismon/keyboard.c
new file mode 100644
index 0000000..6bada5c
--- /dev/null
+++ b/usr/arrakismon/keyboard.c
@@ -0,0 +1,209 @@
+/**
+ * \file
+ */
+
+/*
+ * Copyright (c) 2009, ETH Zurich.
+ * All rights reserved.
+ *
+ * This file is distributed under the terms in the attached LICENSE file.
+ * If you do not find this file, copies can be found by writing to:
+ * ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich. Attn: Systems Group.
+ */
+
+#include "vmkitmon.h"
+#include "keyboard.h"
+#include <stdlib.h>
+#include <barrelfish/terminal.h>
+
+struct key_map_entry {
+    uint8_t ascii, scan_code;
+};
+
+// this table maps from input through the BF kernel to a key in the guest
+// scan codes taken from http://heim.ifi.uio.no/~stanisls/helppc/scan_codes.html
+static struct key_map_entry key_map[128] = {
+    // capital letters
+    ['A'] = { 0x41, 0x1E },
+    ['B'] = { 0x42, 0x30 },
+    ['C'] = { 0x43, 0x2E },
+    ['D'] = { 0x44, 0x20 },
+    ['E'] = { 0x45, 0x12 },
+    ['F'] = { 0x46, 0x21 },
+    ['G'] = { 0x47, 0x22 },
+    ['H'] = { 0x48, 0x23 },
+    ['I'] = { 0x49, 0x17 },
+    ['J'] = { 0x4A, 0x24 },
+    ['K'] = { 0x4B, 0x25 },
+    ['L'] = { 0x4C, 0x26 },
+    ['M'] = { 0x4D, 0x32 },
+    ['N'] = { 0x4E, 0x31 },
+    ['O'] = { 0x4F, 0x18 },
+    ['P'] = { 0x50, 0x19 },
+    ['Q'] = { 0x51, 0x10 },
+    ['R'] = { 0x52, 0x13 },
+    ['S'] = { 0x53, 0x1F },
+    ['T'] = { 0x54, 0x14 },
+    ['U'] = { 0x55, 0x16 },
+    ['V'] = { 0x56, 0x2F },
+    ['W'] = { 0x57, 0x11 },
+    ['X'] = { 0x58, 0x2D },
+    ['Y'] = { 0x59, 0x15 },
+    ['Z'] = { 0x5A, 0x2C },
+    // small letters
+    ['a'] = { 0x61, 0x1E },
+    ['b'] = { 0x62, 0x30 },
+    ['c'] = { 0x63, 0x2E },
+    ['d'] = { 0x64, 0x20 },
+    ['e'] = { 0x65, 0x12 },
+    ['f'] = { 0x66, 0x21 },
+    ['g'] = { 0x67, 0x22 },
+    ['h'] = { 0x68, 0x23 },
+    ['i'] = { 0x69, 0x17 },
+    ['j'] = { 0x6A, 0x24 },
+    ['k'] = { 0x6B, 0x25 },
+    ['l'] = { 0x6C, 0x26 },
+    ['m'] = { 0x6D, 0x32 },
+    ['n'] = { 0x6E, 0x31 },
+    ['o'] = { 0x6F, 0x18 },
+    ['p'] = { 0x70, 0x19 },
+    ['q'] = { 0x71, 0x10 },
+    ['r'] = { 0x72, 0x13 },
+    ['s'] = { 0x73, 0x1F },
+    ['t'] = { 0x74, 0x14 },
+    ['u'] = { 0x75, 0x16 },
+    ['v'] = { 0x76, 0x2F },
+    ['w'] = { 0x77, 0x11 },
+    ['x'] = { 0x78, 0x2D },
+    ['y'] = { 0x79, 0x15 },
+    ['z'] = { 0x7A, 0x2C },
+    // control characters
+    [0x08] = { 0x08, 0x0e },    // back-space
+    [0x7f] = { 0x7f, 0x0e },    // delete
+    [0x0d] = { 0x0d, 0x1c },    // enter
+    [0x1b] = { 0x1b, 0x01 },    // escape
+    [0x20] = { 0x20, 0x39 },    // space
+    [0x09] = { 0x09, 0x0f }     // tab1
+};
+
+struct keyboard *
+keyboard_new (struct guest *g)
+{
+    struct keyboard *ret = calloc(1, sizeof(struct keyboard));
+
+    ret->guest = g;
+    ret->status = KEYBOARD_STATUS_ENABLED;
+
+    return ret;
+}
+
+static inline int
+handle_60h_out (struct keyboard *k, uint32_t val)
+{
+    if (!(k->status & KEYBOARD_STATUS_IN_CMD)) {
+        printf("keyboard: non command input\n");
+        return -1;
+    }
+
+    switch (k->write_cmd) {
+        // Write Output Port
+        case 0xd1:
+            /* ------------------------------------------------------------------
+             * |KBD data|KBD clk|in buf empty|out buf empty|ud|ud|gate a20|reset|
+             * ------------------------------------------------------------------
+             */
+            // check for gate a20
+            if (val & 0x2) {
+                k->guest->a20_gate_enabled = true;
+            } else {
+                k->guest->a20_gate_enabled = false;
+            }
+            // check for reset
+            if (!(val & 0x1)) {
+                assert(!"System reset requested");
+            }
+            break;
+        default:
+            printf("keyboard: Unhandeled keyboard command");
+            return 1;
+    }
+
+    k->write_cmd = 0;
+    k->status &= ~KEYBOARD_STATUS_IN_CMD;
+
+    return 0;
+}
+
+int
+keyboard_handle_pio_read (struct keyboard *k, uint16_t port,
+                         enum opsize size, uint32_t *val)
+{
+    switch (port) {
+    case 0x64:
+        assert(size & OPSIZE_8);
+        *val = k->status;
+        return HANDLER_ERR_OK;
+    }
+
+    return -1;
+}
+
+int
+keyboard_handle_pio_write (struct keyboard *k, uint16_t port,
+                           enum opsize size, uint32_t val)
+{
+    switch (port) {
+    case 0x60:
+        assert(size & OPSIZE_8);
+        return handle_60h_out(k, val);
+    case 0x64:
+        assert(size & OPSIZE_8);
+        k->write_cmd = val;
+        k->status |= KEYBOARD_STATUS_IN_CMD;
+        return HANDLER_ERR_OK;
+    }
+
+    return -1;
+}
+
+/* waits until a character arrives in the monitor */
+/* FIXME: perhaps it is not such a good idea to stall the whole monitor for
+          this */
+static int
+handle_get_keystroke (struct keyboard *k, struct guest *g)
+{
+    int r;
+    uint8_t chr;
+
+    // loop for now here since we have too many unhandeled keys atm
+    // FIXME: use a complete keymap to avoid this loop
+    while (1) {
+        // wait for input
+        r = terminal_read((char*)&chr, 1);
+        assert(r == 1);
+
+        // check whether our keymap contains the entered key
+        if (key_map[chr].scan_code != 0) {
+            guest_set_al(g, key_map[chr].ascii);
+            guest_set_ah(g, key_map[chr].scan_code);
+            break;
+        } else {
+            printf("keyboard: Unhandeled input char with code %x\n", chr);
+        }
+    }
+
+    return HANDLER_ERR_OK;
+}
+
+int
+keyboard_handle_int16 (struct keyboard *k, struct guest *g) {
+    switch (guest_get_ah(g)) {
+        // KEYBOARD - GET KEYSTROKE
+        case 0:
+            return handle_get_keystroke(k, g);
+        default:
+            break;
+    }
+
+    return HANDLER_ERR_UNHANDELED;
+}
diff --git a/usr/arrakismon/keyboard.h b/usr/arrakismon/keyboard.h
new file mode 100644
index 0000000..c228ae3
--- /dev/null
+++ b/usr/arrakismon/keyboard.h
@@ -0,0 +1,43 @@
+/**
+ * \file
+ */
+
+/*
+ * Copyright (c) 2009, ETH Zurich.
+ * All rights reserved.
+ *
+ * This file is distributed under the terms in the attached LICENSE file.
+ * If you do not find this file, copies can be found by writing to:
+ * ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich. Attn: Systems Group.
+ */
+
+#ifndef KEYBOARD_H
+#define KEYBOARD_H
+
+#include <stdint.h>
+#include "guest.h"
+#include "x86.h"
+
+struct keyboard {
+    struct guest *guest;
+    uint8_t status;             ///< The status register of this controller
+    uint8_t write_cmd;          ///< Pending write command to the data reg
+};
+
+#define KEYBOARD_STATUS_OUT_DATA            (1 << 0)
+#define KEYBOARD_STATUS_IN_DATA             (1 << 1)
+#define KEYBOARD_STATUS_SYSTEM_FLAG         (1 << 2)
+#define KEYBOARD_STATUS_IN_CMD              (1 << 3)
+#define KEYBOARD_STATUS_ENABLED             (1 << 4)
+#define KEYBOARD_STATUS_TR_TIMEOUT          (1 << 5)
+#define KEYBOARD_STATUS_RC_TIMEOUT          (1 << 6)
+#define KEYBOARD_STATUS_PARITY              (1 << 7)
+
+struct keyboard *keyboard_new (struct guest *g);
+int keyboard_handle_pio_read (struct keyboard *k, uint16_t port,
+                              enum opsize size, uint32_t *val);
+int keyboard_handle_pio_write (struct keyboard *k, uint16_t port,
+                               enum opsize size, uint32_t val);
+int keyboard_handle_int16 (struct keyboard *k, struct guest *g);
+
+#endif // KEYBOARD_H
diff --git a/usr/arrakismon/lpc.c b/usr/arrakismon/lpc.c
new file mode 100644
index 0000000..62a099f
--- /dev/null
+++ b/usr/arrakismon/lpc.c
@@ -0,0 +1,786 @@
+/**
+ * \file
+ */
+
+/*
+ * Copyright (c) 2009, ETH Zurich.
+ * All rights reserved.
+ *
+ * This file is distributed under the terms in the attached LICENSE file.
+ * If you do not find this file, copies can be found by writing to:
+ * ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich. Attn: Systems Group.
+ */
+
+/* A lot of the information used to build these models is take from:
+ * http://www.intel.com/Assets/PDF/datasheet/313082.pdf */
+
+#include "vmkitmon.h"
+#include "lpc.h"
+#include <stdlib.h>
+
+
+#define TCW_RW_LSB      1
+#define TCW_RW_MSB      2
+#define TCW_RW_LSB_MSB  3
+
+#define LPC_PIT_MODE_ONE_SHOT       0
+#define LPC_PIT_MODE_RATEN          2
+#define LPC_PIT_MODE_SWAVE          3
+#define LPC_PIT_TIMER0_PERIOD_NS    838
+
+#define PIC_EOI_NSEOI              1
+#define PIC_EOI_SEOI               3
+
+#define PIT_IRQ     0
+#define RTC_IRQ     8
+
+
+static inline uint8_t
+bcd2bin (uint8_t val)
+{
+    return (val & 0x0f) + (val >> 4) * 10;
+}
+
+static inline uint8_t
+bin2bcd(unsigned val)
+{
+    assert(val < 100);
+    return ((val / 10) << 4) + val % 10;
+}
+
+static inline bool
+pic_irq_masked (struct lpc *l, int irq) {
+    assert(irq < 16);
+
+    // if the IRQ is comming from the slave controller check whether it is
+    // masked on the first controller (IRQ2)
+    if (irq > 7 && l->ocw1[0].u.irq_mask & (1 << 2)) {
+        return true;
+    }
+
+    uint8_t rel_irq = irq & 0x7;
+    int ctrlr = irq >> 3;
+    return l->ocw1[ctrlr].u.irq_mask & (1 << rel_irq);
+}
+
+/**
+ * \brief Scan all pending IRQs and send the most important one up to APIC.
+ */
+void
+lpc_pic_process_irqs (struct lpc *l)
+{
+    bool pending = false;
+
+    // check whether the CPU has an interrupt pending
+    if (l->virq_pending(l->virq_user_data, NULL, NULL)) {
+        assert(l->current_irq >= 0 && l->current_irq < 16);
+        pending = true;
+    }
+
+    // find the most priorized IRQ
+    for (int irq = 0; irq < 16; irq++) {
+        // check whether this IRQ is pending
+        if (l->irq_state[irq] == LPC_PIC_IRQ_PENDING) {
+            assert(irq != 2);
+
+            // check whether this irq has a higher (0 beeing high) priority as
+            // a possible pending one
+            if (pending && irq >= l->current_irq) {
+                // we may return here since no further IRQ may have a higher prior
+                return;
+            }
+
+            // check whether we have to remove a pending interrupt
+            if (pending) {
+                // there is an irq pending with lower priority than the current
+                // one, we have to put it back into pending, it will be replaced
+                // by this interrupt
+                assert(l->irq_state[l->current_irq] == LPC_PIC_IRQ_ISR);
+                l->irq_state[l->current_irq] = LPC_PIC_IRQ_PENDING;
+            }
+
+            // process the irq
+            l->irq_state[irq] = LPC_PIC_IRQ_ISR;
+            l->current_irq = irq;
+
+            // assert the virtual interrupt to the CPU
+            // find out the real irq as it is mapped through the PIC init
+            int ctrlr = irq >> 3;
+            assert(ctrlr == 0 || ctrlr == 1);
+            assert(irq <= 7 || ctrlr == 1);
+            uint8_t real_irq = (l->icw2[ctrlr].u.intr_vec_base_addr << 3) |
+                               (irq & 0x7);
+            /*if (irq != 0) {
+                printf("PIC: assert IRQ%u (real %u), pending %u, current_irq %u\n", irq, real_irq, pending, l->current_irq);
+            }*/
+            l->virq_handler(l->virq_user_data, real_irq, irq);
+            return;
+        }
+    }
+}
+
+/**
+ * \brief Assert an IRQ through the PIC.
+ *
+ * This method asserts an IRQ to the CPU. It does not actually generate virtual
+ * interrupts and instead pushed the IRQ forward to the APIC.
+ */
+void
+lpc_pic_assert_irq (struct lpc *l, uint8_t irq)
+{
+    assert(irq < 16 && irq != 2);
+
+    if (!pic_irq_masked(l, irq) && l->irq_state[irq] == LPC_PIC_IRQ_AVAIL) {
+        // assert the irq
+        l->irq_state[irq] = LPC_PIC_IRQ_PENDING;
+    }
+
+    lpc_pic_process_irqs(l);
+}
+
+static void
+pic_eoi (struct lpc *l, int ctrlr)
+{
+    assert(ctrlr == 0 || ctrlr == 1);
+
+    switch (l->ocw2[ctrlr].u.rot_eio_codes) {
+    case PIC_EOI_NSEOI: {
+        // start at IRQ0 for the master and IRQ8 for the slave controller
+        int irq = ctrlr << 3;
+        for (int i = 0; i < 8; i++, irq++) {
+            if (l->irq_state[irq] == LPC_PIC_IRQ_ISR) {
+                l->irq_state[irq] = LPC_PIC_IRQ_AVAIL;
+                break;
+            }
+        }
+        break;
+    }
+    case PIC_EOI_SEOI: {
+        // irq_lvl_sel holds an number between 0 and 7 which represent the
+        // corresponding IRQ on the master and slave controller
+        int irq = l->ocw2[ctrlr].u.irq_lvl_sel | (ctrlr << 3);
+        l->irq_state[irq] = LPC_PIC_IRQ_AVAIL;
+        break;
+    }
+    default:
+        // we do no support all EOI methods yet
+        assert(!"not reached");
+        break;
+    }
+
+    // after an EOI we should process the remaining IRQs
+    lpc_pic_process_irqs(l);
+}
+
+static inline uint64_t
+truncate_to_opsize (enum opsize size, uint64_t val)
+{
+    switch (size) {
+        case OPSIZE_8:
+            return val & 0xff;
+        case OPSIZE_16:
+            return val & 0xffff;
+        case OPSIZE_32:
+            return val & 0xffffffff;
+        case OPSIZE_64:
+            return val;
+    }
+
+    assert(!"not reached");
+    return 0;
+}
+
+static inline void
+cycle_counter_access_byte (struct lpc *l, int reg)
+{
+    // check whether we have to cycle the byte pointer
+    if (l->sbytes[reg].u.rw_mode == TCW_RW_LSB_MSB) {
+        switch (l->counter_current_byte[reg]) {
+        case LPC_PIT_LSB:
+            l->counter_current_byte[reg] = LPC_PIT_MSB;
+            break;
+        case LPC_PIT_MSB:
+            l->counter_current_byte[reg] = LPC_PIT_LSB;
+            break;
+        case LPC_PIT_NONE:
+            assert(!"not reached");
+        }
+    }
+}
+
+#if 0
+static inline uint32_t
+timer_countdown_reg_read (struct lpc *l, int reg)
+{
+    uint32_t ret;
+
+    assert(l->counters_next_byte[reg] != LPC_PIT_NONE);
+
+    // write the requested byte
+    if (l->counters_next_byte[reg] != LPC_PIT_LSB) {
+        ret = l->counters[reg] & 0xff;
+    } else if (l->counters_next_byte[reg] != LPC_PIT_MSB) {
+        ret = (l->counters[reg] >> 8) & 0xff;
+    }
+
+    cycle_counter_access_byte(l, reg);
+
+    return ret;
+}
+#endif
+
+static inline void
+pit_write_current_byte (struct lpc *l, int reg, uint16_t src, uint8_t *dest)
+{
+    // write the requested byte
+    if (l->counter_current_byte[reg] == LPC_PIT_LSB) {
+        *dest = src;
+    } else if (l->counter_current_byte[reg] == LPC_PIT_MSB) {
+        *dest = src >> 8;
+    } else {
+        assert(!"not reached");
+    }
+}
+
+static inline uint8_t
+pit_counter_read (struct lpc *l, int reg)
+{
+    assert(reg == 0 || reg == 2);
+    assert(l->counter_current_byte[reg] != LPC_PIT_NONE);
+
+    uint16_t val;
+
+    // read the current value
+    if (reg == 2 && !l->nmi_sc_reg.u.tim_cnt2_en) {
+        // if we are dealing with counter 2 and it is disabled we just return
+        // the initial value
+        val = l->initial_count[2];
+    } else {
+        // otherwise we read the value from the real counter
+
+        // if the counter is latched then its value has been stored in the buffer
+        // otherwhise we take it directly from the counter
+        if (l->counter_latched[reg]) {
+            // the value was read before
+            val = l->buffer_val[reg];
+        } else {
+            val = (timer_remaining(l->timer[reg]) * 1000 /
+                  LPC_PIT_TIMER0_PERIOD_NS) % l->initial_count[reg];
+        }
+    }
+
+    uint8_t ret_val;
+    if (l->counter_current_byte[reg] == LPC_PIT_LSB) {
+        ret_val = val;
+    } else {
+        ret_val = val >> 8;
+        // reset a possible latch command
+        l->counter_latched[reg] = false;
+    }
+    cycle_counter_access_byte(l, reg);
+
+    return ret_val;
+}
+
+/**
+ * \brief Handles writes to the ICW or OCW registers of both PICs.
+ *
+ * \param ctrlr     0 inidicates the master and 1 the slave controller
+ * \param port      the relative port (0 or 1) based at 0x20 or 0xa0 accessed
+ */
+static inline uint8_t
+pic_icw_ocw_read (struct lpc *l, int ctrlr, uint16_t port)
+{
+    assert(ctrlr == 0 || ctrlr == 1);
+    assert(port == 0 || port == 1);
+
+    switch (port) {
+    case 0:
+        // ICW1, OCW2, OCW3 are write only
+        assert(!"not reached");
+        break;
+    case 1:
+        return l->ocw1[ctrlr].raw;
+    }
+
+    assert(!"not reached");
+    return 0;
+}
+
+int
+lpc_handle_pio_read (struct lpc *l, uint16_t port, enum opsize size,
+                     uint32_t *val)
+{
+    switch (port) {
+    // PIC
+    case 0x20:
+    case 0x21:
+        *val = pic_icw_ocw_read(l, 0, port - 0x20);
+        return HANDLER_ERR_OK;
+    case 0xa0:
+    case 0xa1:
+        *val = pic_icw_ocw_read(l, 1, port - 0xa0);
+        return HANDLER_ERR_OK;
+
+    // RTC
+    case 0x70:
+    case 0x72:
+    case 0x74:
+    case 0x76:
+        assert(!"these io-ports should not be read");
+        break;
+    // primary ram bank access
+    case 0x71:
+    case 0x75:
+        if (l->rtc_prim_addr < 128) {
+            *val = l->rtc_prim_ram.raw[l->rtc_prim_addr];
+            // clear register C on read
+            if (l->rtc_prim_addr == 0xc) {
+                l->rtc_prim_ram.u.C.raw = 0;
+            }
+        }
+        return HANDLER_ERR_OK;
+    // second ram bank access
+    case 0x73:
+    case 0x77:
+        if (l->rtc_sec_addr < 128) {
+            *val = l->rtc_sec_ram[l->rtc_sec_addr];
+        }
+        return HANDLER_ERR_OK;;
+
+    // NMI
+    case 0x61:
+        // pass the out pin state of PIT counter 2
+        if (l->nmi_sc_reg.u.tim_cnt2_en) {
+            l->nmi_sc_reg.u.tmr2_out_sts = l->sbytes[2].u.out_pin_state;
+        } else {
+            l->nmi_sc_reg.u.tmr2_out_sts = 0;
+        }
+
+        *val = l->nmi_sc_reg.raw;
+        return HANDLER_ERR_OK;
+
+    // Timer
+    case 0x41:
+        assert(!"not reached");
+        break;
+    case 0x40:
+    case 0x42:
+        *val = pit_counter_read(l, port - 0x40);
+        return HANDLER_ERR_OK;
+    case 0x43:
+        *val = 0;
+        return HANDLER_ERR_OK;
+
+    default:
+        printf("lpc: Unhandled read access to port %x\n", port);
+        return HANDLER_ERR_UNHANDELED;
+    }
+
+    return -1;
+}
+
+#if 0
+static void
+rtc_timer_callback (struct timer *t, void *data)
+{
+    struct lpc *l = data;
+
+    // some restrictions
+    // all uniplemented features
+    assert(l->rtc_prim_ram.u.B.u.data_mode == 0);
+    assert(l->rtc_prim_ram.u.B.u.hour_format == 1);
+    assert(l->rtc_prim_ram.u.B.u.aie == 0);
+    assert(l->rtc_prim_ram.u.B.u.pie == 0);
+    assert(l->rtc_prim_ram.u.B.u.set == 0);
+    assert(l->rtc_prim_ram.u.B.u.sqwe == 0);
+
+    uint8_t sec = bcd2bin(l->rtc_prim_ram.u.seconds);
+    uint8_t min = bcd2bin(l->rtc_prim_ram.u.minutes);
+    uint8_t hour = bcd2bin(l->rtc_prim_ram.u.hours);
+    uint8_t dow = bcd2bin(l->rtc_prim_ram.u.day_of_week);
+    uint8_t dom = bcd2bin(l->rtc_prim_ram.u.day_of_month);
+    uint8_t mon = bcd2bin(l->rtc_prim_ram.u.month);
+    uint8_t year = bcd2bin(l->rtc_prim_ram.u.year);
+
+    // increment RTC by one second
+    sec++;
+    if (sec >= 60) {
+        sec = 0;
+        min++;
+    }
+    if (min >= 60) {
+        min = 0;
+        hour++;
+    }
+    if (hour >= 24) {
+        hour = 0;
+        dow++;
+        dom++;
+    }
+    if (dow > 7) {
+        dow = 0;
+    }
+    // FIXME: simply wrong!
+    if (dom > 30) {
+        dom = 0;
+        mon++;
+    }
+    if (mon >= 12) {
+        mon = 0;
+        year++;
+    }
+
+    l->rtc_prim_ram.u.seconds = bin2bcd(sec);
+    l->rtc_prim_ram.u.minutes = bin2bcd(min);
+    l->rtc_prim_ram.u.hours = bin2bcd(hour);
+    l->rtc_prim_ram.u.day_of_week = bin2bcd(dow);
+    l->rtc_prim_ram.u.day_of_month = bin2bcd(dom);
+    l->rtc_prim_ram.u.month = bin2bcd(mon);
+    l->rtc_prim_ram.u.year = bin2bcd(year);
+
+    // trigger update interrupt if desired
+    if (l->rtc_prim_ram.u.B.u.uie) {
+        l->rtc_prim_ram.u.C.u.uf = 1;
+        lpc_pic_assert_irq(l, RTC_IRQ);
+    }
+
+}
+#endif
+
+static void
+handle_counter_timer (struct timer *t, void *user_data)
+{
+    struct lpc *l = user_data;
+
+    int reg;
+    if (t == l->timer[0]) {
+        reg = 0;
+        // assert the IRQ
+        lpc_pic_assert_irq(l, PIT_IRQ);
+    } else if (t == l->timer[2]) {
+        reg = 2;
+    } else {
+        assert(!"timer callback for unknown counter!");
+        return;
+    }
+
+    switch (l->sbytes[reg].u.mode_type) {
+    case LPC_PIT_MODE_ONE_SHOT:
+        // set the out pin to high
+        l->sbytes[reg].u.out_pin_state = 1;
+        // destroy the timer
+        timer_destroy(t);
+        l->timer[reg] = NULL;
+        break;
+
+    case LPC_PIT_MODE_SWAVE:
+        // cycle between zero and one every time the counter rolls
+        // over its initial value
+        l->sbytes[reg].u.out_pin_state = !l->sbytes[reg].u.out_pin_state;
+        break;
+
+    case LPC_PIT_MODE_RATEN:
+        // we do not set the out pin to one for one cycle as it would be on
+        // real hardware
+        // the running timer is peridic therefore we do not need to do anything
+        // here
+        break;
+    }
+}
+
+static inline void
+timer_countdown_reg_write (struct lpc *l, int reg, uint8_t val)
+{
+    uint16_t buf = l->initial_count[reg];
+
+    assert(l->counter_current_byte[reg] != LPC_PIT_NONE);
+
+    // write the requested byte
+    if (l->counter_current_byte[reg] == LPC_PIT_LSB) {
+        l->initial_count[reg] = (buf & 0xff00) | val;
+    } else if (l->counter_current_byte[reg] == LPC_PIT_MSB) {
+        l->initial_count[reg] = (val << 8) | (buf & 0xff);
+    }
+
+    // actions to be done at the end of a counter config cycle
+    // in LSB MSB mode this is the case after MSB has been written in all other
+    // modes this true after all writes
+    // TCW_RW_LSB_MSB ==> LPC_PIT_MSB
+    if (l->sbytes[reg].u.rw_mode != TCW_RW_LSB_MSB ||
+        l->counter_current_byte[reg] == LPC_PIT_MSB) {
+        // counter 0 asserts an interrupt so start a timer on this event
+        if (reg == 0 || reg == 2) {
+            // destroy a possible running timer before creating a new one
+            if (l->timer[reg] != NULL) {
+                timer_destroy(l->timer[reg]);
+            }
+
+            // set up the new timer
+            bool periodic = l->sbytes[reg].u.mode_type != LPC_PIT_MODE_ONE_SHOT;
+
+            // start the PIT timer
+            l->timer[reg] = timer_create((uint64_t)l->initial_count[reg] *
+                                         LPC_PIT_TIMER0_PERIOD_NS / 1000,
+                                         periodic, handle_counter_timer, l);
+            // only start timer 2 if it is enabled
+            if (!(reg == 2 && !l->nmi_sc_reg.u.tim_cnt2_en)) {
+                timer_start(l->timer[reg]);
+            }
+        }
+        // other counters do not assert an IRQ so just pass on the config
+        else {
+            //lpc_timer_config(reg, l->sbytes[reg].u.mode_type,
+            //                 l->initial_count[reg]);
+        }
+    }
+
+    cycle_counter_access_byte(l, reg);
+}
+
+/**
+ * \brief Handles writes to the ICW or OCW registers of both PICs.
+ *
+ * \param ctrlr     0 inidicates the master and 1 the slave controller
+ * \param port      the relative port (0 or 1) based at 0x20 or 0xa0 accessed
+ */
+static inline void
+pic_icw_ocw_write (struct lpc *l, int ctrlr, uint16_t port, uint8_t val)
+{
+    assert(ctrlr == 0 || ctrlr == 1);
+    assert(port == 0 || port == 1);
+
+    switch (port) {
+    case 0:
+        // check whether the IWC cycle should start
+        if (val & 0x10) {
+            // ICW cycle
+            l->icw1[ctrlr].raw = val;
+            assert(l->icw1[ctrlr].u.sigl_or_casc == 0);
+            assert(l->icw1[ctrlr].u.icw_sel != 0);
+            // start the cycle
+            l->current_icw[ctrlr] = LPC_PIC_ICW_2;
+        } else {
+            // OCW write
+            // bit 3 indicates which control word shall be written
+            if (val & 0x8) {
+                // OCW 3
+                l->ocw3[ctrlr].raw = val;
+                assert(l->ocw3[ctrlr].u.ocw_sel == 1);
+            } else {
+                // OCW 2
+                l->ocw2[ctrlr].raw = val;
+                assert(l->ocw2[ctrlr].u.ocw_sel == 0);
+                pic_eoi(l, ctrlr);
+            }
+        }
+        break;
+    case 1:
+        // check whether we are in IWC mode
+        if (l->current_icw[ctrlr] != LPC_PIC_ICW_NONE) {
+            switch (l->current_icw[ctrlr]) {
+            case LPC_PIC_ICW_2:
+                l->icw2[ctrlr].raw = val;
+                assert(l->icw2[ctrlr].u.intr_req_lvl == 0);
+                l->current_icw[ctrlr] = LPC_PIC_ICW_3;
+                break;
+            case LPC_PIC_ICW_3:
+                l->icw3[ctrlr].raw = val;
+                if (ctrlr == 0) {
+                    assert(l->icw3[ctrlr].um.casc_slave_ctrlr == 1);
+                }
+                if (l->icw1[ctrlr].u.icw4_req) {
+                    l->current_icw[ctrlr] = LPC_PIC_ICW_4;
+                } else {
+                    l->current_icw[ctrlr] = LPC_PIC_ICW_NONE;
+                }
+                break;
+            case LPC_PIC_ICW_4:
+                l->icw4[ctrlr].raw = val;
+                assert(l->icw4[ctrlr].u.microproc_mode != 0);
+                assert(!l->icw4[ctrlr].u.buf_mode);
+                assert(!l->icw4[ctrlr].u.sfn_mod);
+                // AEOI not supported yet
+                assert(!l->icw4[ctrlr].u.aeoi);
+                l->current_icw[ctrlr] = LPC_PIC_ICW_NONE;
+                break;
+            default:
+                assert(!"not reached");
+                break;
+            }
+        }
+        // OCW1 write
+        else {
+            l->ocw1[ctrlr].raw = val;
+        }
+        break;
+    default:
+        assert(!"not reached");
+    }
+}
+
+int
+lpc_handle_pio_write (struct lpc *l, uint16_t port, enum opsize size,
+                      uint32_t val)
+{
+    switch (port) {
+    // PIC
+    case 0x20:
+    case 0x21:
+        pic_icw_ocw_write(l, 0, port - 0x20, val);
+        return HANDLER_ERR_OK;
+    case 0xa0:
+    case 0xa1:
+        pic_icw_ocw_write(l, 1, port - 0xa0, val);
+        return HANDLER_ERR_OK;
+
+    //  RTC
+    case 0x70:
+    case 0x74:
+        if ((val >> 7) & 1) {
+            l->nmi_masked = true;
+        } else {
+            l->nmi_masked = false;
+        }
+        l->rtc_prim_addr = val & 0x7f;
+        return HANDLER_ERR_OK;
+    case 0x71:
+    case 0x75:
+        if (l->rtc_prim_addr < 128) {
+            l->rtc_prim_ram.raw[l->rtc_prim_addr] = val;
+        }
+        return HANDLER_ERR_OK;
+    case 0x72:
+    case 0x76:
+        l->rtc_sec_addr = val;
+        return HANDLER_ERR_OK;
+    case 0x73:
+    case 0x77:
+        if (l->rtc_sec_addr < 128) {
+            l->rtc_sec_ram[l->rtc_sec_addr] = val;
+        }
+        return HANDLER_ERR_OK;
+
+    // NMI Controller
+    case 0x61:
+        // only the first 4 bits are writable
+        l->nmi_sc_reg.raw |= val & 0xf;
+        // start/stop the counter 2 if required
+        if (l->timer[2]) {
+            if (l->nmi_sc_reg.u.tim_cnt2_en && !timer_is_running(l->timer[2])) {
+                timer_start(l->timer[2]);
+            } else if (!l->nmi_sc_reg.u.tim_cnt2_en
+                       && timer_is_running(l->timer[2])) {
+                timer_stop(l->timer[2]);
+            }
+        }
+        return HANDLER_ERR_OK;
+
+    // Timer
+    // Write to the countdown registers
+    case 0x40:
+        timer_countdown_reg_write(l, 0, val);
+        return HANDLER_ERR_OK;
+    case 0x41:
+        timer_countdown_reg_write(l, 1, val);
+        return HANDLER_ERR_OK;
+    case 0x42:
+        timer_countdown_reg_write(l, 2, val);
+        return HANDLER_ERR_OK;
+    // Write to the timer control register (TCW)
+    case 0x43: {
+        union lpc_pit_tcw tcw = { .raw = val };
+
+        // check for some unimplemented stuff
+        if (tcw.u.countdown_select != 0) {
+            printf("lpc timer: only binary countdown is supported\n");
+            return HANDLER_ERR_FATAL;
+        }
+        // not all modes are implemented
+        assert(tcw.u.mode_select == LPC_PIT_MODE_ONE_SHOT ||
+               tcw.u.mode_select == LPC_PIT_MODE_RATEN);
+        if (tcw.u.counter_select == 3) {
+            printf("lpc timer: read back command not implemented\n");
+            return HANDLER_ERR_FATAL;
+        }
+
+        // we do not support counter 1
+        assert(tcw.u.counter_select != 1);
+
+        // check for latch command
+        if (tcw.u.rw_select == 0) {
+            l->counter_latched[tcw.u.counter_select] = true;
+            l->buffer_val[tcw.u.counter_select] =
+                (timer_remaining(l->timer[tcw.u.counter_select]) *
+                1000 / LPC_PIT_TIMER0_PERIOD_NS) %
+                l->initial_count[tcw.u.counter_select];
+            return HANDLER_ERR_OK;
+        }
+
+        l->sbytes[tcw.u.counter_select].raw = (uint8_t)val;
+        l->sbytes[tcw.u.counter_select].u.count_avail = 0;
+        l->sbytes[tcw.u.counter_select].u.out_pin_state = 0;
+
+        // set the access mode
+        switch (tcw.u.rw_select) {
+        case TCW_RW_LSB_MSB:
+            l->counter_current_byte[tcw.u.counter_select] = LPC_PIT_LSB;
+            break;
+        // we only support LSB MSB mode atm
+        default:
+            assert(!"not reached");
+        }
+
+        return HANDLER_ERR_OK;
+    }
+
+    default:
+        printf("lpc: Unhandled write access to port %x\n", port);
+        return HANDLER_ERR_UNHANDELED;
+    }
+
+    return -1;
+}
+
+struct lpc *
+lpc_new (lpc_virtual_irq_handler virq_handler,
+         lpc_virtual_irq_pending virq_pending, void *user_data,
+         struct apic *apic)
+{
+    struct lpc *ret = calloc(1, sizeof(struct lpc));
+
+    ret->virq_handler = virq_handler;
+    ret->virq_pending = virq_pending;
+    ret->virq_user_data = user_data;
+    ret->apic = apic;
+
+    ret->current_irq = -1;
+
+#if 0
+    // RTC init
+    ret->rtc_prim_ram.u.B.u.hour_format = 1;
+    // init some time
+    ret->rtc_prim_ram.u.day_of_month = bin2bcd(29);
+    ret->rtc_prim_ram.u.month = bin2bcd(8);
+    ret->rtc_prim_ram.u.year = bin2bcd(9);
+    // start the RTC timer to to be called every second
+    ret->rtc_timer = timer_create(1000000, true, rtc_timer_callback, ret);
+    timer_start(ret->rtc_timer);
+#endif
+
+    return ret;
+}
+
+void
+lpc_rtc_get_time_bcd (struct lpc *l, uint8_t *hour, uint8_t *min, uint8_t *sec)
+{
+    if (hour != NULL) {
+        *hour = l->rtc_prim_ram.u.hours;
+    }
+    if (min != NULL) {
+        *min = l->rtc_prim_ram.u.minutes;
+    }
+    if (sec != NULL) {
+        *sec = l->rtc_prim_ram.u.seconds;
+    }
+}
diff --git a/usr/arrakismon/lpc.h b/usr/arrakismon/lpc.h
new file mode 100644
index 0000000..5e85ba9
--- /dev/null
+++ b/usr/arrakismon/lpc.h
@@ -0,0 +1,300 @@
+/**
+ * \file
+ */
+
+/*
+ * Copyright (c) 2009, ETH Zurich.
+ * All rights reserved.
+ *
+ * This file is distributed under the terms in the attached LICENSE file.
+ * If you do not find this file, copies can be found by writing to:
+ * ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich. Attn: Systems Group.
+ */
+
+#ifndef LPC_H
+#define LPC_H
+
+#include <stdint.h>
+#include <stdbool.h>
+#include <timer/timer.h>
+#include "apic.h"
+
+
+/**
+ * \brief Check whether an IRQ may be asserted on the VM right now.
+ *
+ * #irq and #irq_prio are defined if the fuction returns true. The describe
+ * the current waiting interrupt and its priority.
+ */
+typedef bool (*lpc_virtual_irq_pending) (void *user_data, uint8_t *irq,
+        uint8_t *irq_prio);
+
+/**
+ * \brief Assert an IRQ in the virtual machine.
+ */
+typedef void (*lpc_virtual_irq_handler) (void *user_data, uint8_t irq,
+        uint8_t irq_prio);
+
+// LPC Timer
+union lpc_pit_tcw {
+    struct {
+        uint8_t     countdown_select        : 1;
+        uint8_t     mode_select             : 3;
+        uint8_t     rw_select               : 2;
+        uint8_t     counter_select          : 2;
+    } __attribute__((packed)) u;
+    uint8_t raw;
+} __attribute__((packed));
+
+union lpc_pit_sbyte {
+    struct {
+        uint8_t     countdown_type          : 1;
+        uint8_t     mode_type               : 3;
+        uint8_t     rw_mode                 : 2;
+        uint8_t     count_avail             : 1;
+        uint8_t     out_pin_state           : 1;
+    } __attribute__((packed)) u;
+    uint8_t raw;
+} __attribute__((packed));
+
+
+// NMI
+
+union lpc_nmi_sc {
+    struct {
+        uint8_t     tim_cnt2_en             : 1; ///< Timer Counter 2 Enable 
+        uint8_t     spkr_dat_en             : 1; ///< Speaker Data Enable
+        uint8_t     pci_serr_en             : 1; ///< PCI SERR# Enable
+        uint8_t     iochk_nmi_en            : 1; ///< IOCHK# NMI Enable
+        uint8_t     ref_toggle              : 1; ///< Refresh Cycle Toggle
+        uint8_t     tmr2_out_sts            : 1; ///< Timer Counter 2 OUT Status
+        uint8_t     iochk_nmi_sts           : 1; ///< IOCHK# NMI Source Status
+        uint8_t     serr_nmi_sts            : 1; ///< SERR# NMI Source Status
+    } __attribute__((packed)) u;
+    uint8_t raw;
+} __attribute__((packed));
+
+
+// PIC
+
+union lpc_pic_icw1 {
+    struct {
+        uint8_t     icw4_req                : 1; ///< ICW4 Write Required
+        /// Single or Cascade, 0 means Cascade
+        uint8_t     sigl_or_casc            : 1;
+        uint8_t     adi                     : 1;
+        uint8_t     edge_lvl_bank_sel       : 1; ///< Edge/Level Bank Select
+        uint8_t     icw_sel                 : 1; ///< ICW/OCW Select
+        uint8_t     rsvd                    : 3;
+    } __attribute__((packed)) u;
+    uint8_t raw;
+} __attribute__((packed));
+
+union lpc_pic_icw2 {
+    struct {
+        uint8_t     intr_req_lvl            : 3; ///< Interrupt Request Level
+        uint8_t     intr_vec_base_addr      : 5; ///< Interrupt Vector Base Address
+    } __attribute__((packed)) u;
+    uint8_t raw;
+} __attribute__((packed));
+
+union lpc_pic_icw3 {
+    /// Master Controller
+    struct {
+        uint8_t     rsvd1                   : 2;
+        /// Cascaded Interrupt Controller IRQ Connection
+        uint8_t     casc_slave_ctrlr        : 1;
+        uint8_t     rsvd2                   : 5;
+    } __attribute__((packed)) um;
+    /// Slave Controller
+    struct {
+        uint8_t     slave_id_code           : 3; ///< Slave Identification Code
+        uint8_t     rsvd                    : 5;
+    } __attribute__((packed)) us;
+    uint8_t raw;
+} __attribute__((packed));
+
+union lpc_pic_icw4 {
+    struct {
+        uint8_t     microproc_mode      : 1; ///< Microprocessor Mode
+        uint8_t     aeoi                : 1; ///< Automatic End of Interrupt
+        uint8_t     ms_sl_mode          : 1; ///< Master/Slave in Buffered Mode
+        uint8_t     buf_mode            : 1; ///< Buffered Mode
+        uint8_t     sfn_mod             : 1; ///< Special Fully Nested Mode
+        uint8_t     rsvd                : 3;
+    } __attribute__((packed)) u;
+    uint8_t raw;
+} __attribute__((packed));
+
+union lpc_pic_ocw1 {
+    struct {
+        uint8_t     irq_mask            : 8; ///< Interrupt Request Mask
+    } __attribute__((packed)) u;
+    uint8_t raw;
+} __attribute__((packed));
+
+union lpc_pic_ocw2 {
+    struct {
+        uint8_t     irq_lvl_sel         : 3; ///< Interrupt Level Select
+        uint8_t     ocw_sel             : 2; ///< OCW Select
+        uint8_t     rot_eio_codes       : 3; ///< Rotate and EOI Codes
+    } __attribute__((packed)) u;
+    uint8_t raw;
+} __attribute__((packed));
+
+union lpc_pic_ocw3 {
+    struct {
+        uint8_t     reg_read_cmd        : 2; ///< Register Read Command
+        uint8_t     poll_mode           : 1; ///< Poll Mode Command
+        uint8_t     ocw_sel             : 2; ///< OCW Select
+        uint8_t     smm_en              : 1; ///< Enable Special Mask Mode
+        uint8_t     smm                 : 1; ///< Special Mask Mode
+        uint8_t     rsvd                : 1;
+    } __attribute__((packed)) u;
+    uint8_t raw;
+} __attribute__((packed));
+
+
+// RTC
+
+union lpc_rtc_a {
+    struct {
+        uint8_t     rate_sel            : 3; ///< Rate Select
+        uint8_t     div_chain_sel       : 3; ///< Division Chain Select
+        uint8_t     uip                 : 1; ///< Update In Progress
+    } __attribute__((packed)) u;
+    uint8_t raw;
+} __attribute__((packed));
+
+union lpc_rtc_b {
+    struct {
+        uint8_t     dse                 : 1; ///< Daylight Savings Enable
+        uint8_t     hour_format         : 1; ///< Hour Format 
+        uint8_t     data_mode           : 1; ///< Data Mode
+        uint8_t     sqwe                : 1; ///< Square Wave Enable
+        uint8_t     uie                 : 1; ///< Update-Ended Interrupt Enable
+        uint8_t     aie                 : 1; ///< Alarm Interrupt Enable
+        uint8_t     pie                 : 1; ///< Periodic Interrupt Enable
+        uint8_t     set                 : 1; ///< Update Cycle Inhibit
+    } __attribute__((packed)) u;
+    uint8_t raw;
+} __attribute__((packed));
+
+union lpc_rtc_c {
+    struct {
+        uint8_t     rsvd                : 4;
+        uint8_t     uf                  : 1; ///< Update-Ended Flag
+        uint8_t     af                  : 1; ///< Alarm Flag
+        uint8_t     pf                  : 1; ///< Periodic Interrupt Flag
+        uint8_t     irqf                : 1; ///< Interrupt Request Flag
+    } __attribute__((packed)) u;
+    uint8_t raw;
+} __attribute__((packed));
+
+union lpc_rtc_d {
+    struct {
+        uint8_t     data_alarm          : 6; ///< Data Alarm
+        uint8_t     rsvd                : 1;
+        uint8_t     vrt                 : 1; ///< Valid RAM and Time Bit
+    } __attribute__((packed)) u;
+    uint8_t raw;
+} __attribute__((packed));
+
+union lpc_rtc_prim_ram {
+    struct {
+        uint8_t     seconds;
+        uint8_t     seconds_alarm;
+        uint8_t     minutes;
+        uint8_t     minutes_alarm;
+        uint8_t     hours;
+        uint8_t     hours_alarm;
+        uint8_t     day_of_week;
+        uint8_t     day_of_month;
+        uint8_t     month;
+        uint8_t     year;
+        union lpc_rtc_a A;
+        union lpc_rtc_b B;
+        union lpc_rtc_c C;
+        union lpc_rtc_d D;
+        uint8_t     ram[114];
+    } __attribute__((packed)) u;
+    uint8_t raw[128];
+} __attribute__((packed));
+
+
+// LPC main data structures
+
+enum lpc_pit_next_byte {
+    LPC_PIT_NONE = 0,
+    LPC_PIT_LSB,
+    LPC_PIT_MSB
+};
+
+enum lpc_pic_current_icw {
+    LPC_PIC_ICW_NONE,
+    LPC_PIC_ICW_2,
+    LPC_PIC_ICW_3,
+    LPC_PIC_ICW_4
+};
+
+enum lpc_pic_irq_state {
+    LPC_PIC_IRQ_AVAIL = 0,
+    LPC_PIC_IRQ_PENDING,
+    LPC_PIC_IRQ_ISR
+};
+
+
+struct lpc {
+    struct apic     *apic;  ///< The APIC to send IRQs to
+    lpc_virtual_irq_handler     virq_handler;
+    lpc_virtual_irq_pending     virq_pending;
+    void *                      virq_user_data;
+    // NMI Controller
+    bool                nmi_masked;
+    union lpc_nmi_sc    nmi_sc_reg; ///< NMI Status and Control Register
+
+    // Timer
+    union lpc_pit_sbyte         sbytes[3];
+    enum lpc_pit_next_byte      counter_current_byte[3];
+    uint16_t                    initial_count[3];
+    bool                        counter_latched[3];
+    uint16_t                    buffer_val[3];
+    struct timer                *timer[3];
+
+    // PIC
+    // inside the array pos 0 represents the master and 1 the slave controller
+    enum lpc_pic_current_icw    current_icw[2];
+    union lpc_pic_icw1          icw1[2];
+    union lpc_pic_icw2          icw2[2];
+    union lpc_pic_icw3          icw3[2];
+    union lpc_pic_icw4          icw4[2];
+    union lpc_pic_ocw1          ocw1[2];
+    union lpc_pic_ocw2          ocw2[2];
+    union lpc_pic_ocw3          ocw3[2];
+    enum lpc_pic_irq_state      irq_state[16];
+    int                         current_irq;
+
+    // RTC
+    uint8_t                     rtc_prim_addr;
+    union lpc_rtc_prim_ram      rtc_prim_ram;
+    uint8_t                     rtc_sec_addr;
+    uint8_t                     rtc_sec_ram[128];
+    struct timer                *rtc_timer;
+    uint64_t                    rtc_timer_elapsed;
+};
+
+int lpc_init(void);
+struct lpc * lpc_new (lpc_virtual_irq_handler virq_handler,
+                      lpc_virtual_irq_pending virq_pending, void *user_data,
+                      struct apic *apic);
+int lpc_handle_pio_read (struct lpc *l, uint16_t port, enum opsize size,
+                         uint32_t *val);
+int lpc_handle_pio_write (struct lpc *l, uint16_t port, enum opsize size,
+                          uint32_t val);
+void lpc_pic_assert_irq (struct lpc *l, uint8_t irq);
+void lpc_pic_process_irqs (struct lpc *l);
+
+void lpc_rtc_get_time_bcd (struct lpc *l, uint8_t *hour, uint8_t *min,
+                           uint8_t *sec);
+
+#endif // LPC_H
diff --git a/usr/arrakismon/pc16550d.c b/usr/arrakismon/pc16550d.c
new file mode 100644
index 0000000..b61bb0e
--- /dev/null
+++ b/usr/arrakismon/pc16550d.c
@@ -0,0 +1,348 @@
+/**
+ * \file
+ */
+
+/*
+ * Copyright (c) 2009, ETH Zurich.
+ * All rights reserved.
+ *
+ * This file is distributed under the terms in the attached LICENSE file.
+ * If you do not find this file, copies can be found by writing to:
+ * ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich. Attn: Systems Group.
+ */
+
+/* This represents a simple implementation of a 16550 uart controller. It
+ * neglects all timing issues, tranfer rate and error conditions. It declines to
+ * know about FIFOs (which make it to a 16450 controller in fact). In addition
+ * we are almost agnostic to the MCR and MSR register. Everything is
+ * forwarded directly to the terminal. */
+
+#include "vmkitmon.h"
+#include "pc16550d.h"
+#include <stdlib.h>
+#include <barrelfish/terminal.h>
+
+#define FIFO_POS(x)     ((x) & PC16550D_FIFO_MASK)
+
+struct pc16550d *
+pc16550d_new (uint16_t base_port, uint8_t irq, struct lpc *lpc)
+{
+    assert(lpc != NULL);
+
+    struct pc16550d *u = calloc(1, sizeof(struct pc16550d));
+
+    pc16550d_mem_initialize(&u->dev, (mackerel_addr_t)u->regs);
+
+    u->base_port = base_port;
+    u->irq = irq;
+    u->lpc = lpc;
+
+    // initialize the LSR register to have an empty transmit buffer
+    pc16550d_mem_lsr_thre_wrf(&u->dev, 1);
+    pc16550d_mem_lsr_temt_wrf(&u->dev, 1);
+
+    return u;
+}
+
+/**
+ * \brief Check all necessary conditions to raise a certain irq and does so.
+ *
+ * This method must be called at the end of every function returning back to
+ * the guest otherwise some interrupts may get lost.
+ */
+static inline void
+process_interrupt_conditions (struct pc16550d *u)
+{
+    // cycle through the sources for interrupts in the order of their priority
+    // check whethter they are enabled and pending and raise them accordingly
+
+    // data overrun
+    if (pc16550d_mem_ier_rd(&u->dev).elsi &&
+        pc16550d_mem_lsr_rd(&u->dev).oe) {
+
+        pc16550d_mem_iir_iid_wrf(&u->dev, pc16550d_mem_irq_rls);
+    }
+    // receiver data available
+    else if (pc16550d_mem_ier_rd(&u->dev).erbfi &&
+             pc16550d_mem_lsr_rd(&u->dev).dr) {
+        pc16550d_mem_iir_iid_wrf(&u->dev, pc16550d_mem_irq_rda);
+    }
+    // TODO: Here we need the timeout interrupt
+    // transmitter holding register emtpy
+    else if (pc16550d_mem_ier_rd(&u->dev).etbei &&
+             pc16550d_mem_lsr_rd(&u->dev).thre) {
+        pc16550d_mem_iir_iid_wrf(&u->dev, pc16550d_mem_irq_thre);
+    }
+    // no interrupt condition available
+    else {
+        pc16550d_mem_iir_iid_wrf(&u->dev, pc16550d_mem_irq_none);
+    }
+
+    // if there is an intr pending then inform the PIC accordingly
+    if (pc16550d_mem_iir_rd(&u->dev).iid != pc16550d_mem_irq_none) {
+        lpc_pic_assert_irq(u->lpc, u->irq);
+    }
+}
+
+/* this method clears the current pending interrupt
+ * to eventually raise the next interrupt */
+static inline void
+clear_interrupt (struct pc16550d *u)
+{
+    pc16550d_mem_iir_iid_wrf(&u->dev, pc16550d_mem_irq_none);
+}
+
+static inline void
+process_lsr_change (struct pc16550d *u)
+{
+    // for now we only process the interrupts
+}
+
+static inline void
+process_thr_change (struct pc16550d *u)
+{
+    // put out the character
+    char chr = pc16550d_mem_thr_rd_raw(&u->dev);
+    int r = terminal_write(&chr, 1);
+    assert(r == 1);
+
+    // writing the THR reg resets the THRE interrupt pending state
+    if (pc16550d_mem_iir_rd(&u->dev).iid == pc16550d_mem_irq_thre) {
+        clear_interrupt(u);
+    }
+
+    // we always simulate the transmitter register to be empty (an infinitly
+    // fast serial line)
+    pc16550d_mem_lsr_thre_wrf(&u->dev, 1);
+    pc16550d_mem_lsr_temt_wrf(&u->dev, 1);
+
+    process_lsr_change(u);
+}
+
+static inline void
+process_fcr_change (struct pc16550d *u)
+{
+    if (pc16550d_mem_fcr_rd(&u->dev).rfifo_reset) {
+        u->fifo_in_produced = u->fifo_in_consumed = 0;
+        pc16550d_mem_lsr_dr_wrf(&u->dev, 0);
+        pc16550d_mem_lsr_oe_wrf(&u->dev, 0);
+        process_lsr_change(u);
+    }
+}
+
+int
+pc16550d_handle_pio_read (struct pc16550d *u, uint16_t port,
+                          enum opsize size, uint32_t *val)
+{
+    assert(u != NULL);
+    assert(port >= u->base_port);
+
+    port -= u->base_port;
+
+    switch (port) {
+    case 0:
+        if (pc16550d_mem_lcr_rd(&u->dev).dlab) {
+            // DL(L) read
+            switch (size) {
+            case OPSIZE_8:
+                *val = pc16550d_mem_dll_rd_raw(&u->dev);
+                break;
+            default:
+                *val = pc16550d_mem_dl_rd_raw(&u->dev);
+                break;
+            }
+        } else {
+            // RBR read
+            if (FIFO_POS(u->fifo_in_produced) ==
+                FIFO_POS(u->fifo_in_consumed)) {
+                *val = 0;
+            } else {
+                *val = u->fifo_in[FIFO_POS(u->fifo_in_consumed)];
+                u->fifo_in_consumed++;
+            }
+            // reset the data ready bit
+            if (FIFO_POS(u->fifo_in_produced) ==
+                FIFO_POS(u->fifo_in_consumed)) {
+                pc16550d_mem_lsr_dr_wrf(&u->dev, 0);
+                process_lsr_change(u);
+            }
+        }
+        break;
+    case 1:
+        if (pc16550d_mem_lcr_rd(&u->dev).dlab) {
+            // DLM read
+            *val = pc16550d_mem_dlm_rd_raw(&u->dev);
+        } else {
+            // IER READ
+            *val = pc16550d_mem_ier_rd_raw(&u->dev);
+        }
+        break;
+    case 2:
+        // IIR read
+        *val = pc16550d_mem_iir_rd_raw(&u->dev);
+        // reading the IIR reg resets the THRE interrupt pending state
+        // (after the read)
+        if (pc16550d_mem_iir_rd(&u->dev).iid == pc16550d_mem_irq_thre) {
+            clear_interrupt(u);
+        }
+        break;
+    case 3:
+        // LCR read
+        *val = pc16550d_mem_lcr_rd_raw(&u->dev);
+        break;
+    case 4:
+        // MCR read
+        *val = pc16550d_mem_mcr_rd_raw(&u->dev);
+        break;
+    case 5:
+        // LSR read
+        *val = pc16550d_mem_lsr_rd_raw(&u->dev);
+        // reset possible error conditions
+        pc16550d_mem_lsr_oe_wrf(&u->dev, 0);
+        process_lsr_change(u);
+        break;
+    case 6:
+        // MSR read
+        *val = pc16550d_mem_msr_rd_raw(&u->dev);
+        break;
+    case 7:
+        // SCR read
+        *val = pc16550d_mem_scr_rd_raw(&u->dev);
+        break;
+    default:
+        assert(!"pc16550d: read access to unknown port");
+        break;
+    }
+
+    // check whether interrupts shall be raised
+    process_interrupt_conditions(u);
+
+    return HANDLER_ERR_OK;
+}
+
+int
+pc16550d_handle_pio_write (struct pc16550d *u, uint16_t port,
+                           enum opsize size, uint32_t val)
+{
+    assert(u != NULL);
+    assert(port >= u->base_port);
+
+    port -= u->base_port;
+
+    /* all registers which do no processing after they are written and do not
+     * abort the application just ignore their content and store it in case it
+     * is read by the user */
+
+    switch (port) {
+    case 0:
+        if (pc16550d_mem_lcr_rd(&u->dev).dlab) {
+            // DL(L) write
+            switch (size) {
+            case OPSIZE_8:
+                pc16550d_mem_dll_wr_raw(&u->dev, val);
+                break;
+            default:
+                pc16550d_mem_dl_wr_raw(&u->dev, val);
+            }
+            pc16550d_mem_thr_wr_raw(&u->dev, val);
+        } else {
+            // THR write
+            pc16550d_mem_thr_wr_raw(&u->dev, val);
+            process_thr_change(u);
+        }
+        break;
+    case 1:
+        if (pc16550d_mem_lcr_rd(&u->dev).dlab) {
+            // DLM write
+            pc16550d_mem_dlm_wr_raw(&u->dev, val);
+        } else {
+            // IER write
+            pc16550d_mem_ier_wr_raw(&u->dev, val);
+            /* this register only holds info necessary for other operations
+             * therefore we do not need to do any processing */
+        }
+        break;
+    case 2:
+        // FCR write
+        pc16550d_mem_fcr_wr_raw(&u->dev, val);
+        process_fcr_change(u);
+        break;
+    case 3:
+        // LCR write
+        pc16550d_mem_lcr_wr_raw(&u->dev, val);
+        break;
+    case 4:
+        // MCR write
+        pc16550d_mem_mcr_wr_raw(&u->dev, val);
+        break;
+    case 5:
+        // LSR write
+        assert(!"LSR should not be written to");
+        pc16550d_mem_lsr_wr_raw(&u->dev, val);
+        process_lsr_change(u);
+        break;
+    case 6:
+        assert(!"MSR should not be written to");
+        // MSR write
+        pc16550d_mem_msr_wr_raw(&u->dev, val);
+        break;
+    case 7:
+        // SCR write
+        pc16550d_mem_scr_wr_raw(&u->dev, val);
+        break;
+    default:
+        assert(!"pc16550d: write access to unknown port");
+        break;
+    }
+
+    // check whether interrupts shall be raised
+    process_interrupt_conditions(u);
+
+    return HANDLER_ERR_OK;
+}
+
+#if 0
+static void
+input_handler (void *user_data, const char *str, size_t size)
+{
+    assert(user_data != NULL);
+
+    struct pc16550d *u = user_data;
+
+    if (size == 0) {
+        return;
+    }
+
+    // copy the string into our fifo
+    for (int i = 0; i < size; i++) {
+        u->fifo_in[FIFO_POS(u->fifo_in_produced)] = str[i];
+        u->fifo_in_produced++;
+
+        // check for overrun
+        if (FIFO_POS(u->fifo_in_produced) ==
+            FIFO_POS(u->fifo_in_consumed)) {
+            u->fifo_in_produced = u->fifo_in_consumed = 0;
+            pc16550d_mem_lsr_oe_wrf(&u->dev, 1);
+        }
+    }
+
+    // tell the user that data is available
+    pc16550d_mem_lsr_dr_wrf(&u->dev, 1);
+
+    // raise interrupts when necessary
+    process_interrupt_conditions(u);
+}
+#endif
+
+void
+pc16550d_attach_to_console (struct pc16550d *u)
+{
+    assert(u != NULL);
+
+    assert(!"NYI");
+#if 0
+    errval_t err;
+    err = terminal_register_input_handler(input_handler, u);
+    assert(err_is_ok(err));
+#endif
+}
diff --git a/usr/arrakismon/pc16550d.h b/usr/arrakismon/pc16550d.h
new file mode 100644
index 0000000..1d877b3
--- /dev/null
+++ b/usr/arrakismon/pc16550d.h
@@ -0,0 +1,44 @@
+/**
+ * \file
+ */
+
+/*
+ * Copyright (c) 2009, ETH Zurich.
+ * All rights reserved.
+ *
+ * This file is distributed under the terms in the attached LICENSE file.
+ * If you do not find this file, copies can be found by writing to:
+ * ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich. Attn: Systems Group.
+ */
+
+#ifndef PC16550D_H
+#define PC16550D_H
+
+#include <stdint.h>
+#include <stdbool.h>
+#include "lpc.h"
+#include "pc16550d_mem_dev.h"
+
+#define PC16550D_FIFO_BITS      4
+#define PC16550D_FIFO_SIZE      (1 << PC16550D_FIFO_BITS)
+#define PC16550D_FIFO_MASK      (PC16550D_FIFO_SIZE - 1)
+
+struct pc16550d {
+    uint16_t        base_port;
+    uint8_t         irq;
+    struct lpc      *lpc;
+    pc16550d_mem_t  dev;
+    uint8_t         regs[12];
+    char            fifo_in[PC16550D_FIFO_SIZE];
+    unsigned int    fifo_in_produced;
+    unsigned int    fifo_in_consumed;
+};
+
+struct pc16550d *pc16550d_new (uint16_t base_port, uint8_t irq, struct lpc *lpc);
+int pc16550d_handle_pio_read (struct pc16550d *u, uint16_t port,
+                              enum opsize size, uint32_t *val);
+int pc16550d_handle_pio_write (struct pc16550d *u, uint16_t port,
+                               enum opsize size, uint32_t val);
+void pc16550d_attach_to_console (struct pc16550d *u);
+
+#endif //PC16550D_H
diff --git a/usr/arrakismon/pci.c b/usr/arrakismon/pci.c
new file mode 100644
index 0000000..48b9772
--- /dev/null
+++ b/usr/arrakismon/pci.c
@@ -0,0 +1,156 @@
+/**
+ * \file PCI bus
+ *
+ * Virtual PCI bus implementation.
+ */
+
+/*
+ * Copyright (c) 2009, ETH Zurich.
+ * All rights reserved.
+ *
+ * This file is distributed under the terms in the attached LICENSE file.
+ * If you do not find this file, copies can be found by writing to:
+ * ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich. Attn: Systems Group.
+ */
+
+#include <stdlib.h>
+
+#include "vmkitmon.h"
+#include "pci.h"
+#include "pci_devices.h"
+
+#define INVALID         0xffffffff
+
+int pci_handle_pio_write(struct pci *pci, uint16_t port, enum opsize size,
+                         uint32_t val)
+{
+    assert(pci != NULL);
+
+    switch(port) {
+    case 0xcf8:         // PCI config address port
+        VMKIT_PCI_DEBUG("wrote %x to 0xcf8\n", val);
+        if(size == OPSIZE_32) {
+            pci->address.raw = val;
+        } else {
+            VMKIT_PCI_DEBUG("ignoring write (not 32bit opsize)\n");
+        }
+        break;
+
+    case 0xcfc:         // PCI config data port
+    case 0xcfd:
+    case 0xcfe:
+    case 0xcff:
+
+        if(port != 0xcfc) {
+            printf("!!!!!!!!!!!!!!!!! Unaligned write !!!!!!!!!!!!!!!\n");
+        }
+
+        VMKIT_PCI_DEBUG("wrote %x to 0x%x\n", val, port);
+        {
+            int busnr = pci->address.d.bus_nr;
+            int device = pci->address.d.dev_nr;
+            struct pci_bus *bus = pci->bus[busnr];
+
+            if(bus == NULL) {
+                break;
+            }
+
+            struct pci_device *dev = bus->device[device];
+
+            if(dev != NULL) {
+                dev->confspace_write(dev, pci->address, size, val);
+            }
+        }
+        break;
+
+    default:
+        VMKIT_PCI_DEBUG("write to invalid port\n");
+        break;
+    }
+
+    return 0;
+}
+
+int pci_handle_pio_read(struct pci *pci, uint16_t port, enum opsize size,
+                        uint32_t *val)
+{
+    assert(pci != NULL);
+
+    switch(port) {
+    case 0xcf8:         // PCI config address port
+        *val = pci->address.raw;
+        VMKIT_PCI_DEBUG("read from 0xcf8: %x\n", *val);
+        break;
+
+    case 0xcfc:         // PCI config data port
+    case 0xcfd:
+    case 0xcfe:
+    case 0xcff:
+        {
+            int busnr = pci->address.d.bus_nr;
+            int device = pci->address.d.dev_nr;
+            struct pci_bus *bus = pci->bus[busnr];
+
+            if(bus == NULL) {
+                *val = INVALID;
+                break;
+            }
+
+            struct pci_device *dev = bus->device[device];
+
+            if(dev != NULL) {
+                dev->confspace_read(dev, pci->address, size, val);
+            } else {
+                *val = INVALID;
+            }
+        }
+
+        // Shift on unaligned read (masking is done later)
+        *val >>= (port - 0xcfc) * 8;
+
+        VMKIT_PCI_DEBUG("read %x from 0x%x\n", *val, port);
+        break;
+
+    default:
+        VMKIT_PCI_DEBUG("read from invalid port\n");
+        break;
+    }
+
+    return 0;
+}
+
+static struct pci_bus *pci_new_bus(void)
+{
+    struct pci_bus *bus = calloc(1, sizeof(struct pci_bus));
+    return bus;
+}
+
+struct pci *pci_new(void)
+{
+    struct pci *pci = calloc(1, sizeof(struct pci));
+
+    pci->bus[0] = pci_new_bus();
+
+    // Put a host-bridge on the bus (Linux expects to find one)
+    struct pci_device *bridge = pci_hostbridge_new();
+    pci_attach_device(pci, 0, 0, bridge);
+
+    return pci;
+}
+
+int pci_attach_device(struct pci *pci, uint8_t busnr, uint8_t devnr,
+                      struct pci_device *device)
+{
+    struct pci_bus *bus = pci->bus[busnr];
+
+    if(bus == NULL) {
+        return -1;
+    }
+
+    if(bus->device[devnr] != NULL) {
+        return -2;
+    }
+
+    bus->device[devnr] = device;
+    return 0;
+}
diff --git a/usr/arrakismon/pci.h b/usr/arrakismon/pci.h
new file mode 100644
index 0000000..48648d5
--- /dev/null
+++ b/usr/arrakismon/pci.h
@@ -0,0 +1,66 @@
+/**
+ * \file PCI bus
+ *
+ * Virtual PCI bus implementation.
+ */
+
+/*
+ * Copyright (c) 2009, ETH Zurich.
+ * All rights reserved.
+ *
+ * This file is distributed under the terms in the attached LICENSE file.
+ * If you do not find this file, copies can be found by writing to:
+ * ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich. Attn: Systems Group.
+ */
+
+#ifndef PCI_H
+#define PCI_H
+
+union pci_config_address_word {
+    uint32_t raw;
+    struct {
+         uint32_t mbz : 2;
+         uint32_t doubleword : 6;
+         uint32_t fnct_nr : 3;
+         uint32_t dev_nr : 5;
+         uint32_t bus_nr : 8;
+         uint32_t res : 7;
+         uint32_t enable_conf_space_mapping : 1;
+    } __attribute__ ((packed)) d;
+} __attribute__ ((packed)) ;
+
+struct pci_device;
+
+typedef void (*pci_device_confspace_write)(struct pci_device *dev,
+                                           union pci_config_address_word addr,
+                                           enum opsize size, uint32_t val);
+
+typedef void (*pci_device_confspace_read)(struct pci_device *dev,
+                                          union pci_config_address_word addr,
+                                          enum opsize size, uint32_t *val);
+
+struct pci_device {
+    pci_device_confspace_write  confspace_write;
+    pci_device_confspace_read   confspace_read;
+    void                        *state;
+};
+
+struct pci_bus {
+    struct pci_device   *device[32];
+};
+
+struct pci {
+    union pci_config_address_word       address;
+    struct pci_bus                      *bus[256];
+};
+
+struct pci *pci_new(void);
+int pci_handle_pio_write(struct pci *pci, uint16_t port, enum opsize size,
+                         uint32_t val);
+int pci_handle_pio_read(struct pci *pci, uint16_t port, enum opsize size,
+                        uint32_t *val);
+
+int pci_attach_device(struct pci *pci, uint8_t busnr, uint8_t devnr,
+                      struct pci_device *device);
+
+#endif
diff --git a/usr/arrakismon/pci_devices.h b/usr/arrakismon/pci_devices.h
new file mode 100644
index 0000000..460f1b2
--- /dev/null
+++ b/usr/arrakismon/pci_devices.h
@@ -0,0 +1,19 @@
+/**
+ * \file PCI device functions
+ */
+
+/*
+ * Copyright (c) 2009, ETH Zurich.
+ * All rights reserved.
+ *
+ * This file is distributed under the terms in the attached LICENSE file.
+ * If you do not find this file, copies can be found by writing to:
+ * ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich. Attn: Systems Group.
+ */
+
+#ifndef PCI_DEVICES_H
+#define PCI_DEVICES_H
+
+struct pci_device *pci_hostbridge_new(void);
+
+#endif
diff --git a/usr/arrakismon/pci_host.c b/usr/arrakismon/pci_host.c
new file mode 100644
index 0000000..ae49b52
--- /dev/null
+++ b/usr/arrakismon/pci_host.c
@@ -0,0 +1,80 @@
+/**
+ * \file PCI VM-to-host interface
+ */
+
+/*
+ * Copyright (c) 2009, ETH Zurich.
+ * All rights reserved.
+ *
+ * This file is distributed under the terms in the attached LICENSE file.
+ * If you do not find this file, copies can be found by writing to:
+ * ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich. Attn: Systems Group.
+ */
+
+#include <stdlib.h>
+
+#include "vmkitmon.h"
+#include "pci.h"
+#include "pci_host.h"
+#include "pci_hdr0_mem_dev.h"
+
+#define INVALID         0xffffffff
+
+#define VMKIT_PCI_HOST_DEBUG_SWITCH
+
+#if defined(VMKIT_PCI_HOST_DEBUG_SWITCH)
+#define VMKIT_PCI_HOST_DEBUG(x...) printf("VMKit PCI host: " x)
+#else
+#define VMKIT_PCI_HOST_DEBUG(x...) ((void)0)
+#endif
+
+struct pci_host {
+    pci_hdr0_mem_t      ph;
+    uint32_t            pci_header[0x40];
+};
+
+static void confspace_write(struct pci_device *dev,
+                            union pci_config_address_word addr,
+                            enum opsize size, uint32_t val)
+{
+}
+
+static void confspace_read(struct pci_device *dev,
+                           union pci_config_address_word addr,
+                           enum opsize size, uint32_t *val)
+{
+    struct pci_host *h = dev->state;
+
+    if(addr.d.fnct_nr != 0) {
+        *val = INVALID;
+        return;
+    }
+
+    if(addr.d.doubleword < 0x40) {
+        *val = h->pci_header[addr.d.doubleword];
+        VMKIT_PCI_HOST_DEBUG("reading register %d, opsize %d: %x\n",
+                             addr.d.doubleword, size, *val);
+
+        if(size == 1) {
+            *val = (*val) & 0xffff;
+        }
+    } else {
+        *val = INVALID;
+    }
+}
+
+void init_host_devices(struct pci *pci)
+{
+    struct pci_device *dev = calloc(1, sizeof(struct pci_device));
+    struct pci_host *host = calloc(1, sizeof(struct pci_host));
+    pci_hdr0_mem_t *ph = &host->ph;
+
+    dev->confspace_write = confspace_write;
+    dev->confspace_read = confspace_read;
+    dev->state = host;
+
+    pci_hdr0_mem_initialize(ph, (mackerel_addr_t)host->pci_header);
+
+    int r = pci_attach_device(pci, 0, 1, dev);
+    assert(r == 0);
+}
diff --git a/usr/arrakismon/pci_host.h b/usr/arrakismon/pci_host.h
new file mode 100644
index 0000000..a75f544
--- /dev/null
+++ b/usr/arrakismon/pci_host.h
@@ -0,0 +1,21 @@
+/**
+ * \file PCI VM-to-host interface
+ */
+
+/*
+ * Copyright (c) 2009, ETH Zurich.
+ * All rights reserved.
+ *
+ * This file is distributed under the terms in the attached LICENSE file.
+ * If you do not find this file, copies can be found by writing to:
+ * ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich. Attn: Systems Group.
+ */
+
+#ifndef PCI_HOST_H
+#define PCI_HOST_H
+
+#include "pci.h"
+
+void init_host_devices(struct pci *pci);
+
+#endif
diff --git a/usr/arrakismon/pci_hostbridge.c b/usr/arrakismon/pci_hostbridge.c
new file mode 100644
index 0000000..9293a5b
--- /dev/null
+++ b/usr/arrakismon/pci_hostbridge.c
@@ -0,0 +1,70 @@
+/**
+ * \file Fake PCI host bridge
+ */
+
+/*
+ * Copyright (c) 2009, ETH Zurich.
+ * All rights reserved.
+ *
+ * This file is distributed under the terms in the attached LICENSE file.
+ * If you do not find this file, copies can be found by writing to:
+ * ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich. Attn: Systems Group.
+ */
+
+#include <stdlib.h>
+
+#include "vmkitmon.h"
+#include "pci.h"
+#include "pci_devices.h"
+#include "pci_hdr0_mem_dev.h"
+
+#define INVALID         0xffffffff
+
+struct pci_hostbridge {
+    pci_hdr0_mem_t      ph;
+    uint32_t            pci_header[0x40];
+};
+
+static void confspace_write(struct pci_device *dev,
+                            union pci_config_address_word addr,
+                            enum opsize size, uint32_t val)
+{
+}
+
+static void confspace_read(struct pci_device *dev,
+                           union pci_config_address_word addr,
+                           enum opsize size, uint32_t *val)
+{
+    struct pci_hostbridge *h = dev->state;
+
+    if(addr.d.fnct_nr != 0) {
+        *val = INVALID;
+        return;
+    }
+
+    if(addr.d.doubleword < 0x40) {
+        *val = h->pci_header[addr.d.doubleword];
+    } else {
+        *val = INVALID;
+    }
+}
+
+struct pci_device *pci_hostbridge_new(void)
+{
+    struct pci_device *dev = calloc(1, sizeof(struct pci_device));
+    struct pci_hostbridge *host = calloc(1, sizeof(struct pci_hostbridge));
+    pci_hdr0_mem_t *ph = &host->ph;
+
+    dev->confspace_write = confspace_write;
+    dev->confspace_read = confspace_read;
+    dev->state = host;
+
+    pci_hdr0_mem_initialize(ph, (mackerel_addr_t)host->pci_header);
+
+    // Fake a host bridge
+    pci_hdr0_mem_vendor_id_wr(ph, 0x8086);
+    pci_hdr0_mem_device_id_wr(ph, 1);
+    pci_hdr0_mem_class_code_clss_wrf(ph, pci_hdr0_mem_bridge);
+
+    return dev;
+}
diff --git a/usr/arrakismon/ps.c b/usr/arrakismon/ps.c
new file mode 100644
index 0000000..f1e0d1a
--- /dev/null
+++ b/usr/arrakismon/ps.c
@@ -0,0 +1,53 @@
+/*
+ * Copyright (c) 2009, 2011, ETH Zurich.
+ * All rights reserved.
+ *
+ * This file is distributed under the terms in the attached LICENSE file.
+ * If you do not find this file, copies can be found by writing to:
+ * ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich. Attn: Systems Group.
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <assert.h>
+#include <barrelfish/barrelfish.h>
+#include <vfs/vfs.h>
+
+#include "ps.h"
+
+static struct ps_entry *entries[MAX_DOMAINS];
+
+errval_t ps_allocate(struct ps_entry *entry, domainid_t *domainid)
+{
+    for(domainid_t i = 1; i < MAX_DOMAINS; i++) {
+        if(entries[i] == NULL) {
+            entries[i] = entry;
+            *domainid = i;
+            return SYS_ERR_OK;
+        }
+    }
+
+    return SPAWN_ERR_DOMAIN_ALLOCATE;
+}
+
+void ps_remove(domainid_t domain_id)
+{
+    assert(domain_id < MAX_DOMAINS);
+    entries[domain_id] = NULL;
+}
+
+bool ps_exists(domainid_t domain_id)
+{
+    assert(domain_id < MAX_DOMAINS);
+    return entries[domain_id] != NULL ? true : false;
+}
+
+struct ps_entry *ps_get(domainid_t domain_id)
+{
+    if(domain_id >= MAX_DOMAINS) {
+        return NULL;
+    }
+
+    return entries[domain_id];
+}
diff --git a/usr/arrakismon/ps.h b/usr/arrakismon/ps.h
new file mode 100644
index 0000000..3b9d173
--- /dev/null
+++ b/usr/arrakismon/ps.h
@@ -0,0 +1,46 @@
+/*
+ * Copyright (c) 2009, 2011, ETH Zurich.
+ * All rights reserved.
+ *
+ * This file is distributed under the terms in the attached LICENSE file.
+ * If you do not find this file, copies can be found by writing to:
+ * ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich. Attn: Systems Group.
+ */
+
+#ifndef PS_H
+#define PS_H
+
+#include <stdbool.h>
+#include <barrelfish/barrelfish.h>
+#include <barrelfish_kpi/types.h>
+#include <barrelfish_kpi/init.h>
+
+#define MAX_DOMAINS     256
+
+enum ps_status {
+    PS_STATUS_RUNNING,
+    PS_STATUS_ZOMBIE
+};
+
+struct ps_waiter {
+    struct ps_waiter *next;
+    struct spawn_binding *binding;
+};
+
+struct ps_entry {
+    char *argv[MAX_CMDLINE_ARGS];
+    char *argbuf;
+    size_t argbytes;
+    struct capref rootcn_cap, dcb;
+    struct cnoderef rootcn;
+    uint8_t exitcode;
+    enum ps_status status;
+    struct ps_waiter *waiters;
+};
+
+errval_t ps_allocate(struct ps_entry *entry, domainid_t *domainid);
+void ps_remove(domainid_t domain_id);
+bool ps_exists(domainid_t domain_id);
+struct ps_entry *ps_get(domainid_t domain_id);
+
+#endif
diff --git a/usr/arrakismon/realmode.c b/usr/arrakismon/realmode.c
new file mode 100644
index 0000000..f8fd914
--- /dev/null
+++ b/usr/arrakismon/realmode.c
@@ -0,0 +1,314 @@
+/**
+ * \file
+ */
+
+/*
+ * Copyright (c) 2009, ETH Zurich.
+ * All rights reserved.
+ *
+ * This file is distributed under the terms in the attached LICENSE file.
+ * If you do not find this file, copies can be found by writing to:
+ * ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich. Attn: Systems Group.
+ */
+
+#include "vmkitmon.h"
+#include <x86emu.h>
+#include "realmode.h"
+#include "svm.h"
+#include "x86.h"
+
+static struct guest *env = NULL;
+static bool valid_exit = false;
+
+static inline void
+set_vmcb_exit(amd_vmcb_t *vmcb, uint64_t code, uint64_t info1, uint64_t info2)
+{
+    amd_vmcb_exitcode_wr(vmcb, code);
+    amd_vmcb_exitinfo1_wr(vmcb, info1);
+    amd_vmcb_exitinfo2_wr(vmcb, info2);
+}
+
+/* real mode interface functions */
+
+static uint8_t
+io_inb (uint16_t port)
+{
+    assert(!"inb not implemented");
+    return 0;
+}
+
+static uint16_t
+io_inw (uint16_t port)
+{
+    assert(!"inw not implemented");
+    return 0;
+}
+
+static uint32_t
+io_inl (uint16_t port)
+{
+    assert(!"inl not implemented");
+    return 0;
+}
+
+static void
+io_outb (uint16_t port, uint8_t val)
+{
+    uint32_t info1;
+
+    info1 = X86_IO_ACCESS_SZ8 | X86_IO_ACCESS_A16;
+    info1 |= port << 16;
+    set_vmcb_exit(&env->vmcb, SVM_VMEXIT_IOIO, info1, M.x86.R_EIP);
+    valid_exit = true;
+
+    // move EIP back to the start of the instruction
+    M.x86.R_EIP -= 2;
+
+    HALT_SYS();
+}
+
+static void
+io_outw (uint16_t port, uint16_t val)
+{
+    assert(!"outw not implemented");
+}
+
+static void
+io_outl (uint16_t port, uint32_t val)
+{
+    assert(!"outl not implemented");
+}
+
+static void
+int_handler (int num)
+{
+    // check whether the interrupt corresponds to an exception
+    // in real-mode everything from 10 is not an ecxeption
+    if (num < 10) {
+        // exception raised
+        // check whether this exception should be intercepted
+        if (amd_vmcb_exceptions_rd_raw(&env->vmcb) & (1 << num)) {
+            assert(!"Intercepted exception raised");
+        } else {
+            assert(!"Realmode raised an exception which is not captured");
+        }
+    } else {
+        // software interrupt raised
+        // check whether we are interessted in SW interrupts
+        if (amd_vmcb_intercepts_rd(&env->vmcb).intn == 1) {
+            set_vmcb_exit(&env->vmcb, SVM_VMEXIT_SWINT, 0, 0);
+            valid_exit = true;
+        } else {
+            assert(!"SWINT occured but not intercepted by the VMM");
+        }
+    }
+
+    // move EIP back to the start of the instruction
+    M.x86.R_EIP -= 2;
+
+    HALT_SYS();
+}
+
+/**
+ * \brief Initializes this module.
+ *
+ * Needs to be called before any other call to realmode functionality.
+ *
+ * \return Zero on success, non-zero on failure
+ */
+errval_t
+realmode_init (void)
+{
+    // initialize the io hooks
+    X86EMU_pioFuncs io_hooks = {
+        .inb = io_inb,
+        .inw = io_inw,
+        .inl = io_inl,
+        .outb = io_outb,
+        .outw = io_outw,
+        .outl = io_outl
+    };
+    X86EMU_setupPioFuncs(&io_hooks);
+
+    // initialize interrupt handers
+    X86EMU_intrFuncs int_hooks[256];
+    for (int i = 0; i < 256; i++) {
+        int_hooks[i] = int_handler;
+    }
+    X86EMU_setupIntrFuncs(int_hooks);
+
+    return SYS_ERR_OK;
+}
+
+void
+realmode_switch_to (struct guest *g)
+{
+    assert(g != NULL);
+    assert(env == NULL);
+
+    env = g;
+
+    // sanity check
+    assert(g->mem_low_va == 0 && g->mem_high_va >= 0x100000);
+
+    // copy the registers
+    M.x86.R_EAX = amd_vmcb_rax_rd(&g->vmcb);
+    M.x86.R_EBX = g->ctrl->regs.rbx;
+    M.x86.R_ECX = g->ctrl->regs.rcx;
+    M.x86.R_EDX = g->ctrl->regs.rdx;
+
+    M.x86.R_ESP = amd_vmcb_rsp_rd(&g->vmcb);
+    M.x86.R_EBP = g->ctrl->regs.rbp;
+    M.x86.R_ESI = g->ctrl->regs.rsi;
+    M.x86.R_EDI = g->ctrl->regs.rdi;
+    M.x86.R_EIP = amd_vmcb_rip_rd(&g->vmcb);
+    M.x86.R_EFLG = amd_vmcb_rflags_rd_raw(&g->vmcb);
+
+    // calculate the segment selector from the supplied base because the stored
+    // selector might not point to the correct RM segment
+    M.x86.R_CS = amd_vmcb_cs_base_rd(&g->vmcb) >> 4;
+    M.x86.R_DS = amd_vmcb_ds_base_rd(&g->vmcb) >> 4;
+    M.x86.R_ES = amd_vmcb_es_base_rd(&g->vmcb) >> 4;
+    M.x86.R_FS = amd_vmcb_fs_base_rd(&g->vmcb) >> 4;
+    M.x86.R_GS = amd_vmcb_gs_base_rd(&g->vmcb) >> 4;
+    M.x86.R_SS = amd_vmcb_ss_base_rd(&g->vmcb) >> 4;
+
+    // copy memory location
+    M.mem_base = guest_to_host(g->mem_low_va);
+    if (g->a20_gate_enabled) {
+        // add 1024 byte at the end if the a20 gate is enabled
+        M.mem_size = 0x100400;
+    } else {
+        // without a20 gate we are suppoed to have 1MB of memory
+        M.mem_size = 0x100000;
+    }
+}
+
+void
+realmode_switch_from (struct guest *g)
+{
+    // save all state
+    amd_vmcb_rax_wr(&g->vmcb, M.x86.R_EAX);
+    g->ctrl->regs.rbx = M.x86.R_EBX;
+    g->ctrl->regs.rcx = M.x86.R_ECX;
+    g->ctrl->regs.rdx = M.x86.R_EDX;
+
+    amd_vmcb_rsp_wr(&g->vmcb, M.x86.R_ESP);
+    g->ctrl->regs.rbp = M.x86.R_EBP;
+    g->ctrl->regs.rsi = M.x86.R_ESI;
+    g->ctrl->regs.rdi = M.x86.R_EDI;
+    amd_vmcb_rip_wr(&g->vmcb, M.x86.R_EIP);
+    amd_vmcb_rflags_wr_raw(&g->vmcb, M.x86.R_EFLG);
+
+    // only copy the segments back if they were changed during execution
+    // take the base as reference value because the selector might be invalid
+    // (this happens e.g. in a switch from protected mode to real-mode, where
+    // real-mode segment is read from the GDT)
+    // FIXME: this is not 100% save: If the code changes the seg selectors to
+    //        same value as the initial one then it wont be captured here
+    if ((amd_vmcb_cs_base_rd(&g->vmcb) >> 4) != M.x86.R_CS) {
+        VMCB_WRITE_SEGREG_REALMODE(&g->vmcb, cs, M.x86.R_CS);
+    }
+    if ((amd_vmcb_ds_base_rd(&g->vmcb) >> 4) != M.x86.R_DS) {
+        VMCB_WRITE_SEGREG_REALMODE(&g->vmcb, ds, M.x86.R_DS);
+    }
+    if ((amd_vmcb_es_base_rd(&g->vmcb) >> 4) != M.x86.R_ES) {
+        VMCB_WRITE_SEGREG_REALMODE(&g->vmcb, es, M.x86.R_ES);
+    }
+    if ((amd_vmcb_fs_base_rd(&g->vmcb) >> 4) != M.x86.R_FS) {
+        VMCB_WRITE_SEGREG_REALMODE(&g->vmcb, fs, M.x86.R_FS);
+    }
+    if ((amd_vmcb_gs_base_rd(&g->vmcb) >> 4) != M.x86.R_GS) {
+        VMCB_WRITE_SEGREG_REALMODE(&g->vmcb, gs, M.x86.R_GS);
+    }
+    if ((amd_vmcb_ss_base_rd(&g->vmcb) >> 4) != M.x86.R_SS) {
+        VMCB_WRITE_SEGREG_REALMODE(&g->vmcb, ss, M.x86.R_SS);
+    }
+
+    env = NULL;
+}
+
+int
+realmode_exec (void)
+{
+    assert(env != NULL);
+
+    valid_exit = false;
+
+    // run the simulator
+    X86EMU_exec ();
+
+    // examine halt reason
+    if (valid_exit) {
+        return REALMODE_ERR_OK;
+    }
+
+    uint8_t *code = (uint8_t *)(M.mem_base + (M.x86.R_CS << 4) + M.x86.R_EIP);
+
+    // check for two byte operation
+    if (code[-2] == 0x0f) {
+        union x86_modrm mod;
+
+        // move EIP back to the start of the instruction
+        M.x86.R_EIP -= 2;
+        mod.raw = code[0];
+
+        // check for LGDT
+        if (code[-1] == 0x01 && mod.u.regop == 2) {
+            // handle instruction
+            if (amd_vmcb_intercepts_rd(&env->vmcb).wrgdtr == 1) {
+                set_vmcb_exit(&env->vmcb, SVM_VMEXIT_GDTR_WRITE, 0, 0);
+                return REALMODE_ERR_OK;
+            } else {
+                assert(!"LGTR not intercepted");
+            }
+        }
+        // check for LIDT
+        if (code[-1] == 0x01 && mod.u.regop == 3) {
+            if (amd_vmcb_intercepts_rd(&env->vmcb).wridtr == 1) {
+                set_vmcb_exit(&env->vmcb, SVM_VMEXIT_IDTR_WRITE, 0, 0);
+                return REALMODE_ERR_OK;
+            } else {
+                assert(!"LITR not intercepted");
+            }
+        }
+        // check for CR access
+        else if (code[-1] == 0x20 || code[-1] == 0x22) {
+            if (mod.u.regop != 0) {
+                assert(!"realmode: only access to CR0 are allowed atm");
+            }
+            if (code[-1] == 0x20) { // check for read
+                if (amd_vmcb_cr_access_rd(&env->vmcb).rdcr0 == 1) {
+                    set_vmcb_exit(&env->vmcb, SVM_VMEXIT_CR0_READ, 0, 0);
+                    return REALMODE_ERR_OK;
+                }
+            } else {
+                if (amd_vmcb_cr_access_rd(&env->vmcb).wrcr0 == 1) {
+                    set_vmcb_exit(&env->vmcb, SVM_VMEXIT_CR0_WRITE, 0, 0);
+                    return REALMODE_ERR_OK;
+                }
+            }
+            assert(!"CR0 access not intercepted");
+        }
+        // CPUID
+        else if (code[-1] == 0xa2) {
+            set_vmcb_exit(&env->vmcb, SVM_VMEXIT_CPUID, 0, 0);
+            return REALMODE_ERR_OK;
+        }
+    }
+
+    printf("EIP: %08x, code %02x %02x %02x %02x\n", M.x86.R_EIP - 2,
+           code[-2], code[-1], code[0], code[1]);
+    assert(!"Unknown exit condition");
+    return REALMODE_ERR_OK;
+}
+
+/* libx86emu relies on this function */
+void printk(const char *fmt, ...)
+{
+    va_list ap;
+
+    va_start(ap, fmt);
+    vprintf(fmt, ap);
+    va_end(ap);
+}
diff --git a/usr/arrakismon/realmode.h b/usr/arrakismon/realmode.h
new file mode 100644
index 0000000..bb634a8
--- /dev/null
+++ b/usr/arrakismon/realmode.h
@@ -0,0 +1,28 @@
+/**
+ * \file
+ */
+
+/*
+ * Copyright (c) 2009, ETH Zurich.
+ * All rights reserved.
+ *
+ * This file is distributed under the terms in the attached LICENSE file.
+ * If you do not find this file, copies can be found by writing to:
+ * ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich. Attn: Systems Group.
+ */
+
+#ifndef REALMODE_H
+#define REALMODE_H
+
+#include "vmkitmon.h"
+
+#define REALMODE_ERR_OK                 (0)
+#define REALMODE_ERR_INVLD_ENV          (-1)
+#define REALMODE_ERR_NOT_SUPP           (-2)
+
+errval_t realmode_init (void);
+void realmode_switch_to (struct guest *g);
+void realmode_switch_from (struct guest *g);
+int realmode_exec (void);
+
+#endif // REALMODE_H
diff --git a/usr/arrakismon/svm.h b/usr/arrakismon/svm.h
new file mode 100644
index 0000000..ee79e89
--- /dev/null
+++ b/usr/arrakismon/svm.h
@@ -0,0 +1,60 @@
+/**
+ * \file
+ */
+
+/*
+ * Copyright (c) 2009, ETH Zurich.
+ * All rights reserved.
+ *
+ * This file is distributed under the terms in the attached LICENSE file.
+ * If you do not find this file, copies can be found by writing to:
+ * ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich. Attn: Systems Group.
+ */
+
+#ifndef AMD_SVM_H
+#define AMD_SVM_H
+
+#include <stdint.h>
+#include "amd_vmcb_dev.h"
+
+/* EXITCODE */
+
+#define SVM_VMEXIT_CR0_READ         0x0
+#define SVM_VMEXIT_CR0_WRITE        0x10
+#define SVM_VMEXIT_CR0_SEL_WRITE    0x65
+#define SVM_VMEXIT_IDTR_WRITE       0x6a
+#define SVM_VMEXIT_GDTR_WRITE       0x6b
+#define SVM_VMEXIT_CPUID            0x72
+#define SVM_VMEXIT_SWINT            0x75
+#define SVM_VMEXIT_HLT              0x78
+#define SVM_VMEXIT_IOIO             0x7b
+#define SVM_VMEXIT_MSR              0x7c
+#define SVM_VMEXIT_VMMCALL          0x81
+#define SVM_VMEXIT_NPF              0x400
+
+/* IO ACCESS FLAGS (EXITINFO1) */
+#define SVM_IOIO_TYPE_MASK          (1 << 0)
+#define SVM_IOIO_STR_MASK           (1 << 2)
+#define SVM_IOIO_REP_MASK           (1 << 3)
+#define SVM_IOIO_SZ8_MASK           (1 << 4)
+#define SVM_IOIO_SZ16_MASK          (1 << 5)
+#define SVM_IOIO_SZ32_MASK          (1 << 6)
+#define SVM_IOIO_A16_MASK           (1 << 7)
+#define SVM_IOIO_A32_MASK           (1 << 8)
+#define SVM_IOIO_A64_MASK           (1 << 9)
+
+
+/**
+ * \brief Convenience macro to write real-mode segmentation registers
+ *
+ * Write the selector, base and limit to a selector reg according to real-mode
+ * segmentation rules to the VMCB.
+ */
+#define VMCB_WRITE_SEGREG_REALMODE(vmcb,reg,selector)                   \
+do {                                                                    \
+    amd_vmcb_ ##reg## _selector_wr((vmcb), (selector));                 \
+    amd_vmcb_ ##reg## _base_wr((vmcb), (selector) << 4);                \
+    amd_vmcb_ ##reg## _limit_wr((vmcb), ((selector) << 4) + 0xffff);    \
+} while (0)
+
+#endif // AMD_SVM_H
diff --git a/usr/arrakismon/vmkitmon.c b/usr/arrakismon/vmkitmon.c
new file mode 100644
index 0000000..cc123c4
--- /dev/null
+++ b/usr/arrakismon/vmkitmon.c
@@ -0,0 +1,414 @@
+/**
+ * \file
+ */
+
+/*
+ * Copyright (c) 2009, 2010, 2011, ETH Zurich.
+ * All rights reserved.
+ *
+ * This file is distributed under the terms in the attached LICENSE file.
+ * If you do not find this file, copies can be found by writing to:
+ * ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich. Attn: Systems Group.
+ */
+
+#include "vmkitmon.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <barrelfish/barrelfish.h>
+#include <barrelfish/nameservice_client.h>
+#include <barrelfish/cpu_arch.h>
+/* #include <barrelfish/terminal.h> */
+#include <vfs/vfs.h>
+#include <vfs/vfs_path.h>
+#include <spawndomain/spawndomain.h>
+#include <if/arrakis_defs.h>
+#include <if/monitor_blocking_rpcclient_defs.h>
+/* #include <timer/timer.h> */
+#include "ps.h"
+
+#define SERVICE_BASENAME    "arrakis" // the core ID is appended to this
+
+static errval_t spawn_arrakis(char *path, char *const argv[], char *argbuf,
+			      size_t argbytes, char *const envp[], 
+			      struct capref inheritcn_cap, struct capref argcn_cap,
+			      domainid_t *domainid)
+{
+    errval_t err, msgerr;
+
+    /* read file into memory */
+    vfs_handle_t fh;
+    err = vfs_open(path, &fh);
+    if (err_is_fail(err)) {
+        return err_push(err, SPAWN_ERR_LOAD);
+    }
+
+    struct vfs_fileinfo info;
+    err = vfs_stat(fh, &info);
+    if (err_is_fail(err)) {
+        vfs_close(fh);
+        return err_push(err, SPAWN_ERR_LOAD);
+    }
+
+    assert(info.type == VFS_FILE);
+    uint8_t *image = malloc(info.size);
+    if (image == NULL) {
+        vfs_close(fh);
+        return err_push(err, SPAWN_ERR_LOAD);        
+    }
+
+    size_t pos = 0, readlen;
+    do {
+        err = vfs_read(fh, &image[pos], info.size - pos, &readlen);
+        if (err_is_fail(err)) {
+            vfs_close(fh);
+            free(image);
+            return err_push(err, SPAWN_ERR_LOAD);
+        } else if (readlen == 0) {
+            vfs_close(fh);
+            free(image);
+            return SPAWN_ERR_LOAD; // XXX
+        } else {
+            pos += readlen;
+        }
+    } while (err_is_ok(err) && readlen > 0 && pos < info.size);
+
+    err = vfs_close(fh);
+    if (err_is_fail(err)) {
+        DEBUG_ERR(err, "failed to close file %s", path);
+    }
+
+    // find short name (last part of path)
+    char *name = strrchr(path, VFS_PATH_SEP);
+    if (name == NULL) {
+        name = path;
+    } else {
+        name++;
+    }
+
+    /* spawn the image */
+    struct spawninfo si;
+    err = spawn_load_image(&si, (lvaddr_t)image, info.size, CURRENT_CPU_TYPE,
+                           name, disp_get_core_id(), argv, envp, inheritcn_cap,
+                           argcn_cap);
+    if (err_is_fail(err)) {
+        free(image);
+        return err;
+    }
+
+    free(image);
+
+    /* request connection from monitor */
+    struct monitor_blocking_rpc_client *mrpc = get_monitor_blocking_rpc_client();
+    struct capref monep;
+    err = mrpc->vtbl.alloc_monitor_ep(mrpc, &msgerr, &monep);
+    if (err_is_fail(err)) {
+        return err_push(err, SPAWN_ERR_MONITOR_CLIENT);
+    } else if (err_is_fail(msgerr)) {
+        return msgerr;
+    }
+
+    /* copy connection into the new domain */
+    struct capref destep = {
+        .cnode = si.rootcn,
+        .slot  = ROOTCN_SLOT_MONITOREP,
+    };
+    err = cap_copy(destep, monep);
+    if (err_is_fail(err)) {
+        spawn_free(&si);
+        cap_destroy(monep);
+        return err_push(err, SPAWN_ERR_MONITOR_CLIENT);
+    }
+
+    err = cap_destroy(monep);
+    if (err_is_fail(err)) {
+        return err_push(err, SPAWN_ERR_MONITOR_CLIENT);
+    }
+
+    debug_printf("spawning %s on core %u\n", path, disp_get_core_id());
+
+    /* give the perfmon capability */
+    struct capref dest, src;
+    dest.cnode = si.taskcn;
+    dest.slot = TASKCN_SLOT_PERF_MON;
+    src.cnode = cnode_task;
+    src.slot = TASKCN_SLOT_PERF_MON;
+    err = cap_copy(dest, src);
+    if (err_is_fail(err)) {
+        return err_push(err, INIT_ERR_COPY_PERF_MON);
+    }
+
+    // Create a new guest control structure
+    struct guest *g = guest_create();
+    assert(g != NULL);
+
+    // run the domain
+    spawn_guest_domain(g, &si);
+
+    err = guest_make_runnable(g, true);
+    assert_err(err, "guest_make_runnable");
+
+    // Allocate domain id
+    struct ps_entry *pe = malloc(sizeof(struct ps_entry));
+    assert(pe != NULL);
+    memset(pe, 0, sizeof(struct ps_entry));
+    memcpy(pe->argv, argv, MAX_CMDLINE_ARGS*sizeof(*argv));
+    pe->argbuf = argbuf;
+    pe->argbytes = argbytes;
+    /*
+     * NB: It's important to keep a copy of the DCB *and* the root
+     * CNode around.  We need to revoke both (in the right order, see
+     * kill_domain() below), so that we ensure no one else is
+     * referring to the domain's CSpace anymore. Especially the loop
+     * created by placing rootcn into its own address space becomes a
+     * problem here.
+     */
+    err = slot_alloc(&pe->rootcn_cap);
+    assert(err_is_ok(err));
+    err = cap_copy(pe->rootcn_cap, si.rootcn_cap);
+    pe->rootcn = si.rootcn;
+    assert(err_is_ok(err));
+    err = slot_alloc(&pe->dcb);
+    assert(err_is_ok(err));
+    err = cap_copy(pe->dcb, si.dcb);
+    assert(err_is_ok(err));
+    pe->status = PS_STATUS_RUNNING;
+    err = ps_allocate(pe, domainid);
+    if(err_is_fail(err)) {
+        free(pe);
+    }
+
+    // Store in target dispatcher frame
+    struct dispatcher_generic *dg = get_dispatcher_generic(si.handle);
+    dg->domain_id = *domainid;
+
+    /* cleanup */
+    err = spawn_free(&si);
+    if (err_is_fail(err)) {
+        return err_push(err, SPAWN_ERR_FREE);
+    }
+
+    return SYS_ERR_OK;
+}
+
+struct pending_spawn_response {
+    struct arrakis_binding *b;
+    errval_t err;
+    domainid_t domainid;
+};
+
+static void retry_spawn_domain_response(void *a)
+{
+    errval_t err;
+
+    struct pending_spawn_response *r = (struct pending_spawn_response*)a;
+    struct arrakis_binding *b = r->b;
+
+    err = b->tx_vtbl.spawn_arrakis_domain_response(b, NOP_CONT, r->err, r->domainid);
+
+    if (err_no(err) == FLOUNDER_ERR_TX_BUSY) {
+        // try again
+        err = b->register_send(b, get_default_waitset(), 
+                               MKCONT(retry_spawn_domain_response,a));
+    }
+    if (err_is_fail(err)) {
+        DEBUG_ERR(err, "error sending spawn_domain reply\n");
+    }
+
+    free(a);
+}
+
+
+static errval_t spawn_reply(struct arrakis_binding *b, errval_t rerr,
+                            domainid_t domainid)
+{
+    errval_t err;
+ 
+    err = b->tx_vtbl.spawn_arrakis_domain_response(b, NOP_CONT, rerr, domainid);
+
+    if (err_is_fail(err)) { 
+        DEBUG_ERR(err, "error sending spawn_domain reply\n");
+
+        if (err_no(err) == FLOUNDER_ERR_TX_BUSY) {
+            // this will be freed in the retry handler
+            struct pending_spawn_response *sr = 
+                malloc(sizeof(struct pending_spawn_response));
+            if (sr == NULL) {
+                return LIB_ERR_MALLOC_FAIL;
+            }
+            sr->b = b;
+            sr->err = rerr;
+            sr->domainid = domainid;
+            err = b->register_send(b, get_default_waitset(), 
+                                   MKCONT(retry_spawn_domain_response, sr));
+            if (err_is_fail(err)) {
+                // note that only one continuation may be registered at a time
+                free(sr);
+                DEBUG_ERR(err, "register_send failed!");
+                return err;
+            }
+        }
+    }
+
+    return SYS_ERR_OK;
+}
+
+
+static void spawn_with_caps_handler(struct arrakis_binding *b, char *path,
+                                    char *argbuf, size_t argbytes,
+                                    char *envbuf, size_t envbytes,
+                                    struct capref inheritcn_cap,
+                                    struct capref argcn_cap)
+{
+    errval_t err;
+    domainid_t domainid = 0;
+
+    /* printf("arrakismon: spawning '%s'\n", path); */
+
+    /* extract arguments from buffer */
+    char *argv[MAX_CMDLINE_ARGS + 1];
+    int i = 0;
+    size_t pos = 0;
+    while (pos < argbytes && i < MAX_CMDLINE_ARGS) {
+        argv[i++] = &argbuf[pos];
+        char *end = memchr(&argbuf[pos], '\0', argbytes - pos);
+        if (end == NULL) {
+            err = SPAWN_ERR_GET_CMDLINE_ARGS;
+            goto finish;
+        }
+        pos = end - argbuf + 1;
+    }
+    assert(i <= MAX_CMDLINE_ARGS);
+    argv[i] = NULL;
+
+    /* extract environment from buffer */
+    char *envp[MAX_CMDLINE_ARGS + 1];
+    i = 0;
+    pos = 0;
+    while (pos < envbytes && i < MAX_CMDLINE_ARGS) {
+        envp[i++] = &envbuf[pos];
+        char *end = memchr(&envbuf[pos], '\0', envbytes - pos);
+        if (end == NULL) {
+            err = SPAWN_ERR_GET_CMDLINE_ARGS;
+            goto finish;
+        }
+        pos = end - envbuf + 1;
+    }
+    assert(i <= MAX_CMDLINE_ARGS);
+    envp[i] = NULL;
+
+    vfs_path_normalise(path);
+
+    err = spawn_arrakis(path, argv, argbuf, argbytes, envp, inheritcn_cap,
+			argcn_cap, &domainid);
+    if (!capref_is_null(inheritcn_cap)) {
+        errval_t err2;
+        err2 = cap_delete(inheritcn_cap);
+        assert(err_is_ok(err2));
+    }
+    if (!capref_is_null(argcn_cap)) {
+        errval_t err2;
+        err2 = cap_delete(argcn_cap);
+        assert(err_is_ok(err2));
+    }
+
+ finish:
+    if(err_is_fail(err)) {
+        free(argbuf);
+        DEBUG_ERR(err, "spawn");
+    }
+
+    err = spawn_reply(b, err, domainid);
+
+    if (err_is_fail(err)) {
+        // not much we can do about this
+        DEBUG_ERR(err, "while sending reply in spawn_handler");
+    }
+
+    free(envbuf);
+    free(path);
+}
+
+
+static void spawn_handler(struct arrakis_binding *b, char *path, char *argbuf,
+                          size_t argbytes, char *envbuf, size_t envbytes)
+{
+    spawn_with_caps_handler(b, path, argbuf, argbytes, envbuf, envbytes,
+                            NULL_CAP, NULL_CAP);
+}
+
+static struct arrakis_rx_vtbl rx_vtbl = {
+    .spawn_arrakis_domain_call = spawn_handler,
+};
+
+static void export_cb(void *st, errval_t err, iref_t iref)
+{
+    if (err_is_fail(err)) {
+        USER_PANIC_ERR(err, "export failed");
+    }
+
+    // construct name
+    char namebuf[32];
+    size_t len = snprintf(namebuf, sizeof(namebuf), "%s.%d", SERVICE_BASENAME,
+                          disp_get_core_id());
+    assert(len < sizeof(namebuf));
+    namebuf[sizeof(namebuf) - 1] = '\0';
+
+    // register this iref with the name service
+    err = nameservice_register(namebuf, iref);
+    if (err_is_fail(err)) {
+        USER_PANIC_ERR(err, "nameservice_register failed");
+    }
+}
+
+static errval_t connect_cb(void *st, struct arrakis_binding *b)
+{
+    // copy my message receive handler vtable to the binding
+    b->rx_vtbl = rx_vtbl;
+    return SYS_ERR_OK;
+}
+
+static errval_t start_service(void)
+{
+    return arrakis_export(NULL, export_cb, connect_cb, get_default_waitset(),
+			  IDC_EXPORT_FLAGS_DEFAULT);
+}
+
+int main (int argc, char *argv[])
+{
+    vfs_init();
+
+    /* err = timer_init(); */
+    /* if (err_is_fail(err)) { */
+    /*     USER_PANIC_ERR(err, "error initialising timer client library\n"); */
+    /* } */
+
+#if 0
+    /* Initialization */
+    err = realmode_init();
+    assert_err(err, "realmode_init");
+
+    // aquire the standard input
+    err = terminal_want_stdin(TERMINAL_SOURCE_SERIAL);
+    assert_err(err, "terminal_want_stdin");
+#endif
+
+    // Start arrakis service
+    start_service();
+
+    // Spawn test arrakis application
+    /* err = spawn_arrakis("/x86_64/sbin/hellotest", ); */
+    /* assert_err(err, "spawn_arrakis"); */
+
+#if 0
+    guest = guest_create ();
+    assert(guest != NULL);
+    err = guest_make_runnable(guest, true);
+    assert_err(err, "guest_make_runnable");
+
+    printf("arrakismon: main loop\n");
+#endif
+
+    messages_handler_loop();
+}
diff --git a/usr/arrakismon/vmkitmon.h b/usr/arrakismon/vmkitmon.h
new file mode 100644
index 0000000..332af1e
--- /dev/null
+++ b/usr/arrakismon/vmkitmon.h
@@ -0,0 +1,43 @@
+/**
+ * \file
+ */
+
+/*
+ * Copyright (c) 2009, 2013, ETH Zurich.
+ * All rights reserved.
+ *
+ * This file is distributed under the terms in the attached LICENSE file.
+ * If you do not find this file, copies can be found by writing to:
+ * ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich. Attn: Systems Group.
+ */
+
+#ifndef VMKITMON_H
+#define VMKITMON_H
+
+#include <barrelfish/barrelfish.h>
+#include <barrelfish_kpi/vmkit.h>
+#include "guest.h"
+
+// Handler return values - this does probably not belong here
+#define HANDLER_ERR_OK              (0)
+#define HANDLER_ERR_FATAL           (-1)
+#define HANDLER_ERR_UNHANDELED      (-2)
+
+#define assert_err(e,m)     \
+do {                        \
+    if (err_is_fail(e)) {   \
+        DEBUG_ERR(e,m);     \
+        abort();            \
+    }                       \
+} while (0)
+
+#define LIKELY(x)       __builtin_expect((x),1)
+#define UNLIKELY(x)     __builtin_expect((x),0)
+
+#if defined(VMKIT_PCI_DEBUG_SWITCH)
+#define VMKIT_PCI_DEBUG(x...) printf("VMKit PCI: " x)
+#else
+#define VMKIT_PCI_DEBUG(x...) ((void)0)
+#endif
+
+#endif // VMKITMON_H
diff --git a/usr/arrakismon/x86.h b/usr/arrakismon/x86.h
new file mode 100644
index 0000000..80cf482
--- /dev/null
+++ b/usr/arrakismon/x86.h
@@ -0,0 +1,285 @@
+/**
+ * \file
+ */
+
+/*
+ * Copyright (c) 2009, ETH Zurich.
+ * All rights reserved.
+ *
+ * This file is distributed under the terms in the attached LICENSE file.
+ * If you do not find this file, copies can be found by writing to:
+ * ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich. Attn: Systems Group.
+ */
+
+#ifndef VMKITMON_X86_H
+#define VMKITMON_X86_H
+
+#include <stdint.h>
+
+/**
+ * \brief Structure to represent a ModR/M byte used by certain instructions
+ */
+union x86_modrm {
+    struct {
+        uint32_t     rm : 3;
+        uint32_t     regop : 3;
+        uint32_t     mod : 2;
+    } __attribute__((packed)) u;
+    uint8_t raw;
+} __attribute__((packed));
+
+/**
+ * \brief This enumeration represents the state of an IO-port access.
+ */
+enum x86_io_access {
+    X86_IO_ACCESS_TYPE  = (1 << 0),     ///< 0 = output (write), 1 = input (read)
+    X86_IO_ACCESS_STR   = (1 << 1),     ///< String based port access (INS, OUTS)
+    X86_IO_ACCESS_REP   = (1 << 2),     ///< Repeated port access
+    X86_IO_ACCESS_SZ8   = (1 << 3),     ///< 8-bit operand size
+    X86_IO_ACCESS_SZ16  = (1 << 4),     ///< 16-bit operand size
+    X86_IO_ACCESS_SZ32  = (1 << 5),     ///< 32-bit operand size
+    X86_IO_ACCESS_A16   = (1 << 6),     ///< 16-bit address size
+    X86_IO_ACCESS_A32   = (1 << 7),     ///< 32-bit address size
+    X86_IO_ACCESS_A64   = (1 << 8)      ///< 64-bit address size
+};
+
+// MSRs
+#define X86_MSR_SYSENTER_CS     0x00000174
+#define X86_MSR_SYSENTER_ESP    0x00000175
+#define X86_MSR_SYSENTER_EIP    0x00000176
+#define X86_MSR_EFER            0xc0000080
+#define X86_MSR_STAR            0xc0000081
+#define X86_MSR_LSTAR           0xc0000082
+#define X86_MSR_CSTAR           0xc0000083
+#define X86_MSR_SFMASK          0xc0000084
+#define X86_MSR_FS_BASE         0xc0000100
+#define X86_MSR_GS_BASE         0xc0000101
+#define X86_MSR_KERNEL_GS_BASE  0xc0000102
+
+
+// Long Mode Paging
+
+/**
+ * \brief Long mode virtual address
+ */
+union x86_lm_va {
+    struct {
+        uint32_t    pa_offset           : 12;
+        uint32_t    pt_idx              : 9;
+        uint32_t    pd_idx              : 9;
+        uint32_t    pdp_idx             : 9;
+        uint32_t    pml4_idx            : 9;
+        uint32_t    sign_extend         : 16;
+    } __attribute__((packed)) u;
+    struct {
+        uint32_t    pa_offset           : 21;
+        uint32_t    pd_idx              : 9;
+        uint32_t    pdp_idx             : 9;
+        uint32_t    pml4_idx            : 9;
+        uint32_t    sign_extend         : 16;
+    } __attribute__((packed)) u2mb;
+    struct {
+        uint32_t    pa_offset           : 30;
+        uint32_t    pdp_idx             : 9;
+        uint32_t    pml4_idx            : 9;
+        uint32_t    sign_extend         : 16;
+    } __attribute__((packed)) u1gb;
+    uint64_t raw;
+} __attribute__((packed));
+
+/**
+ * \brief PML4 Record
+ */
+union x86_lm_pml4_entry {
+    struct {
+        uint32_t    p                   : 1;
+        uint32_t    rw                  : 1;
+        uint32_t    us                  : 1;
+        uint32_t    pwt                 : 1;
+        uint32_t    pcd                 : 1;
+        uint32_t    a                   : 1;
+        uint32_t    ign                 : 1;
+        uint32_t    rsvd                : 2;
+        uint32_t    avl                 : 3;
+        uint64_t    pdp_base_pa         : 40;
+        uint32_t    avail               : 11;
+        uint32_t    nx                  : 1;
+    } __attribute__((packed)) u;
+    uint64_t raw;
+} __attribute__((packed));
+
+/**
+ * \brief Page Directory Pointer Entry
+ */
+union x86_lm_pdp_entry {
+    struct {
+        uint32_t    p                   : 1;
+        uint32_t    rw                  : 1;
+        uint32_t    us                  : 1;
+        uint32_t    pwt                 : 1;
+        uint32_t    pcd                 : 1;
+        uint32_t    a                   : 1;
+        uint32_t    ign                 : 1;
+        uint32_t    ps                  : 1;
+        uint32_t    rsvd                : 1;
+        uint32_t    avl                 : 3;
+        uint64_t    pd_base_pa          : 40;
+        uint32_t    avail               : 11;
+        uint32_t    nx                  : 1;
+    } __attribute__((packed)) u;
+    struct {
+        uint32_t    p                   : 1;
+        uint32_t    rw                  : 1;
+        uint32_t    us                  : 1;
+        uint32_t    pwt                 : 1;
+        uint32_t    pcd                 : 1;
+        uint32_t    a                   : 1;
+        uint32_t    d                   : 1;
+        uint32_t    ps                  : 1;
+        uint32_t    g                   : 1;
+        uint32_t    avl                 : 3;
+        uint32_t    pat                 : 1;
+        uint32_t    rsvd                : 17;
+        uint64_t    base_pa             : 22;
+        uint32_t    avail               : 11;
+        uint32_t    nx                  : 1;
+    } __attribute__((packed)) u1gb;
+    uint64_t raw;
+} __attribute__((packed));
+
+/**
+ * \brief Long mode page directory entry
+ */
+union x86_lm_pd_entry {
+    struct {
+        uint32_t    p                   : 1;
+        uint32_t    rw                  : 1;
+        uint32_t    us                  : 1;
+        uint32_t    pwt                 : 1;
+        uint32_t    pcd                 : 1;
+        uint32_t    a                   : 1;
+        uint32_t    ign1                : 1;
+        uint32_t    ps                  : 1;
+        uint32_t    ign2                : 1;
+        uint32_t    avl                 : 3;
+        uint64_t    pt_base_pa          : 40;
+        uint32_t    avail               : 11;
+        uint32_t    nx                  : 1;
+    } __attribute__((packed)) u;
+    struct {
+        uint32_t    p                   : 1;
+        uint32_t    rw                  : 1;
+        uint32_t    us                  : 1;
+        uint32_t    pwt                 : 1;
+        uint32_t    pcd                 : 1;
+        uint32_t    a                   : 1;
+        uint32_t    d                   : 1;
+        uint32_t    ps                  : 1;
+        uint32_t    g                   : 1;
+        uint32_t    avl                 : 3;
+        uint32_t    pat                 : 1;
+        uint32_t    rsvd                : 8;
+        uint64_t    base_pa             : 31;
+        uint32_t    avail               : 11;
+        uint32_t    nx                  : 1;
+    } __attribute__((packed)) u2mb;
+    uint64_t raw;
+} __attribute__((packed));
+
+/**
+ * \brief Long mode page table entry
+ */
+union x86_lm_pt_entry {
+    struct {
+        uint32_t    p                   : 1;
+        uint32_t    rw                  : 1;
+        uint32_t    us                  : 1;
+        uint32_t    pwt                 : 1;
+        uint32_t    pcd                 : 1;
+        uint32_t    a                   : 1;
+        uint32_t    d                   : 1;
+        uint32_t    pat                 : 1;
+        uint32_t    g                   : 1;
+        uint32_t    avl                 : 3;
+        uint64_t    base_pa             : 40;
+        uint32_t    avail               : 11;
+        uint32_t    nx                  : 1;
+    } __attribute__((packed)) u;
+    uint64_t raw;
+} __attribute__((packed));
+
+
+// Legacy Mode Paging
+
+/**
+ * \brief Legacy mode virtual address
+ */
+union x86_legm_va {
+    struct {
+        uint32_t    pa_offset           : 12;
+        uint32_t    pt_idx              : 10;
+        uint32_t    pd_idx              : 10;
+    } __attribute__((packed)) u;
+    struct {
+        uint32_t    pa_offset           : 22;
+        uint32_t    pd_idx              : 10;
+    } __attribute__((packed)) u4mb;
+    uint32_t raw;
+} __attribute__((packed));
+
+/**
+ * \brief Legacy mode page directory entry
+ */
+union x86_legm_pd_entry {
+    struct {
+        uint32_t    p                   : 1;
+        uint32_t    rw                  : 1;
+        uint32_t    us                  : 1;
+        uint32_t    pwt                 : 1;
+        uint32_t    pcd                 : 1;
+        uint32_t    a                   : 1;
+        uint32_t    ign1                : 1;
+        uint32_t    ps                  : 1;
+        uint32_t    ign2                : 1;
+        uint32_t    avl                 : 3;
+        uint32_t    pt_base_pa          : 20;
+    } __attribute__((packed)) u;
+    struct {
+        uint32_t    p                   : 1;
+        uint32_t    rw                  : 1;
+        uint32_t    us                  : 1;
+        uint32_t    pwt                 : 1;
+        uint32_t    pcd                 : 1;
+        uint32_t    a                   : 1;
+        uint32_t    d                   : 1;
+        uint32_t    ps                  : 1;
+        uint32_t    g                   : 1;
+        uint32_t    avl                 : 3;
+        uint32_t    pat                 : 1;
+        uint32_t    rsvd                : 9;
+        uint32_t    base_pa             : 10;
+    } __attribute__((packed)) u4mb;
+    uint32_t raw;
+} __attribute__((packed));
+
+/**
+ * \brief Legacy mode page table entry
+ */
+union x86_legm_pt_entry {
+    struct {
+        uint32_t    p                   : 1;
+        uint32_t    rw                  : 1;
+        uint32_t    us                  : 1;
+        uint32_t    pwt                 : 1;
+        uint32_t    pcd                 : 1;
+        uint32_t    a                   : 1;
+        uint32_t    d                   : 1;
+        uint32_t    pat                 : 1;
+        uint32_t    g                   : 1;
+        uint32_t    avl                 : 3;
+        uint32_t    base_pa             : 20;
+    } __attribute__((packed)) u;
+    uint32_t raw;
+} __attribute__((packed));
+
+#endif // VMKITMON_X86_H
diff --git a/usr/bench/ahci/Hakefile b/usr/bench/ahci/Hakefile
index 7d9da29..d863a4d 100644
--- a/usr/bench/ahci/Hakefile
+++ b/usr/bench/ahci/Hakefile
@@ -13,6 +13,6 @@
 [
 build application { target = "ahci_bench",
                   cFiles = [ "main.c" ],
-                  addLibraries = libDeps [ "pci", "trace", "skb", "vfs"]
+                  addLibraries = libDeps [ "pci", "trace", "skb", "vfs", "lwip" ]
                  }
 ]
diff --git a/usr/bench/net_latency/elb/Hakefile b/usr/bench/net_latency/elb/Hakefile
index a7644a7..01e4b67 100644
--- a/usr/bench/net_latency/elb/Hakefile
+++ b/usr/bench/net_latency/elb/Hakefile
@@ -37,4 +37,3 @@
 
 
 ]
-
diff --git a/usr/bench/udp_echo/Hakefile b/usr/bench/udp_echo/Hakefile
new file mode 100644
index 0000000..b51e3c2
--- /dev/null
+++ b/usr/bench/udp_echo/Hakefile
@@ -0,0 +1,52 @@
+--------------------------------------------------------------------------
+-- Copyright (c) 2007-2011, 2013, ETH Zurich.
+-- All rights reserved.
+--
+-- This file is distributed under the terms in the attached LICENSE file.
+-- If you do not find this file, copies can be found by writing to:
+-- ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich. Attn: Systems Group.
+--
+-- Hakefile for /usr/tests/e10ktest
+-- 
+--------------------------------------------------------------------------
+
+[ build application { target = "udpecho_e1000",
+                      cFiles = [ "udp_echo.c" ],
+                      addLibraries = libDeps [ "posixcompat", "lwip_arrakis", "e1000n" ]
+                    },
+  build application { target = "udpecho_e10kvf",
+                      cFiles = [ "udp_echo.c" ],
+                      addLibraries = libDeps [ "posixcompat", "lwip_arrakis", "e10k_vf" ]
+                    },
+  build application { target = "udpecho_e10k",
+                      cFiles = [ "udp_echo.c" ],
+                      addLibraries = libDeps [ "posixcompat", "lwip_arrakis", "e10k" ]
+                    },
+  build application { target = "udpecho_arranet_e10k_recvfrom",
+                      cFiles = [ "udp_echo.c" ],
+                      addLibraries = libDeps [ "posixcompat", "arranet", "e10k" ],
+                      addCFlags = [ "-DARRANET_RECVFROM" ]
+                    },
+  build application { target = "udpecho_arranet_e10kvf_recvfrom",
+                      cFiles = [ "udp_echo.c" ],
+                      addLibraries = libDeps [ "posixcompat", "arranet", "e10k_vf" ],
+                      addCFlags = [ "-DARRANET_RECVFROM" ]
+                    },
+  build application { target = "udpecho_arranet_e1000_recvfrom",
+                      cFiles = [ "udp_echo.c" ],
+                      addLibraries = libDeps [ "posixcompat", "arranet", "e1000n" ],
+                      addCFlags = [ "-DARRANET_RECVFROM" ]
+                    },
+  build application { target = "udpecho_arranet_e10k",
+                      cFiles = [ "udp_echo.c" ],
+                      addLibraries = libDeps [ "posixcompat", "arranet", "e10k" ]
+                    },
+  build application { target = "udpecho_arranet_e10kvf",
+                      cFiles = [ "udp_echo.c" ],
+                      addLibraries = libDeps [ "posixcompat", "arranet", "e10k_vf" ]
+                    },
+  build application { target = "udpecho_arranet_e1000",
+                      cFiles = [ "udp_echo.c" ],
+                      addLibraries = libDeps [ "posixcompat", "arranet", "e1000n" ]
+                    }
+]
diff --git a/usr/bench/udp_echo/Makefile b/usr/bench/udp_echo/Makefile
new file mode 100644
index 0000000..624879e
--- /dev/null
+++ b/usr/bench/udp_echo/Makefile
@@ -0,0 +1,10 @@
+CFLAGS = -g -O2 -std=c99
+LDFLAGS = -pthread
+
+all: udp_echo udp_openloop
+
+udp_echo: udp_echo.o
+udp_echo.o: udp_echo.c
+
+udp_openloop: udp_openloop.o
+udp_openloop.o: udp_openloop.c
diff --git a/usr/bench/udp_echo/run_multiloop.sh b/usr/bench/udp_echo/run_multiloop.sh
new file mode 100644
index 0000000..2d58506
--- /dev/null
+++ b/usr/bench/udp_echo/run_multiloop.sh
@@ -0,0 +1,21 @@
+#!/bin/bash
+
+rm -f /tmp/udp_openloop.*.log
+
+n_threads=$1
+client_type=$2
+port=$3
+server=$4
+request_delay=$5
+n_ops_per_client=$6
+starting_id=$7
+
+my_starting_id=$starting_id
+for n in `seq $1`; do
+    #echo Running $client_type $port $server $request_delay $n_ops_per_process $my_starting_id
+    $client_type $port $server $request_delay $n_ops_per_client $my_starting_id > /tmp/udp_openloop.$n.log &
+    let my_starting_id=$my_starting_id+$n_ops_per_client
+done
+wait
+
+cat /tmp/udp_openloop.*.log
diff --git a/usr/bench/udp_echo/udp_echo.c b/usr/bench/udp_echo/udp_echo.c
new file mode 100644
index 0000000..174b357
--- /dev/null
+++ b/usr/bench/udp_echo/udp_echo.c
@@ -0,0 +1,340 @@
+/*
+ * Copyright (c) 2014, ETH Zurich.
+ * All rights reserved.
+ *
+ * This file is distributed under the terms in the attached LICENSE file.
+ * If you do not find this file, copies can be found by writing to:
+ * ETH Zurich D-INFK, CAB F.78, Universitaetstr. 6, CH-8092 Zurich. 
+ * Attn: Systems Group.
+ */
+
+#ifndef BARRELFISH
+#define _POSIX_C_SOURCE 199309L
+#endif
+
+#include <stdio.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <netdb.h>
+#include <sys/types.h> 
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <sys/time.h>
+#ifdef BARRELFISH
+#       include <netif/e1000.h>
+#       include <arranet.h>
+#       include <arranet_debug.h>
+extern int posix_recv_time[POSIX_TRANSA];       // Time until packet at exit of recvfrom
+extern size_t posix_recv_transactions;
+#else
+#	include <time.h>
+#       include <strings.h>
+#endif
+
+/* #include "hash.c" */
+
+#define	timersub(a, b, result)						      \
+  do {									      \
+    (result)->tv_sec = (a)->tv_sec - (b)->tv_sec;			      \
+    (result)->tv_usec = (a)->tv_usec - (b)->tv_usec;			      \
+    if ((result)->tv_usec < 0) {					      \
+      --(result)->tv_sec;						      \
+      (result)->tv_usec += 1000000;					      \
+    }									      \
+  } while (0)
+
+#define BUFSIZE                 1024
+#define MAX_ROUNDS              1000
+
+//#define SIMULATE_PROC_TIME
+//#define ARRANET_RECVFROM
+
+#define MIN(a,b)        ((a) < (b) ? (a) : (b))
+#define MAX(a,b)        ((a) > (b) ? (a) : (b))
+
+static char initbuf[] = "123456789012345678901234567890123456789012345678901234567890123";
+
+static struct timeval tvs[MAX_ROUNDS];
+
+/*
+ * error - wrapper for perror
+ */
+static void error(char *msg) {
+  perror(msg);
+  exit(1);
+}
+
+#ifndef BARRELFISH
+static inline uint64_t rdtsc(void)
+{
+    uint32_t eax, edx;
+    __asm volatile ("rdtsc" : "=a" (eax), "=d" (edx));
+    return ((uint64_t)edx << 32) | eax;
+}
+#endif
+
+#ifndef SENDMSG_WITH_COPY
+static void tx_done(void *opaque)
+{
+    /* printf("Handling %p back to stack\n", opaque); */
+    arranet_recv_free(opaque);
+}
+#endif
+
+int main(int argc, char **argv) {
+  int sockfd; /* socket */
+  int portno; /* port to listen on */
+  socklen_t clientlen; /* byte size of client's address */
+  struct sockaddr_in serveraddr; /* server's addr */
+  struct sockaddr_in clientaddr; /* client addr */
+  /* struct hostent *hostp; /\* client host info *\/ */
+  static char buf[BUFSIZE]; /* message buf */
+  /* char *hostaddrp; /\* dotted decimal host addr string *\/ */
+#ifndef BARRELFISH
+  int optval; /* flag value for setsockopt */
+#endif
+  int proctime = 0;
+  int n; /* message byte size */
+
+#ifdef BARRELFISH
+  lwip_arrakis_start(&argc, &argv);
+
+  // LLC misses
+  invoke_perfmon_activate(cap_perfmon,
+                          0x2e,   // Event to monitor
+                          0x41,   // UMASK
+                          false,      // Kernel
+                          0,      // Counter ID
+                          0,    // number of events to cause overflow
+                          0);
+
+#ifndef SENDMSG_WITH_COPY
+  arranet_register_tx_done_callback(tx_done);
+#endif
+
+#endif
+
+  printf("argc = %d\n", argc);
+
+  for(int i = 0; i < argc; i++) {
+      printf("argv[%d] = '%s'\n", i, argv[i]);
+  }
+
+  int clientmode = (argc > 2 && *argv[2] != '0');
+
+  /* 
+   * check command line arguments 
+   */
+  if (argc < 2) {
+    fprintf(stderr, "usage: %s <port> [server IP|0] [proc time ns]\n", argv[0]);
+    exit(1);
+  }
+  portno = atoi(argv[1]);
+  if(argc == 4) {
+      proctime = atoi(argv[3]);
+  }
+
+  if(!clientmode) {
+      printf("Server on port %d, proctime %d\n", portno, proctime);
+  } else {
+      printf("Client mode\n");
+  }
+
+  /* 
+   * socket: create the parent socket 
+   */
+  sockfd = socket(AF_INET, SOCK_DGRAM, 0);
+  if (sockfd < 0) 
+    error("ERROR opening socket");
+
+#ifndef BARRELFISH
+  /* setsockopt: Handy debugging trick that lets 
+   * us rerun the server immediately after we kill it; 
+   * otherwise we have to wait about 20 secs. 
+   * Eliminates "ERROR on binding: Address already in use" error. 
+   */
+  optval = 1;
+  setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR,
+             (const void *)&optval , sizeof(int));
+#endif
+
+  clientlen = sizeof(clientaddr);
+
+  if(clientmode) {
+      bzero((char *) &clientaddr, sizeof(clientaddr));
+      clientaddr.sin_family = AF_INET;
+      clientaddr.sin_addr.s_addr = inet_addr(argv[2]);
+      if(clientaddr.sin_addr.s_addr == INADDR_NONE) {
+	printf("Error on inet_addr()\n");
+	exit(1);
+      }
+      clientaddr.sin_port = htons((unsigned short)portno);
+
+      // client mode -- initiate packet send
+      memcpy(buf, initbuf, sizeof(initbuf));
+      n = sendto(sockfd, buf, strlen(buf), 0,
+                 (struct sockaddr *) &clientaddr, clientlen);
+      if (n < 0)
+          error("ERROR in first sendto");
+  } else {
+    /*
+     * build the server's Internet address
+     */
+    bzero((char *) &serveraddr, sizeof(serveraddr));
+    serveraddr.sin_family = AF_INET;
+    serveraddr.sin_addr.s_addr = htonl(INADDR_ANY);
+    serveraddr.sin_port = htons((unsigned short)portno);
+
+    /* 
+     * bind: associate the parent socket with a port 
+     */
+    if (bind(sockfd, (struct sockaddr *) &serveraddr, 
+	     sizeof(serveraddr)) < 0) 
+      error("ERROR on binding");
+  }
+
+  /* 
+   * main loop: wait for a datagram, then echo it
+   */
+
+  for(int i = 0; i < MAX_ROUNDS; i = (clientmode ? i + 1 : 0)) {
+    /*
+     * recvfrom: receive a UDP datagram from a client
+     */
+    /* bzero(buf, BUFSIZE); */
+#ifndef ARRANET_RECVFROM
+    n = recvfrom(sockfd, buf, BUFSIZE, 0,
+		 (struct sockaddr *) &clientaddr, &clientlen);
+
+#ifdef DEBUG_LATENCIES
+    if(posix_recv_transactions < POSIX_TRANSA) {
+        protocol_binary_request_no_extras *mypayload = (void *)(buf + UDP_HEADLEN);
+        posix_recv_time[posix_recv_transactions] = get_time() - mypayload->message.header.request.opaque;
+        posix_recv_transactions++;
+    }
+#endif
+#else
+    void *mybuf = NULL;
+    struct packet *myp = NULL;
+    n = recvfrom_arranet(sockfd, &mybuf, &myp,
+                         (struct sockaddr *) &clientaddr, &clientlen);
+
+#ifdef DEBUG_LATENCIES
+    if(posix_recv_transactions < POSIX_TRANSA) {
+        protocol_binary_request_no_extras *mypayload = (void *)(mybuf + UDP_HEADLEN);
+        posix_recv_time[posix_recv_transactions] = get_time() - mypayload->message.header.request.opaque;
+        posix_recv_transactions++;
+    }
+#endif
+
+    /* printf("udp_echo: Got %p from stack\n", myp); */
+#endif
+    if (n < 0)
+      error("ERROR in recvfrom");
+
+    /* printf("server received %zd/%d bytes: %s\n", strlen(buf), n, buf); */
+    /* printf("server received %d bytes\n", n); */
+
+    if(argc > 2) {
+        gettimeofday(&tvs[i], NULL);
+    }
+
+/* #ifndef ARRANET_RECVFROM */
+/*     uint32_t *hashval = (uint32_t *)&buf[24]; */
+/*     *hashval = hash(buf, 64, 0); */
+/* #else */
+/*     uint32_t *hashval = (uint32_t *)(mybuf + 24); */
+/*     *hashval = hash(mybuf, 64, 0); */
+/* #endif */
+
+#ifdef SIMULATE_PROC_TIME
+    uint64_t now = rdtsc();
+    while(rdtsc() - now < proctime);
+    /* if(proctime > 0) { */
+    /*     struct timespec req = { */
+    /*         .tv_sec = 0, */
+    /*         .tv_nsec = proctime, */
+    /*     }; */
+    /*     nanosleep(&req, NULL); */
+    /* } */
+#endif
+
+    /*
+     * sendto: echo the input back to the client 
+     */
+#ifndef ARRANET_RECVFROM
+#       ifdef SENDMSG_WITH_COPY
+    n = sendto(sockfd, buf, n, 0, 
+	       (struct sockaddr *) &clientaddr, clientlen);
+#       else
+    {
+        struct iovec io = {
+            .iov_base = (void *)buf,
+            .iov_len = n,
+            .iov_opaque = buf,
+        };
+
+        struct msghdr msg = {
+            .msg_name = (void *)&clientaddr,
+            .msg_namelen = clientlen,
+            .msg_iov = &io,
+            .msg_iovlen = 1,
+            .msg_flags = 0,
+        };
+
+        n = sendmsg(sockfd, &msg, 0);
+    }
+#       endif
+#else
+#       ifdef SENDMSG_WITH_COPY
+    n = sendto(sockfd, mybuf, n, 0,
+	       (struct sockaddr *) &clientaddr, clientlen);
+
+    arranet_recv_free(myp);
+#       else
+    {
+        /* printf("udp_echo: Sending %p back to stack\n", myp); */
+
+        struct iovec io = {
+            .iov_base = (void *)mybuf,
+            .iov_len = n,
+            .iov_opaque = myp,
+        };
+
+        struct msghdr msg = {
+            .msg_name = (void *)&clientaddr,
+            .msg_namelen = clientlen,
+            .msg_iov = &io,
+            .msg_iovlen = 1,
+            .msg_flags = 0,
+        };
+
+        n = sendmsg(sockfd, &msg, 0);
+    }
+#       endif
+#endif
+    if (n < 0)
+        error("ERROR in sendto");
+  }
+
+  if(argc > 2) {
+      unsigned long sum = 0, min = 99999, max = 0;
+
+      for(int i = 1; i < MAX_ROUNDS; i++) {
+          struct timeval res;
+          timersub(&tvs[i], &tvs[i - 1], &res);
+          unsigned long r = res.tv_sec * 1000000 + res.tv_usec;
+          printf("%lu us\n", r);
+          sum += r;
+          min = MIN(min, r);
+          max = MAX(max, r);
+      }
+
+      printf("average %lu us, min %lu us, max %lu us\n",
+             sum / (MAX_ROUNDS - 1), min, max);
+  }
+
+  return 0;
+}
diff --git a/usr/bench/udp_echo/udp_openloop.c b/usr/bench/udp_echo/udp_openloop.c
new file mode 100644
index 0000000..092e819
--- /dev/null
+++ b/usr/bench/udp_echo/udp_openloop.c
@@ -0,0 +1,181 @@
+/*
+ * Copyright (c) 2014, ETH Zurich.
+ * All rights reserved.
+ *
+ * This file is distributed under the terms in the attached LICENSE file.
+ * If you do not find this file, copies can be found by writing to:
+ * ETH Zurich D-INFK, CAB F.78, Universitaetstr. 6, CH-8092 Zurich. 
+ * Attn: Systems Group.
+ */
+
+#include <stdio.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <netdb.h>
+#include <inttypes.h>
+#include <sys/types.h> 
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <sys/time.h>
+#include <strings.h>
+#include <assert.h>
+#include <pthread.h>
+
+#define	timersub(a, b, result)						      \
+  do {									      \
+    (result)->tv_sec = (a)->tv_sec - (b)->tv_sec;			      \
+    (result)->tv_usec = (a)->tv_usec - (b)->tv_usec;			      \
+    if ((result)->tv_usec < 0) {					      \
+      --(result)->tv_sec;						      \
+      (result)->tv_usec += 1000000;					      \
+    }									      \
+  } while (0)
+
+#define BUFSIZE         1024
+#define MAX_ROUNDS      10000000
+
+#define MIN(a,b)        ((a) < (b) ? (a) : (b))
+#define MAX(a,b)        ((a) > (b) ? (a) : (b))
+
+static struct timeval tvs[MAX_ROUNDS], tst[MAX_ROUNDS];
+
+/*
+ * error - wrapper for perror
+ */
+static void error(char *msg) {
+  perror(msg);
+  exit(1);
+}
+
+static int sockfd; /* socket */
+static struct sockaddr_in clientaddr; /* client addr */
+static socklen_t clientlen; /* byte size of client's address */
+static int delay = 0;
+static size_t rounds, packets = 0;
+
+static void *receiver_func(void *unused)
+{
+  char buf[BUFSIZE]; /* message buf */
+
+  for(int i = 0; i < rounds; i++) {
+    /*
+     * recvfrom: receive a UDP datagram from a client
+     */
+      int n = recvfrom(sockfd, buf, BUFSIZE, 0, NULL, NULL);
+      if (n < 0)
+          error("ERROR in recvfrom");
+
+      /* printf("server received %d bytes\n", n); */
+      assert(n == BUFSIZE);
+
+      /* uint64_t *cnt = (uint64_t *)buf; */
+      struct timeval *tstamp = (struct timeval *)&buf[8];
+      gettimeofday(&tst[i], NULL);
+      timersub(&tst[i], tstamp, &tvs[i]);
+      packets++;
+      /* if(*cnt != i) { */
+      /*     printf("Packets reordered? %d != %" PRIu64 "\n", i, *cnt); */
+      /*     exit(1); */
+      /* } */
+  }
+
+  return NULL;
+}
+
+int main(int argc, char **argv) {
+  int portno; /* port to listen on */
+  int optval; /* flag value for setsockopt */
+  char buf[BUFSIZE]; /* message buf */
+
+  /* 
+   * check command line arguments 
+   */
+  if (argc < 6) {
+    fprintf(stderr, "usage: %s <port> <server IP> <delay us> <rounds> <start_val>\n", argv[0]);
+    exit(1);
+  }
+  portno = atoi(argv[1]);
+  delay = atoi(argv[3]);
+  rounds = atoi(argv[4]);
+  assert(rounds < MAX_ROUNDS);
+  size_t start = atoi(argv[5]);
+
+  /* 
+   * socket: create the parent socket 
+   */
+  sockfd = socket(AF_INET, SOCK_DGRAM, 0);
+  if (sockfd < 0) 
+    error("ERROR opening socket");
+
+  /* setsockopt: Handy debugging trick that lets 
+   * us rerun the server immediately after we kill it; 
+   * otherwise we have to wait about 20 secs. 
+   * Eliminates "ERROR on binding: Address already in use" error. 
+   */
+  optval = 1;
+  setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR,
+             (const void *)&optval , sizeof(int));
+
+  clientlen = sizeof(clientaddr);
+
+  bzero((char *) &clientaddr, sizeof(clientaddr));
+  clientaddr.sin_family = AF_INET;
+  clientaddr.sin_addr.s_addr = inet_addr(argv[2]);
+  if(clientaddr.sin_addr.s_addr == INADDR_NONE) {
+      printf("Error on inet_addr()\n");
+      exit(1);
+  }
+  clientaddr.sin_port = htons((unsigned short)portno);
+
+  pthread_t sender;
+  int ret = pthread_create(&sender, NULL, receiver_func, NULL);
+  assert(ret == 0);
+
+  uint64_t *cnt = (uint64_t *)buf;
+  struct timeval *tstamp = (struct timeval *)&buf[8];
+
+  memset(tstamp, 0, sizeof(struct timeval));
+
+  for(*cnt = 0; *cnt < rounds; (*cnt)++) {
+      struct timeval oldstamp, diff;
+
+      oldstamp = *tstamp;
+
+      do {
+          gettimeofday(tstamp, NULL);
+          timersub(tstamp, &oldstamp, &diff);
+          /* printf("now = %lu, oldstamp = %lu, diff = %lu, delay = %d\n", */
+          /*        tstamp->tv_sec * 1000000 + tstamp->tv_usec, */
+          /*        oldstamp.tv_sec * 1000000 + oldstamp.tv_usec, */
+          /*        diff.tv_sec * 1000000 + diff.tv_usec, delay); */
+      } while((uint64_t)(diff.tv_sec * 1000000 + diff.tv_usec) < (uint64_t)delay);
+
+      int n = sendto(sockfd, buf, BUFSIZE, 0,
+                     (struct sockaddr *) &clientaddr, clientlen);
+      if (n < 0)
+          error("ERROR in sendto");
+  }
+
+  ret = pthread_cancel(sender);
+  assert(ret == 0);
+
+  unsigned long sum = 0, min = 99999, max = 0;
+
+  for(int i = 0; i < packets; i++) {
+      unsigned long r = tvs[i].tv_sec * 1000000 + tvs[i].tv_usec;
+      unsigned long t = tst[i].tv_sec * 1000000 + tst[i].tv_usec;
+      if(t != 0) {
+          printf("%zd %lu %lu %lu us\n", i + start, t - r, t, r);
+          sum += r;
+          min = MIN(min, r);
+          max = MAX(max, r);
+      }
+  }
+
+  printf("average %lu us, min %lu us, max %lu us\n",
+         sum / (packets - 1), min, max);
+
+  return 0;
+}
diff --git a/usr/drivers/e1000/Hakefile b/usr/drivers/e1000/Hakefile
index e5b50ec..e3ce426 100644
--- a/usr/drivers/e1000/Hakefile
+++ b/usr/drivers/e1000/Hakefile
@@ -18,5 +18,12 @@
                       mackerelDevices = [ "e1000" ],
                       addLibraries = libDeps [ "pci", "netQmng", "trace", "octopus" ],
                       architectures = [ "x86_64", "x86_32" ]
+                    },
+  build library { target = "e1000n",
+                      cFiles = [ "e1000n.c", "e1000n_hwinit.c", "e1000n_helpers.c" ],
+                      mackerelDevices = [ "e1000" ],
+                      addLibraries = libDeps [ "pci", "trace", "octopus" ],
+                      architectures = [ "x86_64" ],
+                      addCFlags = [ "-DLIBRARY" ]
                     }
 ]
diff --git a/usr/drivers/e1000/e1000n.c b/usr/drivers/e1000/e1000n.c
index 0668364..79a29a5 100644
--- a/usr/drivers/e1000/e1000n.c
+++ b/usr/drivers/e1000/e1000n.c
@@ -45,6 +45,9 @@
 #include <net_queue_manager/net_queue_manager.h>
 #include <if/net_queue_manager_defs.h>
 #include <trace/trace.h>
+#ifdef LIBRARY
+#       include <netif/e1000.h>
+#endif
 
 #include "e1000n.h"
 
@@ -223,6 +226,18 @@ static uint64_t find_tx_free_slot_count_fn(void)
     return free_slots;
 }
 
+#ifdef LIBRARY
+bool e1000n_queue_empty(void)
+{
+    uint16_t tail, head;
+
+    tail = e1000_tdt_val_rdf(&(e1000), 0);
+    head = e1000_tdh_val_rdf(&(e1000), 0);
+
+    return (head == tail);
+}
+#endif
+
 /*****************************************************************
  * Transmit logic
  *
@@ -342,7 +357,7 @@ static errval_t transmit_pbuf_list_fn(struct driver_buffer *buffers,
             return r;
         }
         E1000_DEBUG("transmit_pbuf done for pbuf 0x%p, index %i\n",
-            opaque, i);
+            buffers[i].opaque, i);
     } // end for: for each pbuf
 #if TRACE_ONLY_SUB_NNET
     trace_event(TRACE_SUBSYS_NNET,  TRACE_EVENT_NNET_TXDRVADD,
@@ -353,7 +368,6 @@ static errval_t transmit_pbuf_list_fn(struct driver_buffer *buffers,
 } // end function: transmit_pbuf_list_fn
 
 
-
 static bool handle_next_received_packet(void)
 {
     volatile union rx_desc *rxd;
@@ -486,11 +500,31 @@ static uint64_t handle_multiple_packets(uint64_t upper_limit)
  *
  * This function should never exit.
  ****************************************************************/
+#ifndef LIBRARY
 static void polling_loop(void)
+#else
+extern struct waitset *lwip_waitset;
+
+void arranet_polling_loop(void)
+{
+    errval_t err = event_dispatch_non_block(barrelfish_interrupt_waitset); // nonblocking
+    if (err != LIB_ERR_NO_EVENT && err_is_fail(err)) {
+        E1000_DEBUG("Error in event_dispatch_non_block, returned %d\n",
+                    (unsigned int)err);
+    }
+    // Give it a manual poll if there were no interrupts
+    if(err_no(err) == LIB_ERR_NO_EVENT) {
+        while(handle_free_TX_slot_fn());
+        handle_multiple_packets(1);
+    }
+}
+
+void e1000n_polling_loop(struct waitset *ws)
+#endif
 {
     uint64_t poll_count = 0;
     uint64_t ts;
-//    uint8_t jobless_iterations = 0;
+    uint8_t jobless_iterations = 0;
     errval_t err;
     bool no_work = true;
 
@@ -499,10 +533,14 @@ static void polling_loop(void)
         ++poll_count;
 
         ts = rdtsc();
+#ifndef LIBRARY
         do_pending_work_for_all();
+#endif
         netbench_record_event_simple(bm, RE_PENDING_WORK, ts);
 
+#ifndef LIBRARY
         struct waitset *ws = get_default_waitset();
+#endif
 
         if (use_interrupt) {
             err = event_dispatch_debug(ws); // blocking // doesn't work correctly
@@ -516,9 +554,11 @@ static void polling_loop(void)
                         (unsigned int)err);
             break;
         } else {
-            no_work = false;
+            no_work = true;
         }
 
+        while(handle_free_TX_slot_fn());
+
 #if TRACE_ETHERSRV_MODE
         trace_event(TRACE_SUBSYS_NNET, TRACE_EVENT_NNET_DRV_POLL, poll_count);
 #endif // TRACE_ETHERSRV_MODE
@@ -536,16 +576,20 @@ static void polling_loop(void)
         }
 */
 
- /*       if (no_work) {
+        if (no_work) {
             ++jobless_iterations;
             if (jobless_iterations == 10) {
-                if (use_interrupt) {
-                    E1000_DEBUG("no work available, yielding thread\n");
-                    thread_yield();
-                }
+#ifndef LIBRARY
+                /* if (use_interrupt) { */
+                /*     E1000_DEBUG("no work available, yielding thread\n"); */
+                /*     thread_yield(); */
+                /* } */
+#else
+                /* E1000_DEBUG("no work available, returning\n"); */
+                return;
+#endif
             }
         }
-*/
     } // end while
 }
 
@@ -611,7 +655,6 @@ static void setup_internal_memory(void)
 }
 
 
-
 static errval_t rx_register_buffer_fn(uint64_t paddr, void *vaddr, void *opaque)
 {
     return add_desc(paddr, opaque);
@@ -640,8 +683,7 @@ static void e1000_init_fn(struct device_mem *bar_info, int nr_allocated_bars)
 
     setup_internal_memory();
 
-
-
+#ifndef LIBRARY
     ethersrv_init(global_service_name, assumed_queue_id, get_mac_address_fn,
 		  NULL,
                   transmit_pbuf_list_fn,
@@ -650,7 +692,17 @@ static void e1000_init_fn(struct device_mem *bar_info, int nr_allocated_bars)
                   receive_buffer_size,
                   rx_register_buffer_fn,
                   rx_find_free_slot_count_fn);
-
+#else
+    ethernetif_backend_init(global_service_name, assumed_queue_id, get_mac_address_fn,
+		  NULL,
+                  transmit_pbuf_list_fn,
+                  find_tx_free_slot_count_fn,
+                  handle_free_TX_slot_fn,
+                  receive_buffer_size,
+                  rx_register_buffer_fn,
+                  rx_find_free_slot_count_fn);
+    
+#endif
 
 #if TRACE_ETHERSRV_MODE
     set_cond_termination(trace_conditional_termination);
@@ -686,8 +738,12 @@ static void e1000_interrupt_handler_fn(void *arg)
         return;
     }
 
+#ifndef LIBRARY
     E1000_DEBUG("e1000 interrupt came in\n");
     handle_multiple_packets(MAX_ALLOWED_PKT_PER_ITERATION);
+#else
+    handle_multiple_packets(1);
+#endif
 }
 
 
@@ -823,7 +879,11 @@ static void check_possible_e1000_card(octopus_mode_t mode, char *record, void *s
  *
  *
  ****************************************************************/
+#ifndef LIBRARY
 int main(int argc, char **argv)
+#else
+int e1000n_driver_init(int argc, char **argv)
+#endif
 {
     char *service_name = 0;
     errval_t err;
@@ -832,7 +892,7 @@ int main(int argc, char **argv)
     E1000_DEBUG("e1000 standalone driver started.\n");
 
     E1000_DEBUG("argc = %d\n", argc);
-    for (int i = 0; i < argc; i++) {
+    for (int i = 1; i < argc; i++) {
         E1000_DEBUG("arg %d = %s\n", i, argv[i]);
         if (strncmp(argv[i], "affinitymin=", strlen("affinitymin=")) == 0) {
             minbase = atol(argv[i] + strlen("affinitymin="));
@@ -982,11 +1042,13 @@ int main(int argc, char **argv)
 
     e1000_print_link_status(&e1000_device);
 
+#ifndef LIBRARY
     E1000_DEBUG("#### starting polling.\n");
     // FIXME: hack to force the driver in polling mode, as interrupts are
     // not reliably working
     use_interrupt = false;
     polling_loop();
+#endif
 
     return 1;
 }
diff --git a/usr/drivers/e1000/e1000n_debug.c b/usr/drivers/e1000/e1000n_debug.c
deleted file mode 100644
index 468948a..0000000
--- a/usr/drivers/e1000/e1000n_debug.c
+++ /dev/null
@@ -1,121 +0,0 @@
-/**
- * \file
- * \brief Intel e1000 driver: Debug functionality
- *
- * This file is a driver for the PCI Express e1000 card
- */
-
-/*
- * Copyright (c) 2007, 2008, 2009, ETH Zurich.
- * All rights reserved.
- *
- * This file is distributed under the terms in the attached LICENSE file.
- * If you do not find this file, copies can be found by writing to:
- * ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich. Attn: Systems Group.
- */
-
-#include <stdio.h>
-#include "e1000n.h"
-#include <net_queue_manager/net_queue_manager.h>
-extern e1000_t d;
-
-/*
- * Handy-dandy shorthand for printing registers: make sure you have a
- * suitable buffer declared.
- */
-#define PR_REG(t) e1000_##t##_pr(pb, PRTBUF_SZ, &d); printf("%s\n",pb)
-#define PR_REGZ(t) e1000_##t##_pri(pb, PRTBUF_SZ, &d, 0); printf("%s\n",pb)
-#define PRTBUF_SZ 4000
-
-
-void print_statistics(void)
-{
-    char pb[PRTBUF_SZ];
-
-    PR_REG(status);
-
-    // Transmit registers
-    PR_REGZ(tdbal);
-    PR_REGZ(tdbah);
-    PR_REGZ(tdlen);
-    PR_REG(tctl);
-    PR_REGZ(txdctl);
-    PR_REGZ(tdh);
-    PR_REGZ(tdt);
-
-    // Receive registers
-    PR_REGZ(rdbal);
-    PR_REGZ(rdbah);
-    PR_REGZ(rdh);
-    PR_REGZ(rdt);
-
-    // Statistics registers
-    PR_REG(crcerrs);
-    PR_REG(algnerrc);
-    PR_REG(symerrs);
-    PR_REG(rxerrc);
-    PR_REG(mpc);
-    PR_REG(scc);
-    PR_REG(ecol);
-    PR_REG(mcc);
-    PR_REG(latecol);
-    PR_REG(colc);
-    PR_REG(dc);
-    PR_REG(tncrs);
-    PR_REG(sec);
-    PR_REG(cexterr);
-    PR_REG(rlec);
-    PR_REG(xonrxc);
-    PR_REG(xontxc);
-    PR_REG(xoffrxc);
-    PR_REG(xofftxc);
-    PR_REG(fcurc);
-    PR_REG(prc64);
-    PR_REG(prc127);
-    PR_REG(prc255);
-    PR_REG(prc511);
-    PR_REG(prc1023);
-    PR_REG(prc1522);
-    PR_REG(gprc);
-    PR_REG(bprc);
-    PR_REG(mcprc);
-    PR_REG(gptc);
-    PR_REG(gorcl);
-    PR_REG(gorch);
-    PR_REG(gotcl);
-    PR_REG(gotch);
-    PR_REG(rnbc);
-    PR_REG(ruc);
-    PR_REG(rfc);
-    PR_REG(roc);
-    PR_REG(rjc);
-    PR_REG(mprc);
-    PR_REG(mpdc);
-    PR_REG(mptc);
-    PR_REG(torl);
-    PR_REG(torh);
-    PR_REG(totl);
-    PR_REG(toth);
-    PR_REG(tpr);
-    PR_REG(tpt);
-    PR_REG(ptc64);
-    PR_REG(ptc127);
-    PR_REG(ptc255);
-    PR_REG(ptc511);
-    PR_REG(ptc1023);
-    PR_REG(ptc1522);
-    PR_REG(mcptc);
-    PR_REG(bptc);
-    PR_REG(tsctc);
-    PR_REG(tsctfc);
-    PR_REG(iac);
-    PR_REG(icrxptc);
-    PR_REG(icrxatc);
-    PR_REG(ictxptc);
-    PR_REG(ictxatc);
-    PR_REG(ictxqec);
-    PR_REG(ictxdltc);
-    PR_REG(icrxdmtc);
-    PR_REG(icrxoc);
-}
-
diff --git a/usr/drivers/e10k/Hakefile b/usr/drivers/e10k/Hakefile
index f07be94..b1f8884 100644
--- a/usr/drivers/e10k/Hakefile
+++ b/usr/drivers/e10k/Hakefile
@@ -1,5 +1,5 @@
 --------------------------------------------------------------------------
--- Copyright (c) 2007-2011, ETH Zurich.
+-- Copyright (c) 2007-2011, 2013, ETH Zurich.
 -- All rights reserved.
 --
 -- This file is distributed under the terms in the attached LICENSE file.
@@ -23,17 +23,57 @@
                                  "e10k_qdriver.c", "helper.c"],
                       flounderBindings = [ "net_queue_manager",
                                            "net_soft_filters",
-                                           "e10k" ],
+                                           "e10k", "e10k_vf" ],
+                      flounderDefs = [ "e10k_vf" ],
                       mackerelDevices = [ "e10k", "e10k_q" ],
                       addLibraries = libDeps [ "netQmng", "pci", "contmng",
                                                "net_device_manager", "bench",
                                                "trace", "skb" ]
                     },
+  
+  build library { target = "e10k",
+                      cFiles = [ "e10k_cdriver.c", "e10k_phy.c", "sleep.c",
+                                 "e10k_qdriver.c", "helper.c"],
+                      mackerelDevices = [ "e10k", "e10k_q" ],
+                      flounderBindings = [ "e10k", "e10k_vf" ],
+                      flounderDefs = [ "e10k_vf" ],
+                      addLibraries = libDeps [ "pci", "bench", "trace", "skb" ],
+                      addCFlags = [ "-DLIBRARY", "-DVTON_DCBOFF" ]
+                    },
+
+  build library { target = "e10k_vf",
+                      cFiles = [ "e10k_vf.c", "e10k_phy.c", "sleep.c",
+                                 "e10k_qdriver.c", "helper.c"],
+                      mackerelDevices = [ "e10k", "e10k_q", "e10k_vf" ],
+                      flounderBindings = [ "e10k_vf" ],
+                      flounderExtraBindings = [ ("e10k_vf", ["rpcclient"]) ],
+                      flounderDefs = [ "e10k_vf" ],
+                      flounderExtraDefs = [ ("e10k_vf",["rpcclient"]) ],
+                      addLibraries = libDeps [ "pci", "bench", "trace", "skb" ],
+                      addCFlags = [ "-DLIBRARY", "-DVF", "-DVTON_DCBOFF" ]
+                    },
+
+  build application { target = "e10k_vf",
+                      cFiles = [ "e10k_vf.c", "e10k_phy.c", "sleep.c",
+                                 "e10k_qdriver.c", "helper.c"],
+                      flounderBindings = [ "net_queue_manager",
+                                           "net_soft_filters",
+                                           "e10k", "e10k_vf" ],
+                      flounderExtraBindings = [ ("e10k_vf", ["rpcclient"]) ],
+                      flounderDefs = [ "e10k_vf" ],
+                      flounderExtraDefs = [ ("e10k_vf",["rpcclient"]) ],
+                      mackerelDevices = [ "e10k", "e10k_q", "e10k_vf" ],
+                      addLibraries = libDeps [ "netQmng", "pci", "contmng",
+                                               "net_device_manager", "bench",
+                                               "trace", "skb" ],
+                      addCFlags = [ "-DVF" ]
+                    },
 
   build application { target = "e10k",
                       cFiles = [ "e10k_cdriver.c", "e10k_phy.c", "sleep.c",
                                  "helper.c"],
-                      flounderBindings = [ "net_queue_manager", "net_soft_filters", "e10k" ],
+                      flounderBindings = [ "net_queue_manager", "net_soft_filters", "e10k", "e10k_vf" ],
+                      flounderDefs = [ "e10k_vf" ],
                       --flounderBindings = [ "e10k"],
                       mackerelDevices = [ "e10k" ],
                       addLibraries = [ "pci", "contmng", "net_device_manager",
diff --git a/usr/drivers/e10k/e10k.h b/usr/drivers/e10k/e10k.h
index f1a5bb0..96b66c1 100644
--- a/usr/drivers/e10k/e10k.h
+++ b/usr/drivers/e10k/e10k.h
@@ -13,7 +13,10 @@
 #include "e10k_dev.h"
 
 #define E10K_PCI_DEVID 0x10FB
+//#define E10K_PCI_DEVID 0x154d
 
 void e10k_phy_init(e10k_t* d);
 
+extern int qi;
+
 #endif // ndef E10K_H_
diff --git a/usr/drivers/e10k/e10k_cdriver.c b/usr/drivers/e10k/e10k_cdriver.c
index 95b0e77..2c3a2ac 100644
--- a/usr/drivers/e10k/e10k_cdriver.c
+++ b/usr/drivers/e10k/e10k_cdriver.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2007-2011, ETH Zurich.
+ * Copyright (c) 2007-2011, 2013, 2014, ETH Zurich.
  * All rights reserved.
  *
  * This file is distributed under the terms in the attached LICENSE file.
@@ -17,14 +17,21 @@
 #include <barrelfish/nameservice_client.h>
 #include <barrelfish/debug.h>
 #include <ipv4/lwip/inet.h>
+#ifdef LIBRARY
+#       include <netif/e1000.h>
+#endif
 
 #include <if/e10k_defs.h>
+#include <if/e10k_vf_defs.h>
 #include <dev/e10k_dev.h>
 
 #include "e10k.h"
 #include "sleep.h"
 #include "helper.h"
 
+//#define VTON_DCBOFF
+//#define DCA_ENABLED
+
 //#define DEBUG(x...) printf("e10k: " x)
 #define DEBUG(x...) do {} while (0)
 
@@ -79,6 +86,27 @@ struct e10k_filter {
     uint16_t l4_type;
 };
 
+union macentry {
+    uint8_t as8[6];
+    uint64_t as64;
+};
+
+static union macentry mactable[128] = {
+    { .as8 = "\x0\x0\x0\x0\x0\x0" },      // First MAC is never set (loaded from card EEPROM)
+
+    { .as8 = "\x22\xc9\xfc\x96\x83\xfc" },
+    { .as8 = "\xce\x43\x5b\xf7\x3e\x60" },
+    { .as8 = "\x6a\xb0\x62\xf6\xa7\x21" },
+    { .as8 = "\xb2\xdf\xf9\x39\xc6\x10" },
+    { .as8 = "\x92\x77\xe7\x3f\x80\x30" },
+    { .as8 = "\xd6\x88\xd6\x86\x4a\x22" },
+    { .as8 = "\x7e\x64\xe9\x2e\xbe\x4b" },
+    { .as8 = "\xba\xac\x49\xd6\x3c\x77" },
+
+    // We set the rest to all zeroes
+
+    // Last MAC (127) never set (loaded from card EEPROM ... at least, it's already there)
+};
 
 // Hack for monolithic driver
 void qd_main(void) __attribute__((weak));
@@ -111,7 +139,7 @@ static void stop_device(void);
 
 static void device_init(void);
 static void queue_hw_init(uint8_t n);
-static void queue_hw_stop(uint8_t n);
+//static void queue_hw_stop(uint8_t n);
 static void interrupt_handler_msix(void* arg);
 //static void interrupt_handler_msix_b(void* arg);
 
@@ -121,7 +149,6 @@ static void e10k_flt_ftqf_setup(int index, struct e10k_filter *filter);
 
 
 static const char *service_name = "e10k";
-uint64_t d_mac;
 static int initialized = 0;
 static e10k_t *d = NULL;
 static struct capref *regframe;
@@ -147,8 +174,7 @@ static char buf[4096];
 static uint32_t pci_bus = PCI_DONT_CARE;
 static uint32_t pci_device = PCI_DONT_CARE;
 static uint32_t pci_function = 0;
-
-
+static uint32_t pci_deviceid = E10K_PCI_DEVID;
 
 
 static void e10k_flt_ftqf_setup(int idx, struct e10k_filter* filter)
@@ -201,6 +227,7 @@ static void e10k_flt_ftqf_setup(int idx, struct e10k_filter* filter)
     e10k_ftqf_wr(d, idx, ftqf);
 }
 
+#ifndef LIBRARY
 static int ftqf_index = 0;
 static int ftqf_alloc(void)
 {
@@ -228,7 +255,7 @@ static errval_t reg_ftfq_filter(struct e10k_filter* f, uint64_t* fid)
 
     return SYS_ERR_OK;
 }
-
+#endif
 
 
 #if 0
@@ -461,13 +488,9 @@ static void device_init(void)
     while (e10k_eec_auto_rd_rdf(d) == 0); // TODO: Timeout
     DEBUG("EEPROM auto read done\n");
 
-
     // Wait for DMA initialization
     while (e10k_rdrxctl_dma_initok_rdf(d) == 0); // TODO: Timeout
 
-    d_mac = e10k_ral_ral_rdf(d, 0) | ((uint64_t) e10k_rah_rah_rdf(d, 0) << 32);
-    DEBUG("mac valid = %x\n", e10k_rah_av_rdf(d, 0));
-
     // Wait for link to come up
     while (e10k_links_lnk_up_rdf(d) == 0); // TODO: Timeout
     DEBUG("Link Up\n");
@@ -518,24 +541,62 @@ static void device_init(void)
     // Just a guess for RSC delay
     e10k_gpie_rsc_delay_wrf(d, 2);
 
-
-    // Initialize multiple register tables
-    for (i = 1; i < 128; i++) {
-        e10k_ral_wr(d, i, 0);
-        e10k_rah_wr(d, i, 0);
+    // Initialize multiple register tables (MAC 0 and 127 are not set)
+    for (i = 0; i < 128; i++) {
+        /* uint64_t mac = e10k_ral_ral_rdf(d, i) | ((uint64_t) e10k_rah_rah_rdf(d, i) << 32); */
+        /* uint8_t *m = (uint8_t *)&mac; */
+        /* DEBUG("Old MAC %d: %02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx ... mac valid = %x\n", */
+        /*       i, m[0], m[1], m[2], m[3], m[4], m[5], e10k_rah_av_rdf(d, 0)); */
+
+        if(i > 0 && i < 127) {
+            e10k_ral_wr(d, i, mactable[i].as64 & 0xffffffff);
+            e10k_rah_wr(d, i, mactable[i].as64 >> 32);
+            e10k_rah_av_wrf(d, i, 1);
+
+            /* mac = e10k_ral_ral_rdf(d, i) | ((uint64_t) e10k_rah_rah_rdf(d, i) << 32); */
+            /* m = (uint8_t *)&mac; */
+            /* DEBUG("New MAC %d: %02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx ... mac valid = %x\n", */
+            /*       i, m[0], m[1], m[2], m[3], m[4], m[5], e10k_rah_av_rdf(d, 0)); */
+        }
     }
     for (i = 0; i < 128; i++)
         e10k_mta_bit_vec_wrf(d, i, 0);
     for (i = 0; i < 128; i++)
         e10k_vfta_vlan_flt_wrf(d, i, 0);
+    for (i = 0; i < 128; i++)
+        e10k_pfvlvfb_wr(d, i, 0);
     for (i = 0; i < 64; i++) {
+#ifdef VTON_DCBOFF
+        e10k_pfvlvf_vi_en_wrf(d, i, 1);
+#else
         e10k_pfvlvf_vi_en_wrf(d, i, 0);
+#endif
         e10k_psrtype_wr(d, i, 0);
     }
     for (i = 0; i < 128; i++)
         e10k_pfuta_wr(d, i, 0);
     for (i = 0; i < 256; i++)
         e10k_mpsar_pool_ena_wrf(d, i, 0);
+
+    // Program direct match MAC forwarding rules
+    // This setup will assign the first 64 MAC addresses each to a different
+    // RX pool. This assumes we have 64 VFs. The rest is set to filtered.
+    for(i = 0; i < 128; i++) {
+        if(i < 32) {
+            // Pools < 32 (low bits)
+            e10k_mpsar_pool_ena_wrf(d, 2 * i, 1 << i);
+            e10k_mpsar_pool_ena_wrf(d, 2 * i + 1, 0);
+        } else if(i < 64) {
+            // Pools >= 32 and < 64 (high bits)
+            e10k_mpsar_pool_ena_wrf(d, 2 * i, 0);
+            e10k_mpsar_pool_ena_wrf(d, 2 * i + 1, 1 << (i - 32));
+        } else {
+            // Pools >= 64 -> DROP
+            e10k_mpsar_pool_ena_wrf(d, 2 * i, 0);
+            e10k_mpsar_pool_ena_wrf(d, 2 * i + 1, 0);
+        }
+    }
+
     for (i = 0; i < 128; i++) {
         e10k_fhft_1_wr(d, i, 0);
         if (i < 64) {
@@ -543,8 +604,13 @@ static void device_init(void)
         }
     }
 
+#ifdef VTON_DCBOFF
+    // Disallow per-queue RSC (not supported in SR-IOV mode)
+    e10k_rfctl_rsc_dis_wrf(d, 1);
+#else
     // Allow for per-queue RSC
     e10k_rfctl_rsc_dis_wrf(d, 0);
+#endif
 
     // Initialize RX filters
     for (i = 0; i < 128; i++) {
@@ -569,10 +635,13 @@ static void device_init(void)
 
 
     // Configure buffers etc. according to specification
-    // Section 4.6.11.3.4 (No DCP, no virtualization, no RSS)
+    // Section 4.6.11.3.4 (DCB, virtualization, no RSS)
     // 1:1 from spec, though not sure if everything is necessary, but since
     // initialization is still buggy, I'd rather be conservative and set some
     // additional flags, even if they aren't strictly necessary.
+    e10k_rttdcs_arbdis_wrf(d, 1);
+
+#ifdef VTON_DCBOFF
     e10k_rxpbsize_size_wrf(d, 0, 0x200);
     e10k_txpbsize_size_wrf(d, 0, 0xA0);
     e10k_txpbthresh_thresh_wrf(d, 0, 0xA0);
@@ -582,49 +651,99 @@ static void device_init(void)
         e10k_txpbthresh_thresh_wrf(d, i, 0x0);
     }
 
-    e10k_mrqc_mrque_wrf(d, e10k_no_rss);
+    e10k_mrqc_mrque_wrf(d, e10k_vrt_only);
     e10k_mtqc_rt_en_wrf(d, 0);
-    e10k_mtqc_vt_en_wrf(d, 0);
-    e10k_mtqc_num_tc_wrf(d, 0);
-    e10k_pfvtctl_vt_en_wrf(d, 0);
+
+    e10k_mtqc_vt_en_wrf(d, 1);
+    e10k_mtqc_num_tc_wrf(d, 1);
+    e10k_pfvtctl_vt_en_wrf(d, 1);
+#else
+    for (i = 0; i < 8; i++) {
+        e10k_rxpbsize_size_wrf(d, i, 0x40);
+        e10k_txpbsize_size_wrf(d, i, 0x14);
+        e10k_txpbthresh_thresh_wrf(d, i, 0x14);
+    }
+
+    e10k_mrqc_mrque_wrf(d, e10k_vrt_only);
+    e10k_mtqc_rt_en_wrf(d, 1);
+    e10k_mtqc_vt_en_wrf(d, 1);
+    e10k_mtqc_num_tc_wrf(d, 2);
+    e10k_pfvtctl_vt_en_wrf(d, 1);
+#endif
     e10k_rtrup2tc_wr(d, 0);
     e10k_rttup2tc_wr(d, 0);
 
+#ifdef VTON_DCBOFF
     e10k_dtxmxszrq_max_bytes_wrf(d, 0xFFF);
+#else
+    e10k_dtxmxszrq_max_bytes_wrf(d, 0x010);
+#endif
+
+    e10k_rttdcs_arbdis_wrf(d, 0);
 
     for (i = 0; i < 128; i++) {
         pfqde = e10k_pfqde_queue_idx_insert(0x0, i);
         pfqde = e10k_pfqde_we_insert(pfqde, 1);
+        // XXX: Might want to set drop enable here
+        /* pfqde = e10k_pfqde_qde_insert(pfqde, 1); */
         e10k_pfqde_wr(d, pfqde);
     }
 
+#ifdef VTON_DCBOFF
     e10k_mflcn_rpfce_wrf(d, 0);
     e10k_mflcn_rfce_wrf(d, 0);
     e10k_fccfg_tfce_wrf(d, e10k_lfc_en);
+#else
+    e10k_mflcn_rpfce_wrf(d, 1);
+    e10k_mflcn_rfce_wrf(d, 0);
+    e10k_fccfg_tfce_wrf(d, e10k_pfc_en);
+#endif
 
-    /* Causes ECC error (could be same problem as with l34timir (see e10k.dev)
+    /* Causes ECC error (could be same problem as with l34timir (see e10k.dev) */
     for (i = 0; i < 128; i++) {
         e10k_rttdqsel_txdq_idx_wrf(d, i);
         e10k_rttdt1c_wr(d, 0);
-    }*/
+    }
+
+    e10k_rttdqsel_txdq_idx_wrf(d, 0);
+    e10k_rttbcnrc_wr(d, 0);
+
     for (i = 0; i < 8; i++) {
         e10k_rttdt2c_wr(d, i, 0);
         e10k_rttpt2c_wr(d, i, 0);
         e10k_rtrpt4c_wr(d, i, 0);
     }
 
+#ifdef VTON_DCBOFF
     e10k_rttdcs_tdpac_wrf(d, 0);
+
+    // XXX: Should be on, but transmit only works when it's off...
+    // Linux driver doesn't seem to set it either
+    /* e10k_rttdcs_vmpac_wrf(d, 1); */
     e10k_rttdcs_vmpac_wrf(d, 0);
+
     e10k_rttdcs_tdrm_wrf(d, 0);
     e10k_rttdcs_bdpm_wrf(d, 1);
-    e10k_rttdcs_bpbfsm_wrf(d, 1);
+    e10k_rttdcs_bpbfsm_wrf(d, 0);
     e10k_rttpcs_tppac_wrf(d, 0);
     e10k_rttpcs_tprm_wrf(d, 0);
     e10k_rttpcs_arbd_wrf(d, 0x224);
     e10k_rtrpcs_rac_wrf(d, 0);
     e10k_rtrpcs_rrm_wrf(d, 0);
-
-
+#else
+    e10k_rttdcs_tdpac_wrf(d, 1);
+    e10k_rttdcs_vmpac_wrf(d, 1);
+    e10k_rttdcs_tdrm_wrf(d, 1);
+    e10k_rttdcs_bdpm_wrf(d, 1);
+    e10k_rttdcs_bpbfsm_wrf(d, 0);
+    e10k_rttpcs_tppac_wrf(d, 1);
+    e10k_rttpcs_tprm_wrf(d, 1);
+    e10k_rttpcs_arbd_wrf(d, 0x004);
+    e10k_rtrpcs_rac_wrf(d, 1);
+    e10k_rtrpcs_rrm_wrf(d, 1);
+
+    e10k_sectxminifg_sectxdcb_wrf(d, 0x1f);
+#endif
 
     // disable relaxed ordering
     for (i = 0; i < 128; i++) {
@@ -648,6 +767,23 @@ static void device_init(void)
         }
     }
 
+    for(i = 0; i < 64; i++) {
+        e10k_pfvml2flt_mpe_wrf(d, i, 1);
+        e10k_pfvml2flt_bam_wrf(d, i, 1);
+        e10k_pfvml2flt_aupe_wrf(d, i, 1);
+    }
+
+#ifdef DCA_ENABLED
+    // Enable DCA (Direct Cache Access)
+    {
+        e10k_dca_ctrl_t dca_ctrl = 0;
+        dca_ctrl = e10k_dca_ctrl_dca_mode_insert(dca_ctrl, e10k_dca10);
+        e10k_dca_ctrl_wr(d, dca_ctrl);
+    }
+
+    printf("DCA globally enabled\n");
+#endif
+
     DEBUG("Card initialized (%d)\n", initialized_before);
 
 
@@ -711,6 +847,7 @@ static void queue_hw_init(uint8_t n)
 
     // Set RSC status
     if (queues[n].use_rsc) {
+        USER_PANIC("RSC not supported in SR-IOV mode!\n");
         e10k_rscctl_1_maxdesc_wrf(d, n, 3);
         e10k_rscctl_1_rsc_en_wrf(d, n, 1);
         // TODO: (how) does this work for queues >=64?
@@ -724,6 +861,11 @@ static void queue_hw_init(uint8_t n)
     e10k_rdt_1_wr(d, n, queues[n].rx_head);
     e10k_rdh_1_wr(d, n, queues[n].rx_head);
 
+#ifdef VTON_DCBOFF
+    // Open virtualization pool gate (assumes 64 VF mapping)
+    e10k_pfvfre_wr(d, n / 64, e10k_pfvfre_rd(d, n / 64) | (1 << ((n / 2) % 32)));
+#endif
+
     e10k_rxdctl_1_enable_wrf(d, n, 1);
     while (e10k_rxdctl_1_enable_rdf(d, n) == 0); // TODO: Timeout
     DEBUG("[%x] RX queue enabled\n", n);
@@ -774,7 +916,6 @@ static void queue_hw_init(uint8_t n)
         }
     }
 
-
     // Enable RX
     if (enable_global) {
         DEBUG("[%x] Enabling RX globally...\n", n);
@@ -782,6 +923,30 @@ static void queue_hw_init(uint8_t n)
         DEBUG("[%x] RX globally enabled\n", n);
     }
 
+#ifdef DCA_ENABLED
+    {
+        // Enable DCA for this queue
+        e10k_dca_rxctrl_t dca_rxctrl = 0;
+
+        dca_rxctrl = e10k_dca_rxctrl_rxdca_desc_insert(dca_rxctrl, 1);
+        dca_rxctrl = e10k_dca_rxctrl_rxdca_hdr_insert(dca_rxctrl, 1);
+        dca_rxctrl = e10k_dca_rxctrl_rxdca_payl_insert(dca_rxctrl, 1);
+
+        uint8_t my_apic_id;
+        errval_t err = sys_debug_get_apic_id(&my_apic_id);
+        assert(err_is_ok(err));
+
+        dca_rxctrl = e10k_dca_rxctrl_cpuid_insert(dca_rxctrl, my_apic_id);
+
+        if(n < 64) {
+            e10k_dca_rxctrl_1_wr(d, n, dca_rxctrl);
+        } else {
+            e10k_dca_rxctrl_2_wr(d, n - 64, dca_rxctrl);
+        }
+
+        printf("DCA enabled on queue %d with APIC ID %d\n", n, my_apic_id);
+    }
+#endif
 
     // Initialize TX queue in HW
     e10k_tdbal_wr(d, n, tx_phys);
@@ -817,11 +982,15 @@ static void queue_hw_init(uint8_t n)
         DEBUG("[%x] TX globally enabled\n", n);
     }
 
+#ifdef VTON_DCBOFF
+    // Open virtualization pool gate (assumes 64 VF mapping)
+    e10k_pfvfte_wr(d, n / 64, e10k_pfvfte_rd(d, n / 64) | (1 << ((n / 2) % 32)));
+#endif
+
     e10k_txdctl_enable_wrf(d, n, 1);
     while (e10k_txdctl_enable_rdf(d, n) == 0); // TODO: Timeout
     DEBUG("[%x] TX queue enabled\n", n);
 
-
     // Some initialization stuff from BSD driver
     e10k_dca_txctrl_txdesc_wbro_wrf(d, n, 0);
 
@@ -829,6 +998,7 @@ static void queue_hw_init(uint8_t n)
 
 }
 
+#ifndef LIBRARY
 /** Stop queue. */
 static void queue_hw_stop(uint8_t n)
 {
@@ -848,6 +1018,7 @@ static void queue_hw_stop(uint8_t n)
     // A bit too much, but make sure memory is not used anymore
     milli_sleep(1);
 }
+#endif
 
 
 /** Stop whole device. */
@@ -974,6 +1145,7 @@ static void idc_write_queue_tails(struct e10k_binding *b)
     assert(err_is_ok(r));
 }
 
+#ifndef LIBRARY
 /** Signal queue driver that the queue is stopped. */
 static void idc_queue_terminated(struct e10k_binding *b)
 {
@@ -1007,10 +1179,20 @@ static void idc_filter_unregistered(struct e10k_binding *b,
     // TODO: handle busy
     assert(err_is_ok(r));
 }
+#endif
 
 /** Request from queue driver for register memory cap */
 void cd_request_device_info(struct e10k_binding *b)
 {
+    assert(initialized);
+#ifdef LIBRARY
+    uint64_t d_mac = e10k_ral_ral_rdf(d, qi) | ((uint64_t) e10k_rah_rah_rdf(d, qi) << 32);
+    DEBUG("mac valid = %x\n", e10k_rah_av_rdf(d, qi));
+#else
+    uint64_t d_mac = e10k_ral_ral_rdf(d, 0) | ((uint64_t) e10k_rah_rah_rdf(d, 0) << 32);
+    DEBUG("mac valid = %x\n", e10k_rah_av_rdf(d, 0));
+#endif
+
     if (b == NULL) {
         struct capref cr;
         errval_t err = slot_alloc(&cr);
@@ -1087,6 +1269,7 @@ void cd_set_interrupt_rate(struct e10k_binding *b,
     }
 }
 
+#ifndef LIBRARY
 /**
  * Request from queue driver to stop hardware queue and free everything
  * associated with that queue.
@@ -1182,9 +1365,77 @@ static void initialize_mngif(void)
                     IDC_BIND_FLAGS_DEFAULT);
     assert(err_is_ok(r));
 }
+#endif
+
+/****** VF/PF server interface *******/
+
+static void init_done_vf(struct e10k_vf_binding *b, uint8_t vfn)
+{
+    assert(vfn < 64);
+
+    DEBUG("VF %d init done\n", vfn);
+
+    // Enable correct pool for VF
+    e10k_pfvfre_wr(d, vfn / 32, e10k_pfvfre_rd(d, vfn / 32) | (1 << (vfn % 32)));
+    e10k_pfvfte_wr(d, vfn / 32, e10k_pfvfte_rd(d, vfn / 32) | (1 << (vfn % 32)));
+
+    if(vfn < 32) {
+        e10k_pfvflrec_wr(d, 0, 1 << vfn);
+    } else {
+        e10k_pfvflrec_wr(d, 1, 1 << (vfn - 32));
+    }
+
+    errval_t err = b->tx_vtbl.init_done_response(b, NOP_CONT);
+    assert(err_is_ok(err));
+}
+
+static void get_mac_address_vf(struct e10k_vf_binding *b, uint8_t vfn)
+{
+    assert(initialized);
+    uint64_t d_mac = e10k_ral_ral_rdf(d, vfn) | ((uint64_t) e10k_rah_rah_rdf(d, vfn) << 32);
+    errval_t err = b->tx_vtbl.get_mac_address_response(b, NOP_CONT, d_mac);
+    assert(err_is_ok(err));
+}
+
+static struct e10k_vf_rx_vtbl vf_rx_vtbl = {
+    .get_mac_address_call = get_mac_address_vf,
+    .init_done_call = init_done_vf,
+};
+
+static void vf_export_cb(void *st, errval_t err, iref_t iref)
+{
+    const char *suffix = "_vf";
+    char name[strlen(service_name) + strlen(suffix) + 1];
+
+    assert(err_is_ok(err));
+
+    // Build label for interal management service
+    sprintf(name, "%s%s", service_name, suffix);
+
+    err = nameservice_register(name, iref);
+    assert(err_is_ok(err));
+    DEBUG("VF/PF interface [%s] exported\n", name);
+}
 
+static errval_t vf_connect_cb(void *st, struct e10k_vf_binding *b)
+{
+    DEBUG("New connection on VF/PF interface\n");
+    b->rx_vtbl = vf_rx_vtbl;
+    return SYS_ERR_OK;
+}
 
+/**
+ * Initialize management interface for queue drivers.
+ * This has to be done _after_ the hardware is initialized.
+ */
+static void initialize_vfif(void)
+{
+    errval_t r;
 
+    r = e10k_vf_export(NULL, vf_export_cb, vf_connect_cb, get_default_waitset(),
+		       IDC_BIND_FLAGS_DEFAULT);
+    assert(err_is_ok(r));
+}
 
 /******************************************************************************/
 /* Initialization code for driver */
@@ -1211,6 +1462,8 @@ static void pci_init_card(struct device_mem* bar_info, int bar_count)
     // Initialize Mackerel binding
     e10k_initialize(d, (void*) bar_info[0].vaddr);
 
+    DEBUG("STATUS = %x\n", e10k_status_rd(d));
+
     // Initialize manager for MSI-X vectors
     if (msix) {
         DEBUG("Enabling MSI-X interrupts\n");
@@ -1232,9 +1485,45 @@ static void pci_init_card(struct device_mem* bar_info, int bar_count)
 
     assert(initialized);
 
+#ifdef VTON_DCBOFF
+    DEBUG("SR-IOV device up routine\n");
+
+    // Setup support for 64 VFs
+    e10k_gcr_ext_vtmode_wrf(d, e10k_vt_64);
+    e10k_gpie_vtmode_wrf(d, e10k_vt_64);
+
+    // Enable virtualization, disable default pool, replication enable
+    e10k_pfvtctl_t pfvtctl = e10k_pfvtctl_rd(d);
+    pfvtctl = e10k_pfvtctl_vt_en_insert(pfvtctl, 1);
+    pfvtctl = e10k_pfvtctl_def_pl_insert(pfvtctl, 0);
+    pfvtctl = e10k_pfvtctl_dis_def_pl_insert(pfvtctl, 1);
+    pfvtctl = e10k_pfvtctl_rpl_en_insert(pfvtctl, 1);
+    e10k_pfvtctl_wr(d, pfvtctl);
+
+    // Enable L2 loopback
+    e10k_pfdtxgswc_lbe_wrf(d, 1);
+
+    // TODO: Accept untagged packets in all VMDQ pools
+    // TODO: Broadcast accept mode
+    // TODO: Accept packets matching PFUTA table
+    // TODO: Accept packets matching MTA table
+    // TODO: Accept untagged packets enable
+    // TODO: Strip VLAN tag for incoming packets
+
+    DEBUG("STATUS = %x\n", e10k_status_rd(d));
+
+    e10k_ctrl_ext_pfrstd_wrf(d, 1);
+#endif
+
+#ifndef LIBRARY
     // Now we initialize the management interface
     DEBUG("Initializing management interface\n");
     initialize_mngif();
+#endif
+
+    DEBUG("Initializing VF/PF interface\n");
+    initialize_vfif();
+    DEBUG("Done with initialization\n");
 }
 
 
@@ -1249,7 +1538,7 @@ static void pci_register(void)
 
     r = pci_register_driver_irq(pci_init_card, PCI_CLASS_ETHERNET,
                                 PCI_DONT_CARE, PCI_DONT_CARE,
-                                PCI_VENDOR_INTEL, E10K_PCI_DEVID,
+                                PCI_VENDOR_INTEL, pci_deviceid,
                                 pci_bus, pci_device, pci_function,
                                 interrupt_handler, NULL);
     assert(err_is_ok(r));
@@ -1260,15 +1549,17 @@ static void parse_cmdline(int argc, char **argv)
     int i;
 
     for (i = 1; i < argc; i++) {
-        if (strncmp(argv[i], "cardname=", strlen("cardname=") - 1) == 0) {
+        if (strncmp(argv[i], "cardname=", strlen("cardname=")) == 0) {
             service_name = argv[i] + strlen("cardname=");
-        } else if (strncmp(argv[i], "bus=", strlen("bus=") - 1) == 0) {
+        } else if (strncmp(argv[i], "bus=", strlen("bus=")) == 0) {
             pci_bus = atol(argv[i] + strlen("bus="));
-        } else if (strncmp(argv[i], "device=", strlen("device=") - 1) == 0) {
+        } else if (strncmp(argv[i], "device=", strlen("device=")) == 0) {
             pci_device = atol(argv[i] + strlen("device="));
-        } else if (strncmp(argv[i], "function=", strlen("function=") - 1) == 0){
+        } else if (strncmp(argv[i], "function=", strlen("function=")) == 0) {
             pci_function = atol(argv[i] + strlen("function="));
-        } else if (strncmp(argv[i], "msix=", strlen("msix=") - 1) == 0) {
+        } else if (strncmp(argv[i], "deviceid=", strlen("deviceid=")) == 0) {
+            pci_deviceid = strtoul(argv[i] + strlen("deviceid="), NULL, 0);
+        } else if (strncmp(argv[i], "msix=", strlen("msix=")) == 0) {
             msix = !!atol(argv[i] + strlen("msix="));
             // also pass this to queue driver
             qd_argument(argv[i]);
@@ -1278,6 +1569,7 @@ static void parse_cmdline(int argc, char **argv)
     }
 }
 
+#ifndef LIBRARY
 static void eventloop(void)
 {
     struct waitset *ws;
@@ -1300,10 +1592,12 @@ void qd_queue_init_data(struct e10k_binding *b, struct capref registers,
 void qd_queue_memory_registered(struct e10k_binding *b) { }
 void qd_write_queue_tails(struct e10k_binding *b) { }
 
-
 int main(int argc, char **argv)
+#else
+int e1000n_driver_init(int argc, char *argv[])
+#endif
 {
-    DEBUG("Started\n");
+    DEBUG("PF driver started\n");
     parse_cmdline(argc, argv);
     pci_register();
 
@@ -1311,5 +1605,6 @@ int main(int argc, char **argv)
         event_dispatch(get_default_waitset());
     }
     qd_main();
+    return 1;
 }
 
diff --git a/usr/drivers/e10k/e10k_qdriver.c b/usr/drivers/e10k/e10k_qdriver.c
index f3c76dd..3c5820c 100644
--- a/usr/drivers/e10k/e10k_qdriver.c
+++ b/usr/drivers/e10k/e10k_qdriver.c
@@ -19,21 +19,34 @@
 #include <trace/trace.h>
 
 #include <if/e10k_defs.h>
-#include <dev/e10k_dev.h>
+#ifndef VF
+#       include <dev/e10k_dev.h>
+#else
+#       include <dev/e10k_vf_dev.h>
+#endif
 #include <dev/e10k_q_dev.h>
 #include <pci/pci.h>
 
+#ifdef LIBRARY
+#       include <netif/e1000.h>
+#endif
+
 #include "helper.h"
 #include "e10k_queue.h"
 
-
+#ifdef PRINT_QUEUES
+static void *glbl_rx_virt = NULL;
+static size_t glbl_rx_size = 0;
+#endif
 
 /******************************************************************************/
 /* Compile time parameters */
 
 /* Size of the TX and RX rings */
-#define NTXDESCS 512
+/* #define NTXDESCS 1024 */
+#define NTXDESCS 2048
 #define NRXDESCS 2048
+//#define NRXDESCS 512
 
 /* Size of RX buffers */
 #define RXBUFSZ 2048
@@ -112,10 +125,14 @@ static bool standalone = false;
 static struct e10k_binding *binding = NULL;
 
 /** Queue index for this manager instance */
-static int qi = -1;
+int qi = -1;
 
 /** Mackerel handle for device */
+#ifndef VF
 static e10k_t *d = NULL;
+#else
+static e10k_vf_t *d = NULL;
+#endif
 
 /** Queue handle for queue management library */
 static e10k_queue_t *q;
@@ -133,7 +150,15 @@ static int initialized = 0;
 static bool cache_coherence = true;
 
 /** Indicates whether TX head index write back should be used */
+#ifndef VF
 static bool use_txhwb = true;
+#else
+// XXX: TX HWB doesn't work on the VF. Probably a bug in the
+// driver. It stalls the output queue after a few packets have gone
+// out. The Linux VF driver doesn't seem to use TX HWB.
+// If you fix this, you'll get a 5% performance boost.
+static bool use_txhwb = false;
+#endif
 
 /** Indicates whether Interrupts should be used */
 static bool use_interrupts = false;
@@ -156,7 +181,6 @@ static struct capref rx_frame;
 /** Capability for head index write back feature */
 static struct capref txhwb_frame;
 
-
 /******************************************************************************/
 /* Debugging code, etc. */
 
@@ -181,45 +205,133 @@ static void queue_debug(const char* fmt, ...)
     vprintf(fmt, va);
     va_end(va);
 }
-#endif
 
 /* Helper code for debugging that dumps the statistics registers that are != 0.
  * Most registers are cleared uppon a read. */
-#if 0
-#define prnonz(x) uint32_t x = e10k_##x##_rd(d); if (x) printf(#x "=%x ", x)
+#ifdef STATS_DUMP
+#ifndef VF
+#define prnonz(x) uint32_t x = e10k_##x##_rd(d); if (x) snprintf(str[cnt++], 32, #x "=%x", x)
+#define prnonzary(x, n)			      \
+  for(int i = 0; i < n; i++) {		      \
+    uint32_t reg = e10k_##x##_rd(d, i);	      \
+    if (reg) snprintf(str[cnt++], 32, #x ".%d=%x", i, reg);	\
+  }
 static void stats_dump(void)
 {
-    queue_debug("");
-    prnonz(tpt);
-    prnonz(gptc);
-    prnonz(txdgpc);
-
-    prnonz(tpr);
-    prnonz(gprc);
-    prnonz(rxdgpc);
+  char str[256][32];
+  int cnt = 0;
+  memset(str, 0, 256 * 32);
+
+  prnonzary(pfvfte, 2);
+  /* prnonzary(pfvfspoof, 8); */
+  /* prnonz(rttbcnrc); */
+  /* prnonzary(mpsar, 256); */
+  prnonz(picause);
+  prnonz(rttdcs);
+
+  prnonz(fwsm);
+  prnonz(eicr);
+
+  prnonz(dmatxctl);
+  prnonzary(tdbal, 128);
+  prnonzary(tdbah, 128);
+  prnonzary(tdlen, 128);
+  prnonzary(tdh, 128);
+  prnonzary(tdt, 128);
+  prnonzary(txdctl, 128);
+  prnonzary(tdwbal, 128);
+  prnonzary(tdwbah, 128);
+  prnonz(mtqc);
+
+  /* prnonzary(pfvflre, 2); */
 
     prnonz(crcerrs);
     prnonz(illerrc);
     prnonz(errbc);
+    prnonzary(rxmpc, 8);
+    prnonz(mlfc);
+    prnonz(mrfc);
     prnonz(rlec);
+    prnonz(ssvpc);
+    // ...
+    prnonz(gprc);
+    prnonz(gorcl);
+    prnonz(gorch);
+    prnonz(rxnfgpc);
+    // ...
+    prnonz(rxdgpc);
+    // ...
+    prnonz(gptc);
+    prnonz(gotcl);
+    prnonz(gotch);
+    prnonz(txdgpc);
+    // ...
     prnonz(ruc);
     prnonz(rfc);
     prnonz(roc);
     prnonz(rjc);
-    prnonz(rxnfgpc);
     prnonz(mngprc);
     prnonz(mngpdc);
+    prnonz(torl);
+    prnonz(torh);
+    prnonz(tpr);
+    prnonz(tpt);
+    // ...
+    prnonz(mspdc);
+    // ...
+    prnonzary(qprc, 16);
+    prnonzary(qprdc, 16);
+    // ...
+
+    if(cnt > 0) {
+      queue_debug("");
+      for(int i = 0; i < cnt; i++) {
+	printf("%s ", str[i]);
+      }
+      printf("\n");
+    }
+}
+#else   // VF
+#define prnonz(x)                                               \
+    uint32_t x = e10k_vf_##x##_rd(d);                           \
+    static uint32_t last_##x = 0;                               \
+    if (x != last_##x) {                                        \
+      snprintf(str[cnt++], 32, #x "=%x", x);                      \
+      last_##x = x;                                               \
+    }
+static void stats_dump(void)
+{
+  char str[256][32];
+  int cnt = 0;
+  memset(str, 0, 256 * 32);
+
+    prnonz(vfgprc);
+    prnonz(vfgptc);
+    prnonz(vfgorc_lsb);
+    prnonz(vfgorc_msb);
+    prnonz(vfgotc_lsb);
+    prnonz(vfgotc_msb);
+    prnonz(vfmprc);
+
+    if(cnt > 0) {
+      queue_debug("");
+      for(int i = 0; i < cnt; i++) {
+	printf("%s ", str[i]);
+      }
+      printf("\n");
+    }
+}
+#endif
 
-    prnonz(mlfc);
-    prnonz(mrfc);
+#else
 
-    uint32_t qprc = e10k_qprc_rd(d, 0);
-    if (qprc) printf("qprc.0=%x ", qprc);
-    uint32_t qprdc = e10k_qprdc_rd(d, 0);
-    if (qprdc) printf("qprdc.0=%x ", qprdc);
+static void stats_dump(void) {}
 
-    printf("\n");
-}
+#endif
+
+#else
+
+static void stats_dump(void) {}
 
 #endif
 
@@ -252,13 +364,38 @@ static inline bool buf_use_ipxsm(struct driver_buffer *buf)
         buf_use_tcpxsm(buf) || buf_use_udpxsm(buf);
 }
 
-static inline bool buf_tcphdrlen(struct driver_buffer *buf)
+static inline uint8_t buf_tcphdrlen(struct driver_buffer *buf)
 {
     return ((buf->flags & NETIF_TXFLAG_TCPHDRLEN_MASK) >>
         NETIF_TXFLAG_TCPHDRLEN_SHIFT) * 4;
 }
 
+#ifdef LIBRARY
+bool e1000n_queue_empty(void)
+{
+    uint32_t tail, head;
+
+#ifndef VF
+    tail = e10k_tdt_rd(d, qi);
+    head = e10k_tdh_rd(d, qi);
+#else
+    tail = e10k_vf_vftdt_rd(d, qi);
+    head = e10k_vf_vftdh_rd(d, qi);
+#endif
 
+    return (head == tail);
+}
+#endif
+
+/*
+ * This function transmits a packet via the network.
+ *
+ * It has to make sure to properly mark the last packet of an array of
+ * packets, so we can properly collect fully transmitted packets
+ * asynchronously later on. Only the last packet is marked with a
+ * write-back indication and we scan for that to know the packet was
+ * written out.
+ */
 static errval_t transmit_pbuf_list_fn(struct driver_buffer *buffers,
                                       size_t                count)
 {
@@ -318,9 +455,9 @@ static bool handle_free_tx_slot_fn(void)
         return false;
     }
 
-    DEBUG("handle_free_tx_slot_fn: Packet done\n");
+    DEBUG("handle_free_tx_slot_fn: Packet %p done\n", op);
 
-    //stats_dump();
+    stats_dump();
 
 #if TRACE_ETHERSRV_MODE
         trace_event(TRACE_SUBSYS_NNET, TRACE_EVENT_NNET_DRVTXDONE, 0);
@@ -349,7 +486,7 @@ static void check_for_free_txbufs(void)
 
 static errval_t register_rx_buffer_fn(uint64_t paddr, void *vaddr, void *opaque)
 {
-
+    /* printf("Got %p from stack\n", opaque); */
     DEBUG("register_rx_buffer_fn: called\n");
     e10k_queue_add_rxbuf(q, paddr, opaque);
     e10k_queue_bump_rxtail(q);
@@ -363,7 +500,7 @@ static uint64_t find_rx_free_slot_count_fn(void)
     return e10k_queue_free_rxslots(q);
 }
 
-static size_t check_for_new_packets(void)
+static size_t check_for_new_packets(int num)
 {
     size_t len;
     void *op;
@@ -376,7 +513,40 @@ static size_t check_for_new_packets(void)
 
     if (!initialized) return 0;
 
-    //stats_dump();
+    /* stats_dump(); */
+
+#ifdef PRINT_QUEUES
+    uint64_t *tv = glbl_rx_virt;
+    size_t cnt = 0;
+    for(size_t i = 0; i < glbl_rx_size / 8; i++) {
+        if(tv[i] != 0) {
+            printf("%zx: %lx, ", i, tv[i]);
+            cnt++;
+        }
+        if(cnt % 16 == 0) {
+            printf("\n");
+            cnt++;
+        }
+    }
+    printf("\n");
+#endif
+
+#ifndef VF
+#if 0
+    // Check if queue runs too full
+    int rdtp = e10k_rdt_1_rd(d, qi);
+    int rdhp = e10k_rdh_1_rd(d, qi);
+    if(rdtp < rdhp) {
+        if(NRXDESCS - (rdhp - rdtp) < 10) {
+            printf("Running low on receive buffers! rdhp = %u, rdtp = %u\n", rdhp, rdtp);
+        }
+    } else {
+        if(rdtp - rdhp < 10) {
+            printf("Running low on receive buffers! rdhp = %u, rdtp = %u\n", rdhp, rdtp);
+        }
+    }
+#endif
+#endif
 
     // TODO: This loop can cause very heavily bursty behaviour, if the packets
     // arrive faster than they can be processed.
@@ -399,6 +569,11 @@ static size_t check_for_new_packets(void)
         if (last) {
             process_received_packet(buf, pkt_cnt, flags);
             pkt_cnt = 0;
+            if(num != 0) {
+                count++;
+                flags = 0;
+                break;
+            }
         } else {
             assert(pkt_cnt < MAXDESCS - 1);
         }
@@ -422,7 +597,11 @@ static errval_t update_txtail(void *opaque, size_t tail)
 {
     assert(d != NULL);
 
+#ifndef VF
     e10k_tdt_wr(d, qi, tail);
+#else
+    e10k_vf_vftdt_wr(d, qi, tail);
+#endif
     return SYS_ERR_OK;
 }
 
@@ -430,7 +609,11 @@ static errval_t update_rxtail(void *opaque, size_t tail)
 {
     assert(d != NULL);
 
+#ifndef VF
     e10k_rdt_1_wr(d, qi, tail);
+#else
+    e10k_vf_vfrdt_wr(d, qi, tail);
+#endif
     return SYS_ERR_OK;
 }
 
@@ -478,9 +661,15 @@ static void setup_queue(void)
     rx_virt = alloc_map_frame(flags, rx_size, &rx_frame);
     assert(rx_virt != NULL);
 
+#ifdef PRINT_QUEUES
+    glbl_rx_virt = rx_virt;
+    glbl_rx_size = rx_size;
+#endif
+
     // Register memory with device manager
     txhwb_virt = NULL;
     if (use_txhwb) {
+        INITDEBUG("Using transmit write-back\n");
         txhwb_size = BASE_PAGE_SIZE;
         txhwb_virt = alloc_map_frame(flags, txhwb_size, &txhwb_frame);
         assert(txhwb_virt != NULL);
@@ -625,7 +814,11 @@ void qd_queue_init_data(struct e10k_binding *b, struct capref registers,
 
     // Initialize mackerel device
     d = malloc(sizeof(*d));
+#ifndef VF
     e10k_initialize(d, virt);
+#else
+    e10k_vf_initialize(d, virt);
+#endif
 
     // Initialize queue
     setup_queue();
@@ -639,10 +832,17 @@ void qd_queue_memory_registered(struct e10k_binding *b)
     hwqueue_initialized();
 
     // Register queue with queue_mgr library
+#ifndef LIBRARY
     ethersrv_init((char*) service_name, qi, get_mac_addr_fn, terminate_queue_fn,
         transmit_pbuf_list_fn, find_tx_free_slot_count_fn,
         handle_free_tx_slot_fn, RXBUFSZ, register_rx_buffer_fn,
         find_rx_free_slot_count_fn);
+#else
+    ethernetif_backend_init((char*) service_name, qi, get_mac_addr_fn, terminate_queue_fn,
+        transmit_pbuf_list_fn, find_tx_free_slot_count_fn,
+        handle_free_tx_slot_fn, RXBUFSZ, register_rx_buffer_fn,
+        find_rx_free_slot_count_fn);
+#endif
 }
 
 // Callback from device manager
@@ -654,6 +854,7 @@ void qd_write_queue_tails(struct e10k_binding *b)
     e10k_queue_bump_txtail(q);
 }
 
+#ifndef LIBRARY
 // Callback from device manager
 static void idc_queue_terminated(struct e10k_binding *b)
 {
@@ -722,6 +923,18 @@ static void connect_to_mngif(void)
     assert(err_is_ok(r));
 }
 
+#else
+
+void ethersrv_argument(const char* arg)
+{
+    if (strncmp(arg, "queue=", strlen("queue=") - 1) == 0) {
+        printf("Arrakis: Not passing '%s' argument to ethersrv\n", arg);
+    } else {
+        printf("Warning: ethersrv_argument '%s' not supported in Arrakis!\n", arg);
+    }
+}
+#endif
+
 void qd_argument(const char *arg)
 {
     if (strncmp(arg, "cardname=", strlen("cardname=") - 1) == 0) {
@@ -759,6 +972,7 @@ void qd_argument(const char *arg)
     }
 }
 
+#ifndef LIBRARY
 static void parse_cmdline(int argc, char **argv)
 {
     int i;
@@ -767,23 +981,54 @@ static void parse_cmdline(int argc, char **argv)
     }
 }
 
-
 static void eventloop(void)
+#else
+extern struct waitset *lwip_waitset;
+
+#ifdef LIBRARY
+void arranet_polling_loop(void)
 {
-    struct waitset *ws;
+    /* errval_t err; */
+    /* err = event_dispatch_non_block(barrelfish_interrupt_waitset); */
+    check_for_free_txbufs();
+    if(!use_interrupts) {
+        check_for_new_packets(1);
+    } else {
+        assert(!"NYI?");
+    }
+}
+#endif
+
+void e1000n_polling_loop(struct waitset *ws)
+#endif
+{
+#ifndef LIBRARY
+    struct waitset *ws = get_default_waitset();
+#endif
     errval_t err;
 
-    INITDEBUG("eventloop()\n");
+    /* INITDEBUG("eventloop()\n"); */
 
-    ws = get_default_waitset();
     while (1) {
         err = event_dispatch_non_block(ws);
-        do_pending_work_for_all();
-        check_for_new_packets();
+#ifdef LIBRARY
         check_for_free_txbufs();
+#else
+        do_pending_work_for_all();
+#endif
+        if(!use_interrupts) {
+            check_for_new_packets(0);
+            /* check_for_new_packets(1); */
+            check_for_free_txbufs();
+        }
+
+#ifdef LIBRARY
+        break;
+#endif
     }
 }
 
+#ifndef LIBRARY
 static void eventloop_ints(void)
 {
     struct waitset *ws;
@@ -795,6 +1040,7 @@ static void eventloop_ints(void)
         do_pending_work_for_all();
     }
 }
+#endif
 
 static void interrupt_handler(void *data)
 {
@@ -810,7 +1056,7 @@ void qd_interrupt(bool is_rx, bool is_tx)
 #endif // TRACE_ETHERSRV_MODE
 
     if (is_rx) {
-        count = check_for_new_packets();
+        count = check_for_new_packets(0);
         if (count == 0) {
             //printf("No RX\n");
         }
@@ -831,10 +1077,13 @@ void qd_main(void)
                    "is enabled.");
     }
 
+#ifndef LIBRARY
     if (standalone) {
         connect_to_mngif();
     } else {
+#endif
         idc_request_device_info();
+#ifndef LIBRARY
     }
 
     if (use_interrupts) {
@@ -842,8 +1091,10 @@ void qd_main(void)
     } else {
         eventloop();
     }
+#endif
 }
 
+#ifndef LIBRARY
 int main(int argc, char **argv)
 {
     DEBUG("Started\n");
@@ -854,7 +1105,6 @@ int main(int argc, char **argv)
 
 
 
-
 void cd_request_device_info(struct e10k_binding *b)
 {
     USER_PANIC("Should not be called");
@@ -881,3 +1131,4 @@ void cd_set_interrupt_rate(struct e10k_binding *b,
     USER_PANIC("Should not be called");
 }
 
+#endif
diff --git a/usr/drivers/e10k/e10k_queue.h b/usr/drivers/e10k/e10k_queue.h
index 68aa833..83beb29 100644
--- a/usr/drivers/e10k/e10k_queue.h
+++ b/usr/drivers/e10k/e10k_queue.h
@@ -36,7 +36,7 @@ struct e10k_queue {
     void**                          tx_opaque;
     bool*                           tx_isctx;
     size_t                          tx_head;
-    size_t                          tx_tail;
+    size_t                          tx_tail, tx_lasttail;
     size_t                          tx_size;
     uint32_t*                       tx_hwb;
 
@@ -62,7 +62,7 @@ static inline e10k_queue_t* e10k_queue_init(void* tx, size_t tx_size,
     q->tx_opaque = calloc(tx_size, sizeof(void*));
     q->tx_isctx = calloc(tx_size, sizeof(bool));
     q->tx_head = 0;
-    q->tx_tail = 0;
+    q->tx_tail = q->tx_lasttail = 0;
     q->tx_size = tx_size;
     q->tx_hwb = tx_hwb;
 
@@ -88,6 +88,8 @@ static inline int e10k_queue_add_txcontext(e10k_queue_t* q, uint8_t idx,
     e10k_q_tdesc_adv_ctx_t d;
     size_t tail = q->tx_tail;
 
+    memset(q->tx_ring[tail], 0, e10k_q_tdesc_adv_wb_size);
+
     // TODO: Check if there is room in the queue
     q->tx_isctx[tail] = true;
     d = q->tx_ring[tail];
@@ -95,6 +97,7 @@ static inline int e10k_queue_add_txcontext(e10k_queue_t* q, uint8_t idx,
     e10k_q_tdesc_adv_rd_dtyp_insert(d, e10k_q_adv_ctx);
     e10k_q_tdesc_adv_rd_dext_insert(d, 1);
 
+    /* e10k_q_tdesc_adv_ctx_bcntlen_insert(d, 0x3f); */
     e10k_q_tdesc_adv_ctx_idx_insert(d, idx);
     e10k_q_tdesc_adv_ctx_maclen_insert(d, maclen);
     e10k_q_tdesc_adv_ctx_iplen_insert(d, iplen);
@@ -102,6 +105,7 @@ static inline int e10k_queue_add_txcontext(e10k_queue_t* q, uint8_t idx,
     e10k_q_tdesc_adv_ctx_l4len_insert(d, l4len);
     e10k_q_tdesc_adv_ctx_l4t_insert(d, l4t);
 
+    q->tx_lasttail = q->tx_tail;
     q->tx_tail = (tail + 1) % q->tx_size;
     return 0;
 }
@@ -114,6 +118,8 @@ static inline int e10k_queue_add_txbuf_ctx(e10k_queue_t* q, uint64_t phys,
     e10k_q_tdesc_adv_rd_t d;
     size_t tail = q->tx_tail;
 
+    memset(q->tx_ring[tail], 0, e10k_q_tdesc_adv_wb_size);
+
     // TODO: Check if there is room in the queue
     q->tx_isctx[tail] = false;
     q->tx_opaque[tail] = opaque;
@@ -137,6 +143,7 @@ static inline int e10k_queue_add_txbuf_ctx(e10k_queue_t* q, uint64_t phys,
         e10k_q_tdesc_adv_rd_txsm_insert(d, txsm);
     }
 
+    q->tx_lasttail = q->tx_tail;
     q->tx_tail = (tail + 1) % q->tx_size;
     return 0;
 }
@@ -148,9 +155,18 @@ static inline int e10k_queue_add_txbuf(e10k_queue_t* q, uint64_t phys,
             -1, false, false);
 }
 
+/*
+ * Reclaim 1 packet from the TX queue once it's handled by the
+ * card. Call multiple times to reclaim more packets.
+ *
+ * \param       q       Queue to check
+ * \param       opaque  Contains opaque data of reclaimed packet, if any
+ *
+ * \return 1 if no packet can be reclaimed, 0 otherwise.
+ */
 static inline int e10k_queue_get_txbuf(e10k_queue_t* q, void** opaque)
 {
-    e10k_q_tdesc_adv_wb_t d;
+    /* e10k_q_tdesc_adv_wb_t d; */
     size_t head = q->tx_head;
     int result = 1;
 
@@ -159,17 +175,41 @@ static inline int e10k_queue_get_txbuf(e10k_queue_t* q, void** opaque)
         return 1;
     }
 
-    d = q->tx_ring[head];
-    if (!q->tx_hwb && !e10k_q_tdesc_adv_wb_dd_extract(d)) {
-        return 1;
+    if(!q->tx_hwb) {
+        size_t idx = head;
+
+        // Skip over context and non-EOP descriptors
+        while(idx != q->tx_tail && q->tx_isctx[idx] && !e10k_q_tdesc_adv_wb_dd_extract(q->tx_ring[idx])) {
+            idx = (idx + 1) % q->tx_size;
+        }
+
+        /* d = q->tx_ring[head]; */
+        /* d = q->tx_ring[idx]; */
+        /* if (!e10k_q_tdesc_adv_wb_dd_extract(d)) { */
+        /*     return 1; */
+        /* } */
+
+        if(idx == q->tx_tail) {
+            return 1;
+        }
     }
 
+    // Check the last written packet, which should be marked with a
+    // write-back indicator (RS bit)
+    /* if (!q->tx_hwb) { */
+    /*     assert(!q->tx_isctx[q->tx_lasttail]); */
+    /*     if(!e10k_q_tdesc_adv_wb_dd_extract(q->tx_ring[q->tx_lasttail])) { */
+    /*         return 1; */
+    /*     } */
+    /* } */
+
+    // That last packet got written out, now go reclaim from the head pointer.
     if (!q->tx_isctx[head]) {
         *opaque = q->tx_opaque[head];
         result = 0;
     }
 
-    memset(d, 0, e10k_q_tdesc_adv_wb_size);
+    /* memset(q->tx_ring[head], 0, e10k_q_tdesc_adv_wb_size); */
     q->tx_head = (head + 1) % q->tx_size;
     return result;
 }
diff --git a/usr/drivers/e10k/e10k_vf.c b/usr/drivers/e10k/e10k_vf.c
new file mode 100644
index 0000000..23bca58
--- /dev/null
+++ b/usr/drivers/e10k/e10k_vf.c
@@ -0,0 +1,886 @@
+/*
+ * Copyright (c) 2007-2011, 2013, ETH Zurich.
+ * All rights reserved.
+ *
+ * This file is distributed under the terms in the attached LICENSE file.
+ * If you do not find this file, copies can be found by writing to:
+ * ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich. Attn: Systems Group.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdarg.h>
+
+#include <net_device_manager/net_device_manager.h>
+#include <pci/pci.h>
+#include <barrelfish/nameservice_client.h>
+#include <barrelfish/debug.h>
+#include <ipv4/lwip/inet.h>
+
+#include <if/e10k_defs.h>
+#include <if/e10k_vf_defs.h>
+#include <if/e10k_vf_rpcclient_defs.h>
+#include <dev/e10k_vf_dev.h>
+
+#include "sleep.h"
+#include "helper.h"
+
+#define E10K_PCI_DEVID 0x10ed
+
+//#define DEBUG(x...) printf("e10k_vf: " x)
+#define DEBUG(x...) do {} while (0)
+
+#define QUEUE_INTRX 0
+#define QUEUE_INTTX 1
+
+struct queue_state {
+    bool enabled;
+    struct e10k_binding *binding;
+
+    struct capref tx_frame;
+    struct capref txhwb_frame;
+    struct capref rx_frame;
+    uint32_t rxbufsz;
+
+    size_t msix_index;
+    int16_t msix_intvec;
+    uint8_t msix_intdest;
+    bool use_irq;
+    bool use_rsc;
+
+    uint64_t rx_head;
+    uint64_t tx_head;
+};
+
+enum filter_l4type {
+    L4_OTHER,
+    L4_UDP,
+    L4_TCP,
+    L4_SCTP
+};
+
+enum filter_mask {
+    MASK_L4PROTO    = (1 << 0),
+    MASK_SRCIP      = (1 << 1),
+    MASK_DSTIP      = (1 << 2),
+    MASK_SRCPORT    = (1 << 3),
+    MASK_DSTPORT    = (1 << 4),
+};
+
+struct e10k_filter {
+    bool enabled;
+    uint8_t priority;
+    uint8_t queue;
+
+    uint32_t src_ip;
+    uint32_t dst_ip;
+    uint16_t src_port;
+    uint16_t dst_port;
+
+    uint16_t mask;
+    uint16_t l4_type;
+};
+
+
+// Hack for monolithic driver
+void qd_main(void) __attribute__((weak));
+void qd_argument(const char *arg) __attribute__((weak));
+void qd_interrupt(bool is_rx, bool is_tx) __attribute__((weak));
+void qd_queue_init_data(struct e10k_binding *b, struct capref registers,
+        uint64_t macaddr) __attribute__((weak));
+void qd_queue_memory_registered(struct e10k_binding *b) __attribute__((weak));
+void qd_write_queue_tails(struct e10k_binding *b) __attribute__((weak));
+
+
+void cd_request_device_info(struct e10k_binding *b);
+void cd_register_queue_memory(struct e10k_binding *b,
+                              uint8_t queue,
+                              struct capref tx,
+                              struct capref txhwb,
+                              struct capref rx,
+                              uint32_t rxbufsz,
+                              int16_t msix_intvec,
+                              uint8_t msix_intdest,
+                              bool use_interrupts,
+                              bool use_rsc);
+void cd_set_interrupt_rate(struct e10k_binding *b,
+                           uint8_t queue,
+                           uint16_t rate);
+
+
+static void idc_write_queue_tails(struct e10k_binding *b);
+static void stop_device(void);
+
+static void device_init(void);
+static void queue_hw_init(uint8_t n);
+//static void queue_hw_stop(uint8_t n);
+static void interrupt_handler_msix(void* arg);
+//static void interrupt_handler_msix_b(void* arg);
+
+//static void e10k_flt_ftqf_setup(int index, struct e10k_filter *filter);
+//static void e10k_flt_etype_setup(int filter, int queue, uint16_t etype);
+
+static const char *service_name = "e10k";
+uint64_t d_mac;
+static int initialized = 0;
+static e10k_vf_t *d = NULL;
+static struct capref *regframe;
+static bool msix = true;
+
+// Management of MSI-X vectors
+static struct bmallocator msix_alloc;
+/** MSI-X vector used by cdriver */
+static size_t cdriver_msix = -1;
+static uint8_t cdriver_vector;
+static bool use_interrupts = false;
+
+// State of queues and filters
+static struct queue_state queues[8];
+//static struct e10k_filter filters[128];
+
+//static char buf[4096];
+
+static int vf_num = 0;
+
+/* PCI device address passed on command line */
+static uint32_t pci_bus = PCI_DONT_CARE;
+static uint32_t pci_device = PCI_DONT_CARE;
+static uint32_t pci_function = 0;
+
+static struct e10k_vf_rpc_client *e10k_vf_client = NULL;
+
+static void setup_interrupt(size_t *msix_index, uint8_t core, uint8_t vector)
+{
+    bool res;
+    errval_t err;
+    uint8_t dest;
+
+    res = bmallocator_alloc(&msix_alloc, msix_index);
+    assert(res);
+
+    err = get_apicid_from_core(core, &dest);
+    assert(err_is_ok(err));
+
+    err = pci_msix_vector_init(*msix_index, dest, vector);
+    assert(err_is_ok(err));
+
+    DEBUG("e10k: MSI-X vector setup index=%"PRIx64", core=%d apic=%d swvec=%x\n",
+            *msix_index, core, dest, vector);
+}
+
+/**
+ * Initialize hardware registers.
+ * Is also called after a reset of the device.
+ */
+static void device_init(void)
+{
+    int i;
+    errval_t err;
+    bool initialized_before = initialized;
+
+    initialized = 0;
+
+    stop_device();
+
+#if 0
+    if (initialized_before) {
+        // Save queue heads and tails
+        for (i = 0; i < 128; i++) {
+            if (queues[i].enabled) {
+                queues[i].tx_head = e10k_tdh_rd(d, i);
+                if (i < 64) {
+                    queues[i].rx_head = e10k_rdh_1_rd(d, i);
+                } else {
+                    queues[i].rx_head = e10k_rdh_2_rd(d, i - 64);
+                }
+            }
+        }
+    }
+#else
+    assert(!initialized_before);
+#endif
+
+    // Issue Global reset
+    e10k_vf_vfctrl_rst_wrf(d, 1);
+    // Spec says 10, fbsd driver 50
+    milli_sleep(50);
+    DEBUG("Global reset done\n");
+
+    // Disable interrupts
+    e10k_vf_vfeimc_msix_wrf(d, 7);
+    e10k_vf_vfeicr_rd(d);
+
+    // Wait for link to come up
+    DEBUG("Waiting for Link\n");
+    while (e10k_vf_vflinks_lnk_up_rdf(d) == 0); // TODO: Timeout
+    DEBUG("Link Up\n");
+    milli_sleep(50);
+
+    // Initialize interrupts
+    e10k_vf_vfeicr_wr(d, 7);
+    e10k_vf_vfeitr_wr(d, 0, 0x0);
+    e10k_vf_vfeitr_wr(d, 1, 0x0);
+
+    if (msix) {
+        // Allocate msix vector for cdriver and set up handler
+        if (cdriver_msix == -1) {
+            err = pci_setup_inthandler(interrupt_handler_msix, NULL, &cdriver_vector);
+            assert(err_is_ok(err));
+
+            setup_interrupt(&cdriver_msix, disp_get_core_id(), cdriver_vector);
+        }
+
+        // Map management interrupts to our vector
+        e10k_vf_vfivar_misc_i_alloc0_wrf(d, cdriver_msix);
+        e10k_vf_vfivar_misc_i_allocval0_wrf(d, 1);
+
+        // Enable interrupt
+        e10k_vf_vfeitr_wr(d, cdriver_msix / 32, (1 << (cdriver_msix % 32)));
+    } else {
+        // Enable all interrupts
+        e10k_vf_vfeimc_wr(d, e10k_vf_vfeims_rd(d));
+        e10k_vf_vfeims_msix_wrf(d, 7);
+    }
+
+    // Other stuff
+    e10k_vf_vfpsrtype_wr(d, 0);
+
+    // disable relaxed ordering
+    for (i = 0; i < 8; i++) {
+        e10k_vf_vfdca_txctrl_txdesc_wbro_wrf(d, i, 0);
+        e10k_vf_vfdca_rxctrl_rxhdr_ro_wrf(d, i, 0);
+        e10k_vf_vfdca_rxctrl_rxdata_wrro_wrf(d, i, 0);
+    }
+
+    // enable all queues
+    for (i = 0; i < 2; i++) {
+        e10k_vf_vftxdctl_enable_wrf(d, i, 1);
+    }
+#if 0
+    for (i = 0; i < 8; i++) {
+        e10k_vf_vfrxdctl_enable_wrf(d, i, 0);
+    }
+#endif
+
+    DEBUG("VF initialized (%d)\n", initialized_before);
+
+#if 0
+    // Restore configuration
+    if (initialized_before) {
+        // Restoring filters
+        for (i = 0; i < 128; i++) {
+            if (filters[i].enabled) {
+                e10k_vf_flt_ftqf_setup(i, filters + i);
+            }
+        }
+
+        // Restoring queues
+        for (i = 0; i < 128; i++) {
+            if (queues[i].enabled) {
+                queue_hw_init(i);
+            }
+        }
+
+        DEBUG("Configuration restored\n");
+    }
+#endif
+
+    initialized = 1;
+}
+
+/** Initialize hardware queue n. */
+static void queue_hw_init(uint8_t n)
+{
+    errval_t r;
+    struct frame_identity frameid = { .base = 0, .bits = 0 };
+    uint64_t tx_phys, txhwb_phys, rx_phys;
+    size_t tx_size, rx_size;
+
+    // Get physical addresses for rx/tx rings
+    r = invoke_frame_identify(queues[n].tx_frame, &frameid);
+    assert(err_is_ok(r));
+    tx_phys = frameid.base;
+    tx_size = 1 << frameid.bits;
+
+    r = invoke_frame_identify(queues[n].rx_frame, &frameid);
+    assert(err_is_ok(r));
+    rx_phys = frameid.base;
+    rx_size = 1 << frameid.bits;
+
+
+    DEBUG("tx.phys=%"PRIx64" tx.size=%"PRIu64"\n", tx_phys, tx_size);
+    DEBUG("rx.phys=%"PRIx64" rx.size=%"PRIu64"\n", rx_phys, rx_size);
+
+
+    // Initialize RX queue in HW
+    e10k_vf_vfrdbal_wr(d, n, rx_phys);
+    e10k_vf_vfrdbah_wr(d, n, rx_phys >> 32);
+    e10k_vf_vfrdlen_wr(d, n, rx_size);
+
+    e10k_vf_vfsrrctl_bsz_pkt_wrf(d, n, queues[n].rxbufsz / 1024);
+    e10k_vf_vfsrrctl_bsz_hdr_wrf(d, n, 128 / 64); // TODO: Do 128 bytes suffice in
+                                               //       all cases?
+    e10k_vf_vfsrrctl_desctype_wrf(d, n, e10k_vf_adv_1buf);
+    e10k_vf_vfsrrctl_drop_en_wrf(d, n, 1);
+
+    // Initialize queue pointers (empty)
+    e10k_vf_vfrdt_wr(d, n, queues[n].rx_head);
+    e10k_vf_vfrdh_wr(d, n, queues[n].rx_head);
+
+    e10k_vf_vfrxdctl_enable_wrf(d, n, 1);
+    while (e10k_vf_vfrxdctl_enable_rdf(d, n) == 0); // TODO: Timeout
+    DEBUG("[%x] RX queue enabled\n", n);
+
+    // Setup Interrupts for this queue
+    if (queues[n].use_irq) {
+        DEBUG("[%x] Setting up interrupts\n", n);
+        uint8_t rxv, txv;
+        // Look for interrupt vector
+        if (queues[n].msix_intvec != 0) {
+            if (queues[n].msix_index == -1) {
+                setup_interrupt(&queues[n].msix_index, queues[n].msix_intdest,
+                                queues[n].msix_intvec);
+            }
+            rxv = txv = queues[n].msix_index;
+        } else {
+            rxv = QUEUE_INTRX;
+            txv = QUEUE_INTTX;
+        }
+        DEBUG("rxv=%d txv=%d\n", rxv, txv);
+
+        // Setup mapping queue Rx/Tx -> interrupt
+        uint8_t i = n / 2;
+        if ((n % 2) == 0) {
+            e10k_vf_vfivar_i_alloc0_wrf(d, i, rxv);
+            e10k_vf_vfivar_i_allocval0_wrf(d, i, 1);
+            e10k_vf_vfivar_i_alloc1_wrf(d, i, txv);
+            e10k_vf_vfivar_i_allocval1_wrf(d, i, 1);
+        } else {
+            e10k_vf_vfivar_i_alloc2_wrf(d, i, rxv);
+            e10k_vf_vfivar_i_allocval2_wrf(d, i, 1);
+            e10k_vf_vfivar_i_alloc3_wrf(d, i, txv);
+            e10k_vf_vfivar_i_allocval3_wrf(d, i, 1);
+        }
+        if (queues[n].msix_intvec != 0) {
+            // Enable interrupt
+            e10k_vf_vfeitr_wr(d, rxv / 32, (1 << (rxv % 32)));
+        }
+        if (rxv < 16) {
+            // Make sure interrupt is cleared
+            e10k_vf_vfeicr_wr(d, 1 << rxv);
+        }
+    }
+
+    // We only have 4 TX queues
+    assert(n < 4);
+
+    // Initialize TX queue in HW
+    e10k_vf_vftdbal_wr(d, n, tx_phys);
+    e10k_vf_vftdbah_wr(d, n, tx_phys >> 32);
+    e10k_vf_vftdlen_wr(d, n, tx_size);
+
+    // Initialize TX head index write back
+    if (!capref_is_null(queues[n].txhwb_frame)) {
+        r = invoke_frame_identify(queues[n].txhwb_frame, &frameid);
+        assert(err_is_ok(r));
+        txhwb_phys = frameid.base;
+
+        e10k_vf_vftdwbal_headwb_low_wrf(d, n, txhwb_phys >> 2);
+        e10k_vf_vftdwbah_headwb_high_wrf(d, n, txhwb_phys >> 32);
+        e10k_vf_vftdwbal_headwb_en_wrf(d, n, 1);
+    }
+
+    // Initialized by queue driver to avoid race conditions
+    // Initialize queue pointers
+    assert(queues[n].tx_head == 0);
+    e10k_vf_vftdh_wr(d, n, queues[n].tx_head);
+    e10k_vf_vftdt_wr(d, n, queues[n].tx_head);
+
+    // Configure prefetch and writeback threshhold
+    e10k_vf_vftxdctl_pthresh_wrf(d, n, 8); // FIXME: Figure out what the right number
+                                      //        is here.
+    e10k_vf_vftxdctl_hthresh_wrf(d, n, 0);
+    e10k_vf_vftxdctl_wthresh_wrf(d, n, 0);      // Needs to be 0 for TXHWB
+
+    e10k_vf_vftxdctl_enable_wrf(d, n, 1);
+
+    while (e10k_vf_vftxdctl_enable_rdf(d, n) == 0); // TODO: Timeout
+    DEBUG("[%x] TX queue enabled\n", n);
+
+    // Some initialization stuff from BSD driver
+    e10k_vf_vfdca_txctrl_txdesc_wbro_wrf(d, n, 0);
+
+    idc_write_queue_tails(queues[n].binding);
+}
+
+#if 0
+/** Stop queue. */
+static void queue_hw_stop(uint8_t n)
+{
+#if 0
+    // This process is described in 4.6.7.1.2
+
+    // Disable TX for this queue
+    e10k_txdctl_enable_wrf(d, n, 0);
+
+    // TODO: Flush packet buffers
+    // TODO: Remove all filters
+    // TODO: With RSC we have to wait here (see spec), not used atm
+
+    // Disable RX for this queue
+    e10k_rxdctl_1_enable_wrf(d, n, 0);
+    while (e10k_rxdctl_1_enable_rdf(d, n) != 0); // TODO: Timeout
+
+    // A bit too much, but make sure memory is not used anymore
+    milli_sleep(1);
+#else
+    assert(!"NYI");
+#endif
+}
+#endif
+
+
+/** Stop whole device. */
+static void stop_device(void)
+{
+    DEBUG("Stopping device\n");
+
+    // Disable interrupts
+    e10k_vf_vfeimc_msix_wrf(d, 7);
+    e10k_vf_vfeicr_rd(d);
+
+    // Disable each RX and TX queue
+    for(int i = 0; i < 4; i++) {
+        e10k_vf_vftxdctl_wr(d, i, e10k_vf_vftxdctl_swflsh_insert(0x0, 1));
+    }
+    for(int i = 0; i < 8; i++) {
+        e10k_vf_vfrxdctl_wr(d, i, 0x0);
+    }
+
+    // From BSD driver (not in spec)
+    milli_sleep(2);
+}
+
+static void interrupt_handler_msix(void* arg)
+{
+    DEBUG("MSI-X management interrupt\n");
+    e10k_vf_vfeicr_t eicr = e10k_vf_vfeicr_rd(d);
+
+    eicr &= ~(1 << cdriver_msix);
+
+    // Ensure management MSI-X vector is cleared
+    e10k_vf_vfeicr_wr(d, 1 << cdriver_msix);
+
+    // Reenable interrupt
+    e10k_vf_vfeimc_msix_wrf(d, 1 << (cdriver_msix % 32));
+}
+
+/** Here are the global interrupts handled. */
+static void interrupt_handler(void* arg)
+{
+    e10k_vf_vfeicr_t eicr = e10k_vf_vfeicr_rd(d);
+
+    if (eicr & ((1 << QUEUE_INTRX) | (1 << QUEUE_INTTX))) {
+        e10k_vf_vfeicr_wr(d, eicr);
+        qd_interrupt(!!(eicr & (1 << QUEUE_INTRX)),
+                     !!(eicr & (1 << QUEUE_INTTX)));
+    }
+}
+
+/******************************************************************************/
+/* Management interface implemetation */
+
+/** Send register cap and mac address to queue driver. */
+static void idc_queue_init_data(struct e10k_binding *b,
+                                struct capref registers,
+                                uint64_t macaddr)
+{
+    errval_t r;
+    r = e10k_queue_init_data__tx(b, NOP_CONT, registers, macaddr);
+    // TODO: handle busy
+    assert(err_is_ok(r));
+}
+
+/** Tell queue driver that we are done initializing the queue. */
+static void idc_queue_memory_registered(struct e10k_binding *b)
+{
+    errval_t r;
+    r = e10k_queue_memory_registered__tx(b, NOP_CONT);
+    // TODO: handle busy
+    assert(err_is_ok(r));
+}
+
+/** Send request to queue driver to rewrite the tail pointers of its queues. */
+static void idc_write_queue_tails(struct e10k_binding *b)
+{
+    errval_t r;
+    if (b == NULL) {
+        qd_write_queue_tails(b);
+        return;
+    }
+
+    r = e10k_write_queue_tails__tx(b, NOP_CONT);
+    // TODO: handle busy
+    assert(err_is_ok(r));
+}
+
+#if 0
+/** Signal queue driver that the queue is stopped. */
+static void idc_queue_terminated(struct e10k_binding *b)
+{
+    errval_t r;
+    r = e10k_queue_terminated__tx(b, NOP_CONT);
+    // TODO: handle busy
+    assert(err_is_ok(r));
+}
+#endif
+
+/** Request from queue driver for register memory cap */
+void cd_request_device_info(struct e10k_binding *b)
+{
+    if (b == NULL) {
+        struct capref cr;
+        errval_t err = slot_alloc(&cr);
+        assert(err_is_ok(err));
+        err = cap_copy(cr, *regframe);
+        assert(err_is_ok(err));
+        qd_queue_init_data(b, cr, d_mac);
+        return;
+    }
+    idc_queue_init_data(b, *regframe, d_mac);
+}
+
+/** Request from queue driver to initialize hardware queue. */
+void cd_register_queue_memory(struct e10k_binding *b,
+                              uint8_t n,
+                              struct capref tx_frame,
+                              struct capref txhwb_frame,
+                              struct capref rx_frame,
+                              uint32_t rxbufsz,
+                              int16_t msix_intvec,
+                              uint8_t msix_intdest,
+                              bool use_irq,
+                              bool use_rsc)
+{
+    DEBUG("register_queue_memory(%"PRIu8")\n", n);
+    // TODO: Make sure that rxbufsz is a power of 2 >= 1024
+
+    if (use_irq && msix_intvec != 0 && !msix) {
+        printf("e10k: Queue %d requests MSI-X, but MSI-X is not enabled "
+                " card driver. Ignoring queue\n", n);
+        return;
+    }
+
+    assert(n < 8);
+
+    // Save state so we can restore the configuration in case we need to do a
+    // reset
+    queues[n].enabled = true;
+    queues[n].tx_frame = tx_frame;
+    queues[n].txhwb_frame = txhwb_frame;
+    queues[n].rx_frame = rx_frame;
+    queues[n].tx_head = 0;
+    queues[n].rx_head = 0;
+    queues[n].rxbufsz = rxbufsz;
+    queues[n].msix_index = -1;
+    queues[n].msix_intvec = msix_intvec;
+    queues[n].msix_intdest = msix_intdest;
+    queues[n].binding = b;
+    queues[n].use_irq = use_irq;
+    queues[n].use_rsc = use_rsc;
+
+    queue_hw_init(n);
+
+    if (b == NULL) {
+        qd_queue_memory_registered(b);
+        return;
+    }
+    idc_queue_memory_registered(b);
+}
+
+/** Request from queue driver to initialize hardware queue. */
+void cd_set_interrupt_rate(struct e10k_binding *b,
+                           uint8_t n,
+                           uint16_t rate)
+{
+    DEBUG("set_interrupt_rate(%"PRIu8")\n", n);
+
+#if 0
+    // XXX: interrupt throttle not supported on VF???
+    uint8_t i;
+    e10k_eitrn_t eitr = 0;
+    eitr = e10k_eitrn_itr_int_insert(eitr, rate);
+
+    i = (queues[n].msix_index == -1 ? 0 : queues[n].msix_index);
+    e10k_vf_vfeitr_wr(d, eitr);
+    if (i < 24) {
+        e10k_eitr_l_wr(d, i, eitr);
+    } else {
+        e10k_eitr_h_wr(d, i - 24, eitr);
+    }
+#endif
+}
+
+#if 0
+/**
+ * Request from queue driver to stop hardware queue and free everything
+ * associated with that queue.
+ */
+static void idc_terminate_queue(struct e10k_binding *b, uint8_t n)
+{
+    DEBUG("idc_terminate_queue(q=%d)\n", n);
+
+    queue_hw_stop(n);
+
+    queues[n].enabled = false;
+    queues[n].binding = NULL;
+
+    // TODO: Do we have to free the frame caps, or destroy the binding?
+    idc_queue_terminated(b);
+}
+
+static struct e10k_rx_vtbl rx_vtbl = {
+    .request_device_info = cd_request_device_info,
+    .register_queue_memory = cd_register_queue_memory,
+    .set_interrupt_rate = cd_set_interrupt_rate,
+    .terminate_queue = idc_terminate_queue,
+};
+
+static void export_cb(void *st, errval_t err, iref_t iref)
+{
+    const char *suffix = "_e10kmng";
+    char name[strlen(service_name) + strlen(suffix) + 1];
+
+    assert(err_is_ok(err));
+
+    // Build label for interal management service
+    sprintf(name, "%s%s", service_name, suffix);
+
+    err = nameservice_register(name, iref);
+    assert(err_is_ok(err));
+    DEBUG("Management interface exported\n");
+}
+
+static errval_t connect_cb(void *st, struct e10k_binding *b)
+{
+    DEBUG("New connection on management interface\n");
+    b->rx_vtbl = rx_vtbl;
+    return SYS_ERR_OK;
+}
+
+/**
+ * Initialize management interface for queue drivers.
+ * This has to be done _after_ the hardware is initialized.
+ */
+static void initialize_mngif(void)
+{
+    errval_t r;
+
+    r = e10k_export(NULL, export_cb, connect_cb, get_default_waitset(),
+                    IDC_BIND_FLAGS_DEFAULT);
+    assert(err_is_ok(r));
+}
+#endif
+
+/******************************************************************************/
+/* Initialization code for driver */
+
+/** Callback from pci to initialize a specific PCI device. */
+static void pci_init_card(struct device_mem* bar_info, int bar_count)
+{
+    errval_t err;
+    bool res;
+
+    assert(!initialized);
+
+    d = malloc(sizeof(*d));
+
+    // Map first BAR for register access
+    assert(bar_count >= 1);
+    map_device(&bar_info[0]);
+    regframe = bar_info[0].frame_cap;
+    DEBUG("BAR[0] mapped (v=%llx p=%llx l=%llx)\n",
+            (unsigned long long) bar_info[0].vaddr,
+            (unsigned long long) bar_info[0].paddr,
+            (unsigned long long) bar_info[0].bytes);
+
+    // Initialize Mackerel binding
+    e10k_vf_initialize(d, (void*) bar_info[0].vaddr);
+
+    // Initialize manager for MSI-X vectors
+    if (msix) {
+        DEBUG("Enabling MSI-X interrupts\n");
+        uint16_t msix_count = 0;
+        err = pci_msix_enable(&msix_count);
+        assert(err_is_ok(err));
+        assert(msix_count > 0);
+        DEBUG("MSI-X #vecs=%d\n", msix_count);
+
+        res = bmallocator_init(&msix_alloc, msix_count);
+        assert(res);
+    } else {
+        DEBUG("Using legacy interrupts\n");
+    }
+
+    DEBUG("STATUS = %x\n", e10k_vf_vfstatus_rd(d));
+
+    // Initialize hardware registers etc.
+    DEBUG("Initializing hardware\n");
+    device_init();
+
+    assert(initialized);
+
+    // Tell PF driver
+    err = e10k_vf_client->vtbl.init_done(e10k_vf_client, vf_num);
+    assert(err_is_ok(err));
+
+#if 0
+    // Now we initialize the management interface
+    DEBUG("Initializing management interface\n");
+    initialize_mngif();
+#endif
+}
+
+
+/** Register with PCI */
+static void pci_register(void)
+{
+    errval_t r;
+
+    r = pci_client_connect();
+    assert(err_is_ok(r));
+    DEBUG("connected to pci\n");
+
+    interrupt_handler_fn inthandler;
+
+    if(use_interrupts) {
+        inthandler = interrupt_handler;
+    } else {
+        inthandler = NULL;
+    }
+
+    r = pci_register_driver_irq(pci_init_card, PCI_CLASS_ETHERNET,
+                                PCI_DONT_CARE, PCI_DONT_CARE,
+                                PCI_VENDOR_INTEL, E10K_PCI_DEVID,
+                                pci_bus, pci_device, pci_function,
+                                inthandler, NULL);
+    assert(err_is_ok(r));
+}
+
+static void parse_cmdline(int argc, char **argv)
+{
+    int i;
+
+    for (i = 1; i < argc; i++) {
+        if (strncmp(argv[i], "cardname=", strlen("cardname=") - 1) == 0) {
+            service_name = argv[i] + strlen("cardname=");
+        } else if (strncmp(argv[i], "bus=", strlen("bus=") - 1) == 0) {
+            pci_bus = atol(argv[i] + strlen("bus="));
+        } else if (strncmp(argv[i], "device=", strlen("device=") - 1) == 0) {
+            pci_device = atol(argv[i] + strlen("device="));
+        } else if (strncmp(argv[i], "function=", strlen("function=") - 1) == 0){
+            pci_function = atol(argv[i] + strlen("function="));
+        } else if (strncmp(argv[i], "vf=", strlen("vf=") - 1) == 0){
+            vf_num = atoi(argv[i] + strlen("vf="));
+        } else if (strncmp(argv[i], "msix=", strlen("msix=") - 1) == 0) {
+            msix = !!atol(argv[i] + strlen("msix="));
+            // also pass this to queue driver
+            qd_argument(argv[i]);
+        } else if (strncmp(argv[i], "interrupts=", strlen("interrupts=") - 1) == 0) {
+            use_interrupts = !!atol(argv[i] + strlen("interrupts="));
+            qd_argument(argv[i]);
+        } else {
+            qd_argument(argv[i]);
+        }
+    }
+}
+
+static void vf_bind_cont(void *st, errval_t err, struct e10k_vf_binding *b)
+{
+  assert(err_is_ok(err));
+
+  struct e10k_vf_rpc_client *r = malloc(sizeof(*r));
+  assert(r != NULL);
+  err = e10k_vf_rpc_client_init(r, b);
+  if (err_is_ok(err)) {
+    e10k_vf_client = r;
+  } else {
+    free(r);
+  }
+}
+
+static errval_t e10k_vf_client_connect(void)
+{
+    iref_t iref;
+    errval_t err, err2 = SYS_ERR_OK;
+
+    /* Connect to the pci server */
+    err = nameservice_blocking_lookup("e10k_vf", &iref);
+    if (err_is_fail(err)) {
+        return err;
+    }
+
+    assert(iref != 0);
+
+    /* Setup flounder connection with pci server */
+    err = e10k_vf_bind(iref, vf_bind_cont, &err2, get_default_waitset(),
+                   IDC_BIND_FLAG_RPC_CAP_TRANSFER);
+    if (err_is_fail(err)) {
+        return err;
+    }
+
+    /* XXX: Wait for connection establishment */
+    while (e10k_vf_client == NULL && err2 == SYS_ERR_OK) {
+        messages_wait_and_handle_next();
+    }
+
+    err = e10k_vf_client->vtbl.get_mac_address(e10k_vf_client, vf_num, &d_mac);
+    assert(err_is_ok(err));
+
+    return err2;
+}
+
+#ifndef LIBRARY
+static void eventloop(void)
+{
+    struct waitset *ws;
+
+    ws = get_default_waitset();
+    while (1) {
+        event_dispatch(ws);
+    }
+}
+
+void qd_main(void)
+{
+    eventloop();
+}
+
+void qd_argument(const char *arg) { }
+void qd_interrupt(bool is_rx, bool is_tx) { }
+void qd_queue_init_data(struct e10k_binding *b, struct capref registers,
+        uint64_t macaddr) { }
+void qd_queue_memory_registered(struct e10k_binding *b) { }
+void qd_write_queue_tails(struct e10k_binding *b) { }
+
+int main(int argc, char **argv)
+#else
+int e1000n_driver_init(int argc, char *argv[]);
+int e1000n_driver_init(int argc, char *argv[])
+#endif
+{
+    DEBUG("VF driver started\n");
+    parse_cmdline(argc, argv);
+
+    DEBUG("Connecting to PF driver...\n");
+    e10k_vf_client_connect();
+
+    pci_register();
+
+    while (!initialized) {
+        event_dispatch(get_default_waitset());
+    }
+    qd_main();
+    return 1;
+}
diff --git a/usr/drivers/e10k/sleep.h b/usr/drivers/e10k/sleep.h
index 8534115..74421f6 100644
--- a/usr/drivers/e10k/sleep.h
+++ b/usr/drivers/e10k/sleep.h
@@ -12,7 +12,7 @@
  */
 
 #ifndef __SLEEP_H__
-#define __SLEEP_H_
+#define __SLEEP_H__
 
 void sleep_init(void);
 void cycle_sleep(uint64_t cycles);
diff --git a/usr/fish/Hakefile b/usr/fish/Hakefile
index 1bb3f83..6c074e2 100644
--- a/usr/fish/Hakefile
+++ b/usr/fish/Hakefile
@@ -12,14 +12,14 @@
 
 [ build application { target = "fish",
   		      cFiles = [ "fish.c", "font.c" ],
-		      addLibraries = libDeps ["trace", "skb", "pci", "vfs", "acpi_client"],
+		      addLibraries = libDeps ["trace", "skb", "pci", "vfs", "acpi_client", "lwip" ],
                       flounderExtraBindings = [("acpi", ["rpcclient"])],
   		      flounderBindings = [ "pixels", "acpi" ],
   		      architectures = [ "x86_64", "x86_32" ]
                     },
   build application { target = "fish",
                       cFiles = [ "fish_arm.c", "font.c" ],
-                      addLibraries = libDeps ["trace", "skb", "vfs" ],
+                      addLibraries = libDeps ["trace", "skb", "vfs", "lwip" ],
                       flounderBindings = [ "pixels" ],
                       architectures = [  "armv7" ]
                     }
diff --git a/usr/kaluga/Hakefile b/usr/kaluga/Hakefile
index bbd2a4f..b3354c2 100644
--- a/usr/kaluga/Hakefile
+++ b/usr/kaluga/Hakefile
@@ -17,6 +17,6 @@
                       flounderExtraDefs = [ ("monitor_blocking",["rpcclient"]) ],
                       flounderTHCStubs = [ "octopus" ],
                       addLibraries = libDeps [ "skb", "octopus", "vfs", 
-                                               "spawndomain", "elf", "mm" ],
+                                               "spawndomain", "elf", "mm", "lwip" ],
                       architectures = [ "x86_64", "x86_32", "armv7" ] }
 ]
diff --git a/usr/net-test/Hakefile b/usr/net-test/Hakefile
index 1c0186d..36db632 100644
--- a/usr/net-test/Hakefile
+++ b/usr/net-test/Hakefile
@@ -16,7 +16,7 @@
 
 [ build application { target = "net-test",
                       cFiles = [ "net-test.c" ],
-                      addLibraries = libDeps [ "vfs", "posixcompat" ],
+                      addLibraries = libDeps [ "vfs", "posixcompat", "lwip" ],
                       architectures = [ "x86_64", "scc" ]
                    -- omitCFlags = [ "-Wredundant-decls" ]
                     }
diff --git a/usr/openssh/config.h b/usr/openssh/config.h
index 59384d6..cb77fb6 100644
--- a/usr/openssh/config.h
+++ b/usr/openssh/config.h
@@ -295,7 +295,7 @@
 
 /* Define to 1 if you have the declaration of `SHUT_RD', and to 0 if you
    don't. */
-#define HAVE_DECL_SHUT_RD 0
+#define HAVE_DECL_SHUT_RD 1
 
 /* Define to 1 if you have the declaration of `writev', and to 0 if you don't.
    */
@@ -974,22 +974,22 @@
 #define HAVE_STRUCT_ADDRINFO 1
 
 /* define if you have struct in6_addr data type */
-/* #undef HAVE_STRUCT_IN6_ADDR */
+#define HAVE_STRUCT_IN6_ADDR 1
 
 /* define if you have struct sockaddr_in6 data type */
-/* #undef HAVE_STRUCT_SOCKADDR_IN6 */
+#define HAVE_STRUCT_SOCKADDR_IN6 1
 
 /* Define to 1 if `sin6_scope_id' is a member of `struct sockaddr_in6'. */
 /* #undef HAVE_STRUCT_SOCKADDR_IN6_SIN6_SCOPE_ID */
 
 /* define if you have struct sockaddr_storage data type */
-/* #undef HAVE_STRUCT_SOCKADDR_STORAGE */
+#define HAVE_STRUCT_SOCKADDR_STORAGE 1
 
 /* Define to 1 if `st_blksize' is a member of `struct stat'. */
 #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
 
 /* Define to 1 if the system has the type `struct timespec'. */
-/* #undef HAVE_STRUCT_TIMESPEC */
+#define HAVE_STRUCT_TIMESPEC 1
 
 /* define if you have struct timeval */
 #define HAVE_STRUCT_TIMEVAL 1
diff --git a/usr/pci/Hakefile b/usr/pci/Hakefile
index 02cfbea..0d540a3 100644
--- a/usr/pci/Hakefile
+++ b/usr/pci/Hakefile
@@ -1,5 +1,5 @@
 --------------------------------------------------------------------------
--- Copyright (c) 2007-2012, ETH Zurich.
+-- Copyright (c) 2007-2013, ETH Zurich.
 -- All rights reserved.
 --
 -- This file is distributed under the terms in the attached LICENSE file.
@@ -18,7 +18,7 @@
                       flounderBindings = [ "pci", "acpi", "octopus" ],
                       flounderExtraBindings = [("acpi", ["rpcclient"])],
                                             
-                      mackerelDevices = [ "pci_hdr0", "pci_hdr1", "ht_config" ],
+                      mackerelDevices = [ "pci_hdr0", "pci_hdr1", "ht_config", "pci_sr_iov_cap" ],
                       cFiles = [ "pcimain.c", "pci.c", "pci_service.c", 
                                  "ht_config.c", "pcie.c", "pci_msix.c" ],
                       addCFlags = [ "-Wno-redundant-decls" ],
diff --git a/usr/pci/pci.c b/usr/pci/pci.c
index 634616c..a221bb4 100644
--- a/usr/pci/pci.c
+++ b/usr/pci/pci.c
@@ -19,12 +19,14 @@
 #include <stdlib.h>
 
 #include <barrelfish/barrelfish.h>
+#include <barrelfish/deferred.h>
 
 #include <pci/devids.h>
 #include <mm/mm.h>
 #include <skb/skb.h>
 #include <octopus/getset.h>
 #include <acpi_client/acpi_client.h>
+#include <dev/pci_sr_iov_cap_dev.h>
 
 #include "pci.h"
 #include "driver_mapping.h"
@@ -32,11 +34,12 @@
 #include "ht_config_dev.h"
 #include "pci_debug.h"
 
+#define MIN(a,b)        ((a) < (b) ? (a) : (b))
+
 #define BAR_PROBE       0xffffffff
 
 #define PAGE_BITS BASE_PAGE_BITS
 
-
 struct device_caps {
     struct capref *phys_cap;
     struct capref *frame_cap;
@@ -48,7 +51,8 @@ struct device_caps {
 };
 
 struct device_caps dev_caps[PCI_NBUSES][PCI_NDEVICES][PCI_NFUNCTIONS][PCI_NBARS];
-
+const char *skb_bridge_program = "bridge_page";
+uint16_t max_numvfs = 256;
 
 static void query_bars(pci_hdr0_t devhdr, struct pci_address addr,
                        bool pci2pci_bridge);
@@ -422,30 +426,69 @@ void pci_enable_interrupt_for_device(uint32_t bus, uint32_t dev, uint32_t fun,
     pci_hdr0_command_wr(&hdr, cmd);
 }
 
-
-
-struct bridge_chain {
-    struct pci_address addr;
-    struct bridge_chain *next;
-};
-
-static struct bridge_chain *bridges;
-
+/**
+ * This function performs a recursive, depth-first search through the
+ * PCI hierarchy starting at parentaddr (this should initially be a
+ * PCI root complex), with bus number A. It enters whatever it
+ * discovers (bridges and devices) into the SKB.
+ *
+ * Refer to http://www.tldp.org/LDP/tlk/dd/pci.html for an overview of
+ * a similar discovery algorithm.
+ *
+ * Upon discovery of a bridge, it sets the bridge's primary bus number
+ * to A and assigns a secondary bus number of A + 2. The subordinate
+ * bus number is set to A + 3. This way, buses are spaced 2 apart,
+ * which is sometimes required for SR-IOV hot-plugged buses.
+ */
 static void assign_bus_numbers(struct pci_address parentaddr, uint8_t *busnum,
                                uint8_t maxchild, char* handle)
 {
     struct pci_address addr = { .bus = parentaddr.bus };
 
+    pcie_enable();
+
+    // First go through all bridges on this bus and disable them
+    for (addr.device = 0; addr.device < PCI_NDEVICES; addr.device++) {
+        for (addr.function = 0; addr.function < PCI_NFUNCTIONS; addr.function++) {
+	  pci_hdr1_t bhdr;
+	  pci_hdr1_initialize(&bhdr, addr);
+
+	  uint16_t vendor = pci_hdr1_vendor_id_rd(&bhdr);
+
+	  if (vendor == 0xffff) {
+	    if (addr.function == 0) {
+	      // this device doesn't exist at all
+	      break;
+	    } else {
+	      // this function doesn't exist, but there may be others
+	      continue;
+	    }
+	  }
+
+	  pci_hdr1_hdr_type_t hdr_type = pci_hdr1_hdr_type_rd(&bhdr);
+	  if (hdr_type.fmt == pci_hdr1_pci2pci) {
+	    PCI_DEBUG("Disabling bridge (%u,%u,%u)\n",
+		      addr.bus, addr.device, addr.function);
+
+	    pci_hdr1_bcfg_t bcfg = pci_hdr1_bcfg_rd(&bhdr);
+	    bcfg.pri_bus = 0;
+	    bcfg.sec_bus = 0;
+	    bcfg.sub_bus = 0;
+	    pci_hdr1_bcfg_wr(&bhdr, bcfg);
+	  }
+	}
+    }
+
     for (addr.device = 0; addr.device < PCI_NDEVICES; addr.device++) {
         for (addr.function = 0; addr.function < PCI_NFUNCTIONS; addr.function++) {
             pci_hdr0_t hdr;
             pci_hdr0_initialize(&hdr, addr);
 
-
             pcie_enable();
             uint16_t pcie_vendor = pci_hdr0_vendor_id_rd(&hdr);
             uint16_t vendor = pcie_vendor; 
             bool pcie = true;
+	    bool extended_caps = false;	// Whether to scan for PCI Express extended caps
 
             // Disable PCIe if device exists only in PCI
             if(pcie_vendor != 0xffff) {
@@ -469,14 +512,13 @@ static void assign_bus_numbers(struct pci_address parentaddr, uint8_t *busnum,
             pci_hdr0_class_code_t classcode = pci_hdr0_class_code_rd(&hdr);
             uint16_t device_id = pci_hdr0_device_id_rd(&hdr);
 
-
             /* Disable all decoders for this device,
              * they will be re-enabled as devices are setup.
              * NB: we are using "pci_hdr1" here, but the command field is
              * common to all configuration header types.
              */
-            PCI_DEBUG("disabling decoders for (%hhu,%hhu,%hhu)\n",
-                addr.bus, addr.device, addr.function);
+            /* PCI_DEBUG("disabling decoders for (%hhu,%hhu,%hhu)\n", */
+            /*     addr.bus, addr.device, addr.function); */
             pci_hdr0_command_t cmd = pci_hdr0_command_rd(&hdr);
 
             cmd.mem_space = 0;
@@ -501,7 +543,7 @@ static void assign_bus_numbers(struct pci_address parentaddr, uint8_t *busnum,
                 //ACPI_HANDLE child;
                 char* child = NULL;
                 errval_t error_code;
-                PCI_DEBUG("get irg table for (%hhu,%hhu,%hhu)\n", (*busnum) + 1,
+                PCI_DEBUG("get irq table for (%hhu,%hhu,%hhu)\n", (*busnum) + 1,
                         addr.device, addr.function);
                 struct acpi_rpc_client* cl = get_acpi_rpc_client();
                 // XXX: why do we have two different types for the same thing?
@@ -517,54 +559,27 @@ static void assign_bus_numbers(struct pci_address parentaddr, uint8_t *busnum,
 					assert(!"Check ACPI code");
                 }
 
-                ++*busnum;
+		// Increase by 2 to leave room for SR-IOV
+		(*busnum) += 2;
                 assert(*busnum <= maxchild);
 
-                PCI_DEBUG("found bridge at bus %3d dev %2d fn %d: secondary %3d\n",
-                       addr.bus, addr.device, addr.function, *busnum);
+                PCI_DEBUG("program busses for bridge (%hhu,%hhu,%hhu)\n"
+			  "primary: %hhu, secondary: %hhu, subordinate: %hhu\n",
+			  addr.bus, addr.device, addr.function,
+			  addr.bus, *busnum, (*busnum) + 1);
 
-#if 0
-                // PCI Express bridges must have an extended capability pointer
-                assert(pci_hdr1_status_rd(&bhdr).caplist);
+		// Disable master abort mode on the bridge
+		pci_hdr1_brdg_ctrl_mabort_wrf(&bhdr, 0);
 
-                uint8_t cap_ptr = pci_hdr1_cap_ptr_rd(&bhdr);
-                while (cap_ptr != 0) {
-                    assert(cap_ptr % 4 == 0 && cap_ptr >= 0x40 && cap_ptr < 0x100);
-                    uint32_t capword = pci_read_conf_header(&addr, cap_ptr / 4);
-                    if ((capword & 0xff) == 0x10) { // Check Cap ID
-                        uint16_t capreg = capword >> 16;
-                        uint8_t devport_type = (capreg >> 4) & 0xf;
-
-                        PCI_DEBUG("PCIe device port type 0x%x\n", devport_type);
-                        break;
-                    }
-                    cap_ptr = (capword >> 8) & 0xff;
-                }
-#endif
+		// Clear all errors
+		pci_hdr1_status_wr_raw(&bhdr, 0);
 
-                PCI_DEBUG("program busses for bridge (%hhu,%hhu,%hhu)\n"
-                        "primary: %hhu, secondary: %hhu, subordinate: %hhu\n",
-                    addr.bus, addr.device, addr.function,
-                    addr.bus, *busnum, *busnum);
                 // program bus numbers for this bridge
-                pci_hdr1_pri_bus_wr(&bhdr, addr.bus);
-                pci_hdr1_sec_bus_wr(&bhdr, *busnum);
-                pci_hdr1_sub_bus_wr(&bhdr, *busnum);
-                //reprogramm the subordinate of all above bridges
-                struct bridge_chain *tmp = bridges;
-                while (tmp != NULL) {
-                    pci_hdr1_t tmphdr;
-                    pci_hdr1_initialize(&tmphdr, tmp->addr);
-                    pci_hdr1_sub_bus_wr(&tmphdr, *busnum);
-                    tmp = tmp->next;
-                }
-                //add the current bridge to the bridges stack so that the
-                //following recursive call to assign_bus_numbers can reprogram
-                //this bridge as well with the new subordinate
-                tmp = (struct bridge_chain*)malloc(sizeof(struct bridge_chain));
-                tmp->addr = addr;
-                tmp->next = bridges;
-                bridges = tmp;
+		pci_hdr1_bcfg_t bcfg = pci_hdr1_bcfg_rd(&bhdr);
+		bcfg.pri_bus = addr.bus;
+		bcfg.sec_bus = *busnum;
+		bcfg.sub_bus = 0xff;
+		pci_hdr1_bcfg_wr(&bhdr, bcfg);
 
                 skb_add_fact("bridge(%s,addr(%u,%u,%u),%u,%u,%u,%u,%u, secondary(%hhu)).",
                              (pcie ? "pcie" : "pci"),
@@ -575,7 +590,6 @@ static void assign_bus_numbers(struct pci_address parentaddr, uint8_t *busnum,
                 //use the original hdr (pci_hdr0_t) here
                 query_bars(hdr, addr, true);
 
-
                 // assign bus numbers to secondary bus
                 struct pci_address bridge_addr= {
                     .bus = *busnum, .device = addr.device,
@@ -589,23 +603,16 @@ static void assign_bus_numbers(struct pci_address parentaddr, uint8_t *busnum,
                 } else {
                     pcie_disable();
                 }
-                //remove the current bridge from the bridges stack
-                if (bridges != NULL) {
-                    tmp = bridges;
-                    bridges = bridges->next;
-                    free(tmp);
-                }
-/*
-                printf("reprogram subordinate for bridge (%hhu,%hhu,%hhu): "
-                        "subordinate: %hhu\n", addr.bus, addr.device,
-                        addr.function, *busnum);
-                pci_hdr1_sub_bus_wr(&bhdr, *busnum);
-*/
-            }
 
+		// Set this bridge's subordinate to the maximum of the underlying hierarchy
+		pci_hdr1_bcfg_sub_bus_wrf(&bhdr, (*busnum) + 1);
+            }
 
             //is this a normal PCI device?
             if (hdr_type.fmt == pci_hdr0_nonbridge) {
+	      PCI_DEBUG("Found device (%u, %u, %u), vendor = %x, device = %x\n",
+			addr.bus, addr.device, addr.function, vendor, device_id);
+
                 pci_hdr0_t devhdr;
                 pci_hdr0_initialize(&devhdr, addr);
                 skb_add_fact("device(%s,addr(%u,%u,%u),%u,%u,%u, %u, %u, %d).",
@@ -632,8 +639,256 @@ static void assign_bus_numbers(struct pci_address parentaddr, uint8_t *busnum,
                 // end octopus
 
                 query_bars(devhdr, addr, false);
-            }
 
+                // Process device capabilities if existing
+                if(pci_hdr0_status_rd(&devhdr).caplist) {
+		  uint8_t cap_ptr = pci_hdr0_cap_ptr_rd(&devhdr);
+
+		  // Walk capabilities list
+		  while (cap_ptr != 0) {
+                    assert(cap_ptr % 4 == 0 && cap_ptr >= 0x40 && cap_ptr < 0x100);
+                    uint32_t capword = pci_read_conf_header(&addr, cap_ptr / 4);
+
+		    switch(capword & 0xff) {
+		    case 0x10:	// PCI Express
+		      PCI_DEBUG("PCI Express device\n");
+		      extended_caps = true;
+		      break;
+
+		    default:
+		      PCI_DEBUG("Unknown PCI device capability 0x%x at 0x%x\n",
+				capword & 0xff, cap_ptr);
+		      break;
+		    }
+
+                    cap_ptr = (capword >> 8) & 0xff;
+		  }
+		}
+
+                // Process extended device capabilities if existing
+                if(pcie && extended_caps) {
+		  uint32_t *ad = (uint32_t *)pcie_confspace_access(addr);
+		  assert(ad != NULL);
+		  uint16_t cap_ptr = 0x100;
+
+		  while(cap_ptr != 0) {
+		    uint32_t capword = *(ad + (cap_ptr / 4));
+		    assert(cap_ptr % 4 == 0 && cap_ptr >= 0x100 && cap_ptr < 0x1000);
+
+		    switch(capword & 0xffff) {	// Switch on capability ID
+		    case 0:
+		      // No extended caps
+		      break;
+
+		    case 16:
+		      // SR-IOV capability
+		      {
+			pci_sr_iov_cap_t sr_iov_cap;
+			pci_sr_iov_cap_initialize(&sr_iov_cap,
+						  (mackerel_addr_t)(ad + (cap_ptr / 4)));
+
+			PCI_DEBUG("Found SR-IOV capability\n");
+
+			// Support version 1 for the moment
+			assert(pci_sr_iov_cap_hdr_ver_rdf(&sr_iov_cap) == 1);
+
+			// Support system page size of 4K at the moment
+			assert(pci_sr_iov_cap_sys_psize_rd(&sr_iov_cap) == 1);
+
+#if 0	// Dump cap contents
+			pci_sr_iov_cap_caps_pr(str, 256, &sr_iov_cap);
+			PCI_DEBUG("%s\n", str);
+			pci_sr_iov_cap_ctrl_pr(str, 256, &sr_iov_cap);
+			PCI_DEBUG("%s\n", str);
+			pci_sr_iov_cap_status_pr(str, 256, &sr_iov_cap);
+			PCI_DEBUG("%s\n", str);
+			pci_sr_iov_cap_initialvfs_pr(str, 256, &sr_iov_cap);
+			PCI_DEBUG("%s\n", str);
+			pci_sr_iov_cap_totalvfs_pr(str, 256, &sr_iov_cap);
+			PCI_DEBUG("%s\n", str);
+			pci_sr_iov_cap_numvfs_pr(str, 256, &sr_iov_cap);
+			PCI_DEBUG("%s\n", str);
+			pci_sr_iov_cap_fdl_pr(str, 256, &sr_iov_cap);
+			PCI_DEBUG("%s\n", str);
+			pci_sr_iov_cap_offset_pr(str, 256, &sr_iov_cap);
+			PCI_DEBUG("%s\n", str);
+			pci_sr_iov_cap_stride_pr(str, 256, &sr_iov_cap);
+			PCI_DEBUG("%s\n", str);
+			pci_sr_iov_cap_devid_pr(str, 256, &sr_iov_cap);
+			PCI_DEBUG("%s\n", str);
+			pci_sr_iov_cap_sup_psize_pr(str, 256, &sr_iov_cap);
+			PCI_DEBUG("%s\n", str);
+			pci_sr_iov_cap_sys_psize_pr(str, 256, &sr_iov_cap);
+			PCI_DEBUG("%s\n", str);
+#endif
+
+                        if(max_numvfs > 0) {
+                            // Set maximum number of VFs
+                            uint16_t totalvfs = pci_sr_iov_cap_totalvfs_rd(&sr_iov_cap);
+                            uint16_t numvfs = MIN(totalvfs, max_numvfs);
+                            //			uint16_t numvfs = 8;
+                            PCI_DEBUG("Maximum supported VFs: %u. Enabling: %u\n",
+                                      totalvfs, numvfs);
+                            pci_sr_iov_cap_numvfs_wr(&sr_iov_cap, numvfs);
+
+                            uint16_t offset = pci_sr_iov_cap_offset_rd(&sr_iov_cap);
+                            uint16_t stride = pci_sr_iov_cap_stride_rd(&sr_iov_cap);
+                            uint16_t vf_devid = pci_sr_iov_cap_devid_rd(&sr_iov_cap);
+
+                            PCI_DEBUG("VF offset is 0x%x, stride is 0x%x, device ID is 0x%x\n",
+                                      offset, stride, vf_devid);
+
+#if 0
+                            // Make sure we enable the PF
+                            cmd = pci_hdr0_command_rd(&hdr);
+                            cmd.mem_space = 1;
+                            cmd.io_space = 1;
+                            /* cmd.master = 1; */
+                            pci_hdr0_command_wr(&hdr, cmd);
+#endif
+
+                            // Start VFs (including memory spaces)
+                            pci_sr_iov_cap_ctrl_vf_mse_wrf(&sr_iov_cap, 1);
+                            pci_sr_iov_cap_ctrl_vf_enable_wrf(&sr_iov_cap, 1);
+
+                            // Spec says to wait here for at least 100ms
+                            err = barrelfish_usleep(100000);
+                            assert(err_is_ok(err));
+
+                            // Add all VFs
+                            for(int vfn = 0; vfn < numvfs; vfn++) {
+                                uint8_t busnr = addr.bus +
+                                    ((((addr.device << 3) + addr.function) + offset + stride * vfn) >> 8);
+                                uint8_t devfn = (((addr.device << 3) + addr.function) + offset + stride * vfn) & 0xff;
+                                struct pci_address vf_addr = {
+                                    .bus = busnr,
+                                    .device = devfn >> 3,
+                                    .function = devfn & 7,
+                                };
+
+                                PCI_DEBUG("Adding VF (%u, %u, %u)\n",
+                                          vf_addr.bus, vf_addr.device, vf_addr.function);
+
+                                skb_add_fact("device(%s,addr(%u,%u,%u),%u,%u,%u, %u, %u, %d).",
+                                             (pcie ? "pcie" : "pci"),
+                                             vf_addr.bus, vf_addr.device, vf_addr.function,
+                                             vendor, vf_devid, classcode.clss,
+                                             classcode.subclss, classcode.prog_if,
+                                             0);
+
+                                // octopus start
+                                device_fmt = "hw.pci.device. { "
+                                    "bus: %u, device: %u, function: %u, "
+                                    "vendor: %u, device_id: %u, class: %u, "
+                                    "subclass: %u, prog_if: %u }";
+                                err = oct_mset(SET_SEQUENTIAL, device_fmt,
+                                               vf_addr.bus, vf_addr.device, vf_addr.function, vendor,
+                                               vf_devid, classcode.clss, classcode.subclss,
+                                               classcode.prog_if);
+
+                                assert(err_is_ok(err));
+                                // end octopus
+
+                                // We probe the BARs several times. Strictly
+                                // speaking, this is not necessary, as we
+                                // can calculate all offsets, but we're
+                                // lazy...
+                                pci_hdr0_bar32_t bar, barorigaddr;
+                                for(int i = 0; i < pci_sr_iov_cap_vf_bar_length; i++) {
+                                    union pci_hdr0_bar32_un orig_value;
+                                    orig_value.raw = pci_sr_iov_cap_vf_bar_rd(&sr_iov_cap, i);
+                                    barorigaddr = orig_value.val;
+
+                                    // probe BAR to see if it is implemented
+                                    pci_sr_iov_cap_vf_bar_wr(&sr_iov_cap, i, BAR_PROBE);
+
+                                    bar = (union pci_hdr0_bar32_un){
+                                        .raw = pci_sr_iov_cap_vf_bar_rd(&sr_iov_cap, i) }.val;
+
+                                    //write original value back to the BAR
+                                    pci_sr_iov_cap_vf_bar_wr(&sr_iov_cap, i, orig_value.raw);
+
+                                    if (bar.base == 0) {
+                                        // BAR not implemented
+                                        continue;
+                                    }
+
+                                    // SR-IOV doesn't support IO space BARs
+                                    assert(bar.space == 0);
+                                    int type = -1;
+                                    if (bar.tpe == pci_hdr0_bar_32bit) {
+                                        type = 32;
+                                    }
+                                    if (bar.tpe == pci_hdr0_bar_64bit) {
+                                        type = 64;
+                                    }
+
+                                    if (bar.tpe == pci_hdr0_bar_64bit) {
+                                        //read the upper 32bits of the address
+                                        pci_hdr0_bar32_t bar_high, barorigaddr_high;
+                                        union pci_hdr0_bar32_un orig_value_high;
+                                        orig_value_high.raw = pci_sr_iov_cap_vf_bar_rd(&sr_iov_cap, i + 1);
+                                        barorigaddr_high = orig_value_high.val;
+
+                                        // probe BAR to determine the mapping size
+                                        pci_sr_iov_cap_vf_bar_wr(&sr_iov_cap, i + 1, BAR_PROBE);
+
+                                        bar_high = (union pci_hdr0_bar32_un){
+                                            .raw = pci_sr_iov_cap_vf_bar_rd(&sr_iov_cap, i + 1) }.val;
+
+                                        //write original value back to the BAR
+                                        pci_sr_iov_cap_vf_bar_wr(&sr_iov_cap, i + 1, orig_value_high.raw);
+
+                                        pciaddr_t base64 = bar_high.base;
+                                        base64 <<= 32;
+                                        base64 |= bar.base;
+
+                                        pciaddr_t origbase64 = barorigaddr_high.base;
+                                        origbase64 <<= 32;
+                                        origbase64 |= barorigaddr.base;
+
+                                        PCI_DEBUG("(%u,%u,%u): 64bit BAR %d at 0x%" PRIxPCIADDR ", size %" PRIx64 ", %s\n",
+                                                  vf_addr.bus, vf_addr.device, vf_addr.function,
+                                                  i, (origbase64 << 7) + bar_mapping_size64(base64) * vfn, bar_mapping_size64(base64),
+                                                  (bar.prefetch == 1 ? "prefetchable" : "nonprefetchable"));
+
+                                        skb_add_fact("bar(addr(%u, %u, %u), %d, 16'%"PRIxPCIADDR", "
+                                                     "16'%" PRIx64 ", vf, %s, %d).",
+                                                     vf_addr.bus, vf_addr.device, vf_addr.function,
+                                                     i, (origbase64 << 7) + bar_mapping_size64(base64) * vfn, bar_mapping_size64(base64),
+                                                     (bar.prefetch == 1 ? "prefetchable" : "nonprefetchable"),
+                                                     type);
+
+                                        i++; //step one forward, because it is a 64bit BAR
+                                    } else {
+                                        PCI_DEBUG("(%u,%u,%u): 32bit BAR %d at 0x%" PRIx32 ", size %x, %s\n",
+                                                  vf_addr.bus, vf_addr.device, vf_addr.function,
+                                                  i, (barorigaddr.base << 7) + bar_mapping_size(bar) * vfn, bar_mapping_size(bar),
+                                                  (bar.prefetch == 1 ? "prefetchable" : "nonprefetchable"));
+
+                                        //32bit BAR
+                                        skb_add_fact("bar(addr(%u, %u, %u), %d, 16'%"PRIx32", 16'%" PRIx32 ", vf, %s, %d).",
+                                                     vf_addr.bus, vf_addr.device, vf_addr.function,
+                                                     i, (uint32_t)((barorigaddr.base << 7) + bar_mapping_size(bar) * vfn), (uint32_t)bar_mapping_size(bar),
+                                                     (bar.prefetch == 1 ? "prefetchable" : "nonprefetchable"),
+                                                     type);
+                                    }
+                                }
+                            }
+                        }
+		      }
+		      break;
+
+		    default:
+		      PCI_DEBUG("Unknown extended PCI device capability 0x%x at 0x%x\n",
+				capword & 0xffff, cap_ptr);
+		      break;
+		    }
+
+		    cap_ptr = capword >> 20;
+		  }
+		}
+            }
 
             // is this a multi-function device?
             if (addr.function == 0 && !hdr_type.multi) {
@@ -645,11 +900,57 @@ static void assign_bus_numbers(struct pci_address parentaddr, uint8_t *busnum,
     free(handle);
 }
 
+#if 0
+static void get_bridges(struct pci_address myad)
+{
+    struct pci_address addr = { .bus = myad.bus };
+
+    pcie_enable();
+
+    // First go through all bridges on this bus and disable them
+    for (addr.device = 0; addr.device < PCI_NDEVICES; addr.device++) {
+        for (addr.function = 0; addr.function < PCI_NFUNCTIONS; addr.function++) {
+	  pci_hdr1_t bhdr;
+	  pci_hdr1_initialize(&bhdr, addr);
+
+	  uint16_t vendor = pci_hdr1_vendor_id_rd(&bhdr);
+
+	  if (vendor == 0xffff) {
+	    if (addr.function == 0) {
+	      // this device doesn't exist at all
+	      break;
+	    } else {
+	      // this function doesn't exist, but there may be others
+	      continue;
+	    }
+	  }
+
+	  pci_hdr1_hdr_type_t hdr_type = pci_hdr1_hdr_type_rd(&bhdr);
+	  if (hdr_type.fmt == pci_hdr1_pci2pci) {
+	    pci_hdr1_bcfg_t bcfg = pci_hdr1_bcfg_rd(&bhdr);
+
+	    PCI_DEBUG("Found bridge (%u,%u,%u), primary %u, secondary %u, subordinate %u\n",
+		      addr.bus, addr.device, addr.function,
+		      bcfg.pri_bus, bcfg.sec_bus, bcfg.sub_bus);
+
+	    struct pci_address bridge_addr= {
+	      .bus = bcfg.sec_bus, .device = addr.device,
+	      .function = addr.function
+	    };
+	    
+	    get_bridges(bridge_addr);
+	  }
+	}
+    }
+}
+#endif
+
 void pci_add_root(struct pci_address addr, uint8_t maxchild, char* handle)
 {
-    bridges = NULL;
     uint8_t busnum = addr.bus;
+    /* get_bridges(addr); */
     assign_bus_numbers(addr, &busnum, maxchild, handle);
+    /* get_bridges(addr); */
 }
 
 errval_t pci_setup_root_complex(void)
@@ -780,6 +1081,11 @@ static void query_bars(pci_hdr0_t devhdr, struct pci_address addr,
                 origbase64 <<= 32;
                 origbase64 |= barorigaddr.base;
 
+	      PCI_DEBUG("(%u,%u,%u): 64bit BAR %d at 0x%" PRIxPCIADDR ", size %" PRIx64 ", %s\n",
+			addr.bus, addr.device, addr.function,
+			i, origbase64 << 7, bar_mapping_size64(base64),
+			(bar.prefetch == 1 ? "prefetchable" : "nonprefetchable"));
+
                 skb_add_fact("bar(addr(%u, %u, %u), %d, 16'%"PRIxPCIADDR", "
                              "16'%" PRIx64 ", mem, %s, %d).",
                              addr.bus, addr.device, addr.function,
@@ -789,6 +1095,11 @@ static void query_bars(pci_hdr0_t devhdr, struct pci_address addr,
 
                 i++; //step one forward, because it is a 64bit BAR
             } else {
+	      PCI_DEBUG("(%u,%u,%u): 32bit BAR %d at 0x%" PRIx32 ", size %x, %s\n",
+			addr.bus, addr.device, addr.function,
+			i, barorigaddr.base << 7, bar_mapping_size(bar),
+			(bar.prefetch == 1 ? "prefetchable" : "nonprefetchable"));
+
                 //32bit BAR
                 skb_add_fact("bar(addr(%u, %u, %u), %d, 16'%"PRIx32", 16'%" PRIx32 ", mem, %s, %d).",
                              addr.bus, addr.device, addr.function,
@@ -797,6 +1108,9 @@ static void query_bars(pci_hdr0_t devhdr, struct pci_address addr,
                              type);
             }
         } else {
+	  PCI_DEBUG("(%u,%u,%u): IO BAR %d at 0x%x, size %x\n",
+		    addr.bus, addr.device, addr.function,
+		    i, barorigaddr.base << 7, bar_mapping_size(bar));
             //bar(addr(bus, device, function), barnr, orig address, size, space).
             //where space = mem | io
             skb_add_fact("bar(addr(%u, %u, %u), %d, 16'%"PRIx32", 16'%" PRIx32 ", io, "
@@ -847,8 +1161,13 @@ static void program_bridge_window(uint8_t bus, uint8_t dev, uint8_t fun,
         } else {
             assert((base & 0xffffffff00000000) == 0);
             assert((high & 0xffffffff00000000) == 0);
-            pci_hdr1_mem_base_wr(&bridgehdr, base >> 16);
-            pci_hdr1_mem_limit_wr(&bridgehdr, high >> 16);
+	    pci_hdr1_membl_t membl = {
+	      .base = base >> 16,
+	      .limit = high >> 16,
+	    };
+	    pci_hdr1_membl_wr(&bridgehdr, membl);
+            /* pci_hdr1_mem_base_wr(&bridgehdr, base >> 16); */
+            /* pci_hdr1_mem_limit_wr(&bridgehdr, high >> 16); */
         }
         // enable the memory decoder
         cmd.mem_space = 1;
@@ -932,7 +1251,6 @@ static void enable_busmaster(uint8_t bus, uint8_t dev, uint8_t fun, bool pcie)
     pci_hdr0_command_wr(&devhdr, cmd);
 }
 
-
 void pci_program_bridges(void)
 {
     char element_type[7]; // "device" | "bridge"
@@ -975,9 +1293,11 @@ void pci_program_bridges(void)
 
     output = NULL;
     output_length = 0;
-    skb_execute("[bridge_page], bridge_programming(P, Nr),"
-                       "flatten(P, F),replace_current_BAR_values(F),"
-                       "write(nrelements(Nr)),writeln(P).");
+    char bridge_program[512];
+    snprintf(bridge_program, 512, "[%s], bridge_programming(P, Nr),"
+             "flatten(P, F),replace_current_BAR_values(F),"
+             "write(nrelements(Nr)),writeln(P).", skb_bridge_program);
+    skb_execute(bridge_program);
     output = skb_get_output();
     assert(output != NULL);
     output_length = strlen(output);
@@ -1108,6 +1428,14 @@ void pci_program_bridges(void)
         } else {
             pref = false;
         }
+
+	// Skip virtual functions
+        if (strncmp(space, "vf", strlen("vf")) == 0) {
+	  /* PCI_DEBUG("Skipping VF addr(%hhu, %hhu, %hhu)\n", */
+	  /* 	    bus, dev, fun); */
+	  continue;
+	}
+
         if(strncmp(element_type, "device", strlen("device"))== 0) {
             nr_conversions = sscanf(bar_secondary, "%d", &bar);
             if (nr_conversions != 1) {
@@ -1116,9 +1444,9 @@ void pci_program_bridges(void)
             }
             PCI_DEBUG("programming %s addr(%hhu, %hhu, %hhu), BAR %d, with base = "
                "%"PRIxPCIADDR", high = %"PRIxPCIADDR", size = %"PRIxPCISIZE" in"
-               "space = %s, prefetch = %s...\n",
-               element_type, bus, dev, fun, bar, base, high,
-               size, space, prefetch);
+               "space = %s, prefetch = %s, %s...\n",
+		      element_type, bus, dev, fun, bar, base, high,
+		      size, space, prefetch, pcie ? "PCIe" : "PCI");
             program_device_bar(bus, dev, fun, bar, base, size, bits, mem, pcie);
 
         } else {
@@ -1133,7 +1461,7 @@ void pci_program_bridges(void)
             program_bridge_window(bus, dev, fun,
                                   base, high,
                                   pcie, mem, pref);
-        }
+	}
     }
 }
 
diff --git a/usr/pci/pci.h b/usr/pci/pci.h
index 12cb4fa..0ed520e 100644
--- a/usr/pci/pci.h
+++ b/usr/pci/pci.h
@@ -4,7 +4,7 @@
  */
 
 /*
- * Copyright (c) 2007, 2008, 2009, 2011, ETH Zurich.
+ * Copyright (c) 2007, 2008, 2009, 2011, 2014, ETH Zurich.
  * All rights reserved.
  *
  * This file is distributed under the terms in the attached LICENSE file.
@@ -74,4 +74,7 @@ errval_t pci_msix_enable(struct pci_address *addr, uint16_t *count);
 errval_t pci_msix_vector_init(struct pci_address *addr, uint16_t idx,
                               uint8_t destination, uint8_t vector);
 
+extern const char *skb_bridge_program;
+extern uint16_t max_numvfs;
+
 #endif // PCI_H_
diff --git a/usr/pci/pcie.c b/usr/pci/pcie.c
index 025801c..2f56181 100644
--- a/usr/pci/pcie.c
+++ b/usr/pci/pcie.c
@@ -51,7 +51,7 @@ errval_t pcie_setup_confspace(void) {
             return error_code;
         }
 
-        PCI_DEBUG("calling confspace init with: %"PRIu64", %"PRIu16", %"PRIu8", %"PRIu8"",
+        PCI_DEBUG("calling confspace init with: %"PRIu64", %"PRIu16", %"PRIu8", %"PRIu8"\n",
                 address, segment, sbus, ebus);
         int r = pcie_confspace_init(pcie_cap, address, segment, sbus, ebus);
         assert(r == 0);
diff --git a/usr/pci/pcimain.c b/usr/pci/pcimain.c
index f0ec4aa..5a9696c 100644
--- a/usr/pci/pcimain.c
+++ b/usr/pci/pcimain.c
@@ -4,7 +4,7 @@
  */
 
 /*
- * Copyright (c) 2007, 2008, 2009, 2011, ETH Zurich.
+ * Copyright (c) 2007, 2008, 2009, 2011, 2014, ETH Zurich.
  * All rights reserved.
  *
  * This file is distributed under the terms in the attached LICENSE file.
@@ -56,6 +56,17 @@ int main(int argc, char *argv[])
 {
     errval_t err;
 
+    // Parse commandline arguments
+    for(int i = 1; i < argc; i++) {
+        if(!strncmp(argv[i], "skb_bridge_program=", strlen("skb_bridge_program="))) {
+            skb_bridge_program = argv[i] + strlen("skb_bridge_program=");
+        } else if(!strncmp(argv[i], "numvfs=", strlen("numvfs="))) {
+            max_numvfs = atoi(argv[i] + strlen("numvfs="));
+        } else {
+            printf("%s: Unknown commandline option \"%s\" -- skipping.\n", argv[0], argv[i]);
+        }
+    }
+
     err = oct_init();
     if (err_is_fail(err)) {
     	USER_PANIC_ERR(err, "dist initialization failed.");
diff --git a/usr/ramfsd/main.c b/usr/ramfsd/main.c
index 68bc4d4..f5d3483 100644
--- a/usr/ramfsd/main.c
+++ b/usr/ramfsd/main.c
@@ -4,7 +4,7 @@
  */
 
 /*
- * Copyright (c) 2010, 2011, ETH Zurich.
+ * Copyright (c) 2010, 2011, 2013, ETH Zurich.
  * All rights reserved.
  *
  * This file is distributed under the terms in the attached LICENSE file.
@@ -421,7 +421,23 @@ static void populate_multiboot(struct dirent *root, struct bootinfo *bi)
 
             // append line to bootscript
             const char *args = remove_prefix(multiboot_module_rawstring(region));
+            char *line = NULL;
+
+            // Prepend a '/' if path is relative
+            if(args[0] != '/') {
+                line = calloc(strlen(args) + 2, 1);
+                line[0] = '/';
+                strcat(line, args);
+                args = line;
+            }
+
             err = append_to_file(bootscript_f, args);
+
+            // Free temporary buffer if allocated
+            if(line != NULL) {
+                free(line);
+            }
+
             if (err_is_fail(err)) {
                 USER_PANIC_ERR(err, "error appending to bootscript");
             }
diff --git a/usr/skb/Hakefile b/usr/skb/Hakefile
index b2bdf39..e508f04 100644
--- a/usr/skb/Hakefile
+++ b/usr/skb/Hakefile
@@ -1,5 +1,5 @@
 --------------------------------------------------------------------------
--- Copyright (c) 2007-2010, ETH Zurich.
+-- Copyright (c) 2007-2010, 2013, ETH Zurich.
 -- All rights reserved.
 --
 -- This file is distributed under the terms in the attached LICENSE file.
@@ -32,7 +32,7 @@ let ramfs_files = find inDir "eclipse_kernel/lib" ".eco"
                                                  "icsolver", "vfs",
                                                  "posixcompat", "hashtable", "pcre", 
                                                  "octopus_server", "octopus_parser", "skb",
-                                                 "bench", "dmalloc" ],
+                                                 "bench", "dmalloc", "lwip" ],
                        architectures = [ arch ]
                 }
 in
diff --git a/usr/skb/eclipse_kernel/src/config.h b/usr/skb/eclipse_kernel/src/config.h
index e088dc7..cf1eaa1 100644
--- a/usr/skb/eclipse_kernel/src/config.h
+++ b/usr/skb/eclipse_kernel/src/config.h
@@ -274,7 +274,7 @@
 //#define HAVE_SETSID 0
 
 /* Define if you have sigaction.  */
-//#define HAVE_SIGACTION 0
+#define HAVE_SIGACTION 1
 
 /* Define if you have sigaltstack.  */
 //#define HAVE_SIGALTSTACK 0
diff --git a/usr/skb/icparc_solver/eregex.c b/usr/skb/icparc_solver/eregex.c
index 46286b4..d93f3e0 100644
--- a/usr/skb/icparc_solver/eregex.c
+++ b/usr/skb/icparc_solver/eregex.c
@@ -29,7 +29,7 @@
 #include <sys/types.h>
 #include <stdlib.h>	/* for malloc() */
 #include <string.h>
-#include <pcre/pcreposix.h>
+#include <pcreposix.h>
 #include "eclipse.h"
 
 #include <stdio.h>
diff --git a/usr/skb/programs/bridge_bios.pl b/usr/skb/programs/bridge_bios.pl
new file mode 100644
index 0000000..5c5964e
--- /dev/null
+++ b/usr/skb/programs/bridge_bios.pl
@@ -0,0 +1,121 @@
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+% Copyright (c) 2009, 2011, 2013, 2014, ETH Zurich.
+% All rights reserved.
+%
+% This file is distributed under the terms in the attached LICENSE file.
+% If you do not find this file, copies can be found by writing to:
+% ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich. Attn: Systems Group.
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+
+% This SKB PCI bridge config program just uses the preprogrammed
+% values from the BIOS. Use if the regular PCI bridge configurator
+% fails.
+
+:- set_flag(print_depth, 600).
+
+:-dynamic(currentbar/5).
+
+bridge_programming(Plan, NrElements) :-
+    convert_devices(Plan1),
+    get_more(Plan1, Plan2),
+    eval_more(Plan2, Plan3),
+    % Filter IO BARs because some device drivers aren't able to handle them...
+    filter_io_bars(Plan3, Plan),
+    % We can leave out bridges for now, they're not programmed anyway
+    % and we don't care about their BARs.
+    %     DeviceElements = [],
+    % convert_bridges(BridgeElements1),
+    % get_more_bridge(BridgeElements1, BridgeElements),
+    % eval_more(, DeviceElements),
+    % append(DeviceElements, BridgeElements, Plan),
+    length(Plan, NrElements).
+
+convert_devices(L) :-
+        findall(buselement(device, addr(Bus, Device, Function), _, _, _,
+                                  _, _, _, PCIe, _),
+                device(PCIe, addr(Bus, Device, Function), _, _, _, _,
+                       _, _), L).
+
+% convert_bridges(L) :-
+%         findall(buselement(bridge, addr(Bus, Device, Function),
+%                                   secondary(BusNum), _, _, _, mem, _, PCIe, _),
+%                 bridge(PCIe, addr(Bus, Device, Function), _, _, _, _,
+%                        _, secondary(BusNum)), L).
+
+% device(PCIe, addr(Bus, Device, Function), Vendor, DeviceID, Class,
+%        SubClass, ProgIf, IntPin), L).
+% bridge(PCIe, addr(Bus, Device, Function), Vendor, DeviceID, Class, SubClass,
+%        ProgIf, secondary(BusNum)), L).
+% bar(addr(Bus, Device, Function), BARn, Base, Size, MemOrIO, Prefetch, 32or64).
+% buselement(device, addr(Bus, Device, Function), BAR_Secondary, Base, High, Size,
+%                   mem, Prefetch, PCIe, Bits).
+
+get_more([],[]).
+get_more([H|L], OutL) :-
+        get_more(L, InL),
+        buselement(device, addr(Bus, Device, Function), _, _, _,
+                                  _, _, _, PCIe, _) = H,
+        findall(buselement(device, addr(Bus, Device, Function), BARn,
+                                  Base, _, Size, MemIO, Prefetch, PCIe, Bits),
+                bar(addr(Bus, Device, Function), BARn, Base, Size, MemIO, Prefetch, Bits),
+                A),
+        append(A, InL, OutL).
+
+% get_more_bridge([],[]).
+% get_more_bridge([H|L], OutL) :-
+%         get_more_bridge(L, InL),
+%         buselement(bridge, addr(Bus, Device, Function), Secondary, _,
+%                    _, _, mem, _, PCIe, _) = H,
+%         findall(buselement(bridge, addr(Bus, Device, Function), Secondary,
+%                                   Base, _, Size, mem, Prefetch, PCIe, Bits),
+%                 bar(addr(Bus, Device, Function), _, Base, Size, _, Prefetch, Bits),
+%                 A),
+%         append(A, InL, OutL).
+
+eval_more([],[]).
+eval_more([H|L], OutL) :-
+        eval_more(L, InL),
+        buselement(device, addr(Bus, Device, Function), BARn, Base, _,
+                                  Size, MemIO, Prefetch, PCIe, Bits) = H,
+        Limit is Base + Size,
+        append([buselement(device, addr(Bus, Device, Function), BARn, Base, Limit,
+                                  Size, MemIO, Prefetch, PCIe, Bits)], InL,
+               OutL).
+
+filter_io_bars([],[]).
+filter_io_bars([H|L], OutL) :-
+        filter_io_bars(L, InL),
+        buselement(device, addr(Bus, Device, Function), BARn, Base, Limit,
+                   Size, MemIO, Prefetch, PCIe, Bits) = H,
+        ( MemIO = io ->
+            OutL = InL;
+            append([buselement(device, addr(Bus, Device, Function), BARn, Base, Limit,
+                               Size, MemIO, Prefetch, PCIe, Bits)], InL, OutL)
+        ).
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+% store the new values of the BARs
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+replace_current_BAR_values(L) :-
+    delete_current_BAR_values(L),
+    store_current_BAR_values(L).
+
+store_current_BAR_values([]).
+store_current_BAR_values([H|T]) :-
+    ( buselement(device,Addr,BAR,Base,High,Size,_,_,_,_) = H ->
+         assert(currentbar(Addr,BAR,Base,High,Size));
+        true
+    ),
+    store_current_BAR_values(T).
+
+
+delete_current_BAR_values([]).
+delete_current_BAR_values([H|T]) :-
+    ( buselement(device,Addr,BAR,_,_,_,_,_,_,_) = H ->
+        ( currentbar(Addr,BAR,_,_,_) ->
+            retract(currentbar(Addr,BAR,_,_,_));
+            true
+        );
+        true
+    ),
+    delete_current_BAR_values(T).
diff --git a/usr/skb/programs/bridge_fake_bigfish.pl b/usr/skb/programs/bridge_fake_bigfish.pl
new file mode 100644
index 0000000..3c919eb
--- /dev/null
+++ b/usr/skb/programs/bridge_fake_bigfish.pl
@@ -0,0 +1,391 @@
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+% Copyright (c) 2009, 2011, ETH Zurich.
+% All rights reserved.
+%
+% This file is distributed under the terms in the attached LICENSE file.
+% If you do not find this file, copies can be found by writing to:
+% ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich. Attn: Systems Group.
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+
+% This file fakes the machine config for 'bigfish' at UW. I got it
+% from running Barrelfish input to ECLiPSe on Linux and dumping the
+% result in here.
+%
+% It does a few checks to see that the machine it's running on is in
+% fact the same version of bigfish. It does so by evaluating a few
+% facts that should be inserted in the database. I got the facts by
+% running:
+%
+% sed -ne 's/assert(\(.*\))\./        \1,/p' bigfish.cmds > bigfish.facts
+%
+% And then inserting bigfish.facts into the beginning of
+% bridge_programming/2. The first time this actually blew the stack
+% of the SKB, so I removed all unneccessary things and kept only
+% things relevant to PCI bridge programming.
+
+:-lib(ic).
+:-lib(ic_global).
+:-use_module(library(ic_edge_finder)).
+
+:- set_flag(print_depth, 200).
+
+:-dynamic(currentbar/5).
+
+% :-include("../data/data_hand.txt").
+% :-include("../data/data_qemu_hand.txt").
+% :-include("../data/data_qemu.txt").
+% :-include("../data/data_nos3.txt").
+% :-include("../data/data_nos4.txt").
+% :-include("../data/data_nos5.txt").
+% :-include("../data/data_nos6.txt").
+% :-include("../data/data_gruyere.txt").
+% :-include("../data/data_sbrinz1.txt").
+% :-include("../data/data_loner.txt").
+
+
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+% main goal to be called from outside
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+
+bridge_programming(Plan, NrElements) :-
+        ioapic(0,4273995776,0),
+        memory_region(4273995776,12,4096, 6,0),
+        ioapic(1,4274520064,24),
+        memory_region(4274520064,12,4096, 6,0),
+        ioapic(2,4274782208,56),
+        memory_region(4274782208,12,4096, 6,0),
+        fixed_memory(4274585600,4274601984),
+        fixed_memory(4274847744,4274864128),
+        rootbridge_address_window(addr(0, 0, 0), mem(655360, 786431)),
+        rootbridge_address_window(addr(0, 0, 0), mem(4273995776, 4274520063)),
+        rootbridge_address_window(addr(0, 0, 0), mem(4274520064, 4274782207)),
+        rootbridge_address_window(addr(0, 0, 0), mem(3925868544, 4016046079)),
+        rootbridge_address_window(addr(0, 0, 0), mem(3917479936, 3925868543)),
+        rootbridge_address_window(addr(0, 0, 0), mem(4275306496, 4275326975)),
+        rootbridge(addr(0,0,0),childbus(0,30),mem(3925868544,4016046079)),
+        rootbridge_address_window(addr(32, 0, 0), mem(4274782208, 4275044351)),
+        rootbridge_address_window(addr(32, 0, 0), mem(3900702720, 3917479935)),
+        rootbridge(addr(32,0,0),childbus(32,62),mem(3900702720,3917479935)),
+        memory_affinity(0, 655360, 0),
+        memory_affinity(1048576, 3220176896, 0),
+        memory_affinity(4294967296, 1073741824, 0),
+        memory_affinity(5368709120, 4294967296, 1),
+        bridge(pcie,addr(0,2,0),4098,23062,6,4,0, secondary(1)),
+        bridge(pcie,addr(0,4,0),4098,23064,6,4,0, secondary(3)),
+        bridge(pcie,addr(3,0,0),4277,34340,6,4,0, secondary(4)),
+        bar(addr(3, 0, 0), 0, 16'ef2e0000, 16'20000, mem, nonprefetchable, 32),
+        bridge(pcie,addr(4,0,0),4277,34340,6,4,0, secondary(5)),
+        NrElements = 41,
+        Plan = [[buselement(device, addr(1, 0, 0), 0, 3925868544, 3959422976, 33554432, mem, nonprefetchable, pcie, 64), buselement(device, addr(1, 0, 1), 0, 3959422976, 3992977408, 33554432, mem, nonprefetchable, pcie, 64), buselement(device, addr(9, 0, 0), 0, 3992977408, 3993501696, 524288, mem, nonprefetchable, pcie, 64), buselement(device, addr(9, 0, 1), 0, 3993501696, 3994025984, 524288, mem, nonprefetchable, pcie, 64), buselement(device, addr(5, 0, 0), 3, 3995074560, 3995336704, 262144, mem, nonprefetchable, pcie, 64), buselement(device, addr(5, 0, 0), 1, 3995336704, 3995402240, 65536, mem, nonprefetchable, pcie, 64), buselement(device, addr(9, 0, 0), 4, 3994025984, 3994042368, 16384, mem, nonprefetchable, pcie, 64), buselement(device, addr(9, 0, 1), 4, 3994042368, 3994058752, 16384, mem, nonprefetchable, pcie, 64), buselement(device, addr(0, 17, 0), 5, 3996123136, 3996127232, 4096, mem, nonprefetchable, pcie, 32), buselement(bridge, addr(0, 20, 4), secondary(10), 3925868544, 3925868544, 0, mem, nonprefetchable, pcie, 0), buselement(bridge, addr(0, 9, 0), secondary(9), 3992977408, 3995074560, 2097152, mem, nonprefetchable, pcie, 0), buselement(bridge, addr(4, 5, 0), secondary(8), 3995074560, 3995074560, 0, mem, nonprefetchable, pcie, 0), buselement(bridge, addr(4, 4, 0), secondary(7), 3995074560, 3995074560, 0, mem, nonprefetchable, pcie, 0), buselement(bridge, addr(4, 1, 0), secondary(6), 3995074560, 3995074560, 0, mem, nonprefetchable, pcie, 0), buselement(bridge, addr(4, 0, 0), secondary(5), 3995074560, 3996123136, 1048576, mem, nonprefetchable, pcie, 0), buselement(bridge, addr(3, 0, 0), secondary(4), 3995074560, 3996123136, 1048576, mem, nonprefetchable, pcie, 0), buselement(bridge, addr(0, 4, 0), secondary(3), 3995074560, 3996123136, 1048576, mem, nonprefetchable, pcie, 0), buselement(bridge, addr(0, 3, 0), secondary(2), 3925868544, 3925868544, 0, mem, nonprefetchable, pcie, 0), buselement(bridge, addr(0, 2, 0), secondary(1), 3925868544, 3992977408, 67108864, mem, nonprefetchable, pcie, 0), buselement(bridge, addr(0, 20, 4), secondary(10), 3925868544, 3925868544, 0, mem, prefetchable, pcie, 0), buselement(bridge, addr(0, 9, 0), secondary(9), 3925868544, 3925868544, 0, mem, prefetchable, pcie, 0), buselement(bridge, addr(4, 5, 0), secondary(8), 3925868544, 3925868544, 0, mem, prefetchable, pcie, 0), buselement(bridge, addr(4, 4, 0), secondary(7), 3925868544, 3925868544, 0, mem, prefetchable, pcie, 0), buselement(bridge, addr(4, 1, 0), secondary(6), 3925868544, 3925868544, 0, mem, prefetchable, pcie, 0), buselement(bridge, addr(4, 0, 0), secondary(5), 3925868544, 3925868544, 0, mem, prefetchable, pcie, 0), buselement(bridge, addr(3, 0, 0), secondary(4), 3925868544, 3925868544, 0, mem, prefetchable, pcie, 0), buselement(bridge, addr(0, 4, 0), secondary(3), 3925868544, 3925868544, 0, mem, prefetchable, pcie, 0), buselement(bridge, addr(0, 3, 0), secondary(2), 3925868544, 3925868544, 0, mem, prefetchable, pcie, 0), buselement(bridge, addr(0, 2, 0), secondary(1), 3925868544, 3925868544, 0, mem, prefetchable, pcie, 0)], [buselement(device, addr(33, 0, 0), 1, 3900702720, 3904897024, 4194304, mem, nonprefetchable, pcie, 32), buselement(device, addr(33, 0, 1), 1, 3904897024, 3909091328, 4194304, mem, nonprefetchable, pcie, 32), buselement(device, addr(33, 0, 0), 0, 3909091328, 3909222400, 131072, mem, nonprefetchable, pcie, 32), buselement(device, addr(33, 0, 1), 0, 3909222400, 3909353472, 131072, mem, nonprefetchable, pcie, 32), buselement(device, addr(33, 0, 0), 3, 3909353472, 3909369856, 16384, mem, nonprefetchable, pcie, 32), buselement(device, addr(33, 0, 1), 3, 3909369856, 3909386240, 16384, mem, nonprefetchable, pcie, 32), buselement(bridge, addr(32, 11, 0), secondary(35), 3900702720, 3900702720, 0, mem, nonprefetchable, pcie, 0), buselement(bridge, addr(32, 3, 0), secondary(34), 3900702720, 3900702720, 0, mem, nonprefetchable, pcie, 0), buselement(bridge, addr(32, 2, 0), secondary(33), 3900702720, 3910139904, 9437184, mem, nonprefetchable, pcie, 0), buselement(bridge, addr(32, 11, 0), secondary(35), 3900702720, 3900702720, 0, mem, prefetchable, pcie, 0), buselement(bridge, addr(32, 3, 0), secondary(34), 3900702720, 3900702720, 0, mem, prefetchable, pcie, 0), buselement(bridge, addr(32, 2, 0), secondary(33), 3900702720, 3900702720, 0, mem, prefetchable, pcie, 0)]].
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+% small tools
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+
+adjust_range(X, buselement(T,A,Sec,B1,H1,S,Tp,PF, PCIe, Bits), buselement(T,A,Sec,B2,H2,S,Tp,PF, PCIe, Bits)) :-
+    B2 is B1 + X,
+    H2 is H1 + X.
+
+back_to_bytes(Granularity, buselement(T,A,Sec,BP,HP,SP,Tp,PF, PCIe, Bits), buselement(T,A,Sec,B,H,S,Tp,PF, PCIe, Bits)) :-
+    B is BP * Granularity,
+    H is HP * Granularity,
+    S is SP * Granularity.
+
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+% the main part of the allocation. Called once per root bridge
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+
+bridge_assignment(Plan, Root, Granularity, ExclRanges, IOAPICs) :-
+    root(Addr,childbus(MinBus,MaxBus),mem(LMem,HMem)) = Root,
+    X is HMem - LMem,
+    Type = mem,
+
+% prefetchable
+    constrain_bus(Granularity, Type, prefetchable, Addr,MinBus,MaxBus,LMem,HMem,BusElementListP),
+    RBaseP::[LMem..HMem],
+    RHighP::[LMem..HMem],
+    RSizeP::[0..X],
+    devicetree(BusElementListP,buselement(bridge,Addr,secondary(MinBus),RBaseP,RHighP,RSizeP, Type, prefetchable, _, _),TP),
+
+% nonprefetchable
+    constrain_bus(Granularity, Type, nonprefetchable, Addr,MinBus,MaxBus,LMem,HMem,BusElementListNP),
+    RBaseNP::[LMem..HMem],
+    RHighNP::[LMem..HMem],
+    RSizeNP::[0..X],
+    devicetree(BusElementListNP,buselement(bridge,Addr,secondary(MinBus),RBaseNP,RHighNP,RSizeNP, Type, nonprefetchable, _, _),TNP),
+
+% pseudo-root of both trees
+    PseudoBase::[LMem..HMem],
+    PseudoHigh::[LMem..HMem],
+    PseudoSize::[0..X],
+    T = t(buselement(bridge, addr(-1, -1, -1), childbus(-1, -1), PseudoBase, PseudoHigh, PseudoSize, _, _, _, _), [TP, TNP]),
+    setrange(T,_,_,_),
+    nonoverlap(T),
+    naturally_aligned(T, 256, LMem, HMem),
+    tree2list(T,ListaU),
+    sort(6, >=, ListaU, Lista),
+    not_overlap_memory_ranges(Lista, ExclRanges),
+    keep_orig_addr(Lista, 12, 3, _, _, _, _),
+    keep_ioapic_bars(Lista, IOAPICs),
+    labelall(Lista),
+    subtract(Lista,[buselement(bridge,Addr,_,_,_,_,_,prefetchable,_,_)],Pl3),
+    subtract(Pl3,[buselement(bridge,Addr,_,_,_,_,_,nonprefetchable,_,_)],Pl2),
+    subtract(Pl2,[buselement(bridge,addr(-1,-1,-1),_,_,_,_,_,_,_,_)],Pl),
+    maplist(adjust_range(0),Pl,PR),
+    maplist(back_to_bytes(Granularity),PR,Plan).
+
+% dot output:
+%    PrBaseBytePref is RBaseP * Granularity,
+%    PrHighBytePref is RHighP * Granularity,
+%    PrBaseByteNonPref is RBaseNP * Granularity,
+%    PrHighByteNonPref is RHighNP * Granularity,
+%    plan_to_dot(Granularity, Plan, Root, PrBaseBytePref, PrHighBytePref, PrBaseByteNonPref, PrHighByteNonPref).
+    
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+% instantiating the variables
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+
+base(buselement(_,_,_,Base,_,_,_,_,_,_),Base).
+high(buselement(_,_,_,_,High,_,_,_,_,_),High).
+size(buselement(_,_,_,_,_,Size,_,_,_,_),Size).
+
+labelall(BusElementList) :-
+    maplist(base, BusElementList, Base),
+    maplist(high, BusElementList, High),
+    maplist(size, BusElementList, Size),
+    append(Base, High, L1),
+    append(L1, Size, L2),
+    labeling(L2).
+
+
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+% create the list of devices and bridges in form of buselements and create the
+% variables.
+% we care about the allocation of memory mapped registers here, therefore we only
+% look at bar located in "mem", not "io"
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+
+constrain_bus(Granularity, Type, Prefetch, RootAddr,Bus,MaxBus,LMem,HMem,OutBusElementList) :-
+    constrain_bus_ex(Granularity, Type, Prefetch, RootAddr,Bus,MaxBus,LMem,HMem,[],OutBusElementList).
+
+constrain_bus_ex(_, _, _, _,Bus,MaxBus,_,_,InL,InL) :- Bus > MaxBus.
+constrain_bus_ex(Granularity, Type, Prefetch, RootAddr,Bus,MaxBus,LMem,HMem,InBusElementList,OutBusElementList) :-
+    Bus =< MaxBus,
+    SMax is HMem - LMem,
+    ( is_predicate(bridge/8) ->
+	    findall(buselement(bridge,addr(Bus,Dev,Fun),secondary(Sec),Base,High,Size,Type,Prefetch, PCIe, 0),
+	            ( bridge(PCIe, addr(Bus,Dev,Fun), _, _, _, _, _, secondary(Sec)),
+	              not addr(Bus,Dev,Fun) = RootAddr,
+	              Base::[LMem..HMem],High::[LMem..HMem],Size::[0..SMax]
+	            ),BridgeList);
+        BridgeList = []
+    ),
+    ( is_predicate(device/8) ->
+	    findall(buselement(device,addr(Bus,Dev,Fun),BAR,Base,High,SizeP,Type,Prefetch, PCIe, Bits),
+	            ( device(PCIe, addr(Bus,Dev,Fun),_,_,_,_,_,_),
+	              bar(addr(Bus,Dev,Fun),BAR,_,Size, Type, Prefetch, Bits),
+	              Base::[LMem..HMem],High::[LMem..HMem],
+	              ST1 is Size / Granularity,
+	              ceiling(ST1, ST2),
+	              integer(ST2, SizeP)
+	            ),DeviceList);
+        DeviceList = []
+    ),
+    append(BridgeList, DeviceList, MyBusElementList),
+    append(InBusElementList, MyBusElementList, NewBusElementList),
+    NextBus is Bus + 1,
+    constrain_bus_ex(Granularity, Type, Prefetch, RootAddr, NextBus, MaxBus, LMem,HMem,NewBusElementList,OutBusElementList).
+
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+% create the PCI(e) device tree from a list of "buselement" and return it in Tree
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+
+devicetree(List,CurrRoot,Tree) :-
+    buselement(bridge,_,secondary(Sec),_,_,_,_,_,_,_) = CurrRoot,
+    findall(X,(
+               member(Y,List),
+               buselement(_,addr(Sec,_,_),_,_,_,_,_,_,_,_) = Y,
+               devicetree(List, Y, X)),Children
+           ),
+    Tree = t(CurrRoot,Children).
+devicetree(_,CurrRoot,Tree) :-
+    buselement(device,_,_,_,_,_,_,_,_,_) = CurrRoot,
+    Tree = t(CurrRoot, []).
+
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+% convert a tree to a list of buselements
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+
+tree2list([],[]).
+tree2list(Tree, List) :-
+    t(Node,Children) = Tree,
+    ( foreach(El,Children),
+      foreach(L1,ChildList)
+      do
+        tree2list(El,L1)
+    ),
+    flatten(ChildList,L2),
+    List = [Node|L2].
+
+
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+% store the new values of the BARs
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+replace_current_BAR_values(L) :-
+    delete_current_BAR_values(L),
+    store_current_BAR_values(L).
+
+store_current_BAR_values([]).
+store_current_BAR_values([H|T]) :-
+    ( buselement(device,Addr,BAR,Base,High,Size,_,_,_,_) = H ->
+         assert(currentbar(Addr,BAR,Base,High,Size));
+        true
+    ),
+    store_current_BAR_values(T).
+
+
+delete_current_BAR_values([]).
+delete_current_BAR_values([H|T]) :-
+    ( buselement(device,Addr,BAR,_,_,_,_,_,_,_) = H ->
+        ( currentbar(Addr,BAR,_,_,_) ->
+            retract(currentbar(Addr,BAR,_,_,_));
+            true
+        );
+        true
+    ),
+    delete_current_BAR_values(T).
+
+
+
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+% add constraints to the tree
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+
+% make sure that the bridge has a range which includes all the children
+setrange(Tree,SubTreeSize,SubTreeMin,SubTreeMax) :-
+    t(Node,Children) = Tree,
+    ( foreach(El,Children),
+      foreach(Sz,SizeList),
+      foreach(Mi,MinList),
+      foreach(Ma,MaxList)
+      do
+        setrange(El,Sz,Mi,Ma)
+    ),
+    ic_global:sumlist(SizeList,Size),
+    buselement(_,_,_,Base,High,ElemSize,_,_,_,_) = Node,
+    ElemSize $>= Size,
+    ( not MinList=[] ->
+        ic:minlist(MinList,Min),
+        ic:maxlist(MaxList,Max),
+        Min $>= Base,
+        Max $=< High;
+        true
+    ),
+    High $= Base + ElemSize,
+    SubTreeSize $= ElemSize,
+    SubTreeMin $= Base,
+    SubTreeMax $= High.
+setrange([],0,_,_).
+
+
+% make sure that the children do not overlap
+child(t(C,_),C).
+nonoverlap(Tree) :-
+    t(_ ,Children) = Tree,
+    maplist(child,Children,ChildList),
+    ( not ChildList=[] ->
+        maplist(base,ChildList,Base),
+        maplist(size,ChildList,Size),
+        disjunctive(Base,Size);
+        true
+    ),
+    ( foreach(El, Children)
+      do
+        nonoverlap(El)
+    ).
+
+
+naturally_aligned(Tree, BridgeAlignment, LMem, HMem) :-
+    t(Node,Children) = Tree,
+    ( buselement(device,_,_,Base,High,Size,_,_,_,_) = Node ->
+      Divisor is Size
+      ;
+      buselement(bridge,_,_,Base,High,_,_,_,_,_) = Node ->
+      Divisor is BridgeAlignment
+    ),
+
+    T1 is (HMem - LMem) / Divisor,
+    ceiling(T1, T2),
+    integer(T2, Nr),
+    N::[0..Nr],
+    N2::[0..Nr],
+    mod(LMem,Divisor,Remainder),
+    ( Remainder =:= 0 ->
+        Corr is 0;
+        Corr is Divisor - Remainder
+    ),
+    Base $= N*Divisor + LMem + Corr,
+    High $>= Base,
+    High $= N2*Divisor + LMem + Corr,
+    ( foreach(El, Children),
+      param(BridgeAlignment),
+      param(LMem),
+      param(HMem)
+      do
+        naturally_aligned(El, BridgeAlignment, LMem, HMem)
+    ).
+
+
+% do not overlap with the given list of memory ranges
+not_overlap_memory_ranges([], _).
+not_overlap_memory_ranges(_, []).
+not_overlap_memory_ranges([buselement(bridge,_,_,_,_,_,_,_,_,_)|PCIList], MemoryRanges) :-
+    not_overlap_memory_ranges(PCIList, MemoryRanges).
+not_overlap_memory_ranges([H|PCIList], MemoryRanges) :-
+    ( foreach(range(RBase,RSize),MemoryRanges),
+      param(H)
+      do
+      buselement(device,_,_,Base,_,Size,_,_,_,_) = H,
+      append([Base],[RBase],Bases),
+      append([Size],[RSize],Sizes),
+      disjunctive(Bases,Sizes)
+    ),
+    not_overlap_memory_ranges(PCIList, MemoryRanges).
+
+
+keep_orig_addr([], _, _, _, _, _, _).
+keep_orig_addr([H|Buselements], Class, SubClass, ProgIf, Bus, Dev, Fun) :-
+    ( buselement(device,addr(Bus,Dev,Fun),BAR,Base,_,_,_,_,_,_) = H,device(_,addr(Bus,Dev,Fun),_,_,Class, SubClass, ProgIf,_),bar(addr(Bus,Dev,Fun),BAR,OrigBase,_,_,_,_) ->
+       T1 is OrigBase / 4096,
+       floor(T1,T2),
+       integer(T2,KeepBase),
+        Base $= KeepBase;
+        true
+    ),
+    keep_orig_addr(Buselements, Class, SubClass, ProgIf, Bus, Dev, Fun).
+
+% on some machines (sbrinz1) one of the two IOAPICs appears as a BAR
+% on a device which claims to be a RAM memory controller. If this occurs,
+% we want to avoid moving this BAR as otherwise the IOAPIC cannot be reached
+% anymore.
+keep_ioapic_bars(_, []).
+keep_ioapic_bars(Buselements, [H|IOAPICList]) :-
+    (
+    range(B, _) = H,
+    bar(addr(Bus,Dev,Fun),_,OrigBase,_,_,_,_),
+    T1 is OrigBase / 4096,
+    floor(T1,T2),
+    integer(T2,KeepBase),
+    KeepBase =:= B ->
+    keep_orig_addr(Buselements, _, _, _, Bus, Dev, Fun);
+    true
+    ),
+    keep_ioapic_bars(Buselements, IOAPICList).
diff --git a/usr/slideshow/Hakefile b/usr/slideshow/Hakefile
index 3f4e701..ccb0cf2 100644
--- a/usr/slideshow/Hakefile
+++ b/usr/slideshow/Hakefile
@@ -15,6 +15,6 @@
                                  "zlib_load.c" ],
 		      flounderBindings = [ "keyboard", "fb" ],
 		      flounderExtraBindings = [ ("fb", ["rpcclient"]) ],
-              addLibraries = libDeps ["zlib", "vfs" ]
+		      addLibraries = libDeps ["zlib", "vfs", "lwip" ]
                     }
 ]
diff --git a/usr/spawnd/Hakefile b/usr/spawnd/Hakefile
index d9ff407..f5a7aac 100644
--- a/usr/spawnd/Hakefile
+++ b/usr/spawnd/Hakefile
@@ -13,7 +13,7 @@
 [ build application { target = "spawnd",
   		      cFiles = [ "main.c", "bsp_bootup.c", "service.c", "ps.c" ],
 		      addLibraries = libDeps [ "spawndomain", "elf", "trace", "skb",
-                                       "dist", "vfs" ],
+                                       "dist", "vfs", "lwip" ],
   		      flounderDefs = [ "monitor", "monitor_blocking" ],
                       flounderExtraDefs = [ ("monitor_blocking",["rpcclient"]) ],
   		      flounderBindings = [ "spawn" ]
diff --git a/usr/startd/Hakefile b/usr/startd/Hakefile
index 9de0cad..ad7938f 100644
--- a/usr/startd/Hakefile
+++ b/usr/startd/Hakefile
@@ -13,6 +13,6 @@
 [ build application { target = "startd",
   		      cFiles = [ "main.c", "spawn.c" ],
 		      addLibraries = libDeps [ "spawndomain", "elf", "trace",
-                                       "dist", "vfs"]
+                                       "dist", "vfs", "lwip" ]
                    }
 ]
diff --git a/usr/startd/internal.h b/usr/startd/internal.h
index b828615..57bb59b 100644
--- a/usr/startd/internal.h
+++ b/usr/startd/internal.h
@@ -20,5 +20,6 @@ extern const char *gbootmodules;
 void spawn_dist_domains(void);
 void spawn_app_domains(void);
 void spawn_bootscript_domains(void);
+void spawn_arrakis_domains(void);
 
 #endif //INTERNAL_H_
diff --git a/usr/startd/main.c b/usr/startd/main.c
index e6b1396..ec73976 100644
--- a/usr/startd/main.c
+++ b/usr/startd/main.c
@@ -146,5 +146,7 @@ int main(int argc, const char *argv[])
     // startup apps listed in bootscript
     spawn_bootscript_domains();
 
+    spawn_arrakis_domains();
+
     return EXIT_SUCCESS;
 }
diff --git a/usr/startd/spawn.c b/usr/startd/spawn.c
index 154fcf1..bb88e82 100644
--- a/usr/startd/spawn.c
+++ b/usr/startd/spawn.c
@@ -204,6 +204,66 @@ void spawn_dist_domains(void)
     }
 }
 
+void spawn_arrakis_domains(void)
+{
+    struct spawn_info si;
+    size_t bmpos = 0;
+    errval_t err;
+    int r;
+
+    coreid_t my_coreid = disp_get_core_id();
+
+    while (true) {
+
+        r = prepare_spawn(&bmpos, &si);
+        if (r == 0) {
+            return;
+        } else if (r == -1) {
+            DEBUG_ERR(STARTD_ERR_BOOTMODULES,
+                      "failed to read bootmodules entry");
+        }
+
+        /* Only spawn special arrakis modules */
+        if (si.argc >= 2 && strcmp(si.argv[1], "arrakis") == 0) {
+
+            coreid_t coreid;
+            int extra_args;
+
+            // get core id
+            if (si.argc >= 3 && strncmp(si.argv[2], "core=", 5) == 0) {
+
+                char *p = strchr(si.argv[2], '=');
+                assert(p != NULL);
+                coreid = strtol(p + 1, NULL, 10);
+                extra_args = 2;
+
+            } else {
+                coreid = my_coreid;
+                extra_args = 1;
+            }
+
+            // discard 'dist-serv' and 'core=x' argument
+            for (int i = 1; i <= si.argc - extra_args; i++) {
+                si.argv[i] = si.argv[i+extra_args];
+            }
+            si.argc--;
+
+            debug_printf("starting arrakis domain %s on core %d\n", si.name, coreid);
+
+            domainid_t new_domain;
+            err = spawn_arrakis_program(coreid, si.name, si.argv, environ,
+					NULL_CAP, NULL_CAP, 0, &new_domain);
+            if (err_is_fail(err)) {
+                DEBUG_ERR(err, "spawn of %s failed", si.name);
+                continue;
+            }
+        }
+
+        free(si.cmdargs);
+        free(si.name);
+    }
+}
+
 void spawn_app_domains(void)
 {
     struct spawn_info si;
@@ -241,6 +301,7 @@ void spawn_app_domains(void)
         if (si.argc >= 2 && (strcmp(si.argv[1], "boot") == 0
                           || strcmp(si.argv[1], "dist-serv") == 0
                           || strcmp(si.argv[1], "nospawn") == 0
+                          || strcmp(si.argv[1], "arrakis") == 0
                           || strcmp(si.argv[1], "auto") == 0)) {
             spawn_here = false;
         }
diff --git a/usr/tests/e10ktest/Hakefile b/usr/tests/e10ktest/Hakefile
new file mode 100644
index 0000000..875cd3e
--- /dev/null
+++ b/usr/tests/e10ktest/Hakefile
@@ -0,0 +1,29 @@
+--------------------------------------------------------------------------
+-- Copyright (c) 2007-2011, 2013, ETH Zurich.
+-- All rights reserved.
+--
+-- This file is distributed under the terms in the attached LICENSE file.
+-- If you do not find this file, copies can be found by writing to:
+-- ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich. Attn: Systems Group.
+--
+-- Hakefile for /usr/tests/e10ktest
+-- 
+--------------------------------------------------------------------------
+
+[ build application { target = "e1000test",
+                      cFiles = [ "e10ktest.c" ],
+                      addLibraries = [ "e1000n" ]
+                    },
+  build application { target = "e10k_ctrl",
+                      cFiles = [ "e10k_ctrl.c" ],
+                      addLibraries = [ "e10k" ]
+                    },
+  build application { target = "e10ktest_vf",
+                      cFiles = [ "e10ktest.c" ],
+                      addLibraries = [ "e10k_vf" ]
+                    },
+  build application { target = "e10ktest",
+                      cFiles = [ "e10ktest.c" ],
+                      addLibraries = [ "e10k" ]
+                    }
+]
diff --git a/usr/tests/e10ktest/e10k_ctrl.c b/usr/tests/e10ktest/e10k_ctrl.c
new file mode 100644
index 0000000..027c2cf
--- /dev/null
+++ b/usr/tests/e10ktest/e10k_ctrl.c
@@ -0,0 +1,103 @@
+/**
+ * \file
+ * \brief LWIP test/demo code
+ */
+
+/*
+ * Copyright (c) 2008, ETH Zurich.
+ * All rights reserved.
+ *
+ * This file is distributed under the terms in the attached LICENSE file.
+ * If you do not find this file, copies can be found by writing to:
+ * ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich. Attn: Systems Group.
+ */
+
+#include <stdio.h>
+#include <assert.h>
+#include <barrelfish/barrelfish.h>
+#include <netif/e1000.h>
+
+static ether_terminate_queue ether_terminate_queue_ptr = NULL;
+static ether_get_mac_address_t ether_get_mac_address_ptr = NULL;
+static ether_transmit_pbuf_list_t ether_transmit_pbuf_list_ptr = NULL;
+static ether_get_tx_free_slots tx_free_slots_fn_ptr = NULL;
+static ether_handle_free_TX_slot handle_free_tx_slot_fn_ptr = NULL;
+static ether_rx_register_buffer rx_register_buffer_fn_ptr = NULL;
+static ether_rx_get_free_slots rx_get_free_slots_fn_ptr = NULL;
+
+void ethernetif_backend_init(char *service_name, uint64_t queueid,
+                             ether_get_mac_address_t get_mac_ptr,
+                             ether_terminate_queue terminate_queue_ptr,
+                             ether_transmit_pbuf_list_t transmit_ptr,
+                             ether_get_tx_free_slots tx_free_slots_ptr,
+                             ether_handle_free_TX_slot handle_free_tx_slot_ptr,
+                             size_t rx_bufsz,
+                             ether_rx_register_buffer rx_register_buffer_ptr,
+                             ether_rx_get_free_slots rx_get_free_slots_ptr)
+{
+    ether_terminate_queue_ptr = terminate_queue_ptr;
+    ether_get_mac_address_ptr = get_mac_ptr;
+    ether_transmit_pbuf_list_ptr = transmit_ptr;
+    tx_free_slots_fn_ptr = tx_free_slots_ptr;
+    handle_free_tx_slot_fn_ptr = handle_free_tx_slot_ptr;
+    rx_register_buffer_fn_ptr = rx_register_buffer_ptr;
+    rx_get_free_slots_fn_ptr = rx_get_free_slots_ptr;
+    /* printf("PBUF_POOL_BUFSIZE = %u, rx buffer size = %zu\n", PBUF_POOL_BUFSIZE, */
+    /*        rx_bufsz); */
+}
+
+void process_received_packet(struct driver_rx_buffer *buffer, size_t count,
+                             uint64_t flags)
+{
+#if 0
+    // Drop packets with invalid checksums
+    if(flags & NETIF_RXFLAG_IPCHECKSUM) {
+        if(!(flags & NETIF_RXFLAG_IPCHECKSUM_GOOD)) {
+            goto out;
+        }
+    }
+
+    if(flags & NETIF_RXFLAG_L4CHECKSUM) {
+        if(!(flags & NETIF_RXFLAG_L4CHECKSUM_GOOD)) {
+            goto out;
+        }
+    }
+
+    // TODO: Do something with the packet
+
+ out:
+    //now we have consumed the preregistered pbuf containing a received packet
+    //which was processed in this function. Therefore we have to register a new
+    //free buffer for receiving packets.
+    errval_t err;
+    do {
+        err = rx_register_buffer_fn_ptr(p->pa, p->payload, p);
+    } while(err_is_ok(err));
+#endif
+}
+
+bool handle_tx_done(void *opaque)
+{
+    return true;
+}
+
+int main(int argc, char *argv[])
+{
+    uint8_t mac[6];
+
+    printf("Starting e10k control plane...\n");
+
+    e1000n_driver_init(argc, argv);
+
+    ether_get_mac_address_ptr(mac);
+    printf("Control plane MAC address %02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx\n",
+           mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
+
+    // TODO: Add buffers to RX ring for packet reception
+
+    for(;;) {
+        e1000n_polling_loop(get_default_waitset());
+    }
+
+    return 0;
+}
diff --git a/usr/tests/e10ktest/e10ktest.c b/usr/tests/e10ktest/e10ktest.c
new file mode 100644
index 0000000..5b797fe
--- /dev/null
+++ b/usr/tests/e10ktest/e10ktest.c
@@ -0,0 +1,392 @@
+/**
+ * \file
+ * \brief LWIP test/demo code
+ */
+
+/*
+ * Copyright (c) 2008, 2013, ETH Zurich.
+ * All rights reserved.
+ *
+ * This file is distributed under the terms in the attached LICENSE file.
+ * If you do not find this file, copies can be found by writing to:
+ * ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich. Attn: Systems Group.
+ */
+
+#include <stdio.h>
+#include <assert.h>
+#include <barrelfish/barrelfish.h>
+#include <netif/e1000.h>
+/* #include <netif/etharp.h> */
+#include <arranet_impl.h>
+
+static ether_terminate_queue ether_terminate_queue_ptr = NULL;
+static ether_get_mac_address_t ether_get_mac_address_ptr = NULL;
+static ether_transmit_pbuf_list_t ether_transmit_pbuf_list_ptr = NULL;
+static ether_get_tx_free_slots tx_free_slots_fn_ptr = NULL;
+static ether_handle_free_TX_slot handle_free_tx_slot_fn_ptr = NULL;
+static ether_rx_register_buffer rx_register_buffer_fn_ptr = NULL;
+static ether_rx_get_free_slots rx_get_free_slots_fn_ptr = NULL;
+
+uint64_t interrupt_counter = 0;
+uint64_t total_rx_p_count = 0;
+uint64_t total_rx_datasize = 0;
+struct client_closure *g_cl = NULL;
+
+#define MAX_PACKETS     256
+/* #define MAX_PACKETS     2048 */
+#define PACKET_SIZE     2048
+
+//#define MEASURE_LATENCIES
+
+struct packet {
+    uint8_t     *payload;
+    lpaddr_t    pa;
+    size_t      len;
+};
+
+static struct packet rx_packets[MAX_PACKETS], tx_packets[MAX_PACKETS];
+
+void ethernetif_backend_init(char *service_name, uint64_t queueid,
+                             ether_get_mac_address_t get_mac_ptr,
+                             ether_terminate_queue terminate_queue_ptr,
+                             ether_transmit_pbuf_list_t transmit_ptr,
+                             ether_get_tx_free_slots tx_free_slots_ptr,
+                             ether_handle_free_TX_slot handle_free_tx_slot_ptr,
+                             size_t rx_bufsz,
+                             ether_rx_register_buffer rx_register_buffer_ptr,
+                             ether_rx_get_free_slots rx_get_free_slots_ptr)
+{
+    ether_terminate_queue_ptr = terminate_queue_ptr;
+    ether_get_mac_address_ptr = get_mac_ptr;
+    ether_transmit_pbuf_list_ptr = transmit_ptr;
+    tx_free_slots_fn_ptr = tx_free_slots_ptr;
+    handle_free_tx_slot_fn_ptr = handle_free_tx_slot_ptr;
+    rx_register_buffer_fn_ptr = rx_register_buffer_ptr;
+    rx_get_free_slots_fn_ptr = rx_get_free_slots_ptr;
+    /* printf("PBUF_POOL_BUFSIZE = %u, rx buffer size = %zu\n", PBUF_POOL_BUFSIZE, */
+    /*        rx_bufsz); */
+}
+
+static struct packet *get_tx_packet(void)
+{
+    static unsigned int idx = 0;
+    struct packet *p = &tx_packets[idx];
+
+    // Busy-wait until packet not in flight
+    while(p->len != 0) {
+        handle_free_tx_slot_fn_ptr();
+    }
+
+    idx = (idx + 1) % MAX_PACKETS;
+    return p;
+}
+
+static void packet_output(struct packet *p)
+{
+    struct driver_buffer buf;
+
+    buf.pa = p->pa;
+    buf.va = p->payload;
+    buf.len = p->len;
+    buf.flags = 0;
+    buf.opaque = p;
+
+    errval_t err = ether_transmit_pbuf_list_ptr(&buf, 1);
+    assert(err_is_ok(err));
+}
+
+#ifdef MEASURE_LATENCIES
+#include <barrelfish/sys_debug.h>
+
+// This is roughly Mon Apr 25 13:50 CEST 2011
+#define TOD_OFFSET      1303732456ULL
+
+int gettimeofday(struct timeval *tv, struct timezone *tz)
+{
+    uint64_t now = rdtsc();
+    static uint64_t tscperms = 0;
+
+    if(tscperms == 0) {
+        errval_t err = sys_debug_get_tsc_per_ms(&tscperms);
+        assert(err_is_ok(err));
+        assert(tscperms >= 1000);
+    }
+
+    uint64_t tod_us = (TOD_OFFSET * 1000000) + (now / (tscperms / 1000));
+
+    if(tv != NULL) {
+        tv->tv_sec = tod_us / 1000000;
+        tv->tv_usec = tod_us % 1000000;
+    }
+
+    assert(tz == NULL);
+    if(tz != NULL) {
+    }
+
+    return 0;
+}
+
+#define MAX_STAMPS      10000
+
+static uint64_t tstamp[MAX_STAMPS];
+static int stamps = 0;
+#endif
+
+void process_received_packet(struct driver_rx_buffer *buffer, size_t count,
+                             uint64_t flags)
+{
+#ifdef MEASURE_LATENCIES
+    uint64_t instamp = rdtsc();
+#endif
+
+    struct packet *p = buffer->opaque;
+    assert(p != NULL);
+    assert(count == 1);
+    p->len = buffer->len;
+
+    /* printf("Incoming packet\n"); */
+
+    // Drop packets with invalid checksums
+    if(flags & NETIF_RXFLAG_IPCHECKSUM) {
+        if(!(flags & NETIF_RXFLAG_IPCHECKSUM_GOOD)) {
+            goto out;
+        }
+    }
+
+    if(flags & NETIF_RXFLAG_L4CHECKSUM) {
+        if(!(flags & NETIF_RXFLAG_L4CHECKSUM_GOOD)) {
+            goto out;
+        }
+    }
+
+    /* printf("Checksum good\n"); */
+
+    struct eth_hdr *ethhdr = (struct eth_hdr *)p->payload;
+    switch (htons(ethhdr->type)) {
+    case ETHTYPE_ARP:
+        {
+            /* printf("Is an ARP packet\n"); */
+            struct etharp_hdr *arphdr = (struct etharp_hdr *)(p->payload + SIZEOF_ETH_HDR);
+            struct eth_addr mymac;
+            bool ourarp = false;
+
+            if(htons(arphdr->opcode) == ARP_REQUEST) {
+                // 10.0.2.15
+                if(htons(arphdr->dipaddr.addrw[0]) == 0x0a00 &&
+                   htons(arphdr->dipaddr.addrw[1]) == 0x020f) {
+                    memcpy(&mymac.addr, "\x52\x54\x00\x12\x34\x56", ETHARP_HWADDR_LEN);
+                    ourarp = true;
+                } else if(htons(arphdr->dipaddr.addrw[0]) == 0x80d0 &&
+                          htons(arphdr->dipaddr.addrw[1]) == 0x0643) {
+                    // 128.208.6.67
+                    memcpy(&mymac.addr, "\xa0\x36\x9f\x10\x00\xa6", ETHARP_HWADDR_LEN);
+                    ourarp = true;
+                } else if(htons(arphdr->dipaddr.addrw[0]) == 0x80d0 &&
+                          htons(arphdr->dipaddr.addrw[1]) == 0x0682) {
+                    // 128.208.6.130
+                    memcpy(&mymac.addr, "\xa0\x36\x9f\x10\x00\xa2", ETHARP_HWADDR_LEN);
+                    ourarp = true;
+                } else if(htons(arphdr->dipaddr.addrw[0]) == 0xc0a8 &&
+                          htons(arphdr->dipaddr.addrw[1]) == 0x0102) {
+                    // 192.168.1.2
+                    memcpy(&mymac.addr, "\xa0\x36\x9f\x10\x00\xa2", ETHARP_HWADDR_LEN);
+                    ourarp = true;
+                }
+            }
+
+            if(ourarp) {
+                /* printf("ARP request for us\n"); */
+                // Send reply
+                struct packet *outp = get_tx_packet();
+                struct eth_hdr *myeth = (struct eth_hdr *)outp->payload;
+                struct etharp_hdr *myarp = (struct etharp_hdr *)(outp->payload + SIZEOF_ETH_HDR);
+
+                // ETH header
+                memcpy(&myeth->dest, &arphdr->shwaddr, ETHARP_HWADDR_LEN);
+                memcpy(&myeth->src, &mymac, ETHARP_HWADDR_LEN);
+                myeth->type = htons(ETHTYPE_ARP);
+
+                // ARP header
+                myarp->hwtype = htons(1);
+                myarp->proto = htons(ETHTYPE_IP);
+                myarp->hwlen = 6;
+                myarp->protolen = 4;
+                myarp->opcode = htons(ARP_REPLY);
+                memcpy(&myarp->shwaddr, &mymac, ETHARP_HWADDR_LEN);
+                memcpy(&myarp->sipaddr, &arphdr->dipaddr, sizeof(myarp->sipaddr));
+                memcpy(&myarp->dhwaddr, &arphdr->shwaddr, ETHARP_HWADDR_LEN);
+                memcpy(&myarp->dipaddr, &arphdr->sipaddr, sizeof(myarp->dipaddr));
+
+                outp->len = p->len;
+                packet_output(outp);
+            }
+        }
+        break;
+
+    case ETHTYPE_IP:
+        {
+            struct ip_hdr *iphdr = (struct ip_hdr *)(p->payload + SIZEOF_ETH_HDR);
+
+            /* printf("Is an IP packet, type %x\n", IPH_PROTO(iphdr)); */
+
+            if(IPH_PROTO(iphdr) == IP_PROTO_UDP) {
+                struct udp_hdr *udphdr = (struct udp_hdr *)(p->payload + SIZEOF_ETH_HDR + (IPH_HL(iphdr) * 4));
+                uint8_t *payload = p->payload + SIZEOF_ETH_HDR + (IPH_HL(iphdr) * 4) + sizeof(struct udp_hdr);
+
+                /* printf("Got UDP packet, dest IP %x, dest port %u\n", */
+                /*        iphdr->dest.addr, udphdr->dest); */
+
+                if((htonl(iphdr->dest.addr) != 0x80d00643 &&
+                    htonl(iphdr->dest.addr) != 0x80d00682 &&
+                    htonl(iphdr->dest.addr) != 0xc0a80102 &&
+                    htonl(iphdr->dest.addr) != 0x0a00020f) ||
+                   htons(udphdr->dest) != 1234) {
+                    goto out;
+                }
+
+                /* printf("payload '%s'\n", payload); */
+
+                struct packet *outp = get_tx_packet();
+                struct eth_hdr *myeth = (struct eth_hdr *)outp->payload;
+                struct ip_hdr *myip = (struct ip_hdr *)(outp->payload + SIZEOF_ETH_HDR);
+                struct udp_hdr *myudp = (struct udp_hdr *)(outp->payload + SIZEOF_ETH_HDR + (IPH_HL(iphdr) * 4));
+                uint8_t *mypayload = outp->payload + SIZEOF_ETH_HDR + (IPH_HL(iphdr) * 4) + sizeof(struct udp_hdr);
+
+                // ETH header
+                memcpy(&myeth->dest, &ethhdr->src, ETHARP_HWADDR_LEN);
+                memcpy(&myeth->src, &ethhdr->dest, ETHARP_HWADDR_LEN);
+                myeth->type = htons(ETHTYPE_IP);
+
+                // IP header
+                memcpy(myip, iphdr, sizeof(struct ip_hdr));
+                memcpy(&myip->src, &iphdr->dest, sizeof(ip_addr_p_t));
+                memcpy(&myip->dest, &iphdr->src, sizeof(ip_addr_p_t));
+
+                // UDP header
+                memcpy(myudp, udphdr, sizeof(struct udp_hdr));
+                myudp->src = udphdr->dest;
+                myudp->dest = udphdr->src;
+
+                // Payload
+                memcpy(mypayload, payload, htons(udphdr->len) - 8);
+
+                outp->len = p->len;
+                packet_output(outp);
+
+#ifdef MEASURE_LATENCIES
+                uint64_t now = rdtsc();
+                tstamp[stamps] = now - instamp;
+
+                /* printf("got packet %d\n", stamps); */
+
+                stamps++;
+                if(stamps == MAX_STAMPS) {
+                    printf("latencies:\n");
+                    for(int i = 0; i < MAX_STAMPS; i++) {
+                        printf("%" PRIu64 " cycles\n", tstamp[i]);
+                    }
+                    stamps = 0;
+                }
+#endif
+
+            }
+        }
+        break;
+
+    default:
+        break;
+    }
+
+ out:
+    {
+        //now we have consumed the preregistered pbuf containing a received packet
+        //which was processed in this function. Therefore we have to register a new
+        //free buffer for receiving packets.
+        errval_t err = rx_register_buffer_fn_ptr(p->pa, p->payload, p);
+        assert(err_is_ok(err));
+    }
+}
+
+bool handle_tx_done(void *opaque)
+{
+    struct packet *p = opaque;
+    p->len = 0;
+    return true;
+}
+
+/* allocate a single frame, mapping it into our vspace with given attributes */
+static void *alloc_map_frame(vregion_flags_t attr, size_t size, struct capref *retcap)
+{
+    struct capref frame;
+    errval_t r;
+
+    r = frame_alloc(&frame, size, NULL);
+    assert(err_is_ok(r));
+    void *va;
+    r = vspace_map_one_frame_attr(&va, size, frame, attr,
+                                  NULL, NULL);
+    if (err_is_fail(r)) {
+        DEBUG_ERR(r, "vspace_map_one_frame failed");
+        return NULL;
+    }
+
+    if (retcap != NULL) {
+        *retcap = frame;
+    }
+
+    return va;
+}
+
+int main(int argc, char *argv[])
+{
+    uint8_t mac[6];
+
+    printf("Starting e10k test program...\n");
+
+    e1000n_driver_init(argc, argv);
+
+    ether_get_mac_address_ptr(mac);
+    printf("e10ktest MAC address %02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx\n",
+           mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
+
+    struct capref frame;
+    uint8_t *ram_base = alloc_map_frame(VREGION_FLAGS_READ_WRITE,
+                                        MAX_PACKETS * PACKET_SIZE, &frame);
+    assert(ram_base != NULL);
+
+    struct frame_identity id;
+    errval_t err = invoke_frame_identify(frame, &id);
+    assert(err_is_ok(err));
+
+    // Add buffers to RX ring for packet reception
+    for(int i = 0; i < MAX_PACKETS; i++) {
+        struct packet *p = &rx_packets[i];
+
+        p->payload = ram_base + (i * PACKET_SIZE);
+        p->pa = id.base + (i * PACKET_SIZE);
+        p->len = PACKET_SIZE;
+
+        err = rx_register_buffer_fn_ptr(p->pa, p->payload, p);
+        assert(err_is_ok(err));
+    }
+
+    // Setup TX packets
+    ram_base = alloc_map_frame(VREGION_FLAGS_READ_WRITE,
+                               MAX_PACKETS * PACKET_SIZE, &frame);
+    assert(ram_base != NULL);
+    err = invoke_frame_identify(frame, &id);
+    assert(err_is_ok(err));
+    for(int i = 0; i < MAX_PACKETS; i++) {
+        struct packet *p = &tx_packets[i];
+        p->payload = ram_base + (i * PACKET_SIZE);
+        p->pa = id.base + (i * PACKET_SIZE);
+        p->len = 0;
+    }
+
+    for(;;) {
+        arranet_polling_loop();
+        //        e1000n_polling_loop(get_default_waitset());
+    }
+
+    return 0;
+}
diff --git a/usr/tests/e10ktest/e10ktest_latencies.c b/usr/tests/e10ktest/e10ktest_latencies.c
new file mode 100644
index 0000000..6031c64
--- /dev/null
+++ b/usr/tests/e10ktest/e10ktest_latencies.c
@@ -0,0 +1,369 @@
+/**
+ * \file
+ * \brief LWIP test/demo code
+ */
+
+/*
+ * Copyright (c) 2008, 2013, ETH Zurich.
+ * All rights reserved.
+ *
+ * This file is distributed under the terms in the attached LICENSE file.
+ * If you do not find this file, copies can be found by writing to:
+ * ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich. Attn: Systems Group.
+ */
+
+#include <stdio.h>
+#include <assert.h>
+#include <barrelfish/barrelfish.h>
+#include <netif/e1000.h>
+#include <netif/etharp.h>
+#include <lwip/ip.h>
+#include <lwip/udp.h>
+
+static ether_terminate_queue ether_terminate_queue_ptr = NULL;
+static ether_get_mac_address_t ether_get_mac_address_ptr = NULL;
+static ether_transmit_pbuf_list_t ether_transmit_pbuf_list_ptr = NULL;
+static ether_get_tx_free_slots tx_free_slots_fn_ptr = NULL;
+static ether_handle_free_TX_slot handle_free_tx_slot_fn_ptr = NULL;
+static ether_rx_register_buffer rx_register_buffer_fn_ptr = NULL;
+static ether_rx_get_free_slots rx_get_free_slots_fn_ptr = NULL;
+
+uint64_t interrupt_counter = 0;
+uint64_t total_rx_p_count = 0;
+uint64_t total_rx_datasize = 0;
+struct client_closure *g_cl = NULL;
+
+#define MAX_PACKETS     256
+#define PACKET_SIZE     2048
+
+struct packet {
+    uint8_t     *payload;
+    lpaddr_t    pa;
+    size_t      len;
+};
+
+static struct packet rx_packets[MAX_PACKETS], tx_packets[MAX_PACKETS];
+
+void ethernetif_backend_init(char *service_name, uint64_t queueid,
+                             ether_get_mac_address_t get_mac_ptr,
+                             ether_terminate_queue terminate_queue_ptr,
+                             ether_transmit_pbuf_list_t transmit_ptr,
+                             ether_get_tx_free_slots tx_free_slots_ptr,
+                             ether_handle_free_TX_slot handle_free_tx_slot_ptr,
+                             size_t rx_bufsz,
+                             ether_rx_register_buffer rx_register_buffer_ptr,
+                             ether_rx_get_free_slots rx_get_free_slots_ptr)
+{
+    ether_terminate_queue_ptr = terminate_queue_ptr;
+    ether_get_mac_address_ptr = get_mac_ptr;
+    ether_transmit_pbuf_list_ptr = transmit_ptr;
+    tx_free_slots_fn_ptr = tx_free_slots_ptr;
+    handle_free_tx_slot_fn_ptr = handle_free_tx_slot_ptr;
+    rx_register_buffer_fn_ptr = rx_register_buffer_ptr;
+    rx_get_free_slots_fn_ptr = rx_get_free_slots_ptr;
+    /* printf("PBUF_POOL_BUFSIZE = %u, rx buffer size = %zu\n", PBUF_POOL_BUFSIZE, */
+    /*        rx_bufsz); */
+}
+
+static struct packet *get_tx_packet(void)
+{
+    static unsigned int idx = 0;
+    struct packet *p = &tx_packets[idx];
+
+    // Busy-wait until packet not in flight
+    while(p->len != 0) {
+        handle_free_tx_slot_fn_ptr();
+    }
+
+    idx = (idx + 1) % MAX_PACKETS;
+    return p;
+}
+
+static void packet_output(struct packet *p)
+{
+    struct driver_buffer buf;
+
+    buf.pa = p->pa;
+    buf.va = p->payload;
+    buf.len = p->len;
+    buf.flags = 0;
+    buf.opaque = p;
+
+    errval_t err = ether_transmit_pbuf_list_ptr(&buf, 1);
+    assert(err_is_ok(err));
+}
+
+#include <barrelfish/sys_debug.h>
+
+// This is roughly Mon Apr 25 13:50 CEST 2011
+#define TOD_OFFSET      1303732456ULL
+
+int gettimeofday(struct timeval *tv, struct timezone *tz)
+{
+    uint64_t now = rdtsc();
+    static uint64_t tscperms = 0;
+
+    if(tscperms == 0) {
+        errval_t err = sys_debug_get_tsc_per_ms(&tscperms);
+        assert(err_is_ok(err));
+        assert(tscperms >= 1000);
+    }
+
+    uint64_t tod_us = (TOD_OFFSET * 1000000) + (now / (tscperms / 1000));
+
+    if(tv != NULL) {
+        tv->tv_sec = tod_us / 1000000;
+        tv->tv_usec = tod_us % 1000000;
+    }
+
+    assert(tz == NULL);
+    if(tz != NULL) {
+    }
+
+    return 0;
+}
+
+#define MAX_STAMPS      10000
+
+static uint64_t tstamp[MAX_STAMPS];
+static int stamps = 0;
+
+void process_received_packet(struct driver_rx_buffer *buffer, size_t count,
+                             uint64_t flags)
+{
+    uint64_t instamp = rdtsc();
+
+    struct packet *p = buffer->opaque;
+    assert(p != NULL);
+    assert(count == 1);
+    p->len = buffer->len;
+
+    /* printf("Incoming packet\n"); */
+
+    // Drop packets with invalid checksums
+    if(flags & NETIF_RXFLAG_IPCHECKSUM) {
+        if(!(flags & NETIF_RXFLAG_IPCHECKSUM_GOOD)) {
+            goto out;
+        }
+    }
+
+    if(flags & NETIF_RXFLAG_L4CHECKSUM) {
+        if(!(flags & NETIF_RXFLAG_L4CHECKSUM_GOOD)) {
+            goto out;
+        }
+    }
+
+    /* printf("Checksum good\n"); */
+
+    struct eth_hdr *ethhdr = (struct eth_hdr *)p->payload;
+    switch (htons(ethhdr->type)) {
+    case ETHTYPE_ARP:
+        {
+            /* printf("Is an ARP packet\n"); */
+            struct etharp_hdr *arphdr = (struct etharp_hdr *)(p->payload + SIZEOF_ETH_HDR);
+            struct eth_addr mymac;
+            bool ourarp = false;
+
+            if(htons(arphdr->opcode) == ARP_REQUEST) {
+                // 10.0.2.15
+                if(htons(arphdr->dipaddr.addrw[0]) == 0x0a00 &&
+                   htons(arphdr->dipaddr.addrw[1]) == 0x020f) {
+                    memcpy(&mymac.addr, "\x52\x54\x00\x12\x34\x56", ETHARP_HWADDR_LEN);
+                    ourarp = true;
+                } else if(htons(arphdr->dipaddr.addrw[0]) == 0x80d0 &&
+                          htons(arphdr->dipaddr.addrw[1]) == 0x0643) {
+                    memcpy(&mymac.addr, "\xa0\x36\x9f\x10\x00\xa6", ETHARP_HWADDR_LEN);
+                    ourarp = true;
+                }
+            }
+
+            if(ourarp) {
+                /* printf("ARP request for us\n"); */
+                // Send reply
+                struct packet *outp = get_tx_packet();
+                struct eth_hdr *myeth = (struct eth_hdr *)outp->payload;
+                struct etharp_hdr *myarp = (struct etharp_hdr *)(outp->payload + SIZEOF_ETH_HDR);
+
+                // ETH header
+                memcpy(&myeth->dest, &arphdr->shwaddr, ETHARP_HWADDR_LEN);
+                memcpy(&myeth->src, &mymac, ETHARP_HWADDR_LEN);
+                myeth->type = htons(ETHTYPE_ARP);
+
+                // ARP header
+                myarp->hwtype = htons(1);
+                myarp->proto = htons(ETHTYPE_IP);
+                myarp->hwlen = 6;
+                myarp->protolen = 4;
+                myarp->opcode = htons(ARP_REPLY);
+                memcpy(&myarp->shwaddr, &mymac, ETHARP_HWADDR_LEN);
+                memcpy(&myarp->sipaddr, &arphdr->dipaddr, sizeof(myarp->sipaddr));
+                memcpy(&myarp->dhwaddr, &arphdr->shwaddr, ETHARP_HWADDR_LEN);
+                memcpy(&myarp->dipaddr, &arphdr->sipaddr, sizeof(myarp->dipaddr));
+
+                outp->len = p->len;
+                packet_output(outp);
+            }
+        }
+        break;
+
+    case ETHTYPE_IP:
+        {
+            struct ip_hdr *iphdr = (struct ip_hdr *)(p->payload + SIZEOF_ETH_HDR);
+
+            /* printf("Is an IP packet, type %x\n", IPH_PROTO(iphdr)); */
+
+            if(IPH_PROTO(iphdr) == IP_PROTO_UDP) {
+                struct udp_hdr *udphdr = (struct udp_hdr *)(p->payload + SIZEOF_ETH_HDR + (IPH_HL(iphdr) * 4));
+                uint8_t *payload = p->payload + SIZEOF_ETH_HDR + (IPH_HL(iphdr) * 4) + sizeof(struct udp_hdr);
+
+                /* printf("Got UDP packet, dest IP %x, dest port %u\n", */
+                /*        iphdr->dest.addr, udphdr->dest); */
+
+                if(htonl(iphdr->dest.addr) != 0x80d00643 ||
+                   htons(udphdr->dest) != 1234) {
+                    goto out;
+                }
+
+                /* printf("payload '%s'\n", payload); */
+
+                struct packet *outp = get_tx_packet();
+                struct eth_hdr *myeth = (struct eth_hdr *)outp->payload;
+                struct ip_hdr *myip = (struct ip_hdr *)(outp->payload + SIZEOF_ETH_HDR);
+                struct udp_hdr *myudp = (struct udp_hdr *)(outp->payload + SIZEOF_ETH_HDR + (IPH_HL(iphdr) * 4));
+                uint8_t *mypayload = outp->payload + SIZEOF_ETH_HDR + (IPH_HL(iphdr) * 4) + sizeof(struct udp_hdr);
+
+                // ETH header
+                memcpy(&myeth->dest, &ethhdr->src, ETHARP_HWADDR_LEN);
+                memcpy(&myeth->src, &ethhdr->dest, ETHARP_HWADDR_LEN);
+                myeth->type = htons(ETHTYPE_IP);
+
+                // IP header
+                memcpy(myip, iphdr, sizeof(struct ip_hdr));
+                memcpy(&myip->src, &iphdr->dest, sizeof(ip_addr_p_t));
+                memcpy(&myip->dest, &iphdr->src, sizeof(ip_addr_p_t));
+
+                // UDP header
+                memcpy(myudp, udphdr, sizeof(struct udp_hdr));
+                myudp->src = udphdr->dest;
+                myudp->dest = udphdr->src;
+
+                // Payload
+                memcpy(mypayload, payload, htons(udphdr->len) - 8);
+
+                outp->len = p->len;
+                packet_output(outp);
+
+                uint64_t now = rdtsc();
+                tstamp[stamps] = now - instamp;
+
+                /* printf("got packet %d\n", stamps); */
+
+                stamps++;
+                if(stamps == MAX_STAMPS) {
+                    printf("latencies:\n");
+                    for(int i = 0; i < MAX_STAMPS; i++) {
+                        printf("%" PRIu64 " cycles\n", tstamp[i]);
+                    }
+                    stamps = 0;
+                }
+
+            }
+        }
+        break;
+
+    default:
+        break;
+    }
+
+ out:
+    {
+        //now we have consumed the preregistered pbuf containing a received packet
+        //which was processed in this function. Therefore we have to register a new
+        //free buffer for receiving packets.
+        errval_t err = rx_register_buffer_fn_ptr(p->pa, p->payload, p);
+        assert(err_is_ok(err));
+    }
+}
+
+bool handle_tx_done(void *opaque)
+{
+    struct packet *p = opaque;
+    p->len = 0;
+    return true;
+}
+
+/* allocate a single frame, mapping it into our vspace with given attributes */
+static void *alloc_map_frame(vregion_flags_t attr, size_t size, struct capref *retcap)
+{
+    struct capref frame;
+    errval_t r;
+
+    r = frame_alloc(&frame, size, NULL);
+    assert(err_is_ok(r));
+    void *va;
+    r = vspace_map_one_frame_attr(&va, size, frame, attr,
+                                  NULL, NULL);
+    if (err_is_fail(r)) {
+        DEBUG_ERR(r, "vspace_map_one_frame failed");
+        return NULL;
+    }
+
+    if (retcap != NULL) {
+        *retcap = frame;
+    }
+
+    return va;
+}
+
+int main(int argc, char *argv[])
+{
+    uint8_t mac[6];
+
+    printf("Starting e10k test program...\n");
+
+    e1000n_driver_init(argc, argv);
+
+    ether_get_mac_address_ptr(mac);
+    printf("e10ktest MAC address %02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx\n",
+           mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
+
+    struct capref frame;
+    uint8_t *ram_base = alloc_map_frame(VREGION_FLAGS_READ_WRITE,
+                                        MAX_PACKETS * PACKET_SIZE, &frame);
+    assert(ram_base != NULL);
+
+    struct frame_identity id;
+    errval_t err = invoke_frame_identify(frame, &id);
+    assert(err_is_ok(err));
+
+    // Add buffers to RX ring for packet reception
+    for(int i = 0; i < MAX_PACKETS; i++) {
+        struct packet *p = &rx_packets[i];
+
+        p->payload = ram_base + (i * PACKET_SIZE);
+        p->pa = id.base + (i * PACKET_SIZE);
+        p->len = PACKET_SIZE;
+
+        err = rx_register_buffer_fn_ptr(p->pa, p->payload, p);
+        assert(err_is_ok(err));
+    }
+
+    // Setup TX packets
+    ram_base = alloc_map_frame(VREGION_FLAGS_READ_WRITE,
+                               MAX_PACKETS * PACKET_SIZE, &frame);
+    assert(ram_base != NULL);
+    err = invoke_frame_identify(frame, &id);
+    assert(err_is_ok(err));
+    for(int i = 0; i < MAX_PACKETS; i++) {
+        struct packet *p = &tx_packets[i];
+        p->payload = ram_base + (i * PACKET_SIZE);
+        p->pa = id.base + (i * PACKET_SIZE);
+        p->len = 0;
+    }
+
+    for(;;) {
+        e1000n_polling_loop(get_default_waitset());
+    }
+
+    return 0;
+}
diff --git a/usr/tests/filetests/Hakefile b/usr/tests/filetests/Hakefile
index 1f7f4df..d4067f0 100644
--- a/usr/tests/filetests/Hakefile
+++ b/usr/tests/filetests/Hakefile
@@ -11,14 +11,14 @@
 [
   build application { target = "fread_test",
                       cFiles = [ "fread_test.c" ],
-                      addLibraries = libDeps ["vfs"]
+                      addLibraries = libDeps ["vfs", "lwip" ]
                     },
   build application { target = "fscanf_test",
                       cFiles = [ "fscanf_test.c" ],
-                      addLibraries = libDeps ["vfs"]
+                      addLibraries = libDeps ["vfs", "lwip" ]
                     },
   build application { target = "fat_test",
                       cFiles = [ "fat_test.c" ],
-                      addLibraries = libDeps ["vfs"]
+                      addLibraries = libDeps ["vfs", "lwip" ]
                     }
   ]
diff --git a/usr/tests/hellotest/Hakefile b/usr/tests/hellotest/Hakefile
index fc41347..2e55e84 100644
--- a/usr/tests/hellotest/Hakefile
+++ b/usr/tests/hellotest/Hakefile
@@ -10,7 +10,10 @@
 -- 
 --------------------------------------------------------------------------
 
-[ build application { target = "hellotest",
-                      cFiles = [ "hellotest.c" ]
-                 }
+[ build arrakisapplication { target = "arrakis_hellotest",
+                             cFiles = [ "hellotest.c" ]
+                           },
+  build application { target = "hellotest",
+                             cFiles = [ "hellotest.c" ]
+                           }
 ]
diff --git a/usr/tests/hellotest/hellotest.c b/usr/tests/hellotest/hellotest.c
index 5ebd7aa..7f5133e 100644
--- a/usr/tests/hellotest/hellotest.c
+++ b/usr/tests/hellotest/hellotest.c
@@ -1,4 +1,5 @@
 #include <stdio.h>
+#include <inttypes.h>
 #include <barrelfish/barrelfish.h>
 
 int main(int argc, char *argv[])
@@ -8,5 +9,33 @@ int main(int argc, char *argv[])
   for (int i = 0;i < argc; i ++) {
     printf("arg[%d] = %s\n", i, argv[i]);
   }
+
+  // Check that we're in privileged mode
+  uint16_t cs;
+  __asm volatile("mov %%cs, %[reg]"
+		 : [reg] "=r" (cs));
+
+  if((cs & 3) == 0) {
+    printf("We're in privileged mode!\n");
+
+    printf("Trying privileged operation...\n");
+    uintptr_t cr0;
+    __asm volatile("mov %%cr0, %[reg]"
+		   : [reg] "=r" (cr0));
+
+    printf("Succeeded! CR0 is %" PRIxPTR "\n", cr0);
+  } else {
+    printf("NO privileged mode enabled\n");
+  }
+
+  printf("Causing pagefault...\n");
+
+  /* __asm volatile ("ud2"); */
+
+  uintptr_t *zero = (uintptr_t *)0;
+  *zero = 0;
+
+  printf("After pagefault\n");
+
   return EXIT_SUCCESS;
 }
diff --git a/usr/tests/net_tests/nfs_throughput/Hakefile b/usr/tests/net_tests/nfs_throughput/Hakefile
index 97f0f27..2039829 100644
--- a/usr/tests/net_tests/nfs_throughput/Hakefile
+++ b/usr/tests/net_tests/nfs_throughput/Hakefile
@@ -12,6 +12,6 @@
 
 [ build application { target = "netthroughput",
                       cFiles = [ "nfs_cat.c"],
-                      addLibraries = libDeps ["vfs"]
+                      addLibraries = libDeps ["vfs", "lwip"]
                     }
 ]
diff --git a/usr/tests/perfmontest/Hakefile b/usr/tests/perfmontest/Hakefile
index 3701e4e..55437dc 100644
--- a/usr/tests/perfmontest/Hakefile
+++ b/usr/tests/perfmontest/Hakefile
@@ -1,5 +1,5 @@
 --------------------------------------------------------------------------
--- Copyright (c) 2007-2010, ETH Zurich.
+-- Copyright (c) 2007-2010, 2013, ETH Zurich.
 -- All rights reserved.
 --
 -- This file is distributed under the terms in the attached LICENSE file.
@@ -12,5 +12,8 @@
 
 [ build application { target = "perfmontest",
                       cFiles = [ "perfmon.c" ]
+                    },
+  build application { target = "spin",
+                      cFiles = [ "spin.c" ]
                     }
 ]
diff --git a/usr/tests/perfmontest/spin.c b/usr/tests/perfmontest/spin.c
new file mode 100644
index 0000000..500b1c1
--- /dev/null
+++ b/usr/tests/perfmontest/spin.c
@@ -0,0 +1,24 @@
+#include <stdio.h>
+#include <string.h>
+#include <inttypes.h>
+#include <barrelfish/barrelfish.h>
+
+#define MEASUREMENTS    1000000
+
+int main(int argc, char *argv[])
+{
+    char a[1024], b[1024];
+    uint64_t sum = 0;
+
+    for(int i = 0; i < MEASUREMENTS; i++) {
+        uint64_t start = rdtsc();
+        memcpy(a, b, 1024);
+        uint64_t end = rdtsc();
+        sum += end - start;
+    }
+
+    printf("avg duration: %" PRIu64 " cycles\n", sum / MEASUREMENTS);
+
+  /* for(;;); */
+  return 0;
+}
diff --git a/usr/tests/posix/Hakefile b/usr/tests/posix/Hakefile
new file mode 100644
index 0000000..e979d36
--- /dev/null
+++ b/usr/tests/posix/Hakefile
@@ -0,0 +1,17 @@
+--------------------------------------------------------------------------
+-- Copyright (c) 2007-2009, 2013, ETH Zurich.
+-- All rights reserved.
+--
+-- This file is distributed under the terms in the attached LICENSE file.
+-- If you do not find this file, copies can be found by writing to:
+-- ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich. Attn: Systems Group.
+--
+-- Hakefile for /usr/tests/spantest
+--
+--------------------------------------------------------------------------
+
+[ build application { target = "socketpipetest" ,
+                      cFiles = [ "socket_pipe.c" ],
+                      addLibraries = libDeps [ "posixcompat", "lwip" ]
+                    }
+]
diff --git a/usr/tests/posix/socket_pipe.c b/usr/tests/posix/socket_pipe.c
new file mode 100644
index 0000000..3ce88ef
--- /dev/null
+++ b/usr/tests/posix/socket_pipe.c
@@ -0,0 +1,42 @@
+#include <stdio.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <assert.h>
+#include <vfs/vfs.h>
+
+static char testmsg[20] = "This is a test mes.";
+
+int main(int argc, char *argv[])
+{
+  int sv[2];
+  char rcv[20];
+
+  vfs_init();
+
+  int r = socketpair(AF_UNIX, SOCK_STREAM, 0, sv);
+  assert(r == 0);
+  
+  ssize_t r2 = write(sv[0], testmsg, 20);
+  assert(r2 == 20);
+
+  ssize_t r3 = read(sv[1], rcv, 20);
+  assert(r3 == 20);
+
+  printf("Received: '%s'\n", rcv);
+
+  int pipes[2];
+  
+  r = pipe(pipes);
+  assert(r == 0);
+
+  r2 = write(pipes[1], testmsg, 20);
+  assert(r2 == 20);
+
+  r3 = read(pipes[0], rcv, 20);
+  assert(r3 == 20);
+
+  printf("Received from pipe: '%s'\n", rcv);
+  
+  return 0;
+}
diff --git a/usr/tests/testdesc/Hakefile b/usr/tests/testdesc/Hakefile
index 90ce5ae..a9a6cb6 100644
--- a/usr/tests/testdesc/Hakefile
+++ b/usr/tests/testdesc/Hakefile
@@ -12,7 +12,7 @@
 
 [ build application { target = "testdesc",
                       cFiles = [ "testdesc.c" ],
-                      addLibraries = libDeps [ "posixcompat", "vfs" ],
+                      addLibraries = libDeps [ "posixcompat", "vfs", "lwip" ],
                       flounderBindings = [ "unixsock" ]
 --                    flounderExtraBindings = [ ("unixsock",["rpcclient"]) ]
                     },
diff --git a/usr/tests/testdesc/testdesc-child.c b/usr/tests/testdesc/testdesc-child.c
index 10f913b..3a8383e 100644
--- a/usr/tests/testdesc/testdesc-child.c
+++ b/usr/tests/testdesc/testdesc-child.c
@@ -108,6 +108,9 @@ static errval_t get_inherited_fds(void)
         case FDTAB_TYPE_LWIP_SOCKET:
             s = "lwip socket";
             break;
+        case FDTAB_TYPE_EPOLL_INSTANCE:
+            s = "epoll instance";
+            break;
         case FDTAB_TYPE_PTM:
             s = "pseudo-terminal master";
             break;
diff --git a/usr/vmkitmon/Hakefile b/usr/vmkitmon/Hakefile
index 00d6b32..807b8ca 100644
--- a/usr/vmkitmon/Hakefile
+++ b/usr/vmkitmon/Hakefile
@@ -24,7 +24,7 @@
                                         "e1000", "e10k", "e10k_q",
                                         "pc16550d_mem", "pci_hdr0_mem" ],
                       flounderDefs = [ "monitor" ],
-                      addLibraries = libDeps [ "spawndomain", "netQmng", "x86emu", "vfs", "pci", "bench"],
+                      addLibraries = libDeps [ "spawndomain", "netQmng", "x86emu", "vfs", "pci", "bench", "lwip" ],
                       -- addLibraries = libDeps [ "spawndomain", "netQmng"],
                       architectures = ["x86_64"]
                     }
